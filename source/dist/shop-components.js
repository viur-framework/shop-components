var zS = Object.defineProperty;
var MS = (c, u, g) => u in c ? zS(c, u, { enumerable: !0, configurable: !0, writable: !0, value: g }) : c[u] = g;
var mo = (c, u, g) => (MS(c, typeof u != "symbol" ? u + "" : u, g), g);
import { reactive as _e, computed as le, useCssVars as NS, openBlock as j, createBlock as ut, Transition as FS, withCtx as Sw, createElementBlock as q, createElementVNode as M, createCommentVNode as he, pushScopeId as bt, popScopeId as kt, ref as Ft, onBeforeMount as jn, withDirectives as cn, unref as ae, vModelText as wo, createTextVNode as se, Fragment as ye, renderList as dt, toDisplayString as Se, Teleport as Dw, inject as Te, shallowRef as ln, shallowReactive as $S, nextTick as LS, defineComponent as Ye, h as Bw, provide as cc, watch as hi, getCurrentInstance as Ic, watchEffect as dr, withModifiers as li, onMounted as lt, renderSlot as VS, resolveComponent as yo, readonly as jS, getCurrentScope as HS, onScopeDispose as US, normalizeClass as Tw, vShow as vc, createVNode as qS, resolveDynamicComponent as WS, mergeProps as GS } from "vue";
import { defineStore as Oc } from "pinia";
const Ee = (c, u) => {
  const g = c.__vccOpts || c;
  for (const [w, k] of u)
    g[w] = k;
  return g;
}, Rc = {
  props: {
    size: {
      type: String,
      default: "2"
    },
    active: {
      type: Boolean,
      default: !0
    },
    logo: {
      default: "logo-cube.svg",
      type: String
    },
    color: {
      default: "var(--sl-color-primary-500)",
      type: String
    }
  },
  setup(c, u) {
    const g = _e({
      trackWidth: le(() => `${c.size / 30}rem`),
      outerSize: le(() => `calc(${c.size}rem + ${g.trackWidth})`),
      spinnerSize: le(() => `${c.size}rem`),
      logoSize: le(() => `calc(${c.size}rem - ${g.trackWidth} * 10)`),
      shadow: le(() => `0px 0px ${c.size / 6}rem 0 color-mix(in hsl, var(--sl-color-neutral-1000), 80% transparent)`)
    });
    return { state: g };
  }
}, yk = () => {
  NS((c) => ({
    "93747d92": c.state.outerSize,
    "284424e5": c.state.shadow,
    "6485ca5e": c.state.logoSize,
    "5d833915": c.state.spinnerSize,
    d5b3feca: c.color,
    "2050b700": c.state.trackWidth
  }));
}, Ek = Rc.setup;
Rc.setup = Ek ? (c, u) => (yk(), Ek(c, u)) : yk;
const KS = (c) => (bt("data-v-46c45785"), c = c(), kt(), c), ZS = {
  key: 0,
  class: "loading"
}, JS = /* @__PURE__ */ KS(() => /* @__PURE__ */ M("sl-spinner", { class: "loader" }, null, -1)), YS = { class: "logo" }, QS = ["src"];
function XS(c, u, g, w, k, S) {
  return j(), ut(FS, null, {
    default: Sw(() => [
      g.active ? (j(), q("div", ZS, [
        JS,
        M("div", YS, [
          M("sl-icon", { src: g.logo }, null, 8, QS)
        ])
      ])) : he("", !0)
    ]),
    _: 1
  });
}
const Pw = /* @__PURE__ */ Ee(Rc, [["render", XS], ["__scopeId", "data-v-46c45785"]]);
let As = class extends Error {
  constructor(u, g, w, k) {
    super(w || g), arguments.length >= 4 && k && Object.assign(this, k), this.statusText = g, this.statusCode = u, this.response = k;
  }
}, dc = null;
function po() {
  return dc || (dc = Oc("requestStore", () => {
    const c = _e({ sKeys: /* @__PURE__ */ new Set() });
    function u() {
      c.sKeys = /* @__PURE__ */ new Set();
    }
    return {
      state: c,
      $reset: u
    };
  })), dc();
}
class ve {
  static resetState() {
    po().$reset(), po().$dispose();
  }
  static buildUrl(u) {
    return u && !(u.startsWith("http://") || u.startsWith("https://") || u.startsWith("//")) && (u = "http://localhost:8080" + u), u;
  }
  static post(u, { dataObj: g = null, callback: w = null, failedCallback: k = null, abortController: S = null, headers: v = null, mode: x = null } = {}) {
    function p() {
      if (g instanceof FormData)
        return g;
      const y = new FormData();
      for (const C in g)
        if (Array.isArray(g[C]))
          for (let b of g[C])
            y.append(C, b);
        else
          y.append(C, g[C]);
      return y;
    }
    let D = rr.post(ve.buildUrl(u), p(), null, v, S, x);
    return D.then(function(y) {
      w && w(y.data);
    }).catch(function(y) {
      k && k(y);
    }), D;
  }
  static async getBatchSkeys(u = 30, g = "json") {
    await ve.get(`/${g}/skey`, {
      dataObj: { amount: u }
    }).then(async (w) => {
      let k = await w.json();
      Array.isArray(k) || (k = [k]), po().state.sKeys = new Set(k);
    });
  }
  static async securePost(u, {
    dataObj: g = null,
    callback: w = null,
    failedCallback: k = null,
    abortController: S = null,
    renderer: v = "json",
    headers: x = null,
    mode: p = null,
    amount: D = 30
  } = {}) {
    let y = null;
    po().state.sKeys.size === 0 && await ve.getBatchSkeys(D);
    const C = [...po().state.sKeys][0];
    return g instanceof FormData ? (g.append("skey", C), po().state.sKeys.delete(C)) : (g || (g = {}), g.skey = C, po().state.sKeys.delete(C)), y = ve.post(u, {
      dataObj: g,
      callback: w,
      abortController: S,
      headers: x,
      mode: p
    }), y;
  }
  static get(u, {
    dataObj: g = null,
    callback: w = null,
    failedCallback: k = null,
    cached: S = !1,
    clearCache: v = !1,
    abortController: x = null,
    headers: p = null,
    mode: D = null,
    //          milli  sec  min  Std  Tage
    cacheTime: y = 1e3 * 60 * 60 * 24 * 1
  } = {}) {
    let C = rr.get(ve.buildUrl(u), g, v, p, x, D);
    return C.then(function(b) {
      w && w(b.data);
    }).catch(function(b) {
      k && k(b);
    }), C;
  }
  static list(u, {
    dataObj: g = null,
    callback: w = null,
    failedCallback: k = null,
    group: S = null,
    abortController: v = null,
    renderer: x = "json"
  } = {}) {
    let p = `/${x}/${u}/list`;
    return S && (p += `/${S}`), ve.get(p, {
      dataObj: g,
      callback: w,
      failedCallback: k,
      abortController: v
    });
  }
  static getStructure(u, { dataObj: g = null, callback: w = null, failedCallback: k = null, group: S = null, abortController: v = null } = {}) {
    u = u.replace(/\//g, ".");
    let x = `/vi/getStructure/${u}/`;
    return S && (x += `/${S}`), ve.get(x, {
      dataObj: g,
      callback: w,
      failedCallback: k,
      abortController: v
    });
  }
  static view(u, g, {
    dataObj: w = null,
    callback: k = null,
    failedCallback: S = null,
    group: v = null,
    abortController: x = null,
    renderer: p = "json"
  } = {}) {
    let D = `/${p}/${u}/view/${g}`;
    return v && (D = `/${p}/${u}/view/${v}/${g}`), ve.get(D, {
      dataObj: w,
      callback: k,
      failedCallback: S,
      abortController: x
    });
  }
  static add(u, {
    dataObj: g = null,
    callback: w = null,
    failedCallback: k = null,
    group: S = null,
    abortController: v = null,
    renderer: x = "json"
  } = {}) {
    let p = `/${x}/${u}/add`;
    return S && (p = `/${x}/${u}/add/${S}`), ve.securePost(p, {
      dataObj: g,
      callback: w,
      failedCallback: k,
      abortController: v
    });
  }
  static edit(u, g, {
    dataObj: w = null,
    callback: k = null,
    failedCallback: S = null,
    group: v = null,
    abortController: x = null,
    renderer: p = "json"
  } = {}) {
    let D = `/${p}/${u}/edit/${g}`;
    return v && (D = `/${p}/${u}/edit/${v}/${g}`), ve.securePost(D, {
      dataObj: w,
      callback: k,
      failedCallback: S,
      abortController: x
    });
  }
  static delete(u, g, {
    dataObj: w = null,
    callback: k = null,
    failedCallback: S = null,
    group: v = null,
    abortController: x = null,
    renderer: p = "json"
  } = {}) {
    let D = `/${p}/${u}/delete/${g}`;
    return v && (D = `/${p}/${u}/delete/${v}/${g}`), ve.securePost(D, {
      dataObj: w,
      callback: k,
      failedCallback: S,
      abortController: x,
      amount: 1
    });
  }
  static downloadUrlFor(u, g = !1) {
    return u && "dest" in u ? g && "thumbnail" in u.dest ? ve.buildUrl(u.dest.thumbnail) : "downloadUrl" in u.dest ? ve.buildUrl(u.dest.downloadUrl) : ve.buildUrl(null) : ve.buildUrl(u);
  }
  static uploadFile(u, g = void 0) {
    const w = {
      fileName: u.name,
      mimeType: u.type || "application/octet-stream",
      size: u.size.toString(),
      node: g
    };
    return new Promise((k, S) => {
      ve.securePost("/vi/file/getUploadURL", { dataObj: w }).then(async (v) => {
        let x = await v.json();
        fetch(x.values.uploadUrl, {
          body: u,
          method: "POST",
          mode: "no-cors"
        }).then(async (p) => {
          const D = {
            key: x.values.uploadKey,
            skelType: "leaf"
          };
          ve.securePost("/vi/file/add", { dataObj: D }).then(async (y) => {
            let C = await y.json();
            C.action === "addSuccess" ? k(C.values) : S(C);
          }).catch((y) => {
            S(y);
          });
        }).catch((p) => {
          S(p);
        });
      }).catch((v) => {
        S(v);
      });
    });
  }
}
class rr {
  constructor() {
    mo(this, "withCredentials", !0);
  }
  static buildOptions(u, g = null, w = null, k = null, S = null) {
    let v = { method: u };
    return v.credentials = "include", v.headers = {
      Accept: "application/json, text/plain, */*"
    }, w && (v.headers = { ...v.headers, ...w }), g && (v.body = g), k && (v.signal = k.signal), S && (v.mode = S), v;
  }
  static get(u, g = null, w = null, k = null, S = null, v = null) {
    function x(p, D) {
      let y = new URL(p);
      if (D && Object.keys(D).length > 0) {
        const C = new URLSearchParams();
        for (const [b, A] of Object.entries(D))
          if (Array.isArray(A))
            for (const P of A)
              C.append(b, P);
          else
            C.append(b, A);
        y.search = C.toString();
      }
      return y.toString();
    }
    return fetch(x(u, g), rr.buildOptions("GET", null, k, S, v)).then(async (p) => {
      if (p.ok)
        return p;
      {
        const D = `${p.status} ${p.statusText}: ${p.headers ? p.headers.get("x-error-descr") : ""}`;
        return Promise.reject(new As(p.status, p.statusText, D, p));
      }
    }).catch((p) => {
      if (p instanceof TypeError) {
        const y = `503 ${p.message}: ${p.headers ? p.headers.get("x-error-descr") : ""}`;
        return Promise.reject(new As(503, p.message, y, p));
      }
      if (p instanceof DOMException && p.name == "AbortError") {
        const y = `${p.code} ${p.name}: ${p.headers ? p.headers.get("x-error-descr") : ""}`;
        return Promise.reject(new As(p.code, p.name, y, { url: u }));
      }
      const D = `${p.statusCode} ${p.statusText}: ${p.headers ? p.headers.get("x-error-descr") : ""}`;
      return Promise.reject(new As(p.statusCode, p.statusText, D, p.response));
    });
  }
  static post(u, g = null, w = null, k = null, S = null, v = null) {
    return fetch(u, rr.buildOptions("POST", g, k, S, v));
  }
}
class eD {
  static objectEmpty(u) {
    return Object.keys(u).length === 0 && u.constructor === Object;
  }
  static getDescr(u, g) {
    try {
      return u.values.filter((w) => w[0] === g)[0][1];
    } catch {
      return "-";
    }
  }
  static unescape(u) {
    return u || (u = ""), String(u).replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&#40;/g, "(").replace(/&#41;/g, ")").replace(/&#61;/g, "=").replace(/&#039;/g, "'").replace(/&#040;/g, "(").replace(/&#041;/g, ")").replace(/&#061;/g, "=");
  }
  static formatString(u, g) {
    function w(v) {
      let x = [], p = [], D = /\$\((.*?)\)/g;
      for (; p; ) {
        if (p = D.exec(v), !p) {
          p = !1;
          continue;
        }
        x.push(p[1]);
      }
      return x;
    }
    let k = w(u), S = [];
    Array.isArray(g) || (g = [g]);
    for (let v of g) {
      let x = u;
      for (let p of k) {
        let D = p.split("."), y = v;
        for (let C of D)
          y && y !== "-" && C in y && y[C] ? y = y[C] : y = "-";
        y = this.unescape(y), x = x.replace("$(" + p + ")", y);
      }
      S.push(x);
    }
    return S.join(", ");
  }
}
class tD extends Error {
  constructor(u, g, w, k) {
    super(w || g), arguments.length >= 4 && k && Object.assign(this, k), this.statusText = g, this.statusCode = u, this.response = k;
  }
}
function at(c, { json: u, method: g, params: w, ...k } = {}) {
  g || (g = u ? "POST" : "GET");
  const S = {
    credentials: "include",
    method: g,
    headers: {
      ...k.headers
    },
    ...k
  };
  if ((c.startsWith("/") || c.startsWith(window.location.origin)) && (S.headers["X-Requested-With"] = "Fetch"), u ? (S.body = JSON.stringify(u), S.headers["Content-Type"] = "application/json") : w && g === "POST" && (typeof w == "string" || w instanceof String ? S.body = new URLSearchParams(w) : w instanceof HTMLFormElement ? S.body = new FormData(w) : (S.body = new FormData(), Object.entries(w).forEach(([v, x]) => {
    if (Array.isArray(x))
      for (const p of x)
        S.body.append(v, p);
    else
      S.body.append(v, x);
  }))), w && (g === "GET" || u)) {
    const v = new URLSearchParams(w);
    c += `?${v.toString()}`;
  }
  return window.fetch(c, S).then(async (v) => {
    if (v.ok)
      return v;
    {
      const x = `${v.status} ${v.statusText}: ${v.headers.get("x-viur-error")}`;
      return Promise.reject(new tD(v.status, v.statusText, x, v));
    }
  });
}
function nD() {
  return at("/json/skey").then((c) => c.json());
}
class oD {
  constructor({
    host_url: u = null,
    shop_module: g = "shop"
  } = {}) {
    /**
     * URL to the shop-backend (ViUR server)
     */
    mo(this, "host_url");
    /**
     * Name of the shop root module
     */
    mo(this, "shop_module");
    /**
     * URL to shop root module with the default renderer
     */
    mo(this, "shop_url");
    /**
     * URL to shop root module with the json renderer
     */
    mo(this, "shop_json_url");
    /**
     * URL to shop API module with the default renderer
     */
    mo(this, "shop_api_url");
    if (u === null)
      try {
        this.host_url = "http://localhost:8080";
      } catch {
        this.host_url = window.location.origin;
      }
    else
      this.host_url = u;
    this.shop_module = g, this.shop_url = `${this.host_url}/${this.shop_module}`, this.shop_json_url = `${this.host_url}/json/${this.shop_module}`, this.shop_api_url = `${this.shop_url}/api`, this.getStructure_url = `${this.host_url}/vi/getStructure`;
  }
  // --- Article ------------------------------------------------------------
  article_view({
    article_key: u,
    parent_cart_key: g
  } = {}) {
    return at(`${this.shop_api_url}/article_view`, {
      params: {
        article_key: u,
        parent_cart_key: g
      }
    }).then((w) => w.json());
  }
  article_add({
    article_key: u,
    parent_cart_key: g,
    quantity: w = 1,
    quantity_mode: k = "increase"
  } = {}) {
    return at(`${this.shop_api_url}/article_add`, {
      method: "POST",
      params: {
        article_key: u,
        parent_cart_key: g,
        quantity: w,
        quantity_mode: k
      }
    }).then((S) => S.json());
  }
  article_update({
    article_key: u,
    parent_cart_key: g,
    quantity: w = 1,
    quantity_mode: k = "increase"
  } = {}) {
    return at(`${this.shop_api_url}/article_update`, {
      method: "POST",
      params: {
        article_key: u,
        parent_cart_key: g,
        quantity: w,
        quantity_mode: k
      }
    }).then((S) => S.json());
  }
  article_remove({
    article_key: u,
    parent_cart_key: g
  } = {}) {
    return at(`${this.shop_api_url}/article_remove`, {
      method: "POST",
      params: {
        article_key: u,
        parent_cart_key: g
      }
    }).then((w) => w.json());
  }
  // --- Cart ---------------------------------------------------------------
  cart_list({ cart_key: u = null } = {}) {
    return at(`${this.shop_api_url}/cart_list`, {
      params: u === null ? {} : { cart_key: u }
    }).then((g) => g.json());
  }
  cart_add({
    parent_cart_key: u,
    name: g,
    cart_type: w,
    // TODO
    customer_comment: k,
    shipping_address_key: S,
    shipping_key: v,
    discount_key: x
  } = {}) {
    return at(`${this.shop_api_url}/cart_add`, {
      method: "POST",
      params: this.removeUndefinedValues({
        parent_cart_key: u,
        name: g,
        cart_type: w,
        // TODO
        customer_comment: k,
        shipping_address_key: S,
        shipping_key: v,
        discount_key: x
      })
    }).then((p) => p.json());
  }
  //TODO
  cart_update({
    cart_key: u,
    parent_cart_key: g,
    cart_type: w,
    // TODO
    name: k,
    customer_comment: S,
    shipping_address_key: v,
    shipping_key: x,
    discount_key: p
  } = {}) {
    return at(`${this.shop_api_url}/cart_update`, {
      method: "POST",
      params: this.removeUndefinedValues({
        cart_key: u,
        parent_cart_key: g,
        cart_type: w,
        // TODO
        name: k,
        customer_comment: S,
        shipping_address_key: v,
        shipping_key: x,
        discount_key: p
      })
    }).then((D) => D.json());
  }
  cart_remove({ cart_key: u } = {}) {
    return at(`${this.shop_api_url}/cart_remove`, {
      method: "POST",
      params: {
        cart_key: u
      }
    }).then((g) => g.json());
  }
  cart_structure() {
    return at(`${this.getStructure_url}/${this.shop_module}.cart`, {
      method: "GET"
    }).then((u) => u.json());
  }
  // --- Address ------------------------------------------------------------
  address_list({} = {}) {
    return at(`${this.shop_json_url}/address/list`, {
      params: {
        limit: 100
      }
    }).then((u) => u.json()).then((u) => u.skellist);
  }
  address_add({
    customer_type: u,
    salutation: g,
    company_name: w,
    firstname: k,
    lastname: S,
    street_name: v,
    street_number: x,
    address_addition: p,
    zip_code: D,
    city: y,
    country: C,
    customer_key: b,
    is_default: A,
    address_type: P
  } = {}) {
    return nD().then((R) => at(`${this.shop_json_url}/address/add`, {
      method: "POST",
      params: this.removeUndefinedValues({
        skey: R,
        customer_type: u,
        salutation: g,
        company_name: w,
        firstname: k,
        lastname: S,
        street_name: v,
        street_number: x,
        address_addition: p,
        zip_code: D,
        city: y,
        country: C,
        customer: b,
        is_default: A,
        address_type: P
      })
    }).then((z) => z.json()).then((z) => z.values));
  }
  address_structure() {
    return at(`${this.getStructure_url}/${this.shop_module}.address`, {
      method: "GET"
    }).then((u) => u.json());
  }
  // --- Order --------------------------------------------------------------
  payment_providers_list({} = {}) {
    return at(`${this.shop_url}/order/payment_providers_list`).then((u) => u.json());
  }
  order_add({
    cart_key: u,
    payment_provider: g,
    billing_address_key: w,
    email: k,
    customer_key: S,
    state_ordered: v,
    state_paid: x,
    state_rts: p
  } = {}) {
    return at(`${this.shop_api_url}/order_add`, {
      method: "POST",
      params: this.removeUndefinedValues({
        cart_key: u,
        payment_provider: g,
        billing_address_key: w,
        email: k,
        customer_key: S,
        state_ordered: v,
        state_paid: x,
        state_rts: p
      })
    }).then((D) => D.json());
  }
  order_update({
    order_key: u,
    payment_provider: g,
    billing_address_key: w,
    email: k,
    customer_key: S,
    state_ordered: v,
    state_paid: x,
    state_rts: p
  } = {}) {
    return at(`${this.shop_api_url}/order_update`, {
      method: "POST",
      params: this.removeUndefinedValues({
        order_key: u,
        payment_provider: g,
        billing_address_key: w,
        email: k,
        customer_key: S,
        state_ordered: v,
        state_paid: x,
        state_rts: p
      })
    }).then((D) => D.json());
  }
  order_checkout_start({
    order_key: u
  } = {}) {
    return at(`${this.shop_url}/order/checkout_start`, {
      method: "POST",
      params: { order_key: u }
    }).then((g) => g.json());
  }
  order_checkout_order({
    order_key: u
  } = {}) {
    return at(`${this.shop_url}/order/checkout_order`, {
      method: "POST",
      params: { order_key: u }
    }).then((g) => g.json());
  }
  order_pp_get_settings({
    order_key: u
  } = {}) {
    return at(`${this.shop_url}/order/checkout_order`, {
      method: "POST",
      params: { order_key: u }
    }).then((g) => g.json());
  }
  // --- User ---------------------------------------------------------------
  user_view({
    user_key: u = "self"
  } = {}) {
    return at(`${this.host_url}/json/user/view/${u}`).then((g) => g.json()).then((g) => g.values);
  }
  // --- Discount -----------------------------------------------------------
  discount_add({
    code: u,
    discount_key: g
  } = {}) {
    return at(`${this.shop_api_url}/discount_add`, {
      method: "POST",
      params: this.removeUndefinedValues({
        code: u,
        discount_key: g
      })
    }).then((w) => w.json());
  }
  // --- Utils -------------------------------------------------------------
  removeUndefinedValues(u) {
    return Object.fromEntries(
      Object.entries(u).filter(([g, w]) => w !== void 0)
    );
  }
}
const En = Oc("cartstore", () => {
  const c = new oD({
    host_url: "http://localhost:8080"
  }), u = _e({
    basket: "",
    carts: {},
    structure: { address: {}, cart: {} }
  });
  async function g() {
    await w();
  }
  async function w() {
    (await c.cart_list()).forEach(async (b) => {
      u.carts[b.key] = {}, u.carts[b.key].info = b, b.cart_type === "basket" && (u.basket = b.key), await k(b.key);
    });
  }
  async function k(C) {
    let b = await c.cart_list({ cart_key: C });
    u.carts[C].items = b;
  }
  async function S(C, b) {
    let A = await c.article_add({
      article_key: C,
      parent_cart_key: b
    });
    await D(b), console.log("addToCart", A);
  }
  async function v(C, b) {
    let A = await c.article_view({
      article_key: C,
      parent_cart_key: b
    });
    console.log("getArticleView", A);
  }
  async function x(C, b) {
    let A = await c.article_remove({
      article_key: C,
      parent_cart_key: b
    });
    await D(b), console.log("remove Resp", A);
  }
  async function p(C, b, A) {
    let P = await c.article_update({
      article_key: C,
      parent_cart_key: b,
      quantity: A,
      quantity_mode: "replace"
    });
    A === 0 && await D(b), console.log("update Resp", P);
  }
  async function D(C) {
    await k(C);
  }
  async function y() {
    let C = await c.address_structure();
    u.structure.address = C.addSkel, console.log("adress add", u.structure.address);
  }
  return {
    state: u,
    addToCart: S,
    getArticleView: v,
    removeItem: x,
    updateItem: p,
    init: g,
    getAdressStructure: y
  };
}), ze = (c) => (bt("data-v-44571029"), c = c(), kt(), c), iD = {
  key: 1,
  class: "bind viur-shop-cart-wrap"
}, rD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("p", null, "Möchten Sie den Artikel wirklich aus dem Warenkorb entfernen?", -1)), sD = {
  class: "footer-wrap",
  slot: "footer"
}, aD = { class: "viur-shop-cart-list" }, lD = {
  key: 0,
  class: "viur-shop-cart-controlbar"
}, cD = { class: "viur-shop-cart-button-list left" }, dD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-icon", {
  library: "hsk",
  name: "pen",
  slot: "suffix"
}, null, -1)), uD = [
  dD
], hD = { distance: "10" }, gD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-icon", {
  class: "dots",
  name: "dots",
  library: "hsk",
  slot: "trigger"
}, null, -1)), mD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  library: "hsk",
  name: "save",
  class: "primary-icon"
}, null, -1)), pD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  library: "hsk",
  name: "project",
  class: "primary-icon"
}, null, -1)), fD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  library: "hsk",
  name: "clone",
  class: "primary-icon"
}, null, -1)), bD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  library: "hsk",
  name: "delete",
  class: "delete-icon"
}, null, -1)), kD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-icon", {
  library: "hsk",
  name: "pen",
  slot: "suffix"
}, null, -1)), wD = [
  kD
], vD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("br", null, null, -1)), _D = {
  ref: "cartActionInfo",
  variant: "primary",
  duration: "3000",
  closable: ""
}, AD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-icon", {
  slot: "icon",
  name: "check"
}, null, -1)), CD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("strong", null, "Warenkorb gespeichert!", -1)), yD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("br", null, null, -1)), ED = [
  AD,
  CD,
  yD
], xD = {
  ref: "cartErrorInfo",
  variant: "danger",
  duration: "3000",
  closable: ""
}, SD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-icon", {
  slot: "icon",
  name: "error"
}, null, -1)), DD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("strong", null, "Warenkorb nicht gespeichert!", -1)), BD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("br", null, null, -1)), TD = [
  SD,
  DD,
  BD
], PD = { key: 2 }, ID = {
  horizontal: "",
  class: "viur-shop-cart-card"
}, OD = ["src"], RD = {
  class: "viur-shop-cart-card-header",
  slot: "header"
}, zD = { class: "viur-shop-cart-card-headline headline" }, MD = { class: "viur-shop-cart-card-body-row" }, ND = { class: "viur-shop-cart-card-body-info" }, FD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("div", { class: "viur-shop-cart-card-descr" }, [
  /* @__PURE__ */ se(" Version: 900x900x2000 "),
  /* @__PURE__ */ M("br"),
  /* @__PURE__ */ se(" Farbe: Chromoptik "),
  /* @__PURE__ */ M("br"),
  /* @__PURE__ */ se(" Glasart: Klar hell mit Edelglasbeschichtung"),
  /* @__PURE__ */ M("br"),
  /* @__PURE__ */ se(" Anschlag: Beidseitig variabel"),
  /* @__PURE__ */ M("br"),
  /* @__PURE__ */ se(" Griff: Stangengriff Exklusiv (56) ")
], -1)), $D = { class: "viur-shop-cart-card-body-footer" }, LD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-button", {
  size: "small",
  outline: "",
  class: "viur-shop-cart-card-add-to-favourites-btn",
  variant: "primary",
  title: "Add to favourites"
}, [
  /* @__PURE__ */ M("sl-icon", {
    name: "heart",
    slot: "prefix"
  })
], -1)), VD = ["onClick"], jD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-icon", {
  name: "trash",
  slot: "prefix"
}, null, -1)), HD = [
  jD
], UD = { class: "viur-shop-cart-card-body-amount" }, qD = ["onUpdate:modelValue", "onInput"], WD = {
  class: "viur-shop-cart-card-price-wrap",
  slot: "footer"
}, GD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("div", { class: "viur-shop-cart-card-price-label" }, "Preis", -1)), KD = { class: "viur-shop-cart-card-price" }, ZD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("div", { class: "viur-shop-cart-card-small-print" }, "Brutto / Stk.", -1)), JD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("h2", { class: "viur-shop-cart-sidebar-headline headline" }, "Zusammenfassung", -1)), YD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("br", null, null, -1)), QD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("sl-input", { label: "Rabattcode eingeben" }, null, -1)), XD = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("br", null, null, -1)), eB = { class: "viur-shop-cart-sidebar-info-line" }, tB = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("span", null, "Zwischensumme", -1)), nB = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("div", { class: "viur-shop-cart-sidebar-info-line" }, [
  /* @__PURE__ */ M("span", null, "Rabatt"),
  /* @__PURE__ */ se(" 0 € ")
], -1)), oB = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("div", { class: "viur-shop-cart-sidebar-info-line" }, [
  /* @__PURE__ */ M("span", null, "Versandkosten"),
  /* @__PURE__ */ se(" 0 € ")
], -1)), iB = { class: "viur-shop-cart-sidebar-info-line total" }, rB = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("span", null, "Gesamt:", -1)), sB = /* @__PURE__ */ ze(() => /* @__PURE__ */ M("div", { class: "viur-shop-cart-sidebar-btn-wrap" }, [
  /* @__PURE__ */ M("sl-button", {
    variant: "info",
    size: "small"
  }, " Jetzt Bestellen "),
  /* @__PURE__ */ M("sl-button", {
    size: "small",
    variant: "primary"
  }, [
    /* @__PURE__ */ M("sl-icon", {
      name: "paypal",
      slot: "prefix"
    }),
    /* @__PURE__ */ se(" Paypal ")
  ])
], -1)), aB = {
  __name: "CartView",
  props: {
    mode: { type: String, default: "basket" },
    cartKey: { type: String, default: "" },
    sidebar: { type: Boolean, default: !0 }
  },
  setup(c) {
    const u = c, g = En(), w = Ft(null), k = _e({
      cartIsInit: le(() => !!g.state.basket.length),
      itemsIsInit: le(() => !!g.state.carts[g.state.basket].items),
      images: {},
      currentItem: {}
    });
    le(() => u.mode === "basket" ? g.state.basket : u.cartKey);
    function S(y) {
      return ve.get(`/json/dk_variante/view/${y}`).then(async (C) => {
        let b = await C.json();
        b = b.values;
        let A = b.dk_artikel.dest.image ? ve.downloadUrlFor(b.dk_artikel.dest.image) : "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80";
        k.images[y] = A;
      }), k.images[y];
    }
    async function v() {
      await g.updateItem(
        k.currentItem.article.dest.key,
        g.state.basket,
        0
      ), w.value.hide();
    }
    function x(y, C, b, A) {
      A === 0 ? (w.value.show(), k.currentItem = y) : g.updateItem(C, b, A);
    }
    function p(y, C, b) {
      w.value.show(), k.currentItem = y;
    }
    function D() {
      g.state.carts[g.state.basket].items.forEach((y) => {
        y.key === k.currentItem.key && (y.quantity = 1);
      }), k.currentItem = {};
    }
    return jn(async () => {
      await g.init();
    }), (y, C) => k.cartIsInit ? (j(), q("div", iD, [
      M("sl-dialog", {
        ref_key: "confirm",
        ref: w,
        onSlHide: D
      }, [
        rD,
        M("div", sD, [
          M("sl-button", {
            variant: "danger",
            onClick: C[0] || (C[0] = (b) => w.value.hide()),
            size: "medium"
          }, " Abbrechen "),
          M("sl-button", {
            variant: "success",
            onClick: v,
            size: "medium"
          }, " Aus Warenkorb entfernen ")
        ])
      ], 544),
      M("div", aD, [
        c.mode !== "basket" ? (j(), q("div", lD, [
          M("div", cD, [
            cn(M("sl-input", {
              ref: "cartNameField",
              name: "cart-name",
              placeholder: "Warenkorbname",
              "onUpdate:modelValue": C[1] || (C[1] = (b) => ae(g).state.carts[ae(g).state.basket].info.name = b),
              required: "true",
              inputmode: "text",
              class: "viur-shop-cart-headline"
            }, uD, 512), [
              [wo, ae(g).state.carts[ae(g).state.basket].info.name]
            ])
          ]),
          M("sl-dropdown", hD, [
            gD,
            M("sl-menu", null, [
              M("sl-menu-item", {
                onClick: C[2] || (C[2] = (...b) => y.saveCart && y.saveCart(...b)),
                title: "Warenkorb speichern"
              }, [
                mD,
                se(" Warenkorb speichern ")
              ]),
              M("sl-menu-item", {
                onClick: C[3] || (C[3] = (...b) => y.saveCart && y.saveCart(...b)),
                title: "Zu Projekt hinzufügen"
              }, [
                pD,
                se(" Zu Projekt hinzufügen ")
              ]),
              M("sl-menu-item", {
                onClick: C[4] || (C[4] = (...b) => y.saveCart && y.saveCart(...b)),
                title: "Warenkorb kopieren"
              }, [
                fD,
                se(" Warenkorb kopieren ")
              ]),
              M("sl-menu-item", {
                onClick: C[5] || (C[5] = (...b) => y.saveCart && y.saveCart(...b)),
                title: "Warenkorb löschen"
              }, [
                bD,
                se(" Warenkorb löschen ")
              ])
            ])
          ])
        ])) : he("", !0),
        c.mode !== "basket" ? cn((j(), q("sl-input", {
          key: 1,
          name: "cart-internalCartNo",
          placeholder: "Freifeld (Kommission)",
          "onUpdate:modelValue": C[6] || (C[6] = (b) => ae(g).state.carts[ae(g).state.basket].info.customer_comment = b),
          inputmode: "text",
          class: "viur-shop-cart-descr"
        }, wD, 512)), [
          [
            wo,
            ae(g).state.carts[ae(g).state.basket].info.customer_comment
          ]
        ]) : he("", !0),
        vD,
        M("sl-alert", _D, ED, 512),
        M("sl-alert", xD, TD, 512),
        k.itemsIsInit ? (j(!0), q(ye, { key: 3 }, dt(ae(g).state.carts[ae(g).state.basket].items, (b) => (j(), q("sl-card", ID, [
          M("img", {
            class: "viur-shop-cart-card-img",
            slot: "image",
            src: S(b.article.dest.key)
          }, null, 8, OD),
          M("div", RD, [
            M("h4", zD, Se(b.article.dest.shop_name) + " | 425018 ", 1)
          ]),
          M("div", MD, [
            M("div", ND, [
              FD,
              M("div", $D, [
                LD,
                M("sl-button", {
                  size: "small",
                  outline: "",
                  class: "viur-shop-cart-card-delete-btn",
                  variant: "primary",
                  title: "Remove from cart",
                  onClick: (A) => p(
                    b,
                    b.article.dest.key,
                    ae(g).state.basket
                  )
                }, HD, 8, VD)
              ])
            ]),
            M("div", UD, [
              cn(M("sl-input", {
                class: "amount-input",
                type: "number",
                label: "Anzahl",
                placeholder: "Number",
                min: "0",
                "onUpdate:modelValue": (A) => b.quantity = A,
                onInput: (A) => x(
                  b,
                  b.article.dest.key,
                  ae(g).state.basket,
                  b.quantity
                )
              }, null, 40, qD), [
                [wo, b.quantity]
              ])
            ]),
            M("div", WD, [
              GD,
              M("div", KD, Se(b.price.retail) + " € ", 1),
              ZD
            ])
          ])
        ]))), 256)) : (j(), q("sl-spinner", PD))
      ]),
      c.sidebar ? (j(), ut(Dw, {
        key: 0,
        to: "#order_sidebar"
      }, [
        JD,
        YD,
        QD,
        XD,
        M("div", eB, [
          tB,
          se(" " + Se(ae(g).state.carts[ae(g).state.basket].info.total) + " € ", 1)
        ]),
        nB,
        oB,
        M("div", iB, [
          rB,
          se(" " + Se(ae(g).state.carts[ae(g).state.basket].info.total) + " € ", 1)
        ]),
        sB
      ])) : he("", !0)
    ])) : (j(), ut(Pw, { key: 0 }));
  }
}, Iw = /* @__PURE__ */ Ee(aB, [["__scopeId", "data-v-44571029"]]), lB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Iw
}, Symbol.toStringTag, { value: "Module" }));
function cB() {
  return Ow().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function Ow() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const dB = typeof Proxy == "function", uB = "devtools-plugin:setup", hB = "plugin:settings:set";
let ri, _c;
function gB() {
  var c;
  return ri !== void 0 || (typeof window < "u" && window.performance ? (ri = !0, _c = window.performance) : typeof globalThis < "u" && (!((c = globalThis.perf_hooks) === null || c === void 0) && c.performance) ? (ri = !0, _c = globalThis.perf_hooks.performance) : ri = !1), ri;
}
function mB() {
  return gB() ? _c.now() : Date.now();
}
class pB {
  constructor(u, g) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = u, this.hook = g;
    const w = {};
    if (u.settings)
      for (const v in u.settings) {
        const x = u.settings[v];
        w[v] = x.defaultValue;
      }
    const k = `__vue-devtools-plugin-settings__${u.id}`;
    let S = Object.assign({}, w);
    try {
      const v = localStorage.getItem(k), x = JSON.parse(v);
      Object.assign(S, x);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return S;
      },
      setSettings(v) {
        try {
          localStorage.setItem(k, JSON.stringify(v));
        } catch {
        }
        S = v;
      },
      now() {
        return mB();
      }
    }, g && g.on(hB, (v, x) => {
      v === this.plugin.id && this.fallbacks.setSettings(x);
    }), this.proxiedOn = new Proxy({}, {
      get: (v, x) => this.target ? this.target.on[x] : (...p) => {
        this.onQueue.push({
          method: x,
          args: p
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (v, x) => this.target ? this.target[x] : x === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(x) ? (...p) => (this.targetQueue.push({
        method: x,
        args: p,
        resolve: () => {
        }
      }), this.fallbacks[x](...p)) : (...p) => new Promise((D) => {
        this.targetQueue.push({
          method: x,
          args: p,
          resolve: D
        });
      })
    });
  }
  async setRealTarget(u) {
    this.target = u;
    for (const g of this.onQueue)
      this.target.on[g.method](...g.args);
    for (const g of this.targetQueue)
      g.resolve(await this.target[g.method](...g.args));
  }
}
function fB(c, u) {
  const g = c, w = Ow(), k = cB(), S = dB && g.enableEarlyProxy;
  if (k && (w.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !S))
    k.emit(uB, c, u);
  else {
    const v = S ? new pB(g, k) : null;
    (w.__VUE_DEVTOOLS_PLUGINS__ = w.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: g,
      setupFn: u,
      proxy: v
    }), v && u(v.proxiedTarget);
  }
}
/*!
  * vue-router v4.3.2
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const Cn = typeof document < "u";
function bB(c) {
  return c.__esModule || c[Symbol.toStringTag] === "Module";
}
const Ie = Object.assign;
function uc(c, u) {
  const g = {};
  for (const w in u) {
    const k = u[w];
    g[w] = $t(k) ? k.map(c) : c(k);
  }
  return g;
}
const er = () => {
}, $t = Array.isArray;
function me(c) {
  const u = Array.from(arguments).slice(1);
  console.warn.apply(console, ["[Vue Router warn]: " + c].concat(u));
}
const Rw = /#/g, kB = /&/g, wB = /\//g, vB = /=/g, _B = /\?/g, zw = /\+/g, AB = /%5B/g, CB = /%5D/g, Mw = /%5E/g, yB = /%60/g, Nw = /%7B/g, EB = /%7C/g, Fw = /%7D/g, xB = /%20/g;
function zc(c) {
  return encodeURI("" + c).replace(EB, "|").replace(AB, "[").replace(CB, "]");
}
function SB(c) {
  return zc(c).replace(Nw, "{").replace(Fw, "}").replace(Mw, "^");
}
function Ac(c) {
  return zc(c).replace(zw, "%2B").replace(xB, "+").replace(Rw, "%23").replace(kB, "%26").replace(yB, "`").replace(Nw, "{").replace(Fw, "}").replace(Mw, "^");
}
function DB(c) {
  return Ac(c).replace(vB, "%3D");
}
function BB(c) {
  return zc(c).replace(Rw, "%23").replace(_B, "%3F");
}
function TB(c) {
  return c == null ? "" : BB(c).replace(wB, "%2F");
}
function ci(c) {
  try {
    return decodeURIComponent("" + c);
  } catch {
    process.env.NODE_ENV !== "production" && me(`Error decoding "${c}". Using original value`);
  }
  return "" + c;
}
const PB = /\/$/, IB = (c) => c.replace(PB, "");
function hc(c, u, g = "/") {
  let w, k = {}, S = "", v = "";
  const x = u.indexOf("#");
  let p = u.indexOf("?");
  return x < p && x >= 0 && (p = -1), p > -1 && (w = u.slice(0, p), S = u.slice(p + 1, x > -1 ? x : u.length), k = c(S)), x > -1 && (w = w || u.slice(0, x), v = u.slice(x, u.length)), w = zB(w ?? u, g), {
    fullPath: w + (S && "?") + S + v,
    path: w,
    query: k,
    hash: ci(v)
  };
}
function OB(c, u) {
  const g = u.query ? c(u.query) : "";
  return u.path + (g && "?") + g + (u.hash || "");
}
function xk(c, u) {
  return !u || !c.toLowerCase().startsWith(u.toLowerCase()) ? c : c.slice(u.length) || "/";
}
function Sk(c, u, g) {
  const w = u.matched.length - 1, k = g.matched.length - 1;
  return w > -1 && w === k && Vn(u.matched[w], g.matched[k]) && $w(u.params, g.params) && c(u.query) === c(g.query) && u.hash === g.hash;
}
function Vn(c, u) {
  return (c.aliasOf || c) === (u.aliasOf || u);
}
function $w(c, u) {
  if (Object.keys(c).length !== Object.keys(u).length)
    return !1;
  for (const g in c)
    if (!RB(c[g], u[g]))
      return !1;
  return !0;
}
function RB(c, u) {
  return $t(c) ? Dk(c, u) : $t(u) ? Dk(u, c) : c === u;
}
function Dk(c, u) {
  return $t(u) ? c.length === u.length && c.every((g, w) => g === u[w]) : c.length === 1 && c[0] === u;
}
function zB(c, u) {
  if (c.startsWith("/"))
    return c;
  if (process.env.NODE_ENV !== "production" && !u.startsWith("/"))
    return me(`Cannot resolve a relative location without an absolute path. Trying to resolve "${c}" from "${u}". It should look like "/${u}".`), c;
  if (!c)
    return u;
  const g = u.split("/"), w = c.split("/"), k = w[w.length - 1];
  (k === ".." || k === ".") && w.push("");
  let S = g.length - 1, v, x;
  for (v = 0; v < w.length; v++)
    if (x = w[v], x !== ".")
      if (x === "..")
        S > 1 && S--;
      else
        break;
  return g.slice(0, S).join("/") + "/" + w.slice(v).join("/");
}
var sr;
(function(c) {
  c.pop = "pop", c.push = "push";
})(sr || (sr = {}));
var tr;
(function(c) {
  c.back = "back", c.forward = "forward", c.unknown = "";
})(tr || (tr = {}));
function MB(c) {
  if (!c)
    if (Cn) {
      const u = document.querySelector("base");
      c = u && u.getAttribute("href") || "/", c = c.replace(/^\w+:\/\/[^\/]+/, "");
    } else
      c = "/";
  return c[0] !== "/" && c[0] !== "#" && (c = "/" + c), IB(c);
}
const NB = /^[^#]+#/;
function FB(c, u) {
  return c.replace(NB, "#") + u;
}
function $B(c, u) {
  const g = document.documentElement.getBoundingClientRect(), w = c.getBoundingClientRect();
  return {
    behavior: u.behavior,
    left: w.left - g.left - (u.left || 0),
    top: w.top - g.top - (u.top || 0)
  };
}
const Is = () => ({
  left: window.scrollX,
  top: window.scrollY
});
function LB(c) {
  let u;
  if ("el" in c) {
    const g = c.el, w = typeof g == "string" && g.startsWith("#");
    if (process.env.NODE_ENV !== "production" && typeof c.el == "string" && (!w || !document.getElementById(c.el.slice(1))))
      try {
        const S = document.querySelector(c.el);
        if (w && S) {
          me(`The selector "${c.el}" should be passed as "el: document.querySelector('${c.el}')" because it starts with "#".`);
          return;
        }
      } catch {
        me(`The selector "${c.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
        return;
      }
    const k = typeof g == "string" ? w ? document.getElementById(g.slice(1)) : document.querySelector(g) : g;
    if (!k) {
      process.env.NODE_ENV !== "production" && me(`Couldn't find element using selector "${c.el}" returned by scrollBehavior.`);
      return;
    }
    u = $B(k, c);
  } else
    u = c;
  "scrollBehavior" in document.documentElement.style ? window.scrollTo(u) : window.scrollTo(u.left != null ? u.left : window.scrollX, u.top != null ? u.top : window.scrollY);
}
function Bk(c, u) {
  return (history.state ? history.state.position - u : -1) + c;
}
const Cc = /* @__PURE__ */ new Map();
function VB(c, u) {
  Cc.set(c, u);
}
function jB(c) {
  const u = Cc.get(c);
  return Cc.delete(c), u;
}
let HB = () => location.protocol + "//" + location.host;
function Lw(c, u) {
  const { pathname: g, search: w, hash: k } = u, S = c.indexOf("#");
  if (S > -1) {
    let x = k.includes(c.slice(S)) ? c.slice(S).length : 1, p = k.slice(x);
    return p[0] !== "/" && (p = "/" + p), xk(p, "");
  }
  return xk(g, c) + w + k;
}
function UB(c, u, g, w) {
  let k = [], S = [], v = null;
  const x = ({ state: b }) => {
    const A = Lw(c, location), P = g.value, R = u.value;
    let z = 0;
    if (b) {
      if (g.value = A, u.value = b, v && v === P) {
        v = null;
        return;
      }
      z = R ? b.position - R.position : 0;
    } else
      w(A);
    k.forEach((F) => {
      F(g.value, P, {
        delta: z,
        type: sr.pop,
        direction: z ? z > 0 ? tr.forward : tr.back : tr.unknown
      });
    });
  };
  function p() {
    v = g.value;
  }
  function D(b) {
    k.push(b);
    const A = () => {
      const P = k.indexOf(b);
      P > -1 && k.splice(P, 1);
    };
    return S.push(A), A;
  }
  function y() {
    const { history: b } = window;
    b.state && b.replaceState(Ie({}, b.state, { scroll: Is() }), "");
  }
  function C() {
    for (const b of S)
      b();
    S = [], window.removeEventListener("popstate", x), window.removeEventListener("beforeunload", y);
  }
  return window.addEventListener("popstate", x), window.addEventListener("beforeunload", y, {
    passive: !0
  }), {
    pauseListeners: p,
    listen: D,
    destroy: C
  };
}
function Tk(c, u, g, w = !1, k = !1) {
  return {
    back: c,
    current: u,
    forward: g,
    replaced: w,
    position: window.history.length,
    scroll: k ? Is() : null
  };
}
function qB(c) {
  const { history: u, location: g } = window, w = {
    value: Lw(c, g)
  }, k = { value: u.state };
  k.value || S(w.value, {
    back: null,
    current: w.value,
    forward: null,
    // the length is off by one, we need to decrease it
    position: u.length - 1,
    replaced: !0,
    // don't add a scroll as the user may have an anchor, and we want
    // scrollBehavior to be triggered without a saved position
    scroll: null
  }, !0);
  function S(p, D, y) {
    const C = c.indexOf("#"), b = C > -1 ? (g.host && document.querySelector("base") ? c : c.slice(C)) + p : HB() + c + p;
    try {
      u[y ? "replaceState" : "pushState"](D, "", b), k.value = D;
    } catch (A) {
      process.env.NODE_ENV !== "production" ? me("Error with push/replace State", A) : console.error(A), g[y ? "replace" : "assign"](b);
    }
  }
  function v(p, D) {
    const y = Ie({}, u.state, Tk(
      k.value.back,
      // keep back and forward entries but override current position
      p,
      k.value.forward,
      !0
    ), D, { position: k.value.position });
    S(p, y, !0), w.value = p;
  }
  function x(p, D) {
    const y = Ie(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      k.value,
      u.state,
      {
        forward: p,
        scroll: Is()
      }
    );
    process.env.NODE_ENV !== "production" && !u.state && me(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`), S(y.current, y, !0);
    const C = Ie({}, Tk(w.value, p, null), { position: y.position + 1 }, D);
    S(p, C, !1), w.value = p;
  }
  return {
    location: w,
    state: k,
    push: x,
    replace: v
  };
}
function WB(c) {
  c = MB(c);
  const u = qB(c), g = UB(c, u.state, u.location, u.replace);
  function w(S, v = !0) {
    v || g.pauseListeners(), history.go(S);
  }
  const k = Ie({
    // it's overridden right after
    location: "",
    base: c,
    go: w,
    createHref: FB.bind(null, c)
  }, u, g);
  return Object.defineProperty(k, "location", {
    enumerable: !0,
    get: () => u.location.value
  }), Object.defineProperty(k, "state", {
    enumerable: !0,
    get: () => u.state.value
  }), k;
}
function GB(c) {
  return c = location.host ? c || location.pathname + location.search : "", c.includes("#") || (c += "#"), process.env.NODE_ENV !== "production" && !c.endsWith("#/") && !c.endsWith("#") && me(`A hash base must end with a "#":
"${c}" should be "${c.replace(/#.*$/, "#")}".`), WB(c);
}
function Ds(c) {
  return typeof c == "string" || c && typeof c == "object";
}
function Vw(c) {
  return typeof c == "string" || typeof c == "symbol";
}
const Nn = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
}, yc = Symbol(process.env.NODE_ENV !== "production" ? "navigation failure" : "");
var Pk;
(function(c) {
  c[c.aborted = 4] = "aborted", c[c.cancelled = 8] = "cancelled", c[c.duplicated = 16] = "duplicated";
})(Pk || (Pk = {}));
const KB = {
  1({ location: c, currentLocation: u }) {
    return `No match for
 ${JSON.stringify(c)}${u ? `
while being at
` + JSON.stringify(u) : ""}`;
  },
  2({ from: c, to: u }) {
    return `Redirected from "${c.fullPath}" to "${JB(u)}" via a navigation guard.`;
  },
  4({ from: c, to: u }) {
    return `Navigation aborted from "${c.fullPath}" to "${u.fullPath}" via a navigation guard.`;
  },
  8({ from: c, to: u }) {
    return `Navigation cancelled from "${c.fullPath}" to "${u.fullPath}" with a new navigation.`;
  },
  16({ from: c, to: u }) {
    return `Avoided redundant navigation to current location: "${c.fullPath}".`;
  }
};
function di(c, u) {
  return process.env.NODE_ENV !== "production" ? Ie(new Error(KB[c](u)), {
    type: c,
    [yc]: !0
  }, u) : Ie(new Error(), {
    type: c,
    [yc]: !0
  }, u);
}
function An(c, u) {
  return c instanceof Error && yc in c && (u == null || !!(c.type & u));
}
const ZB = ["params", "query", "hash"];
function JB(c) {
  if (typeof c == "string")
    return c;
  if (c.path != null)
    return c.path;
  const u = {};
  for (const g of ZB)
    g in c && (u[g] = c[g]);
  return JSON.stringify(u, null, 2);
}
const Ik = "[^/]+?", YB = {
  sensitive: !1,
  strict: !1,
  start: !0,
  end: !0
}, QB = /[.+*?^${}()[\]/\\]/g;
function XB(c, u) {
  const g = Ie({}, YB, u), w = [];
  let k = g.start ? "^" : "";
  const S = [];
  for (const D of c) {
    const y = D.length ? [] : [
      90
      /* PathScore.Root */
    ];
    g.strict && !D.length && (k += "/");
    for (let C = 0; C < D.length; C++) {
      const b = D[C];
      let A = 40 + (g.sensitive ? 0.25 : 0);
      if (b.type === 0)
        C || (k += "/"), k += b.value.replace(QB, "\\$&"), A += 40;
      else if (b.type === 1) {
        const { value: P, repeatable: R, optional: z, regexp: F } = b;
        S.push({
          name: P,
          repeatable: R,
          optional: z
        });
        const L = F || Ik;
        if (L !== Ik) {
          A += 10;
          try {
            new RegExp(`(${L})`);
          } catch (J) {
            throw new Error(`Invalid custom RegExp for param "${P}" (${L}): ` + J.message);
          }
        }
        let U = R ? `((?:${L})(?:/(?:${L}))*)` : `(${L})`;
        C || (U = // avoid an optional / if there are more segments e.g. /:p?-static
        // or /:p?-:p2
        z && D.length < 2 ? `(?:/${U})` : "/" + U), z && (U += "?"), k += U, A += 20, z && (A += -8), R && (A += -20), L === ".*" && (A += -50);
      }
      y.push(A);
    }
    w.push(y);
  }
  if (g.strict && g.end) {
    const D = w.length - 1;
    w[D][w[D].length - 1] += 0.7000000000000001;
  }
  g.strict || (k += "/?"), g.end ? k += "$" : g.strict && (k += "(?:/|$)");
  const v = new RegExp(k, g.sensitive ? "" : "i");
  function x(D) {
    const y = D.match(v), C = {};
    if (!y)
      return null;
    for (let b = 1; b < y.length; b++) {
      const A = y[b] || "", P = S[b - 1];
      C[P.name] = A && P.repeatable ? A.split("/") : A;
    }
    return C;
  }
  function p(D) {
    let y = "", C = !1;
    for (const b of c) {
      (!C || !y.endsWith("/")) && (y += "/"), C = !1;
      for (const A of b)
        if (A.type === 0)
          y += A.value;
        else if (A.type === 1) {
          const { value: P, repeatable: R, optional: z } = A, F = P in D ? D[P] : "";
          if ($t(F) && !R)
            throw new Error(`Provided param "${P}" is an array but it is not repeatable (* or + modifiers)`);
          const L = $t(F) ? F.join("/") : F;
          if (!L)
            if (z)
              b.length < 2 && (y.endsWith("/") ? y = y.slice(0, -1) : C = !0);
            else
              throw new Error(`Missing required param "${P}"`);
          y += L;
        }
    }
    return y || "/";
  }
  return {
    re: v,
    score: w,
    keys: S,
    parse: x,
    stringify: p
  };
}
function eT(c, u) {
  let g = 0;
  for (; g < c.length && g < u.length; ) {
    const w = u[g] - c[g];
    if (w)
      return w;
    g++;
  }
  return c.length < u.length ? c.length === 1 && c[0] === 80 ? -1 : 1 : c.length > u.length ? u.length === 1 && u[0] === 80 ? 1 : -1 : 0;
}
function tT(c, u) {
  let g = 0;
  const w = c.score, k = u.score;
  for (; g < w.length && g < k.length; ) {
    const S = eT(w[g], k[g]);
    if (S)
      return S;
    g++;
  }
  if (Math.abs(k.length - w.length) === 1) {
    if (Ok(w))
      return 1;
    if (Ok(k))
      return -1;
  }
  return k.length - w.length;
}
function Ok(c) {
  const u = c[c.length - 1];
  return c.length > 0 && u[u.length - 1] < 0;
}
const nT = {
  type: 0,
  value: ""
}, oT = /[a-zA-Z0-9_]/;
function iT(c) {
  if (!c)
    return [[]];
  if (c === "/")
    return [[nT]];
  if (!c.startsWith("/"))
    throw new Error(process.env.NODE_ENV !== "production" ? `Route paths should start with a "/": "${c}" should be "/${c}".` : `Invalid path "${c}"`);
  function u(A) {
    throw new Error(`ERR (${g})/"${D}": ${A}`);
  }
  let g = 0, w = g;
  const k = [];
  let S;
  function v() {
    S && k.push(S), S = [];
  }
  let x = 0, p, D = "", y = "";
  function C() {
    D && (g === 0 ? S.push({
      type: 0,
      value: D
    }) : g === 1 || g === 2 || g === 3 ? (S.length > 1 && (p === "*" || p === "+") && u(`A repeatable param (${D}) must be alone in its segment. eg: '/:ids+.`), S.push({
      type: 1,
      value: D,
      regexp: y,
      repeatable: p === "*" || p === "+",
      optional: p === "*" || p === "?"
    })) : u("Invalid state to consume buffer"), D = "");
  }
  function b() {
    D += p;
  }
  for (; x < c.length; ) {
    if (p = c[x++], p === "\\" && g !== 2) {
      w = g, g = 4;
      continue;
    }
    switch (g) {
      case 0:
        p === "/" ? (D && C(), v()) : p === ":" ? (C(), g = 1) : b();
        break;
      case 4:
        b(), g = w;
        break;
      case 1:
        p === "(" ? g = 2 : oT.test(p) ? b() : (C(), g = 0, p !== "*" && p !== "?" && p !== "+" && x--);
        break;
      case 2:
        p === ")" ? y[y.length - 1] == "\\" ? y = y.slice(0, -1) + p : g = 3 : y += p;
        break;
      case 3:
        C(), g = 0, p !== "*" && p !== "?" && p !== "+" && x--, y = "";
        break;
      default:
        u("Unknown state");
        break;
    }
  }
  return g === 2 && u(`Unfinished custom RegExp for param "${D}"`), C(), v(), k;
}
function rT(c, u, g) {
  const w = XB(iT(c.path), g);
  if (process.env.NODE_ENV !== "production") {
    const S = /* @__PURE__ */ new Set();
    for (const v of w.keys)
      S.has(v.name) && me(`Found duplicated params with name "${v.name}" for path "${c.path}". Only the last one will be available on "$route.params".`), S.add(v.name);
  }
  const k = Ie(w, {
    record: c,
    parent: u,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  return u && !k.record.aliasOf == !u.record.aliasOf && u.children.push(k), k;
}
function sT(c, u) {
  const g = [], w = /* @__PURE__ */ new Map();
  u = Mk({ strict: !1, end: !0, sensitive: !1 }, u);
  function k(y) {
    return w.get(y);
  }
  function S(y, C, b) {
    const A = !b, P = aT(y);
    process.env.NODE_ENV !== "production" && uT(P, C), P.aliasOf = b && b.record;
    const R = Mk(u, y), z = [
      P
    ];
    if ("alias" in y) {
      const U = typeof y.alias == "string" ? [y.alias] : y.alias;
      for (const J of U)
        z.push(Ie({}, P, {
          // this allows us to hold a copy of the `components` option
          // so that async components cache is hold on the original record
          components: b ? b.record.components : P.components,
          path: J,
          // we might be the child of an alias
          aliasOf: b ? b.record : P
          // the aliases are always of the same kind as the original since they
          // are defined on the same record
        }));
    }
    let F, L;
    for (const U of z) {
      const { path: J } = U;
      if (C && J[0] !== "/") {
        const ie = C.record.path, ce = ie[ie.length - 1] === "/" ? "" : "/";
        U.path = C.record.path + (J && ce + J);
      }
      if (process.env.NODE_ENV !== "production" && U.path === "*")
        throw new Error(`Catch all routes ("*") must now be defined using a param with a custom regexp.
See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.`);
      if (F = rT(U, C, R), process.env.NODE_ENV !== "production" && C && J[0] === "/" && hT(F, C), b ? (b.alias.push(F), process.env.NODE_ENV !== "production" && dT(b, F)) : (L = L || F, L !== F && L.alias.push(F), A && y.name && !zk(F) && v(y.name)), P.children) {
        const ie = P.children;
        for (let ce = 0; ce < ie.length; ce++)
          S(ie[ce], F, b && b.children[ce]);
      }
      b = b || F, (F.record.components && Object.keys(F.record.components).length || F.record.name || F.record.redirect) && p(F);
    }
    return L ? () => {
      v(L);
    } : er;
  }
  function v(y) {
    if (Vw(y)) {
      const C = w.get(y);
      C && (w.delete(y), g.splice(g.indexOf(C), 1), C.children.forEach(v), C.alias.forEach(v));
    } else {
      const C = g.indexOf(y);
      C > -1 && (g.splice(C, 1), y.record.name && w.delete(y.record.name), y.children.forEach(v), y.alias.forEach(v));
    }
  }
  function x() {
    return g;
  }
  function p(y) {
    let C = 0;
    for (; C < g.length && tT(y, g[C]) >= 0 && // Adding children with empty path should still appear before the parent
    // https://github.com/vuejs/router/issues/1124
    (y.record.path !== g[C].record.path || !jw(y, g[C])); )
      C++;
    g.splice(C, 0, y), y.record.name && !zk(y) && w.set(y.record.name, y);
  }
  function D(y, C) {
    let b, A = {}, P, R;
    if ("name" in y && y.name) {
      if (b = w.get(y.name), !b)
        throw di(1, {
          location: y
        });
      if (process.env.NODE_ENV !== "production") {
        const L = Object.keys(y.params || {}).filter((U) => !b.keys.find((J) => J.name === U));
        L.length && me(`Discarded invalid param(s) "${L.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);
      }
      R = b.record.name, A = Ie(
        // paramsFromLocation is a new object
        Rk(
          C.params,
          // only keep params that exist in the resolved location
          // only keep optional params coming from a parent record
          b.keys.filter((L) => !L.optional).concat(b.parent ? b.parent.keys.filter((L) => L.optional) : []).map((L) => L.name)
        ),
        // discard any existing params in the current location that do not exist here
        // #1497 this ensures better active/exact matching
        y.params && Rk(y.params, b.keys.map((L) => L.name))
      ), P = b.stringify(A);
    } else if (y.path != null)
      P = y.path, process.env.NODE_ENV !== "production" && !P.startsWith("/") && me(`The Matcher cannot resolve relative paths but received "${P}". Unless you directly called \`matcher.resolve("${P}")\`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.`), b = g.find((L) => L.re.test(P)), b && (A = b.parse(P), R = b.record.name);
    else {
      if (b = C.name ? w.get(C.name) : g.find((L) => L.re.test(C.path)), !b)
        throw di(1, {
          location: y,
          currentLocation: C
        });
      R = b.record.name, A = Ie({}, C.params, y.params), P = b.stringify(A);
    }
    const z = [];
    let F = b;
    for (; F; )
      z.unshift(F.record), F = F.parent;
    return {
      name: R,
      path: P,
      params: A,
      matched: z,
      meta: cT(z)
    };
  }
  return c.forEach((y) => S(y)), { addRoute: S, resolve: D, removeRoute: v, getRoutes: x, getRecordMatcher: k };
}
function Rk(c, u) {
  const g = {};
  for (const w of u)
    w in c && (g[w] = c[w]);
  return g;
}
function aT(c) {
  return {
    path: c.path,
    redirect: c.redirect,
    name: c.name,
    meta: c.meta || {},
    aliasOf: void 0,
    beforeEnter: c.beforeEnter,
    props: lT(c),
    children: c.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in c ? c.components || null : c.component && { default: c.component }
  };
}
function lT(c) {
  const u = {}, g = c.props || !1;
  if ("component" in c)
    u.default = g;
  else
    for (const w in c.components)
      u[w] = typeof g == "object" ? g[w] : g;
  return u;
}
function zk(c) {
  for (; c; ) {
    if (c.record.aliasOf)
      return !0;
    c = c.parent;
  }
  return !1;
}
function cT(c) {
  return c.reduce((u, g) => Ie(u, g.meta), {});
}
function Mk(c, u) {
  const g = {};
  for (const w in c)
    g[w] = w in u ? u[w] : c[w];
  return g;
}
function Ec(c, u) {
  return c.name === u.name && c.optional === u.optional && c.repeatable === u.repeatable;
}
function dT(c, u) {
  for (const g of c.keys)
    if (!g.optional && !u.keys.find(Ec.bind(null, g)))
      return me(`Alias "${u.record.path}" and the original record: "${c.record.path}" must have the exact same param named "${g.name}"`);
  for (const g of u.keys)
    if (!g.optional && !c.keys.find(Ec.bind(null, g)))
      return me(`Alias "${u.record.path}" and the original record: "${c.record.path}" must have the exact same param named "${g.name}"`);
}
function uT(c, u) {
  u && u.record.name && !c.name && !c.path && me(`The route named "${String(u.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);
}
function hT(c, u) {
  for (const g of u.keys)
    if (!c.keys.find(Ec.bind(null, g)))
      return me(`Absolute path "${c.record.path}" must have the exact same param named "${g.name}" as its parent "${u.record.path}".`);
}
function jw(c, u) {
  return u.children.some((g) => g === c || jw(c, g));
}
function gT(c) {
  const u = {};
  if (c === "" || c === "?")
    return u;
  const w = (c[0] === "?" ? c.slice(1) : c).split("&");
  for (let k = 0; k < w.length; ++k) {
    const S = w[k].replace(zw, " "), v = S.indexOf("="), x = ci(v < 0 ? S : S.slice(0, v)), p = v < 0 ? null : ci(S.slice(v + 1));
    if (x in u) {
      let D = u[x];
      $t(D) || (D = u[x] = [D]), D.push(p);
    } else
      u[x] = p;
  }
  return u;
}
function Nk(c) {
  let u = "";
  for (let g in c) {
    const w = c[g];
    if (g = DB(g), w == null) {
      w !== void 0 && (u += (u.length ? "&" : "") + g);
      continue;
    }
    ($t(w) ? w.map((S) => S && Ac(S)) : [w && Ac(w)]).forEach((S) => {
      S !== void 0 && (u += (u.length ? "&" : "") + g, S != null && (u += "=" + S));
    });
  }
  return u;
}
function mT(c) {
  const u = {};
  for (const g in c) {
    const w = c[g];
    w !== void 0 && (u[g] = $t(w) ? w.map((k) => k == null ? null : "" + k) : w == null ? w : "" + w);
  }
  return u;
}
const pT = Symbol(process.env.NODE_ENV !== "production" ? "router view location matched" : ""), Fk = Symbol(process.env.NODE_ENV !== "production" ? "router view depth" : ""), Mc = Symbol(process.env.NODE_ENV !== "production" ? "router" : ""), Nc = Symbol(process.env.NODE_ENV !== "production" ? "route location" : ""), xc = Symbol(process.env.NODE_ENV !== "production" ? "router view location" : "");
function Ji() {
  let c = [];
  function u(w) {
    return c.push(w), () => {
      const k = c.indexOf(w);
      k > -1 && c.splice(k, 1);
    };
  }
  function g() {
    c = [];
  }
  return {
    add: u,
    list: () => c.slice(),
    reset: g
  };
}
function Fn(c, u, g, w, k, S = (v) => v()) {
  const v = w && // name is defined if record is because of the function overload
  (w.enterCallbacks[k] = w.enterCallbacks[k] || []);
  return () => new Promise((x, p) => {
    const D = (b) => {
      b === !1 ? p(di(4, {
        from: g,
        to: u
      })) : b instanceof Error ? p(b) : Ds(b) ? p(di(2, {
        from: u,
        to: b
      })) : (v && // since enterCallbackArray is truthy, both record and name also are
      w.enterCallbacks[k] === v && typeof b == "function" && v.push(b), x());
    }, y = S(() => c.call(w && w.instances[k], u, g, process.env.NODE_ENV !== "production" ? fT(D, u, g) : D));
    let C = Promise.resolve(y);
    if (c.length < 3 && (C = C.then(D)), process.env.NODE_ENV !== "production" && c.length > 2) {
      const b = `The "next" callback was never called inside of ${c.name ? '"' + c.name + '"' : ""}:
${c.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
      if (typeof y == "object" && "then" in y)
        C = C.then((A) => D._called ? A : (me(b), Promise.reject(new Error("Invalid navigation guard"))));
      else if (y !== void 0 && !D._called) {
        me(b), p(new Error("Invalid navigation guard"));
        return;
      }
    }
    C.catch((b) => p(b));
  });
}
function fT(c, u, g) {
  let w = 0;
  return function() {
    w++ === 1 && me(`The "next" callback was called more than once in one navigation guard when going from "${g.fullPath}" to "${u.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`), c._called = !0, w === 1 && c.apply(null, arguments);
  };
}
function gc(c, u, g, w, k = (S) => S()) {
  const S = [];
  for (const v of c) {
    process.env.NODE_ENV !== "production" && !v.components && !v.children.length && me(`Record with path "${v.path}" is either missing a "component(s)" or "children" property.`);
    for (const x in v.components) {
      let p = v.components[x];
      if (process.env.NODE_ENV !== "production") {
        if (!p || typeof p != "object" && typeof p != "function")
          throw me(`Component "${x}" in record with path "${v.path}" is not a valid component. Received "${String(p)}".`), new Error("Invalid route component");
        if ("then" in p) {
          me(`Component "${x}" in record with path "${v.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
          const D = p;
          p = () => D;
        } else
          p.__asyncLoader && // warn only once per component
          !p.__warnedDefineAsync && (p.__warnedDefineAsync = !0, me(`Component "${x}" in record with path "${v.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`));
      }
      if (!(u !== "beforeRouteEnter" && !v.instances[x]))
        if (bT(p)) {
          const y = (p.__vccOpts || p)[u];
          y && S.push(Fn(y, g, w, v, x, k));
        } else {
          let D = p();
          process.env.NODE_ENV !== "production" && !("catch" in D) && (me(`Component "${x}" in record with path "${v.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`), D = Promise.resolve(D)), S.push(() => D.then((y) => {
            if (!y)
              return Promise.reject(new Error(`Couldn't resolve component "${x}" at "${v.path}"`));
            const C = bB(y) ? y.default : y;
            v.components[x] = C;
            const A = (C.__vccOpts || C)[u];
            return A && Fn(A, g, w, v, x, k)();
          }));
        }
    }
  }
  return S;
}
function bT(c) {
  return typeof c == "object" || "displayName" in c || "props" in c || "__vccOpts" in c;
}
function $k(c) {
  const u = Te(Mc), g = Te(Nc);
  let w = !1, k = null;
  const S = le(() => {
    const y = ae(c.to);
    return process.env.NODE_ENV !== "production" && (!w || y !== k) && (Ds(y) || (w ? me(`Invalid value for prop "to" in useLink()
- to:`, y, `
- previous to:`, k, `
- props:`, c) : me(`Invalid value for prop "to" in useLink()
- to:`, y, `
- props:`, c)), k = y, w = !0), u.resolve(y);
  }), v = le(() => {
    const { matched: y } = S.value, { length: C } = y, b = y[C - 1], A = g.matched;
    if (!b || !A.length)
      return -1;
    const P = A.findIndex(Vn.bind(null, b));
    if (P > -1)
      return P;
    const R = Lk(y[C - 2]);
    return (
      // we are dealing with nested routes
      C > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      Lk(b) === R && // avoid comparing the child with its parent
      A[A.length - 1].path !== R ? A.findIndex(Vn.bind(null, y[C - 2])) : P
    );
  }), x = le(() => v.value > -1 && _T(g.params, S.value.params)), p = le(() => v.value > -1 && v.value === g.matched.length - 1 && $w(g.params, S.value.params));
  function D(y = {}) {
    return vT(y) ? u[ae(c.replace) ? "replace" : "push"](
      ae(c.to)
      // avoid uncaught errors are they are logged anyway
    ).catch(er) : Promise.resolve();
  }
  if (process.env.NODE_ENV !== "production" && Cn) {
    const y = Ic();
    if (y) {
      const C = {
        route: S.value,
        isActive: x.value,
        isExactActive: p.value,
        error: null
      };
      y.__vrl_devtools = y.__vrl_devtools || [], y.__vrl_devtools.push(C), dr(() => {
        C.route = S.value, C.isActive = x.value, C.isExactActive = p.value, C.error = Ds(ae(c.to)) ? null : 'Invalid "to" value';
      }, { flush: "post" });
    }
  }
  return {
    route: S,
    href: le(() => S.value.href),
    isActive: x,
    isExactActive: p,
    navigate: D
  };
}
const kT = /* @__PURE__ */ Ye({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: !0
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink: $k,
  setup(c, { slots: u }) {
    const g = _e($k(c)), { options: w } = Te(Mc), k = le(() => ({
      [Vk(c.activeClass, w.linkActiveClass, "router-link-active")]: g.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [Vk(c.exactActiveClass, w.linkExactActiveClass, "router-link-exact-active")]: g.isExactActive
    }));
    return () => {
      const S = u.default && u.default(g);
      return c.custom ? S : Bw("a", {
        "aria-current": g.isExactActive ? c.ariaCurrentValue : null,
        href: g.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: g.navigate,
        class: k.value
      }, S);
    };
  }
}), wT = kT;
function vT(c) {
  if (!(c.metaKey || c.altKey || c.ctrlKey || c.shiftKey) && !c.defaultPrevented && !(c.button !== void 0 && c.button !== 0)) {
    if (c.currentTarget && c.currentTarget.getAttribute) {
      const u = c.currentTarget.getAttribute("target");
      if (/\b_blank\b/i.test(u))
        return;
    }
    return c.preventDefault && c.preventDefault(), !0;
  }
}
function _T(c, u) {
  for (const g in u) {
    const w = u[g], k = c[g];
    if (typeof w == "string") {
      if (w !== k)
        return !1;
    } else if (!$t(k) || k.length !== w.length || w.some((S, v) => S !== k[v]))
      return !1;
  }
  return !0;
}
function Lk(c) {
  return c ? c.aliasOf ? c.aliasOf.path : c.path : "";
}
const Vk = (c, u, g) => c ?? u ?? g, AT = /* @__PURE__ */ Ye({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: !1,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(c, { attrs: u, slots: g }) {
    process.env.NODE_ENV !== "production" && yT();
    const w = Te(xc), k = le(() => c.route || w.value), S = Te(Fk, 0), v = le(() => {
      let D = ae(S);
      const { matched: y } = k.value;
      let C;
      for (; (C = y[D]) && !C.components; )
        D++;
      return D;
    }), x = le(() => k.value.matched[v.value]);
    cc(Fk, le(() => v.value + 1)), cc(pT, x), cc(xc, k);
    const p = Ft();
    return hi(() => [p.value, x.value, c.name], ([D, y, C], [b, A, P]) => {
      y && (y.instances[C] = D, A && A !== y && D && D === b && (y.leaveGuards.size || (y.leaveGuards = A.leaveGuards), y.updateGuards.size || (y.updateGuards = A.updateGuards))), D && y && // if there is no instance but to and from are the same this might be
      // the first visit
      (!A || !Vn(y, A) || !b) && (y.enterCallbacks[C] || []).forEach((R) => R(D));
    }, { flush: "post" }), () => {
      const D = k.value, y = c.name, C = x.value, b = C && C.components[y];
      if (!b)
        return jk(g.default, { Component: b, route: D });
      const A = C.props[y], P = A ? A === !0 ? D.params : typeof A == "function" ? A(D) : A : null, z = Bw(b, Ie({}, P, u, {
        onVnodeUnmounted: (F) => {
          F.component.isUnmounted && (C.instances[y] = null);
        },
        ref: p
      }));
      if (process.env.NODE_ENV !== "production" && Cn && z.ref) {
        const F = {
          depth: v.value,
          name: C.name,
          path: C.path,
          meta: C.meta
        };
        ($t(z.ref) ? z.ref.map((U) => U.i) : [z.ref.i]).forEach((U) => {
          U.__vrv_devtools = F;
        });
      }
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        jk(g.default, { Component: z, route: D }) || z
      );
    };
  }
});
function jk(c, u) {
  if (!c)
    return null;
  const g = c(u);
  return g.length === 1 ? g[0] : g;
}
const CT = AT;
function yT() {
  const c = Ic(), u = c.parent && c.parent.type.name, g = c.parent && c.parent.subTree && c.parent.subTree.type;
  if (u && (u === "KeepAlive" || u.includes("Transition")) && typeof g == "object" && g.name === "RouterView") {
    const w = u === "KeepAlive" ? "keep-alive" : "transition";
    me(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${w}>
    <component :is="Component" />
  </${w}>
</router-view>`);
  }
}
function Yi(c, u) {
  const g = Ie({}, c, {
    // remove variables that can contain vue instances
    matched: c.matched.map((w) => zT(w, ["instances", "children", "aliasOf"]))
  });
  return {
    _custom: {
      type: null,
      readOnly: !0,
      display: c.fullPath,
      tooltip: u,
      value: g
    }
  };
}
function Cs(c) {
  return {
    _custom: {
      display: c
    }
  };
}
let ET = 0;
function xT(c, u, g) {
  if (u.__hasDevtools)
    return;
  u.__hasDevtools = !0;
  const w = ET++;
  fB({
    id: "org.vuejs.router" + (w ? "." + w : ""),
    label: "Vue Router",
    packageName: "vue-router",
    homepage: "https://router.vuejs.org",
    logo: "https://router.vuejs.org/logo.png",
    componentStateTypes: ["Routing"],
    app: c
  }, (k) => {
    typeof k.now != "function" && console.warn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), k.on.inspectComponent((y, C) => {
      y.instanceData && y.instanceData.state.push({
        type: "Routing",
        key: "$route",
        editable: !1,
        value: Yi(u.currentRoute.value, "Current Route")
      });
    }), k.on.visitComponentTree(({ treeNode: y, componentInstance: C }) => {
      if (C.__vrv_devtools) {
        const b = C.__vrv_devtools;
        y.tags.push({
          label: (b.name ? `${b.name.toString()}: ` : "") + b.path,
          textColor: 0,
          tooltip: "This component is rendered by &lt;router-view&gt;",
          backgroundColor: Hw
        });
      }
      $t(C.__vrl_devtools) && (C.__devtoolsApi = k, C.__vrl_devtools.forEach((b) => {
        let A = b.route.path, P = Ww, R = "", z = 0;
        b.error ? (A = b.error, P = PT, z = IT) : b.isExactActive ? (P = qw, R = "This is exactly active") : b.isActive && (P = Uw, R = "This link is active"), y.tags.push({
          label: A,
          textColor: z,
          tooltip: R,
          backgroundColor: P
        });
      }));
    }), hi(u.currentRoute, () => {
      p(), k.notifyComponentUpdate(), k.sendInspectorTree(x), k.sendInspectorState(x);
    });
    const S = "router:navigations:" + w;
    k.addTimelineLayer({
      id: S,
      label: `Router${w ? " " + w : ""} Navigations`,
      color: 4237508
    }), u.onError((y, C) => {
      k.addTimelineEvent({
        layerId: S,
        event: {
          title: "Error during Navigation",
          subtitle: C.fullPath,
          logType: "error",
          time: k.now(),
          data: { error: y },
          groupId: C.meta.__navigationId
        }
      });
    });
    let v = 0;
    u.beforeEach((y, C) => {
      const b = {
        guard: Cs("beforeEach"),
        from: Yi(C, "Current Location during this navigation"),
        to: Yi(y, "Target location")
      };
      Object.defineProperty(y.meta, "__navigationId", {
        value: v++
      }), k.addTimelineEvent({
        layerId: S,
        event: {
          time: k.now(),
          title: "Start of navigation",
          subtitle: y.fullPath,
          data: b,
          groupId: y.meta.__navigationId
        }
      });
    }), u.afterEach((y, C, b) => {
      const A = {
        guard: Cs("afterEach")
      };
      b ? (A.failure = {
        _custom: {
          type: Error,
          readOnly: !0,
          display: b ? b.message : "",
          tooltip: "Navigation Failure",
          value: b
        }
      }, A.status = Cs("❌")) : A.status = Cs("✅"), A.from = Yi(C, "Current Location during this navigation"), A.to = Yi(y, "Target location"), k.addTimelineEvent({
        layerId: S,
        event: {
          title: "End of navigation",
          subtitle: y.fullPath,
          time: k.now(),
          data: A,
          logType: b ? "warning" : "default",
          groupId: y.meta.__navigationId
        }
      });
    });
    const x = "router-inspector:" + w;
    k.addInspector({
      id: x,
      label: "Routes" + (w ? " " + w : ""),
      icon: "book",
      treeFilterPlaceholder: "Search routes"
    });
    function p() {
      if (!D)
        return;
      const y = D;
      let C = g.getRoutes().filter((b) => !b.parent || // these routes have a parent with no component which will not appear in the view
      // therefore we still need to include them
      !b.parent.record.components);
      C.forEach(Zw), y.filter && (C = C.filter((b) => (
        // save matches state based on the payload
        Sc(b, y.filter.toLowerCase())
      ))), C.forEach((b) => Kw(b, u.currentRoute.value)), y.rootNodes = C.map(Gw);
    }
    let D;
    k.on.getInspectorTree((y) => {
      D = y, y.app === c && y.inspectorId === x && p();
    }), k.on.getInspectorState((y) => {
      if (y.app === c && y.inspectorId === x) {
        const b = g.getRoutes().find((A) => A.record.__vd_id === y.nodeId);
        b && (y.state = {
          options: DT(b)
        });
      }
    }), k.sendInspectorTree(x), k.sendInspectorState(x);
  });
}
function ST(c) {
  return c.optional ? c.repeatable ? "*" : "?" : c.repeatable ? "+" : "";
}
function DT(c) {
  const { record: u } = c, g = [
    { editable: !1, key: "path", value: u.path }
  ];
  return u.name != null && g.push({
    editable: !1,
    key: "name",
    value: u.name
  }), g.push({ editable: !1, key: "regexp", value: c.re }), c.keys.length && g.push({
    editable: !1,
    key: "keys",
    value: {
      _custom: {
        type: null,
        readOnly: !0,
        display: c.keys.map((w) => `${w.name}${ST(w)}`).join(" "),
        tooltip: "Param keys",
        value: c.keys
      }
    }
  }), u.redirect != null && g.push({
    editable: !1,
    key: "redirect",
    value: u.redirect
  }), c.alias.length && g.push({
    editable: !1,
    key: "aliases",
    value: c.alias.map((w) => w.record.path)
  }), Object.keys(c.record.meta).length && g.push({
    editable: !1,
    key: "meta",
    value: c.record.meta
  }), g.push({
    key: "score",
    editable: !1,
    value: {
      _custom: {
        type: null,
        readOnly: !0,
        display: c.score.map((w) => w.join(", ")).join(" | "),
        tooltip: "Score used to sort routes",
        value: c.score
      }
    }
  }), g;
}
const Hw = 15485081, Uw = 2450411, qw = 8702998, BT = 2282478, Ww = 16486972, TT = 6710886, PT = 16704226, IT = 12131356;
function Gw(c) {
  const u = [], { record: g } = c;
  g.name != null && u.push({
    label: String(g.name),
    textColor: 0,
    backgroundColor: BT
  }), g.aliasOf && u.push({
    label: "alias",
    textColor: 0,
    backgroundColor: Ww
  }), c.__vd_match && u.push({
    label: "matches",
    textColor: 0,
    backgroundColor: Hw
  }), c.__vd_exactActive && u.push({
    label: "exact",
    textColor: 0,
    backgroundColor: qw
  }), c.__vd_active && u.push({
    label: "active",
    textColor: 0,
    backgroundColor: Uw
  }), g.redirect && u.push({
    label: typeof g.redirect == "string" ? `redirect: ${g.redirect}` : "redirects",
    textColor: 16777215,
    backgroundColor: TT
  });
  let w = g.__vd_id;
  return w == null && (w = String(OT++), g.__vd_id = w), {
    id: w,
    label: g.path,
    tags: u,
    children: c.children.map(Gw)
  };
}
let OT = 0;
const RT = /^\/(.*)\/([a-z]*)$/;
function Kw(c, u) {
  const g = u.matched.length && Vn(u.matched[u.matched.length - 1], c.record);
  c.__vd_exactActive = c.__vd_active = g, g || (c.__vd_active = u.matched.some((w) => Vn(w, c.record))), c.children.forEach((w) => Kw(w, u));
}
function Zw(c) {
  c.__vd_match = !1, c.children.forEach(Zw);
}
function Sc(c, u) {
  const g = String(c.re).match(RT);
  if (c.__vd_match = !1, !g || g.length < 3)
    return !1;
  if (new RegExp(g[1].replace(/\$$/, ""), g[2]).test(u))
    return c.children.forEach((v) => Sc(v, u)), c.record.path !== "/" || u === "/" ? (c.__vd_match = c.re.test(u), !0) : !1;
  const k = c.record.path.toLowerCase(), S = ci(k);
  return !u.startsWith("/") && (S.includes(u) || k.includes(u)) || S.startsWith(u) || k.startsWith(u) || c.record.name && String(c.record.name).includes(u) ? !0 : c.children.some((v) => Sc(v, u));
}
function zT(c, u) {
  const g = {};
  for (const w in c)
    u.includes(w) || (g[w] = c[w]);
  return g;
}
function MT(c) {
  const u = sT(c.routes, c), g = c.parseQuery || gT, w = c.stringifyQuery || Nk, k = c.history;
  if (process.env.NODE_ENV !== "production" && !k)
    throw new Error('Provide the "history" option when calling "createRouter()": https://next.router.vuejs.org/api/#history.');
  const S = Ji(), v = Ji(), x = Ji(), p = ln(Nn);
  let D = Nn;
  Cn && c.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
  const y = uc.bind(null, (V) => "" + V), C = uc.bind(null, TB), b = (
    // @ts-expect-error: intentionally avoid the type check
    uc.bind(null, ci)
  );
  function A(V, K) {
    let Y, te;
    return Vw(V) ? (Y = u.getRecordMatcher(V), process.env.NODE_ENV !== "production" && !Y && me(`Parent route "${String(V)}" not found when adding child route`, K), te = K) : te = V, u.addRoute(te, Y);
  }
  function P(V) {
    const K = u.getRecordMatcher(V);
    K ? u.removeRoute(K) : process.env.NODE_ENV !== "production" && me(`Cannot remove non-existent route "${String(V)}"`);
  }
  function R() {
    return u.getRoutes().map((V) => V.record);
  }
  function z(V) {
    return !!u.getRecordMatcher(V);
  }
  function F(V, K) {
    if (K = Ie({}, K || p.value), typeof V == "string") {
      const ue = hc(g, V, K.path), oe = u.resolve({ path: ue.path }, K), qt = k.createHref(ue.fullPath);
      return process.env.NODE_ENV !== "production" && (qt.startsWith("//") ? me(`Location "${V}" resolved to "${qt}". A resolved location cannot start with multiple slashes.`) : oe.matched.length || me(`No match found for location with path "${V}"`)), Ie(ue, oe, {
        params: b(oe.params),
        hash: ci(ue.hash),
        redirectedFrom: void 0,
        href: qt
      });
    }
    process.env.NODE_ENV !== "production" && !Ds(V) && (me(`router.resolve() was passed an invalid location. This will fail in production.
- Location:`, V), V = {});
    let Y;
    if (V.path != null)
      process.env.NODE_ENV !== "production" && "params" in V && !("name" in V) && // @ts-expect-error: the type is never
      Object.keys(V.params).length && me(`Path "${V.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`), Y = Ie({}, V, {
        path: hc(g, V.path, K.path).path
      });
    else {
      const ue = Ie({}, V.params);
      for (const oe in ue)
        ue[oe] == null && delete ue[oe];
      Y = Ie({}, V, {
        params: C(ue)
      }), K.params = C(K.params);
    }
    const te = u.resolve(Y, K), ke = V.hash || "";
    process.env.NODE_ENV !== "production" && ke && !ke.startsWith("#") && me(`A \`hash\` should always start with the character "#". Replace "${ke}" with "#${ke}".`), te.params = y(b(te.params));
    const Ve = OB(w, Ie({}, V, {
      hash: SB(ke),
      path: te.path
    })), ge = k.createHref(Ve);
    return process.env.NODE_ENV !== "production" && (ge.startsWith("//") ? me(`Location "${V}" resolved to "${ge}". A resolved location cannot start with multiple slashes.`) : te.matched.length || me(`No match found for location with path "${V.path != null ? V.path : V}"`)), Ie({
      fullPath: Ve,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash: ke,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/router/issues/328#issuecomment-649481567
        w === Nk ? mT(V.query) : V.query || {}
      )
    }, te, {
      redirectedFrom: void 0,
      href: ge
    });
  }
  function L(V) {
    return typeof V == "string" ? hc(g, V, p.value.path) : Ie({}, V);
  }
  function U(V, K) {
    if (D !== V)
      return di(8, {
        from: K,
        to: V
      });
  }
  function J(V) {
    return ee(V);
  }
  function ie(V) {
    return J(Ie(L(V), { replace: !0 }));
  }
  function ce(V) {
    const K = V.matched[V.matched.length - 1];
    if (K && K.redirect) {
      const { redirect: Y } = K;
      let te = typeof Y == "function" ? Y(V) : Y;
      if (typeof te == "string" && (te = te.includes("?") || te.includes("#") ? te = L(te) : (
        // force empty params
        { path: te }
      ), te.params = {}), process.env.NODE_ENV !== "production" && te.path == null && !("name" in te))
        throw me(`Invalid redirect found:
${JSON.stringify(te, null, 2)}
 when navigating to "${V.fullPath}". A redirect must contain a name or path. This will break in production.`), new Error("Invalid redirect");
      return Ie({
        query: V.query,
        hash: V.hash,
        // avoid transferring params if the redirect has a path
        params: te.path != null ? {} : V.params
      }, te);
    }
  }
  function ee(V, K) {
    const Y = D = F(V), te = p.value, ke = V.state, Ve = V.force, ge = V.replace === !0, ue = ce(Y);
    if (ue)
      return ee(
        Ie(L(ue), {
          state: typeof ue == "object" ? Ie({}, ke, ue.state) : ke,
          force: Ve,
          replace: ge
        }),
        // keep original redirectedFrom if it exists
        K || Y
      );
    const oe = Y;
    oe.redirectedFrom = K;
    let qt;
    return !Ve && Sk(w, te, Y) && (qt = di(16, { to: oe, from: te }), pi(
      te,
      te,
      // this is a push, the only way for it to be triggered from a
      // history.listen is with a redirect, which makes it become a push
      !0,
      // This cannot be the first navigation because the initial location
      // cannot be manually navigated to
      !1
    )), (qt ? Promise.resolve(qt) : ne(oe, te)).catch((pt) => An(pt) ? (
      // navigation redirects still mark the router as ready
      An(
        pt,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? pt : De(pt)
    ) : (
      // reject any unknown error
      Pt(pt, oe, te)
    )).then((pt) => {
      if (pt) {
        if (An(
          pt,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        ))
          return process.env.NODE_ENV !== "production" && // we are redirecting to the same location we were already at
          Sk(w, F(pt.to), oe) && // and we have done it a couple of times
          K && // @ts-expect-error: added only in dev
          (K._count = K._count ? (
            // @ts-expect-error
            K._count + 1
          ) : 1) > 30 ? (me(`Detected a possibly infinite redirection in a navigation guard when going from "${te.fullPath}" to "${oe.fullPath}". Aborting to avoid a Stack Overflow.
 Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.`), Promise.reject(new Error("Infinite redirect in navigation guard"))) : ee(
            // keep options
            Ie({
              // preserve an existing replacement but allow the redirect to override it
              replace: ge
            }, L(pt.to), {
              state: typeof pt.to == "object" ? Ie({}, ke, pt.to.state) : ke,
              force: Ve
            }),
            // preserve the original redirectedFrom if any
            K || oe
          );
      } else
        pt = Ke(oe, te, !0, ge, ke);
      return He(oe, te, pt), pt;
    });
  }
  function de(V, K) {
    const Y = U(V, K);
    return Y ? Promise.reject(Y) : Promise.resolve();
  }
  function I(V) {
    const K = xn.values().next().value;
    return K && typeof K.runWithContext == "function" ? K.runWithContext(V) : V();
  }
  function ne(V, K) {
    let Y;
    const [te, ke, Ve] = NT(V, K);
    Y = gc(te.reverse(), "beforeRouteLeave", V, K);
    for (const ue of te)
      ue.leaveGuards.forEach((oe) => {
        Y.push(Fn(oe, V, K));
      });
    const ge = de.bind(null, V, K);
    return Y.push(ge), dn(Y).then(() => {
      Y = [];
      for (const ue of S.list())
        Y.push(Fn(ue, V, K));
      return Y.push(ge), dn(Y);
    }).then(() => {
      Y = gc(ke, "beforeRouteUpdate", V, K);
      for (const ue of ke)
        ue.updateGuards.forEach((oe) => {
          Y.push(Fn(oe, V, K));
        });
      return Y.push(ge), dn(Y);
    }).then(() => {
      Y = [];
      for (const ue of Ve)
        if (ue.beforeEnter)
          if ($t(ue.beforeEnter))
            for (const oe of ue.beforeEnter)
              Y.push(Fn(oe, V, K));
          else
            Y.push(Fn(ue.beforeEnter, V, K));
      return Y.push(ge), dn(Y);
    }).then(() => (V.matched.forEach((ue) => ue.enterCallbacks = {}), Y = gc(Ve, "beforeRouteEnter", V, K, I), Y.push(ge), dn(Y))).then(() => {
      Y = [];
      for (const ue of v.list())
        Y.push(Fn(ue, V, K));
      return Y.push(ge), dn(Y);
    }).catch((ue) => An(
      ue,
      8
      /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? ue : Promise.reject(ue));
  }
  function He(V, K, Y) {
    x.list().forEach((te) => I(() => te(V, K, Y)));
  }
  function Ke(V, K, Y, te, ke) {
    const Ve = U(V, K);
    if (Ve)
      return Ve;
    const ge = K === Nn, ue = Cn ? history.state : {};
    Y && (te || ge ? k.replace(V.fullPath, Ie({
      scroll: ge && ue && ue.scroll
    }, ke)) : k.push(V.fullPath, ke)), p.value = V, pi(V, K, Y, ge), De();
  }
  let Me;
  function Yt() {
    Me || (Me = k.listen((V, K, Y) => {
      if (!fi.listening)
        return;
      const te = F(V), ke = ce(te);
      if (ke) {
        ee(Ie(ke, { replace: !0 }), te).catch(er);
        return;
      }
      D = te;
      const Ve = p.value;
      Cn && VB(Bk(Ve.fullPath, Y.delta), Is()), ne(te, Ve).catch((ge) => An(
        ge,
        12
        /* ErrorTypes.NAVIGATION_CANCELLED */
      ) ? ge : An(
        ge,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? (ee(
        ge.to,
        te
        // avoid an uncaught rejection, let push call triggerError
      ).then((ue) => {
        An(
          ue,
          20
          /* ErrorTypes.NAVIGATION_DUPLICATED */
        ) && !Y.delta && Y.type === sr.pop && k.go(-1, !1);
      }).catch(er), Promise.reject()) : (Y.delta && k.go(-Y.delta, !1), Pt(ge, te, Ve))).then((ge) => {
        ge = ge || Ke(
          // after navigation, all matched components are resolved
          te,
          Ve,
          !1
        ), ge && (Y.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
        // entry while a different route is displayed
        !An(
          ge,
          8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        ) ? k.go(-Y.delta, !1) : Y.type === sr.pop && An(
          ge,
          20
          /* ErrorTypes.NAVIGATION_DUPLICATED */
        ) && k.go(-1, !1)), He(te, Ve, ge);
      }).catch(er);
    }));
  }
  let At = Ji(), Tt = Ji(), Ut;
  function Pt(V, K, Y) {
    De(V);
    const te = Tt.list();
    return te.length ? te.forEach((ke) => ke(V, K, Y)) : (process.env.NODE_ENV !== "production" && me("uncaught error during route navigation:"), console.error(V)), Promise.reject(V);
  }
  function gr() {
    return Ut && p.value !== Nn ? Promise.resolve() : new Promise((V, K) => {
      At.add([V, K]);
    });
  }
  function De(V) {
    return Ut || (Ut = !V, Yt(), At.list().forEach(([K, Y]) => V ? Y(V) : K()), At.reset()), V;
  }
  function pi(V, K, Y, te) {
    const { scrollBehavior: ke } = c;
    if (!Cn || !ke)
      return Promise.resolve();
    const Ve = !Y && jB(Bk(V.fullPath, 0)) || (te || !Y) && history.state && history.state.scroll || null;
    return LS().then(() => ke(V, K, Ve)).then((ge) => ge && LB(ge)).catch((ge) => Pt(ge, V, K));
  }
  const Hn = (V) => k.go(V);
  let xo;
  const xn = /* @__PURE__ */ new Set(), fi = {
    currentRoute: p,
    listening: !0,
    addRoute: A,
    removeRoute: P,
    hasRoute: z,
    getRoutes: R,
    resolve: F,
    options: c,
    push: J,
    replace: ie,
    go: Hn,
    back: () => Hn(-1),
    forward: () => Hn(1),
    beforeEach: S.add,
    beforeResolve: v.add,
    afterEach: x.add,
    onError: Tt.add,
    isReady: gr,
    install(V) {
      const K = this;
      V.component("RouterLink", wT), V.component("RouterView", CT), V.config.globalProperties.$router = K, Object.defineProperty(V.config.globalProperties, "$route", {
        enumerable: !0,
        get: () => ae(p)
      }), Cn && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !xo && p.value === Nn && (xo = !0, J(k.location).catch((ke) => {
        process.env.NODE_ENV !== "production" && me("Unexpected error when starting the router:", ke);
      }));
      const Y = {};
      for (const ke in Nn)
        Object.defineProperty(Y, ke, {
          get: () => p.value[ke],
          enumerable: !0
        });
      V.provide(Mc, K), V.provide(Nc, $S(Y)), V.provide(xc, p);
      const te = V.unmount;
      xn.add(V), V.unmount = function() {
        xn.delete(V), xn.size < 1 && (D = Nn, Me && Me(), Me = null, p.value = Nn, xo = !1, Ut = !1), te();
      }, process.env.NODE_ENV !== "production" && Cn && xT(V, K, u);
    }
  };
  function dn(V) {
    return V.reduce((K, Y) => K.then(() => I(Y)), Promise.resolve());
  }
  return fi;
}
function NT(c, u) {
  const g = [], w = [], k = [], S = Math.max(u.matched.length, c.matched.length);
  for (let v = 0; v < S; v++) {
    const x = u.matched[v];
    x && (c.matched.find((D) => Vn(D, x)) ? w.push(x) : g.push(x));
    const p = c.matched[v];
    p && (u.matched.find((D) => Vn(D, p)) || k.push(p));
  }
  return [g, w, k];
}
function Fc() {
  return Te(Nc);
}
const $c = (c) => (bt("data-v-dc32dd0b"), c = c(), kt(), c), FT = { class: "viur-shop-item-card-card" }, $T = ["src", "alt"], LT = { class: "viur-shop-item-card-headline" }, VT = /* @__PURE__ */ $c(() => /* @__PURE__ */ M("h4", { class: "viur-shop-item-card-subline" }, "B 21 x H 6,5 x T 19 cm", -1)), jT = { class: "viur-shop-item-card-price" }, HT = {
  class: "viur-shop-item-card-footer",
  slot: "footer"
}, UT = /* @__PURE__ */ $c(() => /* @__PURE__ */ M("sl-icon", {
  name: "bag-plus",
  slot: "prefix"
}, null, -1)), qT = /* @__PURE__ */ $c(() => /* @__PURE__ */ M("sl-button", {
  size: "small",
  outline: "",
  class: "viur-shop-item-card-add-to-favourites-btn",
  variant: "primary",
  title: "Add to favourites"
}, [
  /* @__PURE__ */ M("sl-icon", {
    name: "heart",
    slot: "prefix"
  })
], -1)), WT = {
  __name: "ItemCard",
  props: {
    item: {
      type: Object,
      required: !0
    }
  },
  setup(c) {
    const u = En();
    function g(w) {
      let k = "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80";
      return w.dk_artikel.dest.image ? ve.downloadUrlFor(w.dk_artikel.dest.image) : k;
    }
    return (w, k) => (j(), q("sl-card", FT, [
      M("img", {
        slot: "image",
        src: g(c.item),
        alt: c.item.shop_name,
        loading: "lazy",
        class: "viur-shop-item-card-image"
      }, null, 8, $T),
      M("h3", LT, Se(c.item.shop_name), 1),
      VT,
      M("div", jT, Se(c.item.shop_price_retail) + " €", 1),
      M("div", HT, [
        M("sl-button", {
          size: "small",
          class: "viur-shop-item-card-add-to-cart-btn",
          variant: "primary",
          title: "Add to cart",
          onClick: k[0] || (k[0] = li((S) => ae(u).addToCart(c.item.key, ae(u).state.basket), ["stop"]))
        }, [
          UT,
          se(" In den Warenkorb ")
        ]),
        qT
      ])
    ]));
  }
}, Jw = /* @__PURE__ */ Ee(WT, [["__scopeId", "data-v-dc32dd0b"]]), GT = (c) => (bt("data-v-532e5cf3"), c = c(), kt(), c), KT = {
  key: 0,
  class: "viur-shop-loading-wrap"
}, ZT = /* @__PURE__ */ GT(() => /* @__PURE__ */ M("sl-spinner", null, null, -1)), JT = [
  ZT
], YT = {
  key: 1,
  class: "bind"
}, QT = { class: "page-header" }, XT = { class: "viur-shop-category-view-list" }, eP = ["loading", "disabled"], tP = {
  __name: "CategoryView",
  props: {
    skellist: { type: Array },
    filter: { type: Boolean, default: !0 },
    pageHeader: { type: String, default: "Artikel Liste" },
    listHandler: { type: Object, required: !0 }
  },
  setup(c) {
    const u = c, g = Fc(), w = En(), k = _e({
      skellist: [],
      loading: !0,
      currentCursor: "",
      isLastItem: !1,
      itemCount: 99,
      itemType: le(() => g.params.identifier)
    }), S = u.listHandler;
    async function v() {
      k.loading = !0, await S.next(), k.skellist.length < S.state.skellist.length ? (k.skellist = S.state.skellist, k.loading = !1) : (k.loading = !1, k.isLastItem = !0);
    }
    return lt(async () => {
      await w.init(), await S.fetch(!0), k.skellist = S.state.skellist, k.loading = !1;
    }), (x, p) => k.loading ? (j(), q("div", KT, JT)) : (j(), q("div", YT, [
      M("div", QT, [
        M("h1", null, Se(c.pageHeader), 1)
      ]),
      c.filter ? VS(x.$slots, "filter", { key: 0 }, () => [
        se(" text-transform text-transform TEST ")
      ], !0) : he("", !0),
      M("div", XT, [
        (j(!0), q(ye, null, dt(k.skellist, (D) => (j(), ut(Jw, {
          key: D.shop_name,
          item: D
        }, null, 8, ["item"]))), 128))
      ]),
      M("sl-button", {
        onClick: v,
        loading: k.loading,
        disabled: k.isLastItem,
        class: "viur-shop-category-view-more-button"
      }, " Mehr anzeigen ", 8, eP)
    ]));
  }
}, nP = /* @__PURE__ */ Ee(tP, [["__scopeId", "data-v-532e5cf3"]]), oP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: nP
}, Symbol.toStringTag, { value: "Module" })), Bt = (c) => (bt("data-v-75e70e9a"), c = c(), kt(), c), iP = {
  key: 1,
  class: "list"
}, rP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("h2", { class: "viur-shop-cart-headline headline" }, "Bestellung prüfen", -1)), sP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("br", null, null, -1)), aP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("div", { class: "viur-shop-cart-address-wrap" }, [
  /* @__PURE__ */ M("div", { class: "viur-shop-cart-address" }, [
    /* @__PURE__ */ M("div", { class: "viur-shop-cart-address-headline" }, [
      /* @__PURE__ */ se(" Versandadresse "),
      /* @__PURE__ */ M("sl-button", {
        outline: "",
        size: "small"
      }, [
        /* @__PURE__ */ M("sl-icon", {
          name: "pencil",
          slot: "prefix"
        })
      ])
    ]),
    /* @__PURE__ */ se(" Roland Brose"),
    /* @__PURE__ */ M("br"),
    /* @__PURE__ */ se(" Speicherstraße 33"),
    /* @__PURE__ */ M("br"),
    /* @__PURE__ */ se(" 44147 Dortmund, DE"),
    /* @__PURE__ */ M("br"),
    /* @__PURE__ */ M("br"),
    /* @__PURE__ */ se(" rb@mausbrand.de"),
    /* @__PURE__ */ M("br"),
    /* @__PURE__ */ se(" 0231 21 34 68 90 ")
  ]),
  /* @__PURE__ */ M("div", { class: "viur-shop-cart-address" }, [
    /* @__PURE__ */ M("div", { class: "viur-shop-cart-address-headline" }, [
      /* @__PURE__ */ se(" Rechnungsadresse "),
      /* @__PURE__ */ M("sl-button", {
        outline: "",
        size: "small"
      }, [
        /* @__PURE__ */ M("sl-icon", {
          name: "pencil",
          slot: "prefix"
        })
      ])
    ]),
    /* @__PURE__ */ se(" Roland Brose"),
    /* @__PURE__ */ M("br"),
    /* @__PURE__ */ se(" Speicherstraße 33"),
    /* @__PURE__ */ M("br"),
    /* @__PURE__ */ se(" 44147 Dortmund, DE"),
    /* @__PURE__ */ M("br"),
    /* @__PURE__ */ M("br"),
    /* @__PURE__ */ se(" rb@mausbrand.de"),
    /* @__PURE__ */ M("br"),
    /* @__PURE__ */ se(" 0231 21 34 68 90 ")
  ])
], -1)), lP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("div", { class: "viur-shop-cart-payment" }, [
  /* @__PURE__ */ M("div", { class: "viur-shop-cart-payment-method" }, [
    /* @__PURE__ */ M("span", null, "Zahlungsmethode:"),
    /* @__PURE__ */ se(" Paypal ")
  ]),
  /* @__PURE__ */ M("sl-button", {
    outline: "",
    size: "small"
  }, [
    /* @__PURE__ */ M("sl-icon", {
      name: "pencil",
      slot: "prefix"
    })
  ])
], -1)), cP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("h2", { class: "viur-shop-cart-headline headline" }, "Warenkorb", -1)), dP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("br", null, null, -1)), uP = {
  horizontal: "",
  class: "viur-shop-cart-mini-card"
}, hP = ["src"], gP = {
  class: "viur-shop-cart-mini-cart-header",
  slot: "header"
}, mP = { class: "viur-shop-cart-mini-headline headline" }, pP = { class: "viur-shop-cart-mini-card-body-row" }, fP = { class: "viur-shop-cart-mini-card-body-info" }, bP = { class: "viur-shop-cart-mini-card-info-wrap" }, kP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("div", { class: "viur-shop-cart-mini-card-info" }, [
  /* @__PURE__ */ M("span", null, "Anzahl: "),
  /* @__PURE__ */ se(" 1 ")
], -1)), wP = { class: "viur-shop-cart-mini-card-info" }, vP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("span", null, "Preis: ", -1)), _P = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("h2", { class: "viur-shop-cart-sidebar-headline headline" }, "Jetzt Bestellen", -1)), AP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("br", null, null, -1)), CP = { class: "viur-shop-cart-sidebar-info-line" }, yP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("span", null, "Zwischensumme", -1)), EP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("div", { class: "viur-shop-cart-sidebar-info-line" }, [
  /* @__PURE__ */ M("span", null, "Rabatt"),
  /* @__PURE__ */ se(" 0 € ")
], -1)), xP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("div", { class: "viur-shop-cart-sidebar-info-line" }, [
  /* @__PURE__ */ M("span", null, "Versandkosten"),
  /* @__PURE__ */ se(" 0 € ")
], -1)), SP = { class: "viur-shop-cart-sidebar-info-line total" }, DP = /* @__PURE__ */ Bt(() => /* @__PURE__ */ M("span", null, "Gesamt:", -1)), BP = { class: "viur-shop-cart-sidebar-btn-wrap" }, TP = ["variant", "disabled"], PP = {
  __name: "ConfirmView",
  setup(c) {
    const u = En(), g = _e({
      cartIsInit: le(() => !!u.state.basket.length),
      itemsIsInit: le(() => !!u.state.carts[u.state.basket].items),
      images: {},
      showOrderButton: !1
    });
    function w(S) {
      return ve.get(`/json/dk_variante/view/${S}`).then(async (v) => {
        let x = await v.json();
        x = x.values;
        let p = x.dk_artikel.dest.image ? ve.downloadUrlFor(x.dk_artikel.dest.image) : "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80";
        g.images[S] = p;
      }), g.images[S];
    }
    function k(S) {
      S.target.checked && (g.showOrderButton = !0), S.target.checked || (g.showOrderButton = !1);
    }
    return jn(async () => {
      await u.init();
    }), (S, v) => g.cartIsInit ? (j(), q("div", iP, [
      rP,
      sP,
      aP,
      lP,
      cP,
      dP,
      (j(!0), q(ye, null, dt(ae(u).state.carts[ae(u).state.basket].items, (x) => (j(), q("sl-card", uP, [
        M("img", {
          class: "viur-shop-cart-mini-card-img",
          slot: "image",
          src: w(x.article.dest.key)
        }, null, 8, hP),
        M("div", gP, [
          M("h4", mP, Se(x.article.dest.shop_name) + " | 425018", 1)
        ]),
        M("div", pP, [
          M("div", fP, [
            M("div", bP, [
              kP,
              M("div", wP, [
                vP,
                se(" " + Se(x.article.dest.shop_price_recommended) + " € ", 1)
              ])
            ])
          ])
        ])
      ]))), 256)),
      (j(), ut(Dw, { to: "#order_sidebar" }, [
        _P,
        AP,
        M("div", CP, [
          yP,
          se(" " + Se(ae(u).state.carts[ae(u).state.basket].info.total) + " € ", 1)
        ]),
        EP,
        xP,
        M("div", SP, [
          DP,
          se(" " + Se(ae(u).state.carts[ae(u).state.basket].info.total) + " € ", 1)
        ]),
        M("sl-checkbox", { onSlChange: k }, " Ich akzeptiere die geltenden AGBs und Datenschutzbestimmungen ", 32),
        M("div", BP, [
          M("sl-button", {
            variant: g.showOrderButton ? "info" : "disabled",
            size: "small",
            disabled: !g.showOrderButton
          }, " Zahlungspflichtig bestellen ", 8, TP)
        ])
      ]))
    ])) : (j(), ut(Pw, { key: 0 }));
  }
}, Yw = /* @__PURE__ */ Ee(PP, [["__scopeId", "data-v-75e70e9a"]]), IP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Yw
}, Symbol.toStringTag, { value: "Module" })), Qw = (c) => (bt("data-v-f405011d"), c = c(), kt(), c), OP = { class: "viur-shop-category-list-item" }, RP = /* @__PURE__ */ Qw(() => /* @__PURE__ */ M("img", {
  slot: "image",
  src: "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80",
  alt: "A kitten.",
  class: "viur-shop-category-list-item-img"
}, null, -1)), zP = { class: "viur-shop-category-list-item-headline" }, MP = /* @__PURE__ */ Qw(() => /* @__PURE__ */ M("div", { class: "viur-shop-category-list-fake-link" }, "Alle anzeigen »", -1)), NP = {
  __name: "CategoryList",
  props: {
    list: { type: Array, required: !0 }
  },
  setup(c) {
    const u = En();
    return jn(async () => {
      await u.init();
    }), (g, w) => {
      const k = yo("RouterLink");
      return j(!0), q(ye, null, dt(c.list, (S) => (j(), ut(k, {
        to: { name: "CategoryView", params: { identifier: "dk" } },
        key: S,
        class: "viur-shop-category-list-item-link"
      }, {
        default: Sw(() => [
          M("sl-card", OP, [
            RP,
            M("h2", zP, Se(S), 1),
            MP
          ])
        ]),
        _: 2
      }, 1024))), 128);
    };
  }
}, V7 = /* @__PURE__ */ Ee(NP, [["__scopeId", "data-v-f405011d"]]), ur = (c) => (bt("data-v-7f847de5"), c = c(), kt(), c), FP = { key: 0 }, $P = {
  key: 1,
  class: "form-wrap"
}, LP = ["label"], VP = ["value"], jP = ["disabled"], HP = /* @__PURE__ */ ur(() => /* @__PURE__ */ M("label", { slot: "label" }, "Strasse *", -1)), UP = [
  HP
], qP = ["disabled"], WP = /* @__PURE__ */ ur(() => /* @__PURE__ */ M("label", { slot: "label" }, "Hausnummer *", -1)), GP = [
  WP
], KP = ["disabled"], ZP = /* @__PURE__ */ ur(() => /* @__PURE__ */ M("label", { slot: "label" }, "Postleitzahl *", -1)), JP = [
  ZP
], YP = ["disabled"], QP = /* @__PURE__ */ ur(() => /* @__PURE__ */ M("label", { slot: "label" }, "Stadt*", -1)), XP = [
  QP
], eI = ["disabled"], tI = /* @__PURE__ */ ur(() => /* @__PURE__ */ M("label", { slot: "label" }, "Bundesland", -1)), nI = [
  tI
], oI = {
  __name: "ShippingAdress",
  props: {
    multiAdress: { type: Boolean, default: !1 },
    items: { type: Array }
  },
  emits: ["adressInput", "itemSelection"],
  setup(c, { emit: u }) {
    const g = c, w = u, k = _e({
      selectedItem: null,
      isItemSelected: !1,
      items: {}
    }), S = Ft(null), v = En();
    function x(y) {
      `${[k.selectedItem]}${[y.target.name]}`, w("adressInput", {
        [`${[k.selectedItem]}.${[y.target.name]}`]: y.target.value
      });
    }
    function p(y) {
      if (console.log(y.target.value), !y.target.value.length) {
        D();
        return;
      }
      k.selectedItem = y.target.value, k.isItemSelected = !0;
    }
    function D() {
      console.log("clearing..."), k.selectedItem = null, k.isItemSelected = !1;
    }
    return jn(() => {
      console.log(g.items);
    }), (y, C) => {
      var b, A;
      return (b = ae(v).state.carts[ae(v).state.basket]) != null && b.items ? (j(), q("div", $P, [
        c.multiAdress ? (j(), q("sl-select", {
          key: 0,
          multiple: "",
          clearable: "",
          ref_key: "itemSelection",
          ref: S,
          onSlChange: p,
          onSlClear: D,
          label: "Lieferadresse für: " + k.selectedItem,
          class: "grid-w-4"
        }, [
          (j(!0), q(ye, null, dt((A = ae(v).state.carts[ae(v).state.basket]) == null ? void 0 : A.items, (P) => (j(), q("sl-option", {
            value: P.key
          }, Se(P.shop_name), 9, VP))), 256))
        ], 40, LP)) : he("", !0),
        M("sl-input", {
          name: "street",
          onSlChange: x,
          placeholder: "Straße",
          class: "grid-w-3",
          disabled: !k.isItemSelected
        }, UP, 40, jP),
        M("sl-input", {
          name: "street",
          onSlChange: x,
          placeholder: "Hausnummer",
          type: "number",
          disabled: !k.isItemSelected
        }, GP, 40, qP),
        M("sl-input", {
          name: "street",
          onSlChange: x,
          placeholder: "Postleitzahl",
          type: "number",
          class: "grid-w-2",
          disabled: !k.isItemSelected
        }, JP, 40, KP),
        M("sl-input", {
          name: "city",
          onSlChange: x,
          placeholder: "Stadt",
          class: "grid-w-2",
          disabled: !k.isItemSelected
        }, XP, 40, YP),
        M("sl-input", {
          name: "province",
          onSlChange: x,
          placeholder: "Bundesland",
          class: "grid-w-2",
          disabled: !k.isItemSelected
        }, nI, 40, eI)
      ])) : (j(), q("sl-splinner", FP));
    };
  }
}, j7 = /* @__PURE__ */ Ee(oI, [["__scopeId", "data-v-7f847de5"]]), iI = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({});
    function k(S) {
      u.emit("change", c.name, S.target.value, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: k
    };
  }
}), rI = ["disabled", "value"], sI = ["disabled", "value"];
function aI(c, u, g, w, k, S) {
  var v, x;
  return c.boneState.bonestructure.type === "raw.json" ? (j(), q("sl-textarea", {
    key: 0,
    disabled: (v = c.boneState) == null ? void 0 : v.readonly,
    value: JSON.stringify(c.value),
    onInput: u[0] || (u[0] = (...p) => c.changeEvent && c.changeEvent(...p))
  }, null, 40, rI)) : (j(), q("sl-textarea", {
    key: 1,
    disabled: (x = c.boneState) == null ? void 0 : x.readonly,
    value: c.value,
    onInput: u[1] || (u[1] = (...p) => c.changeEvent && c.changeEvent(...p))
  }, null, 40, sI));
}
const Hk = /* @__PURE__ */ Ee(iI, [["render", aI], ["__scopeId", "data-v-0ebe5f0b"]]), lI = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = _e({});
    function w(k) {
      u.emit("change", c.name, k.target.value, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: g,
      changeEvent: w
    };
  }
}), cI = ["value"];
function dI(c, u, g, w, k, S) {
  return j(), q("sl-input", {
    disabled: "",
    value: c.value,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, cI);
}
const Uk = /* @__PURE__ */ Ee(lI, [["render", dI], ["__scopeId", "data-v-b45a1311"]]);
function uI(c) {
  return HS() ? (US(c), !0) : !1;
}
function hI(c) {
  return typeof c == "function" ? c() : ae(c);
}
const gI = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
function Os(c, u, g = {}) {
  const {
    immediate: w = !0
  } = g, k = Ft(!1);
  let S = null;
  function v() {
    S && (clearTimeout(S), S = null);
  }
  function x() {
    k.value = !1, v();
  }
  function p(...D) {
    v(), k.value = !0, S = setTimeout(() => {
      k.value = !1, S = null, c(...D);
    }, hI(u));
  }
  return w && (k.value = !0, gI && p()), uI(x), {
    isPending: jS(k),
    start: p,
    stop: x
  };
}
const mI = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({
      value: le(() => c.value)
    }), k = Ft(null);
    function S(v) {
      u.emit("change", c.name, v.target.value, c.lang, c.index);
    }
    return dr(() => {
      if (c.autofocus && k.value && k.value !== null && k !== null) {
        const { start: v } = Os(() => {
          k.value.focus();
        }, 600);
        v();
      }
    }), lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      Utils: eD,
      boneState: g,
      changeEvent: S,
      stringBone: k
    };
  }
}), pI = ["disabled", "value", "required"];
function fI(c, u, g, w, k, S) {
  return j(), q("sl-input", {
    ref: "stringBone",
    disabled: c.boneState.readonly,
    value: c.Utils.unescape(c.value),
    required: c.boneState.bonestructure.required,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v)),
    onKeyup: u[1] || (u[1] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, pI);
}
const qk = /* @__PURE__ */ Ee(mI, [["render", fI], ["__scopeId", "data-v-1ccbacc0"]]), bI = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({}), k = Ft(null);
    function S(v) {
      u.emit("change", c.name, v.target.value, c.lang, c.index);
    }
    return dr(() => {
      if (c.autofocus && k.value && k.value !== null && k !== null) {
        const { start: v } = Os(() => {
          k.value.focus();
        }, 600);
        v();
      }
    }), lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: S,
      emailBone: k
    };
  }
}), kI = ["disabled", "value"];
function wI(c, u, g, w, k, S) {
  return j(), q("sl-input", {
    ref: "emailBone",
    disabled: c.boneState.readonly,
    type: "email",
    value: c.value,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, kI);
}
const Wk = /* @__PURE__ */ Ee(bI, [["render", wI], ["__scopeId", "data-v-4328e024"]]), vI = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({
      value: le(() => {
        var v;
        let S = c.value;
        return g.bonestructure.time ? S = (v = c.value) == null ? void 0 : v.split("+")[0] : c.value && (S = new Date(c.value).toISOString().substr(0, 10)), S;
      }),
      typeString: le(() => {
        let S = "datetime-local";
        return g.bonestructure.time || (S = "date"), S;
      })
    });
    function k(S) {
      u.emit("change", c.name, S.target.value, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: k
    };
  }
}), _I = ["disabled", "type", "value"];
function AI(c, u, g, w, k, S) {
  return j(), q("sl-input", {
    disabled: c.boneState.readonly,
    type: c.state.typeString,
    value: c.state.value,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, _I);
}
const Gk = /* @__PURE__ */ Ee(vI, [["render", AI], ["__scopeId", "data-v-f1b8af8c"]]), CI = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: null,
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({
      value: le(() => {
        let S = c.value;
        return Array.isArray(c.value) ? (S = S.filter((v) => g.bonestructure.values.map((x) => x[0].toString()).includes(v)), S.map((v) => v.toString())) : c.value ? c.value.toString() : "";
      })
    });
    function k(S) {
      u.emit("change", c.name, S.target.value, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, w.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: k
    };
  }
}), yI = ["disabled", "value", "multiple"], EI = ["value"];
function xI(c, u, g, w, k, S) {
  return j(), q("sl-select", {
    disabled: c.boneState.readonly,
    value: c.state.value,
    hoist: "",
    multiple: c.boneState.bonestructure.multiple,
    "max-options-visible": "0",
    clearable: "",
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, [
    (j(!0), q(ye, null, dt(c.boneState.bonestructure.values, (v) => (j(), q("sl-option", {
      value: v[0]
    }, Se(v[1]), 9, EI))), 256))
  ], 40, yI);
}
const Kk = /* @__PURE__ */ Ee(CI, [["render", xI], ["__scopeId", "data-v-20ff76f5"]]), SI = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({
      value: le(() => ![!1, null, void 0, ""].includes(c.value))
    });
    function k(S) {
      u.emit("change", c.name, S.target.checked, c.lang, c.index);
    }
    return lt(() => {
      let S = c.value;
      S || (S = !1), u.emit("change", c.name, S, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: k
    };
  }
}), DI = ["disabled", "checked"];
function BI(c, u, g, w, k, S) {
  return j(), q("sl-switch", {
    disabled: c.boneState.readonly,
    checked: c.state.value,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, DI);
}
const Zk = /* @__PURE__ */ Ee(SI, [["render", BI], ["__scopeId", "data-v-363598c8"]]), TI = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({
      value1: "",
      value2: null,
      equal: !1,
      passwordInfo: [],
      requiredPasswordInfo: []
    }), k = Ft(null);
    function S(x) {
      w.value1 === w.value2 ? w.equal = !0 : w.equal = !1, v(w.value1), w.requiredPasswordInfo.length === 0 && w.passwordInfo.length - w.requiredPasswordInfo.length <= g.bonestructure.test_threshold ? u.emit("change", c.name, w.value1, c.lang, c.index, !0) : u.emit("change", c.name, w.value1, c.lang, c.index, !1);
    }
    lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    });
    function v(x) {
      w.passwordInfo = [], w.requiredPasswordInfo = [];
      for (const p of g.bonestructure.tests)
        new RegExp(p[0]).test(x) || (p[2] ? w.requiredPasswordInfo.push(p[1]) : w.passwordInfo.push(p[1]));
      w.equal || w.requiredPasswordInfo.push("Die eingegebenen Passwörter stimmen nicht überein."), w.value1 || w.requiredPasswordInfo.push("Das eingegebene Passwort ist leer.");
    }
    return dr(() => {
      if (c.autofocus && k.value && k.value !== null && k !== null) {
        const { start: x } = Os(() => {
          k.value.focus();
        }, 600);
        x();
      }
    }), hi(
      () => c.value,
      (x, p) => {
        w.value1 = x;
      }
    ), {
      state: w,
      boneState: g,
      changeEvent: S,
      passwordBone: k
    };
  }
}), PI = ["disabled"], II = ["name"], OI = ["name"], RI = { class: "errors" };
function zI(c, u, g, w, k, S) {
  return j(), q(ye, null, [
    cn(M("sl-input", {
      ref: "passwordBone",
      "onUpdate:modelValue": u[0] || (u[0] = (v) => c.state.value1 = v),
      disabled: c.boneState.readonly,
      class: Tw({ "has-check": !c.boneState.readonly }),
      type: "password",
      clearable: "",
      "password-toggle": "true",
      onSlChange: u[1] || (u[1] = (...v) => c.changeEvent && c.changeEvent(...v)),
      onSlClear: u[2] || (u[2] = (v) => c.state.value1 = ""),
      onKeyup: u[3] || (u[3] = (...v) => c.changeEvent && c.changeEvent(...v))
    }, [
      M("sl-icon", {
        slot: "suffix",
        name: c.state.equal && c.state.value1.length ? "check" : "x"
      }, null, 8, II)
    ], 42, PI), [
      [wo, c.state.value1]
    ]),
    c.boneState.readonly ? he("", !0) : cn((j(), q("sl-input", {
      key: 0,
      "onUpdate:modelValue": u[4] || (u[4] = (v) => c.state.value2 = v),
      class: "password-check",
      type: "password",
      clearable: "",
      "password-toggle": "true",
      onSlChange: u[5] || (u[5] = (...v) => c.changeEvent && c.changeEvent(...v)),
      onSlClear: u[6] || (u[6] = (v) => c.state.value2 = ""),
      onKeyup: u[7] || (u[7] = (...v) => c.changeEvent && c.changeEvent(...v))
    }, [
      M("sl-icon", {
        slot: "suffix",
        name: c.state.equal && c.state.value1.length ? "check" : "x"
      }, null, 8, OI)
    ], 544)), [
      [wo, c.state.value2]
    ]),
    M("ul", RI, [
      (j(!0), q(ye, null, dt(c.state.passwordInfo, (v, x) => (j(), q("li", { key: x }, Se(v), 1))), 128)),
      (j(!0), q(ye, null, dt(c.state.requiredPasswordInfo, (v, x) => (j(), q("li", {
        key: x,
        class: "requiredInfo"
      }, Se(v), 1))), 128))
    ])
  ], 64);
}
const Jk = /* @__PURE__ */ Ee(TI, [["render", zI], ["__scopeId", "data-v-0ccf18c0"]]), MI = Ye({
  props: {
    name: String,
    value: null,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({
      value: le(() => c.value),
      structure: le(() => v(g.bonestructure.using)),
      globalRegistration: !1,
      formGroups: le(() => {
        var D;
        let x = { default: { name: "Allgemein", bones: [], groupVisible: !1, groupOpen: !0 } };
        for (const [y, C] of Object.entries(w.structure)) {
          let b = "default", A = w.structure[y], P = w.value[y];
          (D = C == null ? void 0 : C.params) != null && D.category && (b = C.params.category.toLowerCase()), Object.keys(x).includes(b) ? x[b].bones.push({
            boneName: y,
            boneStructure: A,
            boneValue: P
          }) : x[b] = {
            name: C.params.category,
            bones: [
              {
                boneName: y,
                boneStructure: A,
                boneValue: P
              }
            ]
          }, A.visible === !0 && (x[b].groupVisible = !0);
        }
        let p = {};
        return Object.keys(x).sort().forEach(function(y) {
          p[y] = x[y];
        }), p;
      })
    });
    function k(x) {
      u.emit("change", x);
    }
    lt(() => {
      Ic().appContext.components.Bone ? w.globalRegistration = !0 : w.globalRegistration = !1, u.emit("change", c.name, c.value, c.lang, c.index);
    });
    function S(x) {
      console.log(x);
    }
    function v(x) {
      if (Array.isArray(x)) {
        let p = {};
        for (const D in x)
          p[x[D][0]] = x[D][1];
        return p;
      } else
        return x;
    }
    return {
      state: w,
      boneState: g,
      getBoneWidget: vo,
      structureToDict: v,
      changeEvent: k,
      updateValue: S
    };
  }
}), NI = {
  key: 0,
  open: "",
  variant: "danger"
}, FI = {
  key: 1,
  class: "form"
}, $I = ["summary", "open"];
function LI(c, u, g, w, k, S) {
  const v = yo("bone");
  return c.state.globalRegistration ? (j(), q("div", FI, [
    (j(!0), q(ye, null, dt(c.state.formGroups, (x, p) => cn((j(), q("sl-details", {
      key: p,
      summary: x.name,
      open: x.groupOpen
    }, [
      (j(!0), q(ye, null, dt(x.bones, (D) => cn((j(), ut(v, {
        key: D.name,
        is: c.getBoneWidget(c.state.structure[D.boneName].type),
        name: D.boneName,
        structure: c.state.structure,
        skel: c.state.value,
        errors: c.boneState.errors,
        readonly: c.boneState.bonestructure.readonly ? !0 : void 0,
        onChangeInternal: c.changeEvent
      }, null, 8, ["is", "name", "structure", "skel", "errors", "readonly", "onChangeInternal"])), [
        [vc, c.state.structure[D.boneName].visible]
      ])), 128))
    ], 8, $I)), [
      [vc, x.groupVisible]
    ])), 128))
  ])) : (j(), q("sl-alert", NI, " In Order to use this Bone register the bone component globally in your main file "));
}
const Xw = /* @__PURE__ */ Ee(MI, [["render", LI], ["__scopeId", "data-v-26bd4fa7"]]), VI = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: null,
    index: Number,
    lang: String
  },
  components: { Wrapper_nested: Xw },
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({
      value: {},
      index: le(() => c.index),
      lang: le(() => c.lang)
    });
    function k(S) {
      var x;
      (x = w.value) != null && x[S.name] || (w.value ? w.value[S.name] = null : w.value = { [S.name]: null });
      let v = w.value[S.name];
      S.lang ? (v === null && (v = {}), Object.keys(v).includes(S.lang) && S.index !== null ? v[S.lang][S.index] = S.value : v[S.lang] = S.value) : S.index !== null ? (v === null && (v = []), v[S.index] = S.value) : v = S.value, w.value[S.name] = v, u.emit("change", c.name, w.value, c.lang, c.index, !0);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: k
    };
  }
});
function jI(c, u, g, w, k, S) {
  const v = yo("Wrapper_nested");
  return j(), ut(v, {
    value: c.value,
    name: c.name,
    index: c.state.index,
    disabled: c.boneState.bonestructure.readonly,
    onChange: c.changeEvent
  }, null, 8, ["value", "name", "index", "disabled", "onChange"]);
}
const Yk = /* @__PURE__ */ Ee(VI, [["render", jI], ["__scopeId", "data-v-84a761ce"]]), HI = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({});
    function k(S) {
      u.emit("change", c.name, S.target.value, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: k
    };
  }
}), UI = ["disabled", "value"];
function qI(c, u, g, w, k, S) {
  return j(), q("sl-color-picker", {
    disabled: c.boneState.readonly,
    value: c.value,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, UI);
}
const Qk = /* @__PURE__ */ Ee(HI, [["render", qI], ["__scopeId", "data-v-534b9149"]]), WI = Ye({
  inheritAttrs: !1,
  emits: { change: null },
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  setup(c, u) {
    const g = Te("boneState"), w = _e({
      minAmount: le(() => g.bonestructure.minAmount),
      maxAmount: le(() => g.bonestructure.maxAmount),
      precision: le(() => {
        if (g.bonestructure.precision > 1)
          return parseFloat(`0.${"0".repeat(g.bonestructure.precision - 1)}1`);
      })
    }), k = Ft(null);
    function S(v) {
      u.emit("change", c.name, v.target.value, c.lang, c.index);
    }
    return dr(() => {
      if (c.autofocus && k.value && k.value !== null && k !== null) {
        const { start: v } = Os(() => {
          k.value.focus();
        }, 600);
        v();
      }
    }), lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: S,
      numericBone: k
    };
  }
}), GI = ["disabled", "value", "min", "max", "step"], KI = { class: "info" }, ZI = { key: 0 }, JI = { key: 1 }, YI = { key: 2 };
function QI(c, u, g, w, k, S) {
  return j(), q(ye, null, [
    M("sl-input", {
      ref: "numericBone",
      type: "number",
      disabled: c.boneState.readonly,
      value: c.value,
      min: c.state.minAmount,
      max: c.state.maxAmount,
      step: c.state.precision,
      onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v)),
      onKeyup: u[1] || (u[1] = (...v) => c.changeEvent && c.changeEvent(...v))
    }, null, 40, GI),
    M("ul", KI, [
      c.state.minAmount !== -9223372036854776e3 ? (j(), q("li", ZI, Se(c.$t("bones.numeric.min", { val: c.state.minAmount })), 1)) : he("", !0),
      c.state.maxAmount !== 9223372036854776e3 ? (j(), q("li", JI, Se(c.$t("bones.numeric.max", { val: c.state.maxAmount })), 1)) : he("", !0),
      c.state.precision ? (j(), q("li", YI, Se(c.$t("bones.numeric.precision", { val: c.boneState.bonestructure.precision })), 1)) : he("", !0)
    ])
  ], 64);
}
const Xk = /* @__PURE__ */ Ee(WI, [["render", QI], ["__scopeId", "data-v-086ce547"]]), XI = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: { Wrapper_nested: Xw },
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = Te("formatString"), k = _e({
      format: le(() => g == null ? void 0 : g.bonestructure.format),
      skellistdata: null,
      selection: null
    });
    function S(p) {
      let D = "";
      return g.bonestructure.type === "relational.tree.leaf.file" ? D = "skelType=leaf&" : g.bonestructure.type === "relational.tree.node.file" && (D = "skelType=node&"), ve.get(
        `/json/${g.bonestructure.module}/list?${D}limit=99`
      ).then(async (y) => {
        var b;
        const C = await y.json();
        k.skellistdata = {};
        for (let A of C.skellist)
          k.skellistdata[A.key] = A;
        return (b = C.skellist) == null ? void 0 : b.map((A) => ({ text: w(g.bonestructure.format, { dest: A }), value: A.key, data: A }));
      });
    }
    function v(p) {
      k.selection = { dest: k.skellistdata[p.detail.item.value] }, u.emit("change", c.name, k.selection, c.lang, c.index);
    }
    function x(p) {
      var y;
      k.selection || (k.selection = {}), (y = k.selection.rel) != null && y[p.name] || (k.selection.rel ? k.selection.rel[p.name] = null : k.selection.rel = { [p.name]: null });
      let D = k.selection.rel[p.name];
      p.lang ? (D === null && (D = {}), Object.keys(D).includes(p.lang) && p.index !== null ? D[p.lang][p.index] = p.value : D[p.lang] = p.value) : p.index !== null ? (D === null && (D = []), D[p.index] = p.value) : D = p.value, Object.keys(k.selection).includes("rel") && k.selection.rel ? k.selection.rel[p.name] = D : k.selection.rel = { [p.name]: D }, Object.keys(k.selection).includes("dest") && u.emit("change", c.name, k.selection, c.lang, c.index);
    }
    return lt(() => {
      k.selection = c.value, u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: k,
      boneState: g,
      formatString: w,
      changeEvent: v,
      changeEventNested: x,
      getList: S
    };
  }
}), e3 = (c) => (bt("data-v-61dd72e0"), c = c(), kt(), c), t3 = { class: "record" }, n3 = { class: "single-entry" }, o3 = ["value"], i3 = ["disabled", "source"], r3 = ["title"], s3 = /* @__PURE__ */ e3(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), a3 = [
  s3
];
function l3(c, u, g, w, k, S) {
  var x, p;
  const v = yo("Wrapper_nested");
  return j(), q("div", t3, [
    M("div", n3, [
      c.state.selection ? (j(), q("sl-input", {
        key: 0,
        disabled: !0,
        value: c.value ? c.formatString(c.state.format, c.state.selection) : ""
      }, null, 8, o3)) : (j(), q("sl-combobox", {
        key: 1,
        disabled: c.boneState.readonly,
        source: c.getList,
        hoist: "",
        onSlItemSelect: u[0] || (u[0] = (...D) => c.changeEvent && c.changeEvent(...D))
      }, null, 40, i3)),
      !c.boneState.multiple && !c.boneState.isEmpty ? (j(), q("sl-button", {
        key: 2,
        variant: "danger",
        outline: "",
        title: c.$t("bone.del"),
        class: "delete-btn square-btn",
        onClick: u[1] || (u[1] = () => {
          c.$emit("change", c.name, "", c.lang, c.index), c.state.selection = null;
        })
      }, a3, 8, r3)) : he("", !0)
    ]),
    (x = c.boneState) != null && x.bonestructure.using ? (j(), ut(v, {
      key: 0,
      value: (p = c.value) == null ? void 0 : p.rel,
      name: c.name,
      index: c.index,
      disabled: c.boneState.bonestructure.readonly,
      onChange: c.changeEventNested
    }, null, 8, ["value", "name", "index", "disabled", "onChange"])) : he("", !0)
  ]);
}
const ew = /* @__PURE__ */ Ee(XI, [["render", l3], ["__scopeId", "data-v-61dd72e0"]]), c3 = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({});
    function k(S, v) {
      u.emit("change", c.name, S, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: k
    };
  }
}), d3 = { class: "box" };
function u3(c, u, g, w, k, S) {
  return j(), q("div", d3, Se(c.value), 1);
}
const h3 = /* @__PURE__ */ Ee(c3, [["render", u3], ["__scopeId", "data-v-343aca69"]]), g3 = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = Ft(), k = _e({
      loading: !1,
      droparea: !1,
      previewopen: !1
    });
    lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    });
    function S() {
      console.log(ve.downloadUrlFor(c.value)), window.open(ve.downloadUrlFor(c.value));
    }
    function v() {
      return ve.downloadUrlFor(c.value, !1);
    }
    function x(y) {
      const C = {
        fileName: y.name,
        mimeType: y.type || "application/octet-stream",
        size: y.size.toString()
      };
      return new Promise((b, A) => {
        ve.securePost("/json/file/getUploadURL", { dataObj: C }).then(async (P) => {
          let R = await P.json();
          fetch(R.values.uploadUrl, {
            body: y,
            method: "POST",
            mode: "no-cors"
          }).then(async (z) => {
            const F = {
              key: R.values.uploadKey,
              node: void 0,
              skelType: "leaf"
            };
            ve.securePost("/json/file/add", { dataObj: F }).then(async (L) => {
              let U = await L.json();
              U.action === "addSuccess" ? b(U.values) : A(U);
            }).catch((L) => {
              A(L);
            });
          }).catch((z) => {
            A(z);
          });
        }).catch((P) => {
          A(P);
        });
      });
    }
    async function p(y) {
      k.loading = !0;
      for (let C of y.target.files) {
        let b = await x(C);
        u.emit("change", c.name, { dest: b, rel: null }, c.lang, c.index);
      }
      k.loading = !1;
    }
    async function D(y) {
      k.loading = !0, k.droparea = !1;
      for (let C of y.dataTransfer.files) {
        let b = await x(C);
        u.emit("change", c.name, { dest: b, rel: null }, c.lang, c.index);
        break;
      }
      k.loading = !1;
    }
    return {
      state: k,
      boneState: g,
      downloadFile: S,
      createBackgroundImage: v,
      handleUpload: p,
      uploadinput: w,
      handleDrop: D
    };
  }
}), Rs = (c) => (bt("data-v-feddfc55"), c = c(), kt(), c), m3 = {
  key: 0,
  class: "loader"
}, p3 = /* @__PURE__ */ Rs(() => /* @__PURE__ */ M("sl-spinner", { slot: "suffix" }, null, -1)), f3 = [
  p3
], b3 = {
  key: 1,
  class: "droparea"
}, k3 = ["title"], w3 = /* @__PURE__ */ Rs(() => /* @__PURE__ */ M("sl-icon", { name: "upload" }, null, -1)), v3 = [
  w3
], _3 = ["multiple"], A3 = ["title"], C3 = /* @__PURE__ */ Rs(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  name: "download"
}, null, -1)), y3 = [
  C3
], E3 = { class: "box" }, x3 = ["src"], S3 = ["label", "open"], D3 = ["src"], B3 = {
  key: 1,
  class: "preview"
}, T3 = {
  key: 0,
  name: "file-earmark"
}, P3 = { key: 2 }, I3 = ["title"], O3 = /* @__PURE__ */ Rs(() => /* @__PURE__ */ M("sl-icon", { name: "x-lg" }, null, -1)), R3 = [
  O3
];
function z3(c, u, g, w, k, S) {
  var v, x, p, D, y, C, b, A, P, R;
  return j(), q("div", {
    class: "file-wrapper",
    onDragover: u[5] || (u[5] = li((z) => c.state.droparea = !0, ["prevent"])),
    onDragleave: u[6] || (u[6] = (z) => c.state.droparea = !1),
    onDrop: u[7] || (u[7] = li((...z) => c.handleDrop && c.handleDrop(...z), ["prevent"]))
  }, [
    c.state.loading ? (j(), q("div", m3, f3)) : he("", !0),
    c.state.droparea ? (j(), q("div", b3, " Dateien hier hinziehen ")) : he("", !0),
    !c.boneState.readonly && (!c.value || c.state.loading) ? (j(), q("sl-button", {
      key: 2,
      title: c.$t("bone.upload"),
      outline: "",
      class: "upload-btn",
      onClick: u[0] || (u[0] = (z) => c.uploadinput.click())
    }, v3, 8, k3)) : he("", !0),
    M("input", {
      ref: "uploadinput",
      hidden: "",
      type: "file",
      multiple: c.boneState.multiple,
      onChange: u[1] || (u[1] = (...z) => c.handleUpload && c.handleUpload(...z))
    }, null, 40, _3),
    c.value ? (j(), q("sl-button", {
      key: 3,
      title: c.$t("bone.download"),
      onClick: u[2] || (u[2] = (...z) => c.downloadFile && c.downloadFile(...z))
    }, y3, 8, A3)) : he("", !0),
    M("div", E3, [
      (x = (v = c.value) == null ? void 0 : v.dest) != null && x.mimetype.includes("image") ? (j(), q("div", {
        key: 0,
        class: "preview has-preview",
        onClick: u[3] || (u[3] = (z) => c.state.previewopen = !c.state.previewopen)
      }, [
        M("img", {
          class: "preview-img",
          src: c.createBackgroundImage(),
          alt: ""
        }, null, 8, x3),
        M("sl-dialog", {
          label: decodeURIComponent((D = (p = c.value) == null ? void 0 : p.dest) == null ? void 0 : D.name),
          class: "preview-overlay",
          open: c.state.previewopen
        }, [
          M("img", {
            src: c.createBackgroundImage(),
            alt: ""
          }, null, 8, D3)
        ], 8, S3)
      ])) : (j(), q("div", B3, [
        (C = (y = c.value) == null ? void 0 : y.dest) != null && C.name ? (j(), q("sl-icon", T3)) : he("", !0)
      ])),
      (A = (b = c.value) == null ? void 0 : b.dest) != null && A.name ? (j(), q("div", P3, Se(decodeURIComponent((R = (P = c.value) == null ? void 0 : P.dest) == null ? void 0 : R.name)), 1)) : he("", !0)
    ]),
    c.boneState.multiple ? he("", !0) : (j(), q("sl-button", {
      key: 4,
      variant: "danger",
      outline: "",
      title: c.$t("bone.del"),
      class: "delete-btn",
      onClick: u[4] || (u[4] = (z) => c.$emit("change", c.name, "", c.lang, c.index))
    }, R3, 8, I3))
  ], 32);
}
const tw = /* @__PURE__ */ Ee(g3, [["render", z3], ["__scopeId", "data-v-feddfc55"]]);
var ys = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function M3(c) {
  return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c;
}
var Bs = { exports: {} };
Bs.exports;
(function(c, u) {
  (function(g) {
    const w = g.de = g.de || {};
    w.dictionary = Object.assign(w.dictionary || {}, { "%0 of %1": "%0 von %1", "Align cell text to the bottom": "Zellentext unten ausrichten", "Align cell text to the center": "Zellentext zentriert ausrichten", "Align cell text to the left": "Zellentext linksbündig ausrichten", "Align cell text to the middle": "Zellentext mittig ausrichten", "Align cell text to the right": "Zellentext rechtsbündig ausrichten", "Align cell text to the top": "Zellentext oben ausrichten", "Align center": "Zentriert", "Align left": "Linksbündig", "Align right": "Rechtsbündig", "Align table to the left": "Tabelle links ausrichten", "Align table to the right": "Tabelle rechts ausrichten", Alignment: "Ausrichtung", Aquamarine: "Aquamarinblau", Background: "Hintergrund", Black: "Schwarz", "Block quote": "Blockzitat", Blue: "Blau", Bold: "Fett", Border: "Rahmen", "Break text": "Bild teilt Text", "Bulleted List": "Aufzählungsliste", "Bulleted list styles toolbar": "Darstellung der ungeordneten Liste", Cancel: "Abbrechen", "Cannot upload file:": "Die Datei kann nicht hochgeladen werden:", "Caption for image: %0": "Bildunterschrift: %0", "Caption for the image": "Bildunterschrift", "Cell properties": "Zelleneigenschaften", "Center table": "Tabelle zentrieren", "Centered image": "Zentriertes Bild", "Change image text alternative": "Alternativtext ändern", "Choose heading": "Überschrift auswählen", Circle: "Leerer Kreis", Code: "Code", Color: "Farbe", "Color picker": "Farbwähler", Column: "Spalte", Dashed: "Gestrichelt", Decimal: "Dezimalzahlen", "Decimal with leading zero": "Dezimalzahlen mit vorangestellten Nullen", "Decrease indent": "Einzug verkleinern", "Delete column": "Spalte löschen", "Delete row": "Zeile löschen", "Dim grey": "Dunkelgrau", Dimensions: "Größe", Disc: "Gefüllter Kreis", Dotted: "Gepunktet", Double: "Doppelt", Downloadable: "Herunterladbar", "Dropdown toolbar": "Dropdown-Liste Werkzeugleiste", "Edit block": "Absatz bearbeiten", "Edit link": "Link bearbeiten", "Editor block content toolbar": "Editor Blockinhalt-Toolbar", "Editor contextual toolbar": "Editor kontextuelle Toolbar", "Editor editing area: %0": "Bearbeitungsbereich des Editors: %0", "Editor toolbar": "Editor Werkzeugleiste", "Enter image caption": "Bildunterschrift eingeben", "Enter table caption": "Tabellenüberschrift eingeben", "Full size image": "Bild in voller Größe", Green: "Grün", Grey: "Grau", Groove: "Eingeritzt", "Header column": "Kopfspalte", "Header row": "Kopfzeile", Heading: "Überschrift", "Heading 1": "Überschrift 1", "Heading 2": "Überschrift 2", "Heading 3": "Überschrift 3", "Heading 4": "Überschrift 4", "Heading 5": "Überschrift 5", "Heading 6": "Überschrift 6", Height: "Höhe", HEX: "", "Horizontal text alignment toolbar": "Werkzeugleiste für die horizontale Zellentext-Ausrichtung", "HTML object": "HTML-Objekt", "Image resize list": "Bildgrößen-Liste", "Image toolbar": "Bild Werkzeugleiste", "image widget": "Bild-Steuerelement", "In line": "Text in Zeile", "Increase indent": "Einzug vergrößern", Insert: "Einfügen", "Insert column left": "Spalte links einfügen", "Insert column right": "Spalte rechts einfügen", "Insert image": "Bild einfügen", "Insert image via URL": "Bild von URL einfügen", "Insert paragraph after block": "Absatz nach Block einfügen", "Insert paragraph before block": "Absatz vor Block einfügen", "Insert row above": "Zeile oben einfügen", "Insert row below": "Zeile unten einfügen", "Insert table": "Tabelle einfügen", Inset: "Eingelassen", Italic: "Kursiv", Justify: "Blocksatz", "Justify cell text": "Zellentext als Blocksatz ausrichten", "Left aligned image": "Linksbündiges Bild", "Light blue": "Hellblau", "Light green": "Hellgrün", "Light grey": "Hellgrau", Link: "Link", "Link image": "Bild verlinken", "Link URL": "Link Adresse", "List properties": "Listeneigenschaften", "Lower-latin": "Kleingeschriebene lateinische Buchstaben", "Lower–roman": "Kleingeschriebene römische Zahlen", "Merge cell down": "Zelle unten verbinden", "Merge cell left": "Zelle links verbinden", "Merge cell right": "Zelle rechts verbinden", "Merge cell up": "Zelle verbinden", "Merge cells": "Zellen verbinden", Next: "Nächste", None: "Kein Rahmen", "Numbered List": "Nummerierte Liste", "Numbered list styles toolbar": "Darstellung der geordneten Liste", "Open in a new tab": "In neuem Tab öffnen", "Open link in new tab": "Link im neuen Tab öffnen", Orange: "Orange", Original: "Original", Outset: "Geprägt", Padding: "Innenabstand", Paragraph: "Absatz", "Press Enter to type after or press Shift + Enter to type before the widget": "Drücken Sie die Eingabetaste, um nach dem Widget zu tippen oder Shift + Eingabetaste, um vor dem Widget zu tippen.", Previous: "vorherige", Purple: "Violett", Red: "Rot", Redo: "Wiederherstellen", "Remove color": "Farbe entfernen", "Remove Format": "Formatierung entfernen", "Resize image": "Bildgröße ändern", "Resize image to %0": "Bildgröße ändern in %0", "Resize image to the original size": "Bild in Originalgröße ändern", "Restore default": "Standard wiederherstellen", "Reversed order": "Umgekehrte Reihenfolge", "Rich Text Editor": "Rich Text Editor", Ridge: "Hervorgehoben", "Right aligned image": "Rechtsbündiges Bild", Row: "Zeile", Save: "Speichern", "Select all": "Alles auswählen", "Select column": "Spalte auswählen", "Select row": "Zeile auswählen", "Show more items": "Mehr anzeigen", "Side image": "Seitenbild", Solid: "Durchgezogen", "Split cell horizontally": "Zelle horizontal teilen", "Split cell vertically": "Zelle vertikal teilen", Square: "Quadrat", "Start at": "Beginnen mit", "Start index must be greater than 0.": "Der Startwert muss größer als 0 sein.", Strikethrough: "Durchgestrichen", Style: "Rahmenart", Subscript: "Tiefgestellt", Superscript: "Hochgestellt", "Table alignment toolbar": "Werkzeugleiste für die Tabellen-Ausrichtung", "Table cell text alignment": "Ausrichtung des Zellentextes", "Table properties": "Tabelleneigenschaften", "Table toolbar": "Tabelle Werkzeugleiste", "Text alignment": "Textausrichtung", "Text alignment toolbar": "Text-Ausrichtung Toolbar", "Text alternative": "Alternativtext", 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': "Die Farbe ist ungültig. Probieren Sie „#FF0000“ oder „rgb(255,0,0)“ oder „red“.", 'The value is invalid. Try "10px" or "2em" or simply "2".': "Der Wert ist ungültig. Probieren Sie „10px“ oder „2em“ oder „2“.", "This link has no URL": "Dieser Link hat keine Adresse", "To-do List": "Aufgabenliste", "Toggle caption off": "Tabellenüberschrift deaktivieren", "Toggle caption on": "Tabellenüberschrift aktivieren", "Toggle the circle list style": "Leeren Kreis einstellen", "Toggle the decimal list style": "Dezimalzahlen einstellen", "Toggle the decimal with leading zero list style": "Dezimalzahlen mit vorangestellten Nullen einstellen", "Toggle the disc list style": "Gefüllten Kreis einstellen", "Toggle the lower–latin list style": "Kleingeschriebene lateinische Buchstaben einstellen", "Toggle the lower–roman list style": "Kleingeschriebene römische Zahlen einstellen", "Toggle the square list style": "Quadrat einstellen", "Toggle the upper–latin list style": "Großgeschriebene lateinische Buchstaben einstellen", "Toggle the upper–roman list style": "Großgeschriebene römische Zahlen einstellen", Turquoise: "Türkis", "Type or paste your content here.": "Hier Inhalt einfügen.", "Type your title": "Titel eingeben", Underline: "Unterstrichen", Undo: "Rückgängig", Unlink: "Link entfernen", Update: "Aktualisieren", "Update image URL": "Bild-URL aktualisieren", "Upload failed": "Hochladen fehlgeschlagen", "Upload in progress": "Upload läuft", "Upper-latin": "Großgeschriebene lateinische Buchstaben", "Upper-roman": "Großgeschriebene römische Zahlen", "Vertical text alignment toolbar": "Werkzeugleiste für die vertikale Zellentext-Ausrichtung", White: "Weiß", "Widget toolbar": "Widget Werkzeugleiste", Width: "Breite", "Wrap text": "Text umfließt Bild", Yellow: "Gelb" }), w.getPluralForm = function(k) {
      return k != 1;
    };
  })(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})), /*!
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md.
   */
  function(g, w) {
    c.exports = w();
  }(self, () => (() => {
    var g = { 4959: (v, x, p) => {
      const D = p(1103), y = {};
      for (const b of Object.keys(D))
        y[D[b]] = b;
      const C = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
      v.exports = C;
      for (const b of Object.keys(C)) {
        if (!("channels" in C[b]))
          throw new Error("missing channels property: " + b);
        if (!("labels" in C[b]))
          throw new Error("missing channel labels property: " + b);
        if (C[b].labels.length !== C[b].channels)
          throw new Error("channel and label counts mismatch: " + b);
        const { channels: A, labels: P } = C[b];
        delete C[b].channels, delete C[b].labels, Object.defineProperty(C[b], "channels", { value: A }), Object.defineProperty(C[b], "labels", { value: P });
      }
      C.rgb.hsl = function(b) {
        const A = b[0] / 255, P = b[1] / 255, R = b[2] / 255, z = Math.min(A, P, R), F = Math.max(A, P, R), L = F - z;
        let U, J;
        F === z ? U = 0 : A === F ? U = (P - R) / L : P === F ? U = 2 + (R - A) / L : R === F && (U = 4 + (A - P) / L), U = Math.min(60 * U, 360), U < 0 && (U += 360);
        const ie = (z + F) / 2;
        return J = F === z ? 0 : ie <= 0.5 ? L / (F + z) : L / (2 - F - z), [U, 100 * J, 100 * ie];
      }, C.rgb.hsv = function(b) {
        let A, P, R, z, F;
        const L = b[0] / 255, U = b[1] / 255, J = b[2] / 255, ie = Math.max(L, U, J), ce = ie - Math.min(L, U, J), ee = function(de) {
          return (ie - de) / 6 / ce + 0.5;
        };
        return ce === 0 ? (z = 0, F = 0) : (F = ce / ie, A = ee(L), P = ee(U), R = ee(J), L === ie ? z = R - P : U === ie ? z = 0.3333333333333333 + A - R : J === ie && (z = 0.6666666666666666 + P - A), z < 0 ? z += 1 : z > 1 && (z -= 1)), [360 * z, 100 * F, 100 * ie];
      }, C.rgb.hwb = function(b) {
        const A = b[0], P = b[1];
        let R = b[2];
        const z = C.rgb.hsl(b)[0], F = 1 / 255 * Math.min(A, Math.min(P, R));
        return R = 1 - 0.00392156862745098 * Math.max(A, Math.max(P, R)), [z, 100 * F, 100 * R];
      }, C.rgb.cmyk = function(b) {
        const A = b[0] / 255, P = b[1] / 255, R = b[2] / 255, z = Math.min(1 - A, 1 - P, 1 - R);
        return [100 * ((1 - A - z) / (1 - z) || 0), 100 * ((1 - P - z) / (1 - z) || 0), 100 * ((1 - R - z) / (1 - z) || 0), 100 * z];
      }, C.rgb.keyword = function(b) {
        const A = y[b];
        if (A)
          return A;
        let P, R = 1 / 0;
        for (const L of Object.keys(D)) {
          const U = D[L], J = (F = U, ((z = b)[0] - F[0]) ** 2 + (z[1] - F[1]) ** 2 + (z[2] - F[2]) ** 2);
          J < R && (R = J, P = L);
        }
        var z, F;
        return P;
      }, C.keyword.rgb = function(b) {
        return D[b];
      }, C.rgb.xyz = function(b) {
        let A = b[0] / 255, P = b[1] / 255, R = b[2] / 255;
        return A = A > 0.04045 ? ((A + 0.055) / 1.055) ** 2.4 : A / 12.92, P = P > 0.04045 ? ((P + 0.055) / 1.055) ** 2.4 : P / 12.92, R = R > 0.04045 ? ((R + 0.055) / 1.055) ** 2.4 : R / 12.92, [100 * (0.4124 * A + 0.3576 * P + 0.1805 * R), 100 * (0.2126 * A + 0.7152 * P + 0.0722 * R), 100 * (0.0193 * A + 0.1192 * P + 0.9505 * R)];
      }, C.rgb.lab = function(b) {
        const A = C.rgb.xyz(b);
        let P = A[0], R = A[1], z = A[2];
        return P /= 95.047, R /= 100, z /= 108.883, P = P > 8856e-6 ? P ** 0.3333333333333333 : 7.787 * P + 0.13793103448275862, R = R > 8856e-6 ? R ** 0.3333333333333333 : 7.787 * R + 0.13793103448275862, z = z > 8856e-6 ? z ** 0.3333333333333333 : 7.787 * z + 0.13793103448275862, [116 * R - 16, 500 * (P - R), 200 * (R - z)];
      }, C.hsl.rgb = function(b) {
        const A = b[0] / 360, P = b[1] / 100, R = b[2] / 100;
        let z, F, L;
        if (P === 0)
          return L = 255 * R, [L, L, L];
        z = R < 0.5 ? R * (1 + P) : R + P - R * P;
        const U = 2 * R - z, J = [0, 0, 0];
        for (let ie = 0; ie < 3; ie++)
          F = A + 0.3333333333333333 * -(ie - 1), F < 0 && F++, F > 1 && F--, L = 6 * F < 1 ? U + 6 * (z - U) * F : 2 * F < 1 ? z : 3 * F < 2 ? U + (z - U) * (0.6666666666666666 - F) * 6 : U, J[ie] = 255 * L;
        return J;
      }, C.hsl.hsv = function(b) {
        const A = b[0];
        let P = b[1] / 100, R = b[2] / 100, z = P;
        const F = Math.max(R, 0.01);
        return R *= 2, P *= R <= 1 ? R : 2 - R, z *= F <= 1 ? F : 2 - F, [A, 100 * (R === 0 ? 2 * z / (F + z) : 2 * P / (R + P)), 100 * ((R + P) / 2)];
      }, C.hsv.rgb = function(b) {
        const A = b[0] / 60, P = b[1] / 100;
        let R = b[2] / 100;
        const z = Math.floor(A) % 6, F = A - Math.floor(A), L = 255 * R * (1 - P), U = 255 * R * (1 - P * F), J = 255 * R * (1 - P * (1 - F));
        switch (R *= 255, z) {
          case 0:
            return [R, J, L];
          case 1:
            return [U, R, L];
          case 2:
            return [L, R, J];
          case 3:
            return [L, U, R];
          case 4:
            return [J, L, R];
          case 5:
            return [R, L, U];
        }
      }, C.hsv.hsl = function(b) {
        const A = b[0], P = b[1] / 100, R = b[2] / 100, z = Math.max(R, 0.01);
        let F, L;
        L = (2 - P) * R;
        const U = (2 - P) * z;
        return F = P * z, F /= U <= 1 ? U : 2 - U, F = F || 0, L /= 2, [A, 100 * F, 100 * L];
      }, C.hwb.rgb = function(b) {
        const A = b[0] / 360;
        let P = b[1] / 100, R = b[2] / 100;
        const z = P + R;
        let F;
        z > 1 && (P /= z, R /= z);
        const L = Math.floor(6 * A), U = 1 - R;
        F = 6 * A - L, 1 & L && (F = 1 - F);
        const J = P + F * (U - P);
        let ie, ce, ee;
        switch (L) {
          default:
          case 6:
          case 0:
            ie = U, ce = J, ee = P;
            break;
          case 1:
            ie = J, ce = U, ee = P;
            break;
          case 2:
            ie = P, ce = U, ee = J;
            break;
          case 3:
            ie = P, ce = J, ee = U;
            break;
          case 4:
            ie = J, ce = P, ee = U;
            break;
          case 5:
            ie = U, ce = P, ee = J;
        }
        return [255 * ie, 255 * ce, 255 * ee];
      }, C.cmyk.rgb = function(b) {
        const A = b[0] / 100, P = b[1] / 100, R = b[2] / 100, z = b[3] / 100;
        return [255 * (1 - Math.min(1, A * (1 - z) + z)), 255 * (1 - Math.min(1, P * (1 - z) + z)), 255 * (1 - Math.min(1, R * (1 - z) + z))];
      }, C.xyz.rgb = function(b) {
        const A = b[0] / 100, P = b[1] / 100, R = b[2] / 100;
        let z, F, L;
        return z = 3.2406 * A + -1.5372 * P + -0.4986 * R, F = -0.9689 * A + 1.8758 * P + 0.0415 * R, L = 0.0557 * A + -0.204 * P + 1.057 * R, z = z > 31308e-7 ? 1.055 * z ** 0.4166666666666667 - 0.055 : 12.92 * z, F = F > 31308e-7 ? 1.055 * F ** 0.4166666666666667 - 0.055 : 12.92 * F, L = L > 31308e-7 ? 1.055 * L ** 0.4166666666666667 - 0.055 : 12.92 * L, z = Math.min(Math.max(0, z), 1), F = Math.min(Math.max(0, F), 1), L = Math.min(Math.max(0, L), 1), [255 * z, 255 * F, 255 * L];
      }, C.xyz.lab = function(b) {
        let A = b[0], P = b[1], R = b[2];
        return A /= 95.047, P /= 100, R /= 108.883, A = A > 8856e-6 ? A ** 0.3333333333333333 : 7.787 * A + 0.13793103448275862, P = P > 8856e-6 ? P ** 0.3333333333333333 : 7.787 * P + 0.13793103448275862, R = R > 8856e-6 ? R ** 0.3333333333333333 : 7.787 * R + 0.13793103448275862, [116 * P - 16, 500 * (A - P), 200 * (P - R)];
      }, C.lab.xyz = function(b) {
        let A, P, R;
        P = (b[0] + 16) / 116, A = b[1] / 500 + P, R = P - b[2] / 200;
        const z = P ** 3, F = A ** 3, L = R ** 3;
        return P = z > 8856e-6 ? z : (P - 0.13793103448275862) / 7.787, A = F > 8856e-6 ? F : (A - 0.13793103448275862) / 7.787, R = L > 8856e-6 ? L : (R - 0.13793103448275862) / 7.787, A *= 95.047, P *= 100, R *= 108.883, [A, P, R];
      }, C.lab.lch = function(b) {
        const A = b[0], P = b[1], R = b[2];
        let z;
        return z = 360 * Math.atan2(R, P) / 2 / Math.PI, z < 0 && (z += 360), [A, Math.sqrt(P * P + R * R), z];
      }, C.lch.lab = function(b) {
        const A = b[0], P = b[1], R = b[2] / 360 * 2 * Math.PI;
        return [A, P * Math.cos(R), P * Math.sin(R)];
      }, C.rgb.ansi16 = function(b, A = null) {
        const [P, R, z] = b;
        let F = A === null ? C.rgb.hsv(b)[2] : A;
        if (F = Math.round(F / 50), F === 0)
          return 30;
        let L = 30 + (Math.round(z / 255) << 2 | Math.round(R / 255) << 1 | Math.round(P / 255));
        return F === 2 && (L += 60), L;
      }, C.hsv.ansi16 = function(b) {
        return C.rgb.ansi16(C.hsv.rgb(b), b[2]);
      }, C.rgb.ansi256 = function(b) {
        const A = b[0], P = b[1], R = b[2];
        return A === P && P === R ? A < 8 ? 16 : A > 248 ? 231 : Math.round((A - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(A / 255 * 5) + 6 * Math.round(P / 255 * 5) + Math.round(R / 255 * 5);
      }, C.ansi16.rgb = function(b) {
        let A = b % 10;
        if (A === 0 || A === 7)
          return b > 50 && (A += 3.5), A = A / 10.5 * 255, [A, A, A];
        const P = 0.5 * (1 + ~~(b > 50));
        return [(1 & A) * P * 255, (A >> 1 & 1) * P * 255, (A >> 2 & 1) * P * 255];
      }, C.ansi256.rgb = function(b) {
        if (b >= 232) {
          const P = 10 * (b - 232) + 8;
          return [P, P, P];
        }
        let A;
        return b -= 16, [Math.floor(b / 36) / 5 * 255, Math.floor((A = b % 36) / 6) / 5 * 255, A % 6 / 5 * 255];
      }, C.rgb.hex = function(b) {
        const A = (((255 & Math.round(b[0])) << 16) + ((255 & Math.round(b[1])) << 8) + (255 & Math.round(b[2]))).toString(16).toUpperCase();
        return "000000".substring(A.length) + A;
      }, C.hex.rgb = function(b) {
        const A = b.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!A)
          return [0, 0, 0];
        let P = A[0];
        A[0].length === 3 && (P = P.split("").map((z) => z + z).join(""));
        const R = parseInt(P, 16);
        return [R >> 16 & 255, R >> 8 & 255, 255 & R];
      }, C.rgb.hcg = function(b) {
        const A = b[0] / 255, P = b[1] / 255, R = b[2] / 255, z = Math.max(Math.max(A, P), R), F = Math.min(Math.min(A, P), R), L = z - F;
        let U, J;
        return U = L < 1 ? F / (1 - L) : 0, J = L <= 0 ? 0 : z === A ? (P - R) / L % 6 : z === P ? 2 + (R - A) / L : 4 + (A - P) / L, J /= 6, J %= 1, [360 * J, 100 * L, 100 * U];
      }, C.hsl.hcg = function(b) {
        const A = b[1] / 100, P = b[2] / 100, R = P < 0.5 ? 2 * A * P : 2 * A * (1 - P);
        let z = 0;
        return R < 1 && (z = (P - 0.5 * R) / (1 - R)), [b[0], 100 * R, 100 * z];
      }, C.hsv.hcg = function(b) {
        const A = b[1] / 100, P = b[2] / 100, R = A * P;
        let z = 0;
        return R < 1 && (z = (P - R) / (1 - R)), [b[0], 100 * R, 100 * z];
      }, C.hcg.rgb = function(b) {
        const A = b[0] / 360, P = b[1] / 100, R = b[2] / 100;
        if (P === 0)
          return [255 * R, 255 * R, 255 * R];
        const z = [0, 0, 0], F = A % 1 * 6, L = F % 1, U = 1 - L;
        let J = 0;
        switch (Math.floor(F)) {
          case 0:
            z[0] = 1, z[1] = L, z[2] = 0;
            break;
          case 1:
            z[0] = U, z[1] = 1, z[2] = 0;
            break;
          case 2:
            z[0] = 0, z[1] = 1, z[2] = L;
            break;
          case 3:
            z[0] = 0, z[1] = U, z[2] = 1;
            break;
          case 4:
            z[0] = L, z[1] = 0, z[2] = 1;
            break;
          default:
            z[0] = 1, z[1] = 0, z[2] = U;
        }
        return J = (1 - P) * R, [255 * (P * z[0] + J), 255 * (P * z[1] + J), 255 * (P * z[2] + J)];
      }, C.hcg.hsv = function(b) {
        const A = b[1] / 100, P = A + b[2] / 100 * (1 - A);
        let R = 0;
        return P > 0 && (R = A / P), [b[0], 100 * R, 100 * P];
      }, C.hcg.hsl = function(b) {
        const A = b[1] / 100, P = b[2] / 100 * (1 - A) + 0.5 * A;
        let R = 0;
        return P > 0 && P < 0.5 ? R = A / (2 * P) : P >= 0.5 && P < 1 && (R = A / (2 * (1 - P))), [b[0], 100 * R, 100 * P];
      }, C.hcg.hwb = function(b) {
        const A = b[1] / 100, P = A + b[2] / 100 * (1 - A);
        return [b[0], 100 * (P - A), 100 * (1 - P)];
      }, C.hwb.hcg = function(b) {
        const A = b[1] / 100, P = 1 - b[2] / 100, R = P - A;
        let z = 0;
        return R < 1 && (z = (P - R) / (1 - R)), [b[0], 100 * R, 100 * z];
      }, C.apple.rgb = function(b) {
        return [b[0] / 65535 * 255, b[1] / 65535 * 255, b[2] / 65535 * 255];
      }, C.rgb.apple = function(b) {
        return [b[0] / 255 * 65535, b[1] / 255 * 65535, b[2] / 255 * 65535];
      }, C.gray.rgb = function(b) {
        return [b[0] / 100 * 255, b[0] / 100 * 255, b[0] / 100 * 255];
      }, C.gray.hsl = function(b) {
        return [0, 0, b[0]];
      }, C.gray.hsv = C.gray.hsl, C.gray.hwb = function(b) {
        return [0, 100, b[0]];
      }, C.gray.cmyk = function(b) {
        return [0, 0, 0, b[0]];
      }, C.gray.lab = function(b) {
        return [b[0], 0, 0];
      }, C.gray.hex = function(b) {
        const A = 255 & Math.round(b[0] / 100 * 255), P = ((A << 16) + (A << 8) + A).toString(16).toUpperCase();
        return "000000".substring(P.length) + P;
      }, C.rgb.gray = function(b) {
        return [(b[0] + b[1] + b[2]) / 3 / 255 * 100];
      };
    }, 841: (v, x, p) => {
      const D = p(4959), y = p(9325), C = {};
      Object.keys(D).forEach((b) => {
        C[b] = {}, Object.defineProperty(C[b], "channels", { value: D[b].channels }), Object.defineProperty(C[b], "labels", { value: D[b].labels });
        const A = y(b);
        Object.keys(A).forEach((P) => {
          const R = A[P];
          C[b][P] = function(z) {
            const F = function(...L) {
              const U = L[0];
              if (U == null)
                return U;
              U.length > 1 && (L = U);
              const J = z(L);
              if (typeof J == "object")
                for (let ie = J.length, ce = 0; ce < ie; ce++)
                  J[ce] = Math.round(J[ce]);
              return J;
            };
            return "conversion" in z && (F.conversion = z.conversion), F;
          }(R), C[b][P].raw = function(z) {
            const F = function(...L) {
              const U = L[0];
              return U == null ? U : (U.length > 1 && (L = U), z(L));
            };
            return "conversion" in z && (F.conversion = z.conversion), F;
          }(R);
        });
      }), v.exports = C;
    }, 9325: (v, x, p) => {
      const D = p(4959);
      function y(A) {
        const P = function() {
          const z = {}, F = Object.keys(D);
          for (let L = F.length, U = 0; U < L; U++)
            z[F[U]] = { distance: -1, parent: null };
          return z;
        }(), R = [A];
        for (P[A].distance = 0; R.length; ) {
          const z = R.pop(), F = Object.keys(D[z]);
          for (let L = F.length, U = 0; U < L; U++) {
            const J = F[U], ie = P[J];
            ie.distance === -1 && (ie.distance = P[z].distance + 1, ie.parent = z, R.unshift(J));
          }
        }
        return P;
      }
      function C(A, P) {
        return function(R) {
          return P(A(R));
        };
      }
      function b(A, P) {
        const R = [P[A].parent, A];
        let z = D[P[A].parent][A], F = P[A].parent;
        for (; P[F].parent; )
          R.unshift(P[F].parent), z = C(D[P[F].parent][F], z), F = P[F].parent;
        return z.conversion = R, z;
      }
      v.exports = function(A) {
        const P = y(A), R = {}, z = Object.keys(P);
        for (let F = z.length, L = 0; L < F; L++) {
          const U = z[L];
          P[U].parent !== null && (R[U] = b(U, P));
        }
        return R;
      };
    }, 1103: (v) => {
      v.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
    }, 8603: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}", "", { version: 3, sources: ["webpack://./../ckeditor5-basic-styles/theme/code.css"], names: [], mappings: "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content code {
	background-color: hsla(0, 0%, 78%, 0.3);
	padding: .15em;
	border-radius: 2px;
}

.ck.ck-editor__editable .ck-code_selected  {
	background-color: hsla(0, 0%, 78%, 0.5);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 3062: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", { version: 3, sources: ["webpack://./../ckeditor5-block-quote/theme/blockquote.css"], names: [], mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content blockquote {
	/* See #12 */
	overflow: hidden;

	/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */
	padding-right: 1.5em;
	padding-left: 1.5em;

	margin-left: 0;
	margin-right: 0;
	font-style: italic;
	border-left: solid 5px hsl(0, 0%, 80%);
}

.ck-content[dir="rtl"] blockquote {
	border-left: 0;
	border-right: solid 5px hsl(0, 0%, 80%);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 903: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}', "", { version: 3, sources: ["webpack://./../ckeditor5-clipboard/theme/clipboard.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"], names: [], mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CChCA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		display: inline;
		position: relative;
		pointer-events: none;

		& span {
			position: absolute;
			width: 0;
		}
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		& > .ck-widget__selection-handle {
			display: none;
		}

		& > .ck-widget__type-around {
			display: none;
		}
	}
}

.ck.ck-clipboard-drop-target-line {
	position: absolute;
	pointer-events: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-clipboard-drop-target-dot-width: 12px;
	--ck-clipboard-drop-target-dot-height: 8px;
	--ck-clipboard-drop-target-color: var(--ck-color-focus-border)
}

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		& span {
			bottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			border: 1px solid var(--ck-clipboard-drop-target-color);
			background: var(--ck-clipboard-drop-target-color);
			margin-left: -1px;

			/* The triangle above the marker */
			&::after {
				content: "";
				width: 0;
				height: 0;

				display: block;
				position: absolute;
				left: 50%;
				top: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);

				transform: translateX(-50%);
				border-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;
				border-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));
				border-style: solid;
			}
		}
	}

	/*
	 * Styles of the widget that it a drop target.
	 */
	& .ck-widget.ck-clipboard-drop-target-range {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		zoom: 0.6;
		outline: none !important;
	}
}

.ck.ck-clipboard-drop-target-line {
	height: 0;
	border: 1px solid var(--ck-clipboard-drop-target-color);
	background: var(--ck-clipboard-drop-target-color);
	margin-top: -1px;
}
`], sourceRoot: "" }]);
      const A = b;
    }, 3143: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", { version: 3, sources: ["webpack://./../ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor {
	/* All the elements within \`.ck-editor\` are positioned relatively to it.
	 If any element needs to be positioned with respect to the <body>, etc.,
	 it must land outside of the \`.ck-editor\` in DOM. */
	position: relative;

	& .ck-editor__top .ck-sticky-panel .ck-toolbar {
		/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */
		z-index: var(--ck-z-modal);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

.ck.ck-editor__top {
	& .ck-sticky-panel {
		& .ck-toolbar {
			@mixin ck-rounded-corners {
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}

			border-bottom-width: 0;
		}

		& .ck-sticky-panel__content_sticky .ck-toolbar {
			border-bottom-width: 1px;

			@mixin ck-rounded-corners {
				border-radius: 0;
			}
		}
	}
}

/* Note: Use ck-editor__main to make sure these styles don't apply to other editor types */
.ck.ck-editor__main > .ck-editor__editable {
	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */
	background: var(--ck-color-base-background);

	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	&:not(.ck-focused) {
		border-color: var(--ck-color-base-border);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 4717: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}", "", { version: 3, sources: ["webpack://./../ckeditor5-engine/theme/placeholder.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"], names: [], mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* See ckeditor/ckeditor5#936. */
.ck.ck-placeholder,
.ck .ck-placeholder {
	position: relative;

	&::before {
		position: absolute;
		left: 0;
		right: 0;
		content: attr(data-placeholder);

		/* See ckeditor/ckeditor5#469. */
		pointer-events: none;
	}
}

/* See ckeditor/ckeditor5#1987. */
.ck.ck-read-only .ck-placeholder {
	&::before {
		display: none;
	}
}

/*
 * Rules for the \`ck-placeholder\` are loaded before the rules for \`ck-reset_all\` in the base CKEditor 5 DLL build.
 * This fix overwrites the incorrectly set \`position: static\` from \`ck-reset_all\`.
 * See https://github.com/ckeditor/ckeditor5/issues/11418.
 */
.ck.ck-reset_all .ck-placeholder {
	position: relative;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* See ckeditor/ckeditor5#936. */
.ck.ck-placeholder, .ck .ck-placeholder {
	&::before {
		cursor: text;
		color: var(--ck-color-engine-placeholder-text);
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 9315: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-engine/theme/renderer.css"], names: [], mappings: "AAMA,qDACC,YACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Elements marked by the Renderer as hidden should be invisible in the editor. */
.ck.ck-editor__editable span[data-ck-unsafe-element] {
	display: none;
}
`], sourceRoot: "" }]);
      const A = b;
    }, 8733: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", { version: 3, sources: ["webpack://./../ckeditor5-heading/theme/heading.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"], names: [], mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-heading_heading1 {
	font-size: 20px;
}

.ck.ck-heading_heading2 {
	font-size: 17px;
}

.ck.ck-heading_heading3 {
	font-size: 14px;
}

.ck[class*="ck-heading_heading"] {
	font-weight: bold;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Resize dropdown's button label. */
.ck.ck-dropdown.ck-heading-dropdown {
	& .ck-dropdown__button .ck-button__label {
		width: 8em;
	}

	& .ck-dropdown__panel .ck-list__item {
		min-width: 18em;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 5049: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ":root{--ck-html-object-embed-unfocused-outline-width:1px}.ck-widget.html-object-embed{background-color:var(--ck-color-base-foreground);font-size:var(--ck-font-size-base);min-width:calc(76px + var(--ck-spacing-standard));padding:var(--ck-spacing-small);padding-top:calc(var(--ck-font-size-tiny) + var(--ck-spacing-large))}.ck-widget.html-object-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.html-object-embed:before{background:#999;border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);content:attr(data-html-object-embed-label);font-family:var(--ck-font-face);font-size:var(--ck-font-size-tiny);font-style:normal;font-weight:400;left:var(--ck-spacing-standard);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);position:absolute;top:0;transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck-widget.html-object-embed .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck-widget.html-object-embed .html-object-embed__content{pointer-events:none}div.ck-widget.html-object-embed{margin:1em auto}span.ck-widget.html-object-embed{display:inline-block}", "", { version: 3, sources: ["webpack://./../ckeditor5-html-support/theme/datafilter.css"], names: [], mappings: "AAKA,MACC,kDACD,CAEA,6BAEC,gDAAiD,CADjD,kCAAmC,CAKnC,iDAAkD,CAHlD,+BAAgC,CAEhC,oEAgCD,CA7BC,kEACC,wGACD,CAEA,oCAOC,eAA4B,CAG5B,iEAAkE,CAClE,qCAAsC,CAPtC,0CAA2C,CAS3C,+BAAgC,CADhC,kCAAmC,CAVnC,iBAAkB,CADlB,eAAmB,CAKnB,+BAAgC,CAGhC,yIAA0I,CAN1I,iBAAkB,CAElB,KAAM,CAGN,0GAMD,CAGA,2HACC,gBACD,CAEA,yDAEC,mBACD,CAGD,gCACC,eACD,CAEA,iCACC,oBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-html-object-embed-unfocused-outline-width: 1px;
}

.ck-widget.html-object-embed {
	font-size: var(--ck-font-size-base);
	background-color: var(--ck-color-base-foreground);
	padding: var(--ck-spacing-small);
	/* Leave space for label */
	padding-top: calc(var(--ck-font-size-tiny) + var(--ck-spacing-large));
	min-width: calc(76px + var(--ck-spacing-standard));

	&:not(.ck-widget_selected):not(:hover) {
		outline: var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border);
	}

	&::before {
		font-weight: normal;
		font-style: normal;
		position: absolute;
		content: attr(data-html-object-embed-label);
		top: 0;
		left: var(--ck-spacing-standard);
		background: hsl(0deg 0% 60%);
		transition: background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);
		padding: calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);
		border-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);
		color: var(--ck-color-base-background);
		font-size: var(--ck-font-size-tiny);
		font-family: var(--ck-font-face);
	}

	/* Make space for label. */
	& .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before {
		margin-left: 50px;
	}

	& .html-object-embed__content {
		/* Disable user interaction with embed content */
		pointer-events: none;
	}
}

div.ck-widget.html-object-embed {
	margin: 1em auto;
}

span.ck-widget.html-object-embed {
	display: inline-block;
}

`], sourceRoot: "" }]);
      const A = b;
    }, 3508: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/image.css"], names: [], mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content {
	& .image {
		display: table;
		clear: both;
		text-align: center;

		/* Make sure there is some space between the content and the image. Center image by default. */
		/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	 	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
		margin: 0.9em auto;

		/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */
		min-width: 50px;

		& img {
			/* Prevent unnecessary margins caused by line-height (see #44). */
			display: block;

			/* Center the image if its width is smaller than the content's width. */
			margin: 0 auto;

			/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */
			max-width: 100%;

			/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */
			min-width: 100%
		}
	}

	& .image-inline {
		/*
		 * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).
		 * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.
		 * This strange behavior does not happen with inline-flex.
		 */
		display: inline-flex;

		/* While being resized, don't allow the image to exceed the width of the editing root. */
		max-width: 100%;

		/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */
		align-items: flex-start;

		/* When the picture is present it must act as a flex container to let the img resize properly */
		& picture {
			display: flex;
		}

		/* When the picture is present, it must act like a resizable img. */
		& picture,
		& img {
			/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */
			flex-grow: 1;
			flex-shrink: 1;

			/* Prevents overflowing the editing root boundaries when an inline image is very wide. */
			max-width: 100%;
		}
	}
}

.ck.ck-editor__editable {
	/*
	 * Inhertit the content styles padding of the <figcaption> in case the integration overrides \`text-align: center\`
	 * of \`.image\` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native
	 * caret does, and not at the edge of <figcaption>.
	 */
	& .image > figcaption.ck-placeholder::before {
		padding-left: inherit;
		padding-right: inherit;

		/*
		 * Make sure the image caption placeholder doesn't overflow the placeholder area.
		 * See https://github.com/ckeditor/ckeditor5/issues/9162.
		 */
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}


	/*
	 * Make sure the selected inline image always stays on top of its siblings.
	 * See https://github.com/ckeditor/ckeditor5/issues/9108.
	 */
	& .image.ck-widget_selected {
		z-index: 1;
	}

	& .image-inline.ck-widget_selected {
		z-index: 1;

		/*
		 * Make sure the native browser selection style is not displayed.
		 * Inline image widgets have their own styles for the selected state and
		 * leaving this up to the browser is asking for a visual collision.
		 */
		& ::selection {
			display: none;
		}
	}

	/* The inline image nested in the table should have its original size if not resized.
	See https://github.com/ckeditor/ckeditor5/issues/9117. */
	& td,
	& th {
		& .image-inline img {
			max-width: none;
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 2640: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imagecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-image-caption-background: hsl(0, 0%, 97%);
	--ck-color-image-caption-text: hsl(0, 0%, 20%);
	--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);
}

/* Content styles */
.ck-content .image > figcaption {
	display: table-caption;
	caption-side: bottom;
	word-break: break-word;
	color: var(--ck-color-image-caption-text);
	background-color: var(--ck-color-image-caption-background);
	padding: .6em;
	font-size: .75em;
	outline-offset: -1px;
}

/* Editing styles */
.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {
	animation: ck-image-caption-highlight .6s ease-out;
}

@keyframes ck-image-caption-highlight {
	0% {
		background-color: var(--ck-color-image-caption-highligted-background);
	}

	100% {
		background-color: var(--ck-color-image-caption-background);
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 3535: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-image-insert__panel{padding:var(--ck-spacing-large)}.ck.ck-image-insert__ck-finder-button{border:1px solid #ccc;border-radius:var(--ck-border-radius);display:block;margin:var(--ck-spacing-standard) auto;width:100%}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{border:none;margin:0;padding:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageinsert.css"], names: [], mappings: "AAKA,2BACC,+BACD,CAEA,sCAIC,qBAAiC,CACjC,qCAAsC,CAJtC,aAAc,CAEd,sCAAuC,CADvC,UAID,CAGA,oDAGC,WAAY,CADZ,QAAS,CADT,SAGD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-image-insert__panel {
	padding: var(--ck-spacing-large);
}

.ck.ck-image-insert__ck-finder-button {
	display: block;
	width: 100%;
	margin: var(--ck-spacing-standard) auto;
	border: 1px solid hsl(0, 0%, 80%);
	border-radius: var(--ck-border-radius);
}

/* https://github.com/ckeditor/ckeditor5/issues/7986 */
.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {
	padding: 0;
	margin: 0;
	border: none;
}
`], sourceRoot: "" }]);
      const A = b;
    }, 1568: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageinsertformrowview.css"], names: [], mappings: "AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-image-insert-form {
	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}
}

.ck.ck-form__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		flex-grow: 1;
	}

	&.ck-image-insert-form__action-row {
		margin-top: var(--ck-spacing-standard);

		& .ck-button-save,
		& .ck-button-cancel {
			justify-content: center;
		}

		& .ck-button .ck-button__label {
			color: var(--ck-color-text);
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 6270: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageresize.css"], names: [], mappings: "AAKA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .image.image_resized {
	max-width: 100%;
	/*
	The \`<figure>\` element for resized images must not use \`display:table\` as browsers do not support \`max-width\` for it well.
	See https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.
	Fortunately, since we control the width, there is no risk that the image will look bad.
	*/
	display: block;
	box-sizing: border-box;

	& img {
		/* For resized images it is the \`<figure>\` element that determines the image width. */
		width: 100%;
	}

	& > figcaption {
		/* The \`<figure>\` element uses \`display:block\`, so \`<figcaption>\` also has to. */
		display: block;
	}
}

.ck.ck-editor__editable {
	/* The resized inline image nested in the table should respect its parent size.
	See https://github.com/ckeditor/ckeditor5/issues/9117. */
	& td,
	& th {
		& .image-inline.image_resized img {
			max-width: 100%;
		}
	}
}

[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {
	margin-right: var(--ck-spacing-standard);
}

[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {
	margin-left: var(--ck-spacing-standard);
}

.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {
	width: 4em;
}
`], sourceRoot: "" }]);
      const A = b;
    }, 5083: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imagestyle.css"], names: [], mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-image-style-spacing: 1.5em;
	--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);
}

.ck-content {
	/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback
	confirming successful application of the style if image width exceeds the editor's size.
	See https://github.com/ckeditor/ckeditor5/issues/9342 */
	& .image-style-block-align-left,
	& .image-style-block-align-right {
		max-width: calc(100% - var(--ck-image-style-spacing));
	}

	/* Allows displaying multiple floating images in the same line.
	See https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */
	& .image-style-align-left,
	& .image-style-align-right {
		clear: none;
	}

	& .image-style-side {
		float: right;
		margin-left: var(--ck-image-style-spacing);
		max-width: 50%;
	}

	& .image-style-align-left {
		float: left;
		margin-right: var(--ck-image-style-spacing);
	}

	& .image-style-align-center {
		margin-left: auto;
		margin-right: auto;
	}

	& .image-style-align-right {
		float: right;
		margin-left: var(--ck-image-style-spacing);
	}

	& .image-style-block-align-right {
		margin-right: 0;
		margin-left: auto;
	}

	& .image-style-block-align-left {
		margin-left: 0;
		margin-right: auto;
	}

	/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */
	& p + .image-style-align-left,
	& p + .image-style-align-right,
	& p + .image-style-side {
		margin-top: 0;
	}

	& .image-inline {
		&.image-style-align-left,
		&.image-style-align-right {
			margin-top: var(--ck-inline-image-style-spacing);
			margin-bottom: var(--ck-inline-image-style-spacing);
		}

		&.image-style-align-left {
			margin-right: var(--ck-inline-image-style-spacing);
		}

		&.image-style-align-right {
			margin-left: var(--ck-inline-image-style-spacing);
		}
	}
}

.ck.ck-splitbutton {
	/* The button should display as a regular drop-down if the action button
	is forced to fire the same action as the arrow button. */
	&.ck-splitbutton_flatten {
		&:hover,
		&.ck-splitbutton_open {
			& > .ck-splitbutton__action:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {
				background-color: var(--ck-color-button-on-background);

				&::after {
					display: none;
				}
			}
		}

		&.ck-splitbutton_open:hover {
			& > .ck-splitbutton__action:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {
				background-color: var(--ck-color-button-on-hover-background);
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 4036: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadicon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"], names: [], mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-image-upload-complete-icon {
	display: block;
	position: absolute;

	/*
	 * Smaller images should have the icon closer to the border.
	 * Match the icon position with the linked image indicator brought by the link image feature.
	 */
	top: min(var(--ck-spacing-medium), 6%);
	right: min(var(--ck-spacing-medium), 6%);
	border-radius: 50%;
	z-index: 1;

	&::after {
		content: "";
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-image-upload-icon: hsl(0, 0%, 100%);
	--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);

	/* Match the icon size with the linked image indicator brought by the link image feature. */
	--ck-image-upload-icon-size: 20;
	--ck-image-upload-icon-width: 2px;
	--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);
}

.ck-image-upload-complete-icon {
	opacity: 0;
	background: var(--ck-color-image-upload-icon-background);
	animation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;
	animation-fill-mode: forwards, forwards;
	animation-duration: 500ms, 500ms;

	/* To make animation scalable. */
	font-size: calc(1px * var(--ck-image-upload-icon-size));

	/* Hide completed upload icon after 3 seconds. */
	animation-delay: 0ms, 3000ms;

	/*
	 * Use CSS math to simulate container queries.
	 * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things
	 */
	overflow: hidden;
	width: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));
	height: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));

	/* This is check icon element made from border-width mixed with animations. */
	&::after {
		/* Because of border transformation we need to "hard code" left position. */
		left: 25%;

		top: 50%;
		opacity: 0;
		height: 0;
		width: 0;

		transform: scaleX(-1) rotate(135deg);
		transform-origin: left top;
		border-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);
		border-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);

		animation-name: ck-upload-complete-icon-check;
		animation-duration: 500ms;
		animation-delay: 500ms;
		animation-fill-mode: forwards;

		/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */
		box-sizing: border-box;
	}
}

@keyframes ck-upload-complete-icon-show {
	from {
		opacity: 0;
	}

	to {
		opacity: 1;
	}
}

@keyframes ck-upload-complete-icon-hide {
	from {
		opacity: 1;
	}

	to {
		opacity: 0;
	}
}

@keyframes ck-upload-complete-icon-check {
	0% {
		opacity: 1;
		width: 0;
		height: 0;
	}
	33% {
		width: 0.3em;
		height: 0;
	}
	100% {
		opacity: 1;
		width: 0.3em;
		height: 0.45em;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 3773: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadloader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"], names: [], mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-upload-placeholder-loader {
	position: absolute;
	display: flex;
	align-items: center;
	justify-content: center;
	top: 0;
	left: 0;

	&::before {
		content: '';
		position: relative;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);
	--ck-upload-placeholder-loader-size: 32px;
	--ck-upload-placeholder-image-aspect-ratio: 2.8;
}

.ck .ck-image-upload-placeholder {
	/* We need to control the full width of the SVG gray background. */
	width: 100%;
	margin: 0;

	&.image-inline {
		width: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );
	}

	& img {
		/*
		 * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.
		 * There's nothing special about this number except that it should make the image placeholder look like
		 * a real image during this short period after the upload started and before the image was read from the
		 * file system (and a rich preview was loaded).
		 */
		aspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);
	}
}

.ck .ck-upload-placeholder-loader {
	width: 100%;
	height: 100%;

	&::before {
		width: var(--ck-upload-placeholder-loader-size);
		height: var(--ck-upload-placeholder-loader-size);
		border-radius: 50%;
		border-top: 3px solid var(--ck-color-upload-placeholder-loader);
		border-right: 2px solid transparent;
		animation: ck-upload-placeholder-loader 1s linear infinite;
	}
}

@keyframes ck-upload-placeholder-loader {
	to {
		transform: rotate( 360deg );
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 3689: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadprogress.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"], names: [], mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& .image,
	& .image-inline {
		position: relative;
	}

	/* Upload progress bar. */
	& .image .ck-progress-bar,
	& .image-inline .ck-progress-bar {
		position: absolute;
		top: 0;
		left: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& .image,
	& .image-inline {
		/* Showing animation. */
		&.ck-appear {
			animation: fadeIn 700ms;
		}
	}

	/* Upload progress bar. */
	& .image .ck-progress-bar,
	& .image-inline .ck-progress-bar {
		height: 2px;
		width: 0;
		background: var(--ck-color-upload-bar-background);
		transition: width 100ms;
	}
}

@keyframes fadeIn {
	from { opacity: 0; }
	to   { opacity: 1; }
}
`], sourceRoot: "" }]);
      const A = b;
    }, 1905: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/textalternativeform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-text-alternative-form {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;

	& .ck-labeled-field-view {
		display: inline-block;
	}

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 9773: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/link.css"], names: [], mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Class added to span element surrounding currently selected link. */
.ck .ck-link_selected {
	background: var(--ck-color-link-selected-background);

	/* Give linked inline images some outline to let the user know they are also part of the link. */
	& span.image-inline {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);
	}
}

/*
 * Classes used by the "fake visual selection" displayed in the content when an input
 * in the link UI has focus (the browser does not render the native selection in this state).
 */
.ck .ck-fake-link-selection {
	background: var(--ck-color-link-fake-selection);
}

/* A collapsed fake visual selection. */
.ck .ck-fake-link-selection_collapsed {
	height: 100%;
	border-right: 1px solid var(--ck-color-base-text);
	margin-right: -1px;
	outline: solid 1px hsla(0, 0%, 100%, .5);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 2347: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkactions.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"], names: [], mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;

	& .ck-link-actions__preview {
		display: inline-block;

		& .ck-button__label {
			overflow: hidden;
		}
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-link-actions__preview {
			flex-basis: 100%;
		}

		& .ck-button:not(.ck-link-actions__preview) {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	& .ck-button.ck-link-actions__preview {
		padding-left: 0;
		padding-right: 0;

		& .ck-button__label {
			padding: 0 var(--ck-spacing-medium);
			color: var(--ck-color-link-default);
			text-overflow: ellipsis;
			cursor: pointer;

			/* Match the box model of the link editor form's input so the balloon
			does not change width when moving between actions and the form. */
			max-width: var(--ck-input-width);
			min-width: 3em;
			text-align: center;

			&:hover {
				text-decoration: underline;
			}
		}

		&,
		&:hover,
		&:focus,
		&:active {
			background: none;
		}

		&:active {
			box-shadow: none;
		}

		&:focus {
			& .ck-button__label {
				text-decoration: underline;
			}
		}
	}

	@mixin ck-dir ltr {
		& .ck-button:not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-button:not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		& .ck-button.ck-link-actions__preview {
			margin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;

			& .ck-button__label {
				min-width: 0;
				max-width: 100%;
			}
		}

		& .ck-button:not(.ck-link-actions__preview) {
			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 7754: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"], names: [], mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-form {
	display: flex;

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}

/*
 * Style link form differently when manual decorators are available.
 * See: https://github.com/ckeditor/ckeditor5-link/issues/186.
 */
.ck.ck-link-form_layout-vertical {
	display: block;

	/*
	 * Whether the form is in the responsive mode or not, if there are decorator buttons
	 * keep the top margin of action buttons medium.
	 */
	& .ck-button {
		&.ck-button-save,
		&.ck-button-cancel {
			margin-top: var(--ck-spacing-medium);
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

/*
 * Style link form differently when manual decorators are available.
 * See: https://github.com/ckeditor/ckeditor5-link/issues/186.
 */
.ck.ck-link-form_layout-vertical {
	padding: 0;
	min-width: var(--ck-input-width);

	& .ck-labeled-field-view {
		margin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);

		& .ck-input-text {
			min-width: 0;
			width: 100%;
		}
	}

	& > .ck-button {
		padding: var(--ck-spacing-standard);
		margin: 0;
		width: 50%;
		border-radius: 0;

		&:not(:focus) {
			border-top: 1px solid var(--ck-color-base-border);
		}

		@mixin ck-dir ltr {
			margin-left: 0;
		}

		@mixin ck-dir rtl {
			margin-left: 0;

			&:last-of-type {
				border-right: 1px solid var(--ck-color-base-border);
			}
		}
	}

	/* Using additional \`.ck\` class for stronger CSS specificity than \`.ck.ck-link-form > :not(:first-child)\`. */
	& .ck.ck-list {
		margin: var(--ck-spacing-standard) var(--ck-spacing-large);

		& .ck-button.ck-switchbutton {
			padding: 0;
			width: 100%;

			&:hover {
				background: none;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 111: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}', "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkimage.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css"], names: [], mappings: "AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,83BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	/* Linked image indicator */
	& figure.image > a,
	& a span.image-inline {
		&::after {
			display: block;
			position: absolute;
		}
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Match the icon size with the upload indicator brought by the image upload feature. */
	--ck-link-image-indicator-icon-size: 20;
	--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);
}

.ck.ck-editor__editable {
	/* Linked image indicator */
	& figure.image > a,
	& a span.image-inline {
		&::after {
			content: "";

			/*
			 * Smaller images should have the icon closer to the border.
			 * Match the icon position with the upload indicator brought by the image upload feature.
			 */
			top: min(var(--ck-spacing-medium), 6%);
			right: min(var(--ck-spacing-medium), 6%);

			background-color: hsla(0, 0%, 0%, .4);
			background-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");
			background-size: 14px;
			background-repeat: no-repeat;
			background-position: center;
			border-radius: 100%;

			/*
			* Use CSS math to simulate container queries.
			* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things
			*/
			overflow: hidden;
			width: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));
			height: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));
		}
	}
}

`], sourceRoot: "" }]);
      const A = b;
    }, 4721: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:0 var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/collapsible.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/collapsible.css"], names: [], mappings: "AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,wDAAyD,CAFzD,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,yDACD,CAGC,mEACC,wBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-collapsible.ck-collapsible_collapsed {
	& > .ck-collapsible__children {
		display: none;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-collapsible {
	& > .ck.ck-button {
		width: 100%;
		font-weight: bold;
		padding: var(--ck-spacing-medium) var(--ck-spacing-large);
		border-radius: 0;
		color: inherit;

		&:focus {
			background: transparent;
		}

		&:active, &:not(:focus), &:hover:not(:focus) {
			background: transparent;
			border-color: transparent;
			box-shadow: none;
		}

		& > .ck-icon {
			margin-right: var(--ck-spacing-medium);
			width: var(--ck-collapsible-arrow-size);
		}
	}

	& > .ck-collapsible__children {
		padding: 0 var(--ck-spacing-large) var(--ck-spacing-large);
	}

	&.ck-collapsible_collapsed {
		& > .ck.ck-button .ck-icon {
			transform: rotate(-90deg);
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 5730: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck-editor__editable .ck-list-bogus-paragraph{display:block}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/documentlist.css"], names: [], mappings: "AAKA,8CACC,aACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-editor__editable .ck-list-bogus-paragraph {
	display: block;
}
`], sourceRoot: "" }]);
      const A = b;
    }, 4564: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/list.css"], names: [], mappings: "AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content ol {
	list-style-type: decimal;

	& ol {
		list-style-type: lower-latin;

		& ol {
			list-style-type: lower-roman;

			& ol {
				list-style-type: upper-latin;

				& ol {
					list-style-type: upper-roman;
				}
			}
		}
	}
}

.ck-content ul {
	list-style-type: disc;

	& ul {
		list-style-type: circle;

		& ul {
			list-style-type: square;

			& ul {
				list-style-type: square;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 6082: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css"], names: [], mappings: "AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-list-properties {
	/* When there are no list styles and there is no collapsible. */
	&.ck-list-properties_without-styles {
		padding: var(--ck-spacing-large);

		& > * {
			min-width: 14em;

			& + * {
				margin-top: var(--ck-spacing-standard);
			}
		}
	}

	/*
	 * When the numbered list property fields (start at, reversed) should be displayed,
	 * more horizontal space is needed. Reconfigure the style grid to create that space.
	 */
	&.ck-list-properties_with-numbered-properties {
		& > .ck-list-styles-list {
			grid-template-columns: repeat( 4, auto );
		}

		/* When list styles are rendered and property fields are in a collapsible. */
		& > .ck-collapsible {
			border-top: 1px solid var(--ck-color-base-border);

			& > .ck-collapsible__children {
				& > * {
					width: 100%;

					& + * {
						margin-top: var(--ck-spacing-standard);
					}
				}
			}
		}
	}

	& .ck.ck-numbered-list-properties__start-index .ck-input {
		min-width: auto;
		width: 100%;
	}

	& .ck.ck-numbered-list-properties__reversed-order {
		background: transparent;
		padding-left: 0;
		padding-right: 0;
		margin-bottom: calc(-1 * var(--ck-spacing-tiny));

		&:active, &:hover {
			box-shadow: none;
			border-color: transparent;
			background: none;
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 2417: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-list-styles-list{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/liststyles.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"], names: [], mappings: "AAKA,wBACC,YACD,CCFA,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-list-styles-list {
	display: grid;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-list-style-button-size: 44px;
}

.ck.ck-list-styles-list {
	grid-template-columns: repeat( 3, auto );
	row-gap: var(--ck-spacing-medium);
	column-gap: var(--ck-spacing-medium);
	padding: var(--ck-spacing-large);

	& .ck-button {
		/* Make the button look like a thumbnail (the icon "takes it all"). */
		width: var(--ck-list-style-button-size);
		height: var(--ck-list-style-button-size);
		padding: 0;

		/*
		 * Buttons are aligned by the grid so disable default button margins to not collide with the
		 * gaps in the grid.
		 */
		margin: 0;

		/*
		 * Make sure the button border (which is displayed on focus, BTW) does not steal pixels
		 * from the button dimensions and, as a result, decrease the size of the icon
		 * (which becomes blurry as it scales down).
		 */
		box-sizing: content-box;

		& .ck-icon {
			width: var(--ck-list-style-button-size);
			height: var(--ck-list-style-button-size);
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 1199: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-content .todo-list .todo-list__label>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out,background .25s ease-in-out,border .25s ease-in-out;width:100%}.ck-content .todo-list .todo-list__label>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-editor__editable .todo-list .todo-list__label>input{cursor:pointer}.ck-editor__editable .todo-list .todo-list__label>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}', "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/todolist.css"], names: [], mappings: "AAKA,MACC,kCACD,CAEA,uBACC,eA0ED,CAxEC,0BACC,iBAKD,CAHC,qCACC,cACD,CAIA,+CACC,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAqDD,CAxCC,sDAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,0FAAgG,CAJhG,UAKD,CAEA,qDAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAIF,wEACC,qBACD,CAKF,6CACC,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAED,CAMA,wDACC,cAKD,CAHC,qEACC,mCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-todo-list-checkmark-size: 16px;
}

.ck-content .todo-list {
	list-style: none;

	& li {
		margin-bottom: 5px;

		& .todo-list {
			margin-top: 5px;
		}
	}

	& .todo-list__label {
		& > input {
			-webkit-appearance: none;
			display: inline-block;
			position: relative;
			width: var(--ck-todo-list-checkmark-size);
			height: var(--ck-todo-list-checkmark-size);
			vertical-align: middle;

			/* Needed on iOS */
			border: 0;

			/* LTR styles */
			left: -25px;
			margin-right: -15px;
			right: 0;
			margin-left: 0;

			&::before {
				display: block;
				position: absolute;
				box-sizing: border-box;
				content: '';
				width: 100%;
				height: 100%;
				border: 1px solid hsl(0, 0%, 20%);
				border-radius: 2px;
				transition: 250ms ease-in-out box-shadow, 250ms ease-in-out background, 250ms ease-in-out border;
			}

			&::after {
				display: block;
				position: absolute;
				box-sizing: content-box;
				pointer-events: none;
				content: '';

				/* Calculate tick position, size and border-width proportional to the checkmark size. */
				left: calc( var(--ck-todo-list-checkmark-size) / 3 );
				top: calc( var(--ck-todo-list-checkmark-size) / 5.3 );
				width: calc( var(--ck-todo-list-checkmark-size) / 5.3 );
				height: calc( var(--ck-todo-list-checkmark-size) / 2.6 );
				border-style: solid;
				border-color: transparent;
				border-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;
				transform: rotate(45deg);
			}

			&[checked] {
				&::before {
					background: hsl(126, 64%, 41%);
					border-color: hsl(126, 64%, 41%);
				}

				&::after {
					border-color: hsl(0, 0%, 100%);
				}
			}
		}

		& .todo-list__label__description {
			vertical-align: middle;
		}
	}
}

/* RTL styles */
[dir="rtl"] .todo-list .todo-list__label > input {
	left: 0;
	margin-right: 0;
	right: -25px;
	margin-left: -15px;
}

/*
 * To-do list should be interactive only during the editing
 * (https://github.com/ckeditor/ckeditor5/issues/2090).
 */
.ck-editor__editable .todo-list .todo-list__label > input {
	cursor: pointer;

	&:hover::before {
		box-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 2896: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, '.ck-source-editing-area{overflow:hidden;position:relative}.ck-source-editing-area textarea,.ck-source-editing-area:after{border:1px solid transparent;font-family:monospace;font-size:var(--ck-font-size-normal);line-height:var(--ck-line-height-base);margin:0;padding:var(--ck-spacing-large);white-space:pre-wrap}.ck-source-editing-area:after{content:attr(data-value) " ";display:block;visibility:hidden}.ck-source-editing-area textarea{border-color:var(--ck-color-base-border);border-radius:0;box-sizing:border-box;height:100%;outline:none;overflow:hidden;position:absolute;resize:none;width:100%}.ck-rounded-corners .ck-source-editing-area textarea,.ck-source-editing-area textarea.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck-source-editing-area textarea:not([readonly]):focus{border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}', "", { version: 3, sources: ["webpack://./../ckeditor5-source-editing/theme/sourceediting.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,wBAEC,eAAgB,CADhB,iBAED,CAEA,+DAIC,4BAA6B,CAG7B,qBAAsB,CADtB,oCAAqC,CADrC,sCAAuC,CAFvC,QAAS,CADT,+BAAgC,CAMhC,oBACD,CAEA,8BACC,4BAA6B,CAE7B,aAAc,CADd,iBAED,CAEA,iCASC,wCAAyC,CC7BzC,eAAgB,CD2BhB,qBAAsB,CAJtB,WAAY,CAEZ,YAAa,CACb,eAAgB,CALhB,iBAAkB,CAGlB,WAAY,CAFZ,UAkBD,CApBA,yGChBE,qCAAsC,CD4BtC,wBAAyB,CACzB,yBAOF,CAJC,uDEpCA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFwCA", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";
@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css";
@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";

.ck-source-editing-area {
	position: relative;
	overflow: hidden;
}

.ck-source-editing-area::after,
.ck-source-editing-area textarea {
	padding: var(--ck-spacing-large);
	margin: 0;
	border: 1px solid transparent;
	line-height: var(--ck-line-height-base);
	font-size: var(--ck-font-size-normal);
	font-family: monospace;
	white-space: pre-wrap;
}

.ck-source-editing-area::after {
	content: attr(data-value) " ";
	visibility: hidden;
	display: block;
}

.ck-source-editing-area textarea {
	position: absolute;
	width: 100%;
	height: 100%;
	resize: none;
	outline: none;
	overflow: hidden;
	box-sizing: border-box;

	border-color: var(--ck-color-base-border);

	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	&:not([readonly]):focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 7368: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-input-color {
	width: 100%;
	display: flex;
	flex-direction: row-reverse;

	& > input.ck.ck-input-text {
		min-width: auto;
		flex-grow: 1;
	}

	& > div.ck.ck-dropdown {
		min-width: auto;

		/* This dropdown has no arrow but a color preview instead. */
		& > .ck-input-color__button .ck-dropdown__arrow {
			display: none;
		}
	}

	& .ck.ck-input-color__button {
		/* Resolving issue with misaligned buttons on Safari (see #10589) */
		display: flex;

		& .ck.ck-input-color__button__preview {
			position: relative;
			overflow: hidden;

			& > .ck.ck-input-color__button__preview__no-color-indicator {
				position: absolute;
				display: block;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_rounded.css";

.ck.ck-input-color {
	& > .ck.ck-input-text {
		@mixin ck-dir ltr {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		@mixin ck-dir rtl {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* Make sure the focused input is always on top of the dropdown button so its
		   outline and border are never cropped (also when the input is read-only). */
		&:focus {
			z-index: 0;
		}
	}

	& > .ck.ck-dropdown {
		& > .ck.ck-button.ck-input-color__button {
			padding: 0;

			@mixin ck-dir ltr {
				border-top-left-radius: 0;
				border-bottom-left-radius: 0;

				&:not(:focus) {
					border-left: 1px solid transparent;
				}
			}

			@mixin ck-dir rtl {
				border-top-right-radius: 0;
				border-bottom-right-radius: 0;

				&:not(:focus) {
					border-right: 1px solid transparent;
				}
			}

			&.ck-disabled {
				background: var(--ck-color-input-disabled-background);
			}

			& > .ck.ck-input-color__button__preview {
				@mixin ck-rounded-corners;

				width: 20px;
				height: 20px;
				border: 1px solid var(--ck-color-input-border);

				& > .ck.ck-input-color__button__preview__no-color-indicator {
					top: -30%;
					left: 50%;
					height: 150%;
					width: 8%;
					background: hsl(0, 100%, 50%);
					border-radius: 2px;
					transform: rotate(45deg);
					transform-origin: 50%;
				}
			}
		}
	}

	& .ck.ck-input-color__remove-color {
		width: 100%;
		padding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);

		border-bottom-left-radius: 0;
		border-bottom-right-radius: 0;

		&:not(:focus) {
			border-bottom: 1px solid var(--ck-color-input-border);
		}

		@mixin ck-dir ltr {
			border-top-right-radius: 0;
		}

		@mixin ck-dir rtl {
			border-top-left-radius: 0;
		}

		& .ck.ck-icon {
			margin-right: var(--ck-spacing-standard);

			@mixin ck-dir rtl {
				margin-right: 0;
				margin-left: var(--ck-spacing-standard);
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 4070: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/form.css"], names: [], mappings: "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form {
	padding: 0 0 var(--ck-spacing-large);

	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}

	& .ck.ck-input-text {
		min-width: 100%;
		width: 0;
	}

	& .ck.ck-dropdown {
		min-width: 100%;

		& .ck-dropdown__button {
			&:not(:focus) {
				border: 1px solid var(--ck-color-base-border);
			}

			& .ck-button__label {
				width: 100%;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 9247: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/formrow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css"], names: [], mappings: "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		flex-grow: 1;
	}

	&.ck-table-form__action-row {
		& .ck-button-save,
		& .ck-button-cancel {
			justify-content: center;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-form__row {
	padding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		& + * {
			@mixin ck-dir ltr {
				margin-left: var(--ck-spacing-large);
			}

			@mixin ck-dir rtl {
				margin-right: var(--ck-spacing-large);
			}
		}
	}

	& > .ck-label {
		width: 100%;
		min-width: 100%;
	}

	&.ck-table-form__action-row {
		margin-top: var(--ck-spacing-large);

		& .ck-button .ck-button__label {
			color: var(--ck-color-text);
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 1613: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/inserttable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"], names: [], mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-insert-table-dropdown__grid {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-insert-table-dropdown-padding: 10px;
	--ck-insert-table-dropdown-box-height: 11px;
	--ck-insert-table-dropdown-box-width: 12px;
	--ck-insert-table-dropdown-box-margin: 1px;
}

.ck .ck-insert-table-dropdown__grid {
	/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */
	width: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);
	padding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;
}

.ck .ck-insert-table-dropdown__label,
.ck[dir=rtl] .ck-insert-table-dropdown__label {
	text-align: center;
}

.ck .ck-insert-table-dropdown-grid-box {
	min-width: var(--ck-insert-table-dropdown-box-width);
	min-height: var(--ck-insert-table-dropdown-box-height);
	margin: var(--ck-insert-table-dropdown-box-margin);
	border: 1px solid var(--ck-color-base-border);
	border-radius: 1px;
	outline: none;
	transition: none;

	&:focus {
		box-shadow: none;
	}

	&.ck-on {
		border-color: var(--ck-color-focus-border);
		background: var(--ck-color-focus-outer-shadow);
	}
}

`], sourceRoot: "" }]);
      const A = b;
    }, 6306: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/table.css"], names: [], mappings: "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .table {
	/* Give the table widget some air and center it horizontally */
	/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
	margin: 0.9em auto;
	display: table;

	& table {
		/* The table cells should have slight borders */
		border-collapse: collapse;
		border-spacing: 0;

		/* Table width and height are set on the parent <figure>. Make sure the table inside stretches
		to the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */
		width: 100%;
		height: 100%;

		/* The outer border of the table should be slightly darker than the inner lines.
		Also see https://github.com/ckeditor/ckeditor5-table/issues/50. */
		border: 1px double hsl(0, 0%, 70%);

		& td,
		& th {
			min-width: 2em;
			padding: .4em;

			/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it's not necessary here.
			However, the border is a content style, so it should use .ck-content (so it works outside the editor).
			Hence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */
			border: 1px solid hsl(0, 0%, 75%);
		}

		& th {
			font-weight: bold;
			background: hsla(0, 0%, 0%, 5%);
		}
	}
}

/* Text alignment of the table header should match the editor settings and override the native browser styling,
when content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */
.ck-content[dir="rtl"] .table th {
	text-align: right;
}

.ck-content[dir="ltr"] .table th {
	text-align: left;
}

.ck-editor__editable .ck-table-bogus-paragraph {
	/*
	 * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.
	 * See https://github.com/ckeditor/ckeditor5/issues/6062.
	 */
	display: inline-block;

	/*
	 * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.
	 * See https://github.com/ckeditor/ckeditor5/issues/9117.
	 */
	width: 100%;
}
`], sourceRoot: "" }]);
      const A = b;
    }, 2128: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ":root{--ck-color-table-caption-background:#f7f7f7;--ck-color-table-caption-text:#333;--ck-color-table-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-table-caption-background);caption-side:top;color:var(--ck-color-table-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-table-caption-highlighted-background)}to{background-color:var(--ck-color-table-caption-background)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,oDACD,CAGA,8BAMC,yDAA0D,CAJ1D,gBAAiB,CAGjB,wCAAyC,CAJzC,qBAAsB,CAOtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,iBAAkB,CADlB,qBAOD,CAIC,qEACC,iDACD,CAEA,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAGD,sCACC,GACC,qEACD,CAEA,GACC,yDACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-table-caption-background: hsl(0, 0%, 97%);
	--ck-color-table-caption-text: hsl(0, 0%, 20%);
	--ck-color-table-caption-highlighted-background: hsl(52deg 100% 50%);
}

/* Content styles */
.ck-content .table > figcaption {
	display: table-caption;
	caption-side: top;
	word-break: break-word;
	text-align: center;
	color: var(--ck-color-table-caption-text);
	background-color: var(--ck-color-table-caption-background);
	padding: .6em;
	font-size: .75em;
	outline-offset: -1px;
}

/* Editing styles */
.ck.ck-editor__editable .table > figcaption {
	&.table__caption_highlighted {
		animation: ck-table-caption-highlight .6s ease-out;
	}

	&.ck-placeholder::before {
		padding-left: inherit;
		padding-right: inherit;

		/*
		 * Make sure the table caption placeholder doesn't overflow the placeholder area.
		 * See https://github.com/ckeditor/ckeditor5/issues/9162.
		 */
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}
}

@keyframes ck-table-caption-highlight {
	0% {
		background-color: var(--ck-color-table-caption-highlighted-background);
	}

	100% {
		background-color: var(--ck-color-table-caption-background);
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 5087: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecellproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css"], names: [], mappings: "AAOE,6FACC,cAiBD,CAdE,0HAEC,cACD,CAEA,yHAEC,cACD,CAEA,uHACC,WACD,CClBJ,kCACC,WAkBD,CAfE,2FACC,mBAAoB,CACpB,SAAU,CACV,SACD,CAGC,4GACC,eAAgB,CAGhB,qCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-cell-properties-form {
	& .ck-form__row {
		&.ck-table-cell-properties-form__alignment-row {
			flex-wrap: wrap;

			& .ck.ck-toolbar {
				&:first-of-type {
					/* 4 buttons out of 7 (h-alignment + v-alignment) = 0.57 */
					flex-grow: 0.57;
				}

				&:last-of-type {
					/* 3 buttons out of 7 (h-alignment + v-alignment) = 0.43 */
					flex-grow: 0.43;
				}

				& .ck-button {
					flex-grow: 1;
				}
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-cell-properties-form {
	width: 320px;

	& .ck-form__row {
		&.ck-table-cell-properties-form__padding-row {
			align-self: flex-end;
			padding: 0;
			width: 25%;
		}

		&.ck-table-cell-properties-form__alignment-row {
			& .ck.ck-toolbar {
				background: none;

				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */
				margin-top: var(--ck-spacing-standard);
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 4101: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ":root{--ck-color-table-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:-999999px;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:-999999px;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-table-column-resizer-hover);opacity:.25}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecolumnresize.css"], names: [], mappings: "AAKA,MACC,iEAAkE,CAClE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAEC,iBACD,CAEA,wDAOC,gBAAiB,CAGjB,iBAAkB,CATlB,iBAAkB,CAOlB,oDAAqD,CAFrD,aAAc,CAKd,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,2DAA4D,CAC5D,WACD,CAEA,iEACC,mDAAoD,CACpD,WACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-table-column-resizer-hover: var(--ck-color-base-active);
	--ck-table-column-resizer-width: 7px;

	/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.
	   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */
	--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);
}

.ck-content .table .ck-table-resized {
	table-layout: fixed;
}

.ck-content .table table {
	overflow: hidden;
}

.ck-content .table td,
.ck-content .table th {
	position: relative;
}

.ck.ck-editor__editable .table .ck-table-column-resizer {
	position: absolute;
	/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,
	   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as
	   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally
	   unrealistic height for a single table. */
	top: -999999px;
	bottom: -999999px;
	right: var(--ck-table-column-resizer-position-offset);
	width: var(--ck-table-column-resizer-width);
	cursor: col-resize;
	user-select: none;
	z-index: var(--ck-z-default);
}

.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {
	display: none;
}

/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,
   all resizers must be hidden while the table is dragged. */
.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {
	display: none;
}

.ck.ck-editor__editable .table .ck-table-column-resizer:hover,
.ck.ck-editor__editable .table .ck-table-column-resizer__active {
	background-color: var(--ck-color-table-column-resizer-hover);
	opacity: 0.25;
}

.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {
	left: var(--ck-table-column-resizer-position-offset);
	right: unset;
}
`], sourceRoot: "" }]);
      const A = b;
    }, 3881: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ":root{--ck-color-table-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"], names: [], mappings: "AAKA,MACC,6DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-table-focused-cell-background: hsla(212, 90%, 80%, .3);
}

.ck-widget.table {
	& td,
	& th {
		&.ck-editor__nested-editable.ck-editor__nested-editable_focused,
		&.ck-editor__nested-editable:focus {
			/* A very slight background to highlight the focused cell */
			background: var(--ck-color-table-focused-cell-background);

			/* Fixes the problem where surrounding cells cover the focused cell's border.
			It does not fix the problem in all places but the UX is improved.
			See https://github.com/ckeditor/ckeditor5-table/issues/29. */
			border-style: none;
			outline: 1px solid var(--ck-color-focus-border);
			outline-offset: -1px; /* progressive enhancement - no IE support */
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 6237: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCAyBD,CAvBC,8ECxCD,eDyDC,CAjBA,mMCpCA,qCDqDA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAUD,CAPC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-form {
	& .ck-form__row {
		&.ck-table-form__border-row {
			flex-wrap: wrap;
		}

		&.ck-table-form__background-row {
			flex-wrap: wrap;
		}

		&.ck-table-form__dimensions-row {
			flex-wrap: wrap;
			align-items: center;

			& .ck-labeled-field-view {
				display: flex;
				flex-direction: column-reverse;
				align-items: center;

				& .ck.ck-dropdown {
					flex-grow: 0;
				}
			}

			& .ck-table-form__dimension-operator {
				flex-grow: 0;
			}
		}
	}

	& .ck.ck-labeled-field-view {
		/* Allow absolute positioning of the status (error) balloons. */
		position: relative;

		& .ck.ck-labeled-field-view__status {
			position: absolute;
			left: 50%;
			bottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );
			transform: translate(-50%,100%);

			/* Make sure the balloon status stays on top of other form elements. */
			z-index: 1;

			/* The arrow pointing towards the field. */
			&::after {
				content: "";
				position: absolute;
				top: calc( -1 * var(--ck-table-properties-error-arrow-size) );
				left: 50%;
				transform: translateX( -50% );
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

:root {
	--ck-table-properties-error-arrow-size: 6px;
	--ck-table-properties-min-error-width: 150px;
}

.ck.ck-table-form {
	& .ck-form__row {
		&.ck-table-form__border-row {
			& .ck-labeled-field-view {
				& > .ck-label {
					font-size: var(--ck-font-size-tiny);
					text-align: center;
				}
			}

			& .ck-table-form__border-style,
			& .ck-table-form__border-width {
				width: 80px;
				min-width: 80px;
				max-width: 80px;
			}
		}

		&.ck-table-form__dimensions-row {
			padding: 0;

			& .ck-table-form__dimensions-row__width,
			& .ck-table-form__dimensions-row__height {
				margin: 0
			}

			& .ck-table-form__dimension-operator {
				align-self: flex-end;
				display: inline-block;
				height: var(--ck-ui-component-min-height);
				line-height: var(--ck-ui-component-min-height);
				margin: 0 var(--ck-spacing-small);
			}
		}
	}

	& .ck.ck-labeled-field-view {
		padding-top: var(--ck-spacing-standard);

		& .ck.ck-labeled-field-view__status {
			@mixin ck-rounded-corners;

			background: var(--ck-color-base-error);
			color: var(--ck-color-base-background);
			padding: var(--ck-spacing-small) var(--ck-spacing-medium);
			min-width: var(--ck-table-properties-min-error-width);
			text-align: center;

			/* The arrow pointing towards the field. */
			&::after {
				border-color: transparent transparent var(--ck-color-base-error) transparent;
				border-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);
				border-style: solid;
			}

			animation: ck-table-form-labeled-view-status-appear .15s ease both;
		}

		/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */
		& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {
			display: none;
		}
	}
}

@keyframes ck-table-form-labeled-view-status-appear {
	0% {
		opacity: 0;
	}

	100% {
		opacity: 1;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 7341: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tableproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css"], names: [], mappings: "AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-properties-form {
	& .ck-form__row {
		&.ck-table-properties-form__alignment-row {
			flex-wrap: wrap;
			flex-basis: 0;
			align-content: baseline;

			& .ck.ck-toolbar .ck-toolbar__items {
				flex-wrap: nowrap;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-properties-form {
	width: 320px;

	& .ck-form__row {
		&.ck-table-properties-form__alignment-row {
			align-self: flex-end;
			padding: 0;

			& .ck.ck-toolbar {
				background: none;

				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */
				margin-top: var(--ck-spacing-standard);

				& .ck-toolbar__items > * {
					width: 40px;
				}
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 6945: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"], names: [], mappings: "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);
}

.ck.ck-editor__editable .table table {
	& td.ck-editor__editable_selected,
	& th.ck-editor__editable_selected {
		position: relative;
		caret-color: transparent;
		outline: unset;
		box-shadow: unset;

		/* https://github.com/ckeditor/ckeditor5/issues/6446 */
		&:after {
			content: '';
			pointer-events: none;
			background-color: var(--ck-table-selected-cell-background);
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
		}

		& ::selection,
		&:focus {
			background-color: transparent;
		}

		/*
		 * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.
		 * See https://github.com/ckeditor/ckeditor5/issues/9491.
		 */
		& .ck-widget {
			outline: unset;

			& > .ck-widget__selection-handle {
				display: none;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 4906: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/button/button.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-unselectable;

	position: relative;
	display: inline-flex;
	align-items: center;
	justify-content: left;

	& .ck-button__label {
		display: none;
	}

	&.ck-button_with-text {
		& .ck-button__label {
			display: inline-block;
		}
	}

	/* Center the icon horizontally in a button without text. */
	&:not(.ck-button_with-text)  {
		justify-content: center;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../mixins/_button.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-button-colors --ck-color-button-default;
	@mixin ck-rounded-corners;

	white-space: nowrap;
	cursor: default;
	vertical-align: middle;
	padding: var(--ck-spacing-tiny);
	text-align: center;

	/* A very important piece of styling. Go to variable declaration to learn more. */
	min-width: var(--ck-ui-component-min-height);
	min-height: var(--ck-ui-component-min-height);

	/* Normalize the height of the line. Removing this will break consistent height
	among text and text-less buttons (with icons). */
	line-height: 1;

	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	/* Avoid flickering when the foucs border shows up. */
	border: 1px solid transparent;

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .2s ease-in-out, border .2s ease-in-out;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */
	-webkit-appearance: none;

	&:active,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	/* Allow icon coloring using the text "color" property. */
	& .ck-button__icon {
		& use,
		& use * {
			color: inherit;
		}
	}

	& .ck-button__label {
		/* Enable font size inheritance, which allows fluid UI scaling. */
		font-size: inherit;
		font-weight: inherit;
		color: inherit;
		cursor: inherit;

		/* Must be consistent with .ck-icon's vertical align. Otherwise, buttons with and
		without labels (but with icons) have different sizes in Chrome */
		vertical-align: middle;

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}
	}

	& .ck-button__keystroke {
		color: inherit;

		@mixin ck-dir ltr {
			margin-left: var(--ck-spacing-large);
		}

		@mixin ck-dir rtl {
			margin-right: var(--ck-spacing-large);
		}

		font-weight: bold;
		opacity: .7;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
	&.ck-disabled {
		&:active,
		&:focus {
			/* The disabled button should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}

		& .ck-button__icon {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
		& .ck-button__label {
			@mixin ck-disabled;
		}

		& .ck-button__keystroke {
			opacity: .3;
		}
	}

	&.ck-button_with-text {
		padding: var(--ck-spacing-tiny) var(--ck-spacing-standard);

		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__icon {
			@mixin ck-dir ltr {
				margin-left: calc(-1 * var(--ck-spacing-small));
				margin-right: var(--ck-spacing-small);
			}

			@mixin ck-dir rtl {
				margin-right: calc(-1 * var(--ck-spacing-small));
				margin-left: var(--ck-spacing-small);
			}
		}
	}

	&.ck-button_with-keystroke {
		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__label {
			flex-grow: 1;
		}
	}

	/* A style of the button which is currently on, e.g. its feature is active. */
	&.ck-on {
		@mixin ck-button-colors --ck-color-button-on;

		color: var(--ck-color-button-on-color);
	}

	&.ck-button-save {
		color: var(--ck-color-button-save);
	}

	&.ck-button-cancel {
		color: var(--ck-color-button-cancel);
	}
}

/* A style of the button which handles the primary action. */
.ck.ck-button-action,
a.ck.ck-button-action {
	@mixin ck-button-colors --ck-color-button-action;

	color: var(--ck-color-button-action-text);
}

.ck.ck-button-bold,
a.ck.ck-button-bold {
	font-weight: bold;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements a button of given background color.
 *
 * @param {String} $background - Background color of the button.
 * @param {String} $border - Border color of the button.
 */
@define-mixin ck-button-colors $prefix {
	background: var($(prefix)-background);

	&:not(.ck-disabled) {
		&:hover {
			background: var($(prefix)-hover-background);
		}

		&:active {
			background: var($(prefix)-active-background);
		}
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
	&.ck-disabled {
		background: var($(prefix)-disabled-background);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 6758: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-button.ck-switchbutton {
	& .ck-button__toggle {
		display: block;

		& .ck-button__toggle__inner {
			display: block;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature
of the component, floating–point numbers have been used which, for the default font size
(see: --ck-font-size-base), will generate simple integers. */
:root {
	/* 34px at 13px font-size */
	--ck-switch-button-toggle-width: 2.6153846154em;
	/* 14px at 13px font-size */
	--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);
	--ck-switch-button-translation: calc(
		var(--ck-switch-button-toggle-width) -
		var(--ck-switch-button-toggle-inner-size) -
		2px /* Border */
	);
	--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);
}

.ck.ck-button.ck-switchbutton {
	/* Unlike a regular button, the switch button text color and background should never change.
	 * Changing toggle switch (background, outline) is enough to carry the information about the
	 * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)
	 */
	&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {
		color: inherit;
		background: transparent;
	}

	& .ck-button__label {
		@mixin ck-dir ltr {
			/* Separate the label from the switch */
			margin-right: calc(2 * var(--ck-spacing-large));
		}

		@mixin ck-dir rtl {
			/* Separate the label from the switch */
			margin-left: calc(2 * var(--ck-spacing-large));
		}
	}

	& .ck-button__toggle {
		@mixin ck-rounded-corners;

		@mixin ck-dir ltr {
			/* Make sure the toggle is always to the right as far as possible. */
			margin-left: auto;
		}

		@mixin ck-dir rtl {
			/* Make sure the toggle is always to the left as far as possible. */
			margin-right: auto;
		}

		/* Apply some smooth transition to the box-shadow and border. */
		/* Gently animate the background color of the toggle switch */
		transition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;
		border: 1px solid transparent;
		width: var(--ck-switch-button-toggle-width);
		background: var(--ck-color-switch-button-off-background);

		& .ck-button__toggle__inner {
			@mixin ck-rounded-corners {
				border-radius: calc(.5 * var(--ck-border-radius));
			}

			width: var(--ck-switch-button-toggle-inner-size);
			height: var(--ck-switch-button-toggle-inner-size);
			background: var(--ck-color-switch-button-inner-background);

			/* Gently animate the inner part of the toggle switch */
			transition: all 300ms ease;
		}

		&:hover {
			background: var(--ck-color-switch-button-off-hover-background);

			& .ck-button__toggle__inner {
				box-shadow: var(--ck-switch-button-inner-hover-shadow);
			}
		}
	}

	&.ck-disabled .ck-button__toggle {
		@mixin ck-disabled;
	}

	/* Overriding default .ck-button:focus styles + an outline around the toogle */
	&:focus {
		border-color: transparent;
		outline: none;
		box-shadow: none;

		& .ck-button__toggle {
			box-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);
			outline-offset: 1px;
			outline: var(--ck-focus-ring);
		}
	}

	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-on {
		& .ck-button__toggle {
			background: var(--ck-color-switch-button-on-background);

			&:hover {
				background: var(--ck-color-switch-button-on-hover-background);
			}

			& .ck-button__toggle__inner {
				/*
				* Move the toggle switch to the right. It will be animated.
				*/
				@mixin ck-dir ltr {
					transform: translateX( var( --ck-switch-button-translation ) );
				}

				@mixin ck-dir rtl {
					transform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );
				}
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 6781: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"], names: [], mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-color-grid {
	display: grid;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-grid-tile-size: 24px;

	/* Not using global colors here because these may change but some colors in a pallette
	 * require special treatment. For instance, this ensures no matter what the UI text color is,
	 * the check icon will look good on the black color tile. */
	--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);
}

.ck.ck-color-grid {
	grid-gap: 5px;
	padding: 8px;
}

.ck.ck-color-grid__tile {
	width: var(--ck-color-grid-tile-size);
	height: var(--ck-color-grid-tile-size);
	min-width: var(--ck-color-grid-tile-size);
	min-height: var(--ck-color-grid-tile-size);
	padding: 0;
	transition: .2s ease box-shadow;
	border: 0;

	&.ck-disabled {
		cursor: unset;
		transition: unset;
	}

	&.ck-color-table__color-tile_bordered {
		box-shadow: 0 0 0 1px var(--ck-color-base-border);
	}

	& .ck.ck-icon {
		display: none;
		color: var(--ck-color-color-grid-check-icon);
	}

	&.ck-on {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);

		& .ck.ck-icon {
			display: block;
		}
	}

	&.ck-on,
	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		/* Disable the default .ck-button's border ring. */
		border: 0;
	}

	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);
	}
}

.ck.ck-color-grid__label {
	padding: 0 var(--ck-spacing-standard);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 3398: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-input{min-width:unset}.color-picker-hex-input{width:max-content}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/colorpicker/colorpicker.css"], names: [], mappings: "AAKA,aACC,eACD,CAEA,wBACC,iBACD,CAEA,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAMD,CAJC,qDAEC,sCAAuC,CADvC,kCAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-input {
	min-width: unset;
}

.color-picker-hex-input {
	width: max-content;
}

.ck.ck-color-picker__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;

	& .ck-color-picker__hash-view {
		padding-top: var(--ck-spacing-tiny);
		padding-right: var(--ck-spacing-medium);
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 5485: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-dropdown-max-width: 75vw;
}

.ck.ck-dropdown {
	display: inline-block;
	position: relative;

	& .ck-dropdown__arrow {
		pointer-events: none;
		z-index: var(--ck-z-default);
	}

	/* Dropdown button should span horizontally, e.g. in vertical toolbars */
	& .ck-button.ck-dropdown__button {
		width: 100%;
	}

	& .ck-dropdown__panel {
		display: none;
		z-index: var(--ck-z-modal);
		max-width: var(--ck-dropdown-max-width);

		position: absolute;

		&.ck-dropdown__panel-visible {
			display: inline-block;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_n,
		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_nme {
			bottom: 100%;
		}

		&.ck-dropdown__panel_se,
		&.ck-dropdown__panel_sw,
		&.ck-dropdown__panel_smw,
		&.ck-dropdown__panel_sme,
		&.ck-dropdown__panel_s {
			/*
			 * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.
			 * See https://github.com/ckeditor/ckeditor5/issues/1053.
			 */
			top: 100%;
			bottom: auto;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_se {
			left: 0px;
		}

		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_sw {
			right: 0px;
		}

		&.ck-dropdown__panel_s,
		&.ck-dropdown__panel_n {
			/* Positioning panels relative to the center of the button */
			left: 50%;
			transform: translateX(-50%);
		}

		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_smw {
			/* Positioning panels relative to the middle-west of the button */
			left: 75%;
			transform: translateX(-75%);
		}

		&.ck-dropdown__panel_nme,
		&.ck-dropdown__panel_sme {
			/* Positioning panels relative to the middle-east of the button */
			left: 25%;
			transform: translateX(-25%);
		}
	}
}

/*
 * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.
 * See https://github.com/ckeditor/ckeditor5/issues/7874
 */
.ck.ck-toolbar .ck-dropdown__panel {
	z-index: calc( var(--ck-z-modal) + 1 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-dropdown {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-dropdown__arrow {
		width: var(--ck-dropdown-arrow-size);
	}

	@mixin ck-dir ltr {
		& .ck-dropdown__arrow {
			right: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-dropdown__arrow {
			left: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-right: var(--ck-spacing-small);
		}
	}

	&.ck-disabled .ck-dropdown__arrow {
		@mixin ck-disabled;
	}

	& .ck-button.ck-dropdown__button {
		@mixin ck-dir ltr {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-left: var(--ck-spacing-small);
			}
		}

		@mixin ck-dir rtl {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-right: var(--ck-spacing-small);
			}
		}

		/* #23 */
		& .ck-button__label {
			width: 7em;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
		&.ck-disabled .ck-button__label {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/816 */
		&.ck-on {
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
		}

		&.ck-dropdown__button_label-width_auto .ck-button__label {
			width: auto;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/8699 */
		&.ck-off:active,
		&.ck-on:active {
			box-shadow: none;
			
			&:focus {
				@mixin ck-box-shadow var(--ck-focus-outer-shadow);
			}
		}
	}
}

.ck.ck-dropdown__panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	background: var(--ck-color-dropdown-panel-background);
	border: 1px solid var(--ck-color-dropdown-panel-border);
	bottom: 0;

	/* Make sure the panel is at least as wide as the drop-down's button. */
	min-width: 100%;

	/* Disabled corner border radius to be consistent with the .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-dropdown__panel_se {
		border-top-left-radius: 0;
	}

	&.ck-dropdown__panel_sw {
		border-top-right-radius: 0;
	}

	&.ck-dropdown__panel_ne {
		border-bottom-left-radius: 0;
	}

	&.ck-dropdown__panel_nw {
		border-bottom-right-radius: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 3949: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

.ck.ck-dropdown .ck-dropdown__panel .ck-list {
	/* Disabled radius of top-left border to be consistent with .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
	}

	/* Make sure the button belonging to the first/last child of the list goes well with the
	border radius of the entire panel. */
	& .ck-list__item {
		&:first-child .ck-button {
			@mixin ck-rounded-corners {
				border-top-left-radius: 0;
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}
		}

		&:last-child .ck-button {
			@mixin ck-rounded-corners {
				border-top-left-radius: 0;
				border-top-right-radius: 0;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 7686: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-splitbutton {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-splitbutton__action:focus {
		z-index: calc(var(--ck-z-default) + 1);
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-split-button-hover-background: hsl(0, 0%, 92%);
	--ck-color-split-button-hover-border: hsl(0, 0%, 70%);
}

.ck.ck-splitbutton {
	/*
	 * Note: ck-rounded and ck-dir mixins don't go together (because they both use @nest).
	 */
	&:hover > .ck-splitbutton__action,
	&.ck-splitbutton_open > .ck-splitbutton__action {
		@nest [dir="ltr"] & {
			/* Don't round the action button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the action button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}
	}

	& > .ck-splitbutton__arrow {
		/* It's a text-less button and since the icon is positioned absolutely in such situation,
		it must get some arbitrary min-width. */
		min-width: unset;

		@nest [dir="ltr"] & {
			/* Don't round the arrow button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the arrow button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		& svg {
			width: var(--ck-dropdown-arrow-size);
		}
	}

	/* Make sure the divider stretches 100% height of the button
	https://github.com/ckeditor/ckeditor5/issues/10936 */
	& > .ck-splitbutton__arrow:not(:focus) {
		border-top-width: 0px;
		border-bottom-width: 0px;
	}

	/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling
	as a whole. The background of both buttons should stand out and there should be a visual
	separation between both buttons. */
	&.ck-splitbutton_open,
	&:hover {
		/* When the split button hovered as a whole, not as individual buttons. */
		& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {
			background: var(--ck-color-split-button-hover-background);
		}

		/* Splitbutton separator needs to be set with the ::after pseudoselector
		to display properly the borders on focus */
		& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
			content: '';
			position: absolute;
			width: 1px;
			height: 100%;
			background-color: var(--ck-color-split-button-hover-border);
		}

		/* Make sure the divider between the buttons looks fine when the button is focused */
		& > .ck-splitbutton__arrow:focus::after {
			--ck-color-split-button-hover-border: var(--ck-color-focus-border);
		}

		@nest [dir="ltr"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				left: -1px;
			}
		}

		@nest [dir="rtl"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				right: -1px;
			}
		}
	}

	/* Don't round the bottom left and right corners of the buttons when "open"
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-splitbutton_open {
		@mixin ck-rounded-corners {
			& > .ck-splitbutton__action {
				border-bottom-left-radius: 0;
			}

			& > .ck-splitbutton__arrow {
				border-bottom-right-radius: 0;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 7339: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"], names: [], mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-toolbar-dropdown-max-width: 60vw;
}

.ck.ck-toolbar-dropdown > .ck-dropdown__panel {
	/* https://github.com/ckeditor/ckeditor5/issues/5586 */
	width: max-content;
	max-width: var(--ck-toolbar-dropdown-max-width);

	& .ck-button {
		&:focus {
			z-index: calc(var(--ck-z-default) + 1);
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-toolbar-dropdown .ck-toolbar {
	border: 0;
}
`], sourceRoot: "" }]);
      const A = b;
    }, 9688: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_focus.css";
@import "../../mixins/_button.css";

:root {
	--ck-color-editable-blur-selection: hsl(0, 0%, 85%);
}

.ck.ck-editor__editable:not(.ck-editor__nested-editable) {
	@mixin ck-rounded-corners;

	&.ck-focused {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);
	}
}

.ck.ck-editor__editable_inline {
	overflow: auto;
	padding: 0 var(--ck-spacing-standard);
	border: 1px solid transparent;

	&[dir="ltr"] {
		text-align: left;
	}

	&[dir="rtl"] {
		text-align: right;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */
	& > *:first-child {
		margin-top: var(--ck-spacing-large);
	}

	/* https://github.com/ckeditor/ckeditor5/issues/847 */
	& > *:last-child {
		/*
		 * This value should match with the default margins of the block elements (like .media or .image)
		 * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).
		 */
		margin-bottom: var(--ck-spacing-large);
	}

	/* https://github.com/ckeditor/ckeditor5/issues/6517 */
	&.ck-blurred ::selection {
		background: var(--ck-color-editable-blur-selection);
	}
}

/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */
.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {
	&::after {
		border-bottom-color: var(--ck-color-base-foreground);
	}
}

.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {
	&::after {
		border-top-color: var(--ck-color-base-foreground);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 8847: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"], names: [], mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form__header {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	align-items: center;
	justify-content: space-between;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-form-header-height: 38px;
}

.ck.ck-form__header {
	padding: var(--ck-spacing-small) var(--ck-spacing-large);
	height: var(--ck-form-header-height);
	line-height: var(--ck-form-header-height);
	border-bottom: 1px solid var(--ck-color-base-border);

	& .ck-form__header__label {
		font-weight: bold;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 6574: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/icon/icon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"], names: [], mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-icon {
	vertical-align: middle;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));
}

.ck.ck-icon {
	width: var(--ck-icon-size);
	height: var(--ck-icon-size);

	/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */
	font-size: .8333350694em;

	/* Inherit cursor style (#5). */
	cursor: inherit;

	/* This will prevent blurry icons on Firefox. See #340. */
	will-change: transform;

	& * {
		/* Inherit cursor style (#5). */
		cursor: inherit;
	}

	/* Allows dynamic coloring of an icon by inheriting its color from the parent. */
	&.ck-icon_inherit-color {
		color: inherit;

		& * {
			color: inherit;

			&:not([fill]) {
				/* Needed by FF. */
				fill: currentColor;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 4879: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-input-width: 18em;

	/* Backward compatibility. */
	--ck-input-text-width: var(--ck-input-width);
}

.ck.ck-input {
	@mixin ck-rounded-corners;

	background: var(--ck-color-input-background);
	border: 1px solid var(--ck-color-input-border);
	padding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);
	min-width: var(--ck-input-width);

	/* This is important to stay of the same height as surrounding buttons */
	min-height: var(--ck-ui-component-min-height);

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .1s ease-in-out, border .1s ease-in-out;

	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	&[readonly] {
		border: 1px solid var(--ck-color-input-disabled-border);
		background: var(--ck-color-input-disabled-background);
		color: var(--ck-color-input-disabled-text);

		&:focus {
			/* The read-only input should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}
	}

	&.ck-error {
		border-color: var(--ck-color-input-error-border);
		animation: ck-input-shake .3s ease both;

		&:focus {
			@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);
		}
	}
}

@keyframes ck-input-shake {
	20% {
		transform: translateX(-2px);
	}

	40% {
		transform: translateX(2px);
	}

	60% {
		transform: translateX(-1px);
	}

	80% {
		transform: translateX(1px);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 3662: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/label/label.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"], names: [], mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-label {
	display: block;
}

.ck.ck-voice-label {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-label {
	font-weight: bold;
}
`], sourceRoot: "" }]);
      const A = b;
    }, 2577: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-labeled-field-view {
	& > .ck.ck-labeled-field-view__input-wrapper {
		display: flex;
		position: relative;
	}

	& .ck.ck-label {
		display: block;
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../../../mixins/_rounded.css";

:root {
	--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);
	--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));
	--ck-color-labeled-field-label-background: var(--ck-color-base-background);
}

.ck.ck-labeled-field-view {
	@mixin ck-rounded-corners;

	& > .ck.ck-labeled-field-view__input-wrapper {
		width: 100%;

		& > .ck.ck-label {
			top: 0px;

			@mixin ck-dir ltr {
				left: 0px;
			}

			@mixin ck-dir rtl {
				right: 0px;
			}

			pointer-events: none;
			transform-origin: 0 0;

			/* By default, display the label scaled down above the field. */
			transform: translate(var(--ck-spacing-medium), -6px) scale(.75);

			background: var(--ck-color-labeled-field-label-background);
			padding: 0 calc(.5 * var(--ck-font-size-tiny));
			line-height: initial;
			font-weight: normal;

			/* Prevent overflow when the label is longer than the input */
			text-overflow: ellipsis;
			overflow: hidden;

			max-width: 100%;

			transition:
				transform var(--ck-labeled-field-view-transition),
				padding var(--ck-labeled-field-view-transition),
				background var(--ck-labeled-field-view-transition);
		}
	}

	&.ck-error {
		& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
			color: var(--ck-color-base-error);
		}

		& .ck-input:not([readonly]) + .ck.ck-label {
			color: var(--ck-color-base-error);
		}
	}

	& .ck-labeled-field-view__status {
		font-size: var(--ck-font-size-small);
		margin-top: var(--ck-spacing-small);

		/* Let the info wrap to the next line to avoid stretching the layout horizontally.
		The status could be very long. */
		white-space: normal;

		&.ck-labeled-field-view__status_error {
			color: var(--ck-color-base-error);
		}
	}

	/* Disabled fields and fields that have no focus should fade out. */
	&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		color: var(--ck-color-input-disabled-text);
	}

	/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */
	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		@mixin ck-dir ltr {
			transform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		@mixin ck-dir rtl {
			transform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		/* Compensate for the default translate position. */
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));

		background: transparent;
		padding: 0;
	}

	/*------ DropdownView integration ----------------------------------------------------------------------------------- */

	/* Make sure dropdown' background color in any of dropdown's state does not collide with labeled field. */
	& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {
		background: transparent;
	}

	/* When the dropdown is "empty", the labeled field label replaces its label. */
	&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {
		opacity: 0;
	}

	/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 1046: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/list/list.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-list {
	@mixin ck-unselectable;

	display: flex;
	flex-direction: column;

	& .ck-list__item,
	& .ck-list__separator {
		display: block;
	}

	/* Make sure that whatever child of the list item gets focus, it remains on the
	top. Thanks to that, styles like box-shadow, outline, etc. are not masked by
	adjacent list items. */
	& .ck-list__item > *:focus {
		position: relative;
		z-index: var(--ck-z-default);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";

.ck.ck-list {
	@mixin ck-rounded-corners;

	list-style-type: none;
	background: var(--ck-color-list-background);
}

.ck.ck-list__item {
	cursor: default;
	min-width: 12em;

	& .ck-button {
		min-height: unset;
		width: 100%;
		text-align: left;
		border-radius: 0;

		/* List items should have the same height. Use absolute units to make sure it is so
		   because e.g. different heading styles may have different height
		   https://github.com/ckeditor/ckeditor5-heading/issues/63 */
		padding:
			calc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))
			calc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));

		& .ck-button__label {
			/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */
			line-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));
		}

		&:active {
			box-shadow: none;
		}

		&.ck-on {
			background: var(--ck-color-list-button-on-background);
			color: var(--ck-color-list-button-on-text);

			&:active {
				box-shadow: none;
			}

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-on-background-focus);
			}

			&:focus:not(.ck-switchbutton):not(.ck-disabled) {
				border-color: var(--ck-color-base-background);
			}
		}

		&:hover:not(.ck-disabled) {
			background: var(--ck-color-list-button-hover-background);
		}
	}

	/* It's unnecessary to change the background/text of a switch toggle; it has different ways
	of conveying its state (like the switcher) */
	& .ck-switchbutton {
		&.ck-on {
			background: var(--ck-color-list-background);
			color: inherit;

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-hover-background);
				color: inherit;
			}
		}
	}
}

.ck.ck-list__separator {
	height: 1px;
	width: 100%;
	background: var(--ck-color-base-border);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 8793: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Make sure the balloon arrow does not float over its children. */
	--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);
}

.ck.ck-balloon-panel {
	display: none;
	position: absolute;

	z-index: var(--ck-z-modal);

	&.ck-balloon-panel_with-arrow {
		&::before,
		&::after {
			content: "";
			position: absolute;
		}

		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&[class*="arrow_n"] {
		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&[class*="arrow_s"] {
		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&.ck-balloon-panel_visible {
		display: block;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-balloon-border-width: 1px;
	--ck-balloon-arrow-offset: 2px;
	--ck-balloon-arrow-height: 10px;
	--ck-balloon-arrow-half-width: 8px;
	--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);
}

.ck.ck-balloon-panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	min-height: 15px;

	background: var(--ck-color-panel-background);
	border: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);

	&.ck-balloon-panel_with-arrow {
		&::before,
		&::after {
			width: 0;
			height: 0;
			border-style: solid;
		}
	}

	&[class*="arrow_n"] {
		&::before,
		&::after {
			border-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);
		}

		&::before {
			border-color: transparent transparent var(--ck-color-panel-border) transparent;
			margin-top: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent transparent var(--ck-color-panel-background) transparent;
			margin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_s"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);
		}

		&::before {
			border-color: var(--ck-color-panel-border) transparent transparent;
			filter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));
			margin-bottom: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: var(--ck-color-panel-background) transparent transparent transparent;
			margin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_e"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);
		}

		&::before {
			border-color: transparent transparent transparent var(--ck-color-panel-border);
			margin-right: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent transparent transparent var(--ck-color-panel-background);
			margin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_w"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;
		}

		&::before {
			border-color: transparent var(--ck-color-panel-border) transparent transparent;
			margin-left: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent var(--ck-color-panel-background) transparent transparent;
			margin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&.ck-balloon-panel_arrow_n {
		&::before,
		&::after {
			left: 50%;
			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nw {
		&::before,
		&::after {
			left: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_ne {
		&::before,
		&::after {
			right: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_s {
		&::before,
		&::after {
			left: 50%;
			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_sw {
		&::before,
		&::after {
			left: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_se {
		&::before,
		&::after {
			right: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_sme {
		&::before,
		&::after {
			right: 25%;
			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_smw {
		&::before,
		&::after {
			left: 25%;
			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nme {
		&::before,
		&::after {
			right: 25%;
			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nmw {
		&::before,
		&::after {
			left: 25%;
			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_e {
		&::before,
		&::after {
			right: calc(-1 * var(--ck-balloon-arrow-height));
			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: 50%;
		}
	}

	&.ck-balloon-panel_arrow_w {
		&::before,
		&::after {
			left: calc(-1 * var(--ck-balloon-arrow-height));
			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 4650: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"], names: [], mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-balloon-rotator__navigation {
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Buttons inside a toolbar should be centered when rotator bar is wider.
 * See: https://github.com/ckeditor/ckeditor5-ui/issues/495
 */
.ck .ck-balloon-rotator__content .ck-toolbar {
	justify-content: center;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-balloon-rotator__navigation {
	background: var(--ck-color-toolbar-background);
	border-bottom: 1px solid var(--ck-color-toolbar-border);
	padding: 0 var(--ck-spacing-small);

	/* Let's keep similar appearance to \`ck-toolbar\`. */
	& > * {
		margin-right: var(--ck-spacing-small);
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	/* Gives counter more breath than buttons. */
	& .ck-balloon-rotator__counter {
		margin-right: var(--ck-spacing-standard);

		/* We need to use smaller margin because of previous button's right margin. */
		margin-left: var(--ck-spacing-small);
	}
}

.ck .ck-balloon-rotator__content {

	/* Disable default annotation shadow inside rotator with fake panels. */
	& .ck.ck-annotation-wrapper {
		box-shadow: none;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 7676: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-fake-panel {
	position: absolute;

	/* Fake panels should be placed under main balloon content. */
	z-index: calc(var(--ck-z-modal) - 1);
}

.ck .ck-fake-panel div {
	position: absolute;
}

.ck .ck-fake-panel div:nth-child( 1 ) {
	z-index: 2;
}

.ck .ck-fake-panel div:nth-child( 2 ) {
	z-index: 1;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_shadow.css";

:root {
	--ck-balloon-fake-panel-offset-horizontal: 6px;
	--ck-balloon-fake-panel-offset-vertical: 6px;
}

/* Let's use \`.ck-balloon-panel\` appearance. See: balloonpanel.css. */
.ck .ck-fake-panel div {
	@mixin ck-drop-shadow;

	min-height: 15px;

	background: var(--ck-color-panel-background);
	border: 1px solid var(--ck-color-panel-border);
	border-radius: var(--ck-border-radius);

	width: 100%;
	height: 100%;
}

.ck .ck-fake-panel div:nth-child( 1 ) {
	margin-left: var(--ck-balloon-fake-panel-offset-horizontal);
	margin-top: var(--ck-balloon-fake-panel-offset-vertical);
}

.ck .ck-fake-panel div:nth-child( 2 ) {
	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);
	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);
}
.ck .ck-fake-panel div:nth-child( 3 ) {
	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);
	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);
}

/* If balloon is positioned above element, we need to move fake panel to the top. */
.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,
.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,
.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {
	--ck-balloon-fake-panel-offset-vertical: -6px;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 5868: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-sticky-panel {
	& .ck-sticky-panel__content_sticky {
		z-index: var(--ck-z-modal); /* #315 */
		position: fixed;
		top: 0;
	}

	& .ck-sticky-panel__content_sticky_bottom-limit {
		top: auto;
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_shadow.css";

.ck.ck-sticky-panel {
	& .ck-sticky-panel__content_sticky {
		@mixin ck-drop-shadow;

		border-width: 0 1px 1px;
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 6764: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"], names: [], mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck-vertical-form .ck-button {
	&::after {
		content: "";
		width: 0;
		position: absolute;
		right: -1px;
		top: -1px;
		bottom: -1px;
		z-index: 1;
	}

	&:focus::after {
		display: none;
	}
}

.ck.ck-responsive-form {
	@mixin ck-media-phone {
		& .ck-button {
			&::after {
				content: "";
				width: 0;
				position: absolute;
				right: -1px;
				top: -1px;
				bottom: -1px;
				z-index: 1;
			}

			&:focus::after {
				display: none;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck-vertical-form > .ck-button:nth-last-child(2)::after {
	border-right: 1px solid var(--ck-color-base-border);
}

.ck.ck-responsive-form {
	padding: var(--ck-spacing-large);

	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}

	@mixin ck-dir ltr {
		& > :not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& > :not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		padding: 0;
		width: calc(.8 * var(--ck-input-width));

		& .ck-labeled-field-view {
			margin: var(--ck-spacing-large) var(--ck-spacing-large) 0;

			& .ck-input-text {
				min-width: 0;
				width: 100%;
			}

			/* Let the long error messages wrap in the narrow form. */
			& .ck-labeled-field-view__error {
				white-space: normal;
			}
		}

		/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */
		& > .ck-button:nth-last-child(2) {
			&::after {
				border-right: 1px solid var(--ck-color-base-border);
			}
		}

		& > .ck-button:nth-last-child(1),
		& > .ck-button:nth-last-child(2) {
			padding: var(--ck-spacing-standard);
			margin-top: var(--ck-spacing-large);
			border-radius: 0;

			&:not(:focus) {
				border-top: 1px solid var(--ck-color-base-border);
			}

			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;

				&:last-of-type {
					border-right: 1px solid var(--ck-color-base-border);
				}
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 9695: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"], names: [], mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-block-toolbar-button {
	position: absolute;
	z-index: var(--ck-z-default);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-block-toolbar-button: var(--ck-color-text);
	--ck-block-toolbar-button-size: var(--ck-font-size-normal);
}

.ck.ck-block-toolbar-button {
	color: var(--ck-color-block-toolbar-button);
	font-size: var(--ck-block-toolbar-size);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 5542: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-toolbar {
	@mixin ck-unselectable;

	display: flex;
	flex-flow: row nowrap;
	align-items: center;

	& > .ck-toolbar__items {
		display: flex;
		flex-flow: row wrap;
		align-items: center;
		flex-grow: 1;

	}

	& .ck.ck-toolbar__separator {
		display: inline-block;

		/*
		 * A leading or trailing separator makes no sense (separates from nothing on one side).
		 * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and
		 * moved to another toolbar in the dropdown.
		 */
		&:first-child,
		&:last-child {
			display: none;
		}
	}

	& .ck-toolbar__line-break {
		flex-basis: 100%;
	}

	&.ck-toolbar_grouping > .ck-toolbar__items {
		flex-wrap: nowrap;
	}

	&.ck-toolbar_vertical > .ck-toolbar__items {
		flex-direction: column;
	}

	&.ck-toolbar_floating > .ck-toolbar__items {
		flex-wrap: nowrap;
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		& > .ck-dropdown__button .ck-dropdown__arrow {
			display: none;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-toolbar {
	@mixin ck-rounded-corners;

	background: var(--ck-color-toolbar-background);
	padding: 0 var(--ck-spacing-small);
	border: 1px solid var(--ck-color-toolbar-border);

	& .ck.ck-toolbar__separator {
		align-self: stretch;
		width: 1px;
		min-width: 1px;
		background: var(--ck-color-toolbar-border);

		/*
		 * These margins make the separators look better in balloon toolbars (when aligned with the "tip").
		 * See https://github.com/ckeditor/ckeditor5/issues/7493.
		 */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	& .ck-toolbar__line-break {
		height: 0;
	}

	& > .ck-toolbar__items {
		& > *:not(.ck-toolbar__line-break) {
			/* (#11) Separate toolbar items. */
			margin-right: var(--ck-spacing-small);
		}

		/* Don't display a separator after an empty items container, for instance,
		when all items were grouped */
		&:empty + .ck.ck-toolbar__separator {
			display: none;
		}
	}

	& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),
	& > .ck.ck-toolbar__grouped-dropdown {
		/* Make sure items wrapped to the next line have v-spacing */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	&.ck-toolbar_vertical {
		/* Items in a vertical toolbar span the entire width. */
		padding: 0;

		/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */
		& > .ck-toolbar__items > .ck {
			/* Items in a vertical toolbar should span the horizontal space. */
			width: 100%;

			/* Items in a vertical toolbar should have no margin. */
			margin: 0;

			/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */
			border-radius: 0;
		}
	}

	&.ck-toolbar_compact {
		/* No spacing around items. */
		padding: 0;

		& > .ck-toolbar__items > * {
			/* Compact toolbar items have no spacing between them. */
			margin: 0;

			/* "Middle" children should have no rounded corners. */
			&:not(:first-child):not(:last-child) {
				border-radius: 0;
			}
		}
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		/*
		 * Dropdown button has asymmetric padding to fit the arrow.
		 * This button has no arrow so let's revert that padding back to normal.
		 */
		& > .ck.ck-button.ck-dropdown__button {
			padding-left: var(--ck-spacing-tiny);
		}
	}

	/* A drop-down containing the nested toolbar with configured items. */
	& .ck-toolbar__nested-toolbar-dropdown {
		/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */
		& > .ck-dropdown__panel {
			min-width: auto;
		}

		& > .ck-button > .ck-button__label {
			max-width: 7em;
			width: auto;
		}
	}

	&:focus {
		outline: none;
	}

	@nest .ck-toolbar-container & {
		border: 0;
	}
}

/* stylelint-disable */

/*
 * Styles for RTL toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="rtl"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="rtl"] {
	& > .ck-toolbar__items > .ck {
		margin-right: 0;
	}

	&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {
		/* (#11) Separate toolbar items. */
		margin-left: var(--ck-spacing-small);
	}

	& > .ck-toolbar__items > .ck:last-child {
		margin-left: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-left: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-left: var(--ck-spacing-small);
	}
}

/*
 * Styles for LTR toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="ltr"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="ltr"] {
	& > .ck-toolbar__items > .ck:last-child {
		margin-right: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-right: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-right: var(--ck-spacing-small);
	}
}

/* stylelint-enable */
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 3332: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"], names: [], mappings: "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-balloon-panel.ck-tooltip {
	/* Keep tooltips transparent for any interactions. */
	pointer-events: none;

	z-index: calc( var(--ck-z-modal) + 100 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

.ck.ck-balloon-panel.ck-tooltip {
	--ck-balloon-border-width: 0px;
	--ck-balloon-arrow-offset: 0px;
	--ck-balloon-arrow-half-width: 4px;
	--ck-balloon-arrow-height: 4px;
	--ck-color-panel-background: var(--ck-color-tooltip-background);

	padding: 0 var(--ck-spacing-medium);

	& .ck-tooltip__text {
		font-size: .9em;
		line-height: 1.5;
		color: var(--ck-color-tooltip-text);
	}

	/* Reset balloon panel styles */
	box-shadow: none;

	/* Hide the default shadow of the .ck-balloon-panel tip */
	&::before {
		display: none;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 4793: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);border:0;box-shadow:none;min-height:unset}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/globals/_hidden.css", "webpack://./../ckeditor5-ui/theme/globals/_reset.css", "webpack://./../ckeditor5-ui/theme/globals/_zindex.css", "webpack://./../ckeditor5-ui/theme/globals/_transition.css", "webpack://./../ckeditor5-ui/theme/globals/_poweredby.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"], names: [], mappings: "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAItD,0CAA2C,CAF3C,QAAS,CACT,eAAgB,CAEhB,gBA6CD,CA3CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,2BAA4B,CAC5B,8CACD,CC5DD,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which hides an element in DOM.
 */
.ck-hidden {
	/* Override selector specificity. Otherwise, all elements with some display
	style defined will override this one, which is not a desired result. */
	display: none !important;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-reset,
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	box-sizing: border-box;
	width: auto;
	height: auto;
	position: static;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-z-default: 1;
	--ck-z-modal: calc( var(--ck-z-default) + 999 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class that disables all transitions of the element and its children.
 */
.ck-transitions-disabled,
.ck-transitions-disabled * {
	transition: none !important;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-powered-by-line-height: 10px;
	--ck-powered-by-padding-vertical: 2px;
	--ck-powered-by-padding-horizontal: 4px;
	--ck-powered-by-text-color: hsl(0, 0%, 31%);
	--ck-powered-by-border-radius: var(--ck-border-radius);
	--ck-powered-by-background: hsl(0, 0%, 100%);
	--ck-powered-by-border-color: var(--ck-color-focus-border);
}

.ck.ck-balloon-panel.ck-powered-by-balloon {
	--ck-border-radius: var(--ck-powered-by-border-radius);

	border: 0;
	box-shadow: none;
	background: var(--ck-powered-by-background);
	min-height: unset;

	& .ck.ck-powered-by {
		line-height: var(--ck-powered-by-line-height);

		& a {
			cursor: pointer;
			display: flex;
			align-items: center;
			opacity: .66;
			filter: grayscale(80%);
			line-height: var(--ck-powered-by-line-height);
			padding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);
		}

		& .ck-powered-by__label {
			font-size: 7.5px;
			letter-spacing: -.2px;
			padding-left: 2px;
			text-transform: uppercase;
			font-weight: bold;
			margin-right: 4px;
			cursor: pointer;
			line-height: normal;
			color: var(--ck-powered-by-text-color);

		}

		& .ck-icon {
			display: block;
			cursor: pointer;
		}

		&:hover {
			& a {
				filter: grayscale(0%);
				opacity: 1;
			}
		}
	}

	&[class*="position_border"] {
		border: var(--ck-focus-ring);
		border-color: var(--ck-powered-by-border-color);
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-base-foreground: 								hsl(0, 0%, 98%);
	--ck-color-base-background: 								hsl(0, 0%, 100%);
	--ck-color-base-border: 									hsl(220, 6%, 81%);
	--ck-color-base-action: 									hsl(104, 50.2%, 42.5%);
	--ck-color-base-focus: 										hsl(209, 92%, 70%);
	--ck-color-base-text: 										hsl(0, 0%, 20%);
	--ck-color-base-active: 									hsl(218.1, 100%, 58%);
	--ck-color-base-active-focus:								hsl(218.2, 100%, 52.5%);
	--ck-color-base-error:										hsl(15, 100%, 43%);

	/* -- Generic colors ------------------------------------------------------------------------ */

	--ck-color-focus-border-coordinates: 						218, 81.8%, 56.9%;
	--ck-color-focus-border: 									hsl(var(--ck-color-focus-border-coordinates));
	--ck-color-focus-outer-shadow:								hsl(212.4, 89.3%, 89%);
	--ck-color-focus-disabled-shadow:							hsla(209, 90%, 72%,.3);
	--ck-color-focus-error-shadow:								hsla(9,100%,56%,.3);
	--ck-color-text: 											var(--ck-color-base-text);
	--ck-color-shadow-drop: 									hsla(0, 0%, 0%, 0.15);
	--ck-color-shadow-drop-active:								hsla(0, 0%, 0%, 0.2);
	--ck-color-shadow-inner: 									hsla(0, 0%, 0%, 0.1);

	/* -- Buttons ------------------------------------------------------------------------------- */

	--ck-color-button-default-background: 						transparent;
	--ck-color-button-default-hover-background: 				hsl(0, 0%, 94.1%);
	--ck-color-button-default-active-background: 				hsl(0, 0%, 94.1%);
	--ck-color-button-default-disabled-background: 				transparent;

	--ck-color-button-on-background: 							hsl(212, 100%, 97.1%);
	--ck-color-button-on-hover-background: 						hsl(211.7, 100%, 92.9%);
	--ck-color-button-on-active-background: 					hsl(211.7, 100%, 92.9%);
	--ck-color-button-on-disabled-background: 					hsl(211, 15%, 95%);
	--ck-color-button-on-color:									hsl(218.1, 100%, 58%);


	--ck-color-button-action-background: 						var(--ck-color-base-action);
	--ck-color-button-action-hover-background: 					hsl(104, 53.2%, 40.2%);
	--ck-color-button-action-active-background: 				hsl(104, 53.2%, 40.2%);
	--ck-color-button-action-disabled-background: 				hsl(104, 44%, 58%);
	--ck-color-button-action-text: 								var(--ck-color-base-background);

	--ck-color-button-save: 									hsl(120, 100%, 27%);
	--ck-color-button-cancel: 									hsl(15, 100%, 43%);

	--ck-color-switch-button-off-background:					hsl(0, 0%, 57.6%);
	--ck-color-switch-button-off-hover-background:				hsl(0, 0%, 49%);
	--ck-color-switch-button-on-background:						var(--ck-color-button-action-background);
	--ck-color-switch-button-on-hover-background:				hsl(104, 53.2%, 40.2%);
	--ck-color-switch-button-inner-background:					var(--ck-color-base-background);
	--ck-color-switch-button-inner-shadow:						hsla(0, 0%, 0%, 0.1);

	/* -- Dropdown ------------------------------------------------------------------------------ */

	--ck-color-dropdown-panel-background: 						var(--ck-color-base-background);
	--ck-color-dropdown-panel-border: 							var(--ck-color-base-border);

	/* -- Input --------------------------------------------------------------------------------- */

	--ck-color-input-background: 								var(--ck-color-base-background);
	--ck-color-input-border: 									var(--ck-color-base-border);
	--ck-color-input-error-border:								var(--ck-color-base-error);
	--ck-color-input-text: 										var(--ck-color-base-text);
	--ck-color-input-disabled-background: 						hsl(0, 0%, 95%);
	--ck-color-input-disabled-border: 							var(--ck-color-base-border);
	--ck-color-input-disabled-text: 							hsl(0, 0%, 46%);

	/* -- List ---------------------------------------------------------------------------------- */

	--ck-color-list-background: 								var(--ck-color-base-background);
	--ck-color-list-button-hover-background: 					var(--ck-color-button-default-hover-background);
	--ck-color-list-button-on-background: 						var(--ck-color-button-on-color);
	--ck-color-list-button-on-background-focus: 				var(--ck-color-button-on-color);
	--ck-color-list-button-on-text:								var(--ck-color-base-background);

	/* -- Panel --------------------------------------------------------------------------------- */

	--ck-color-panel-background: 								var(--ck-color-base-background);
	--ck-color-panel-border: 									var(--ck-color-base-border);

	/* -- Toolbar ------------------------------------------------------------------------------- */

	--ck-color-toolbar-background: 								var(--ck-color-base-background);
	--ck-color-toolbar-border: 									var(--ck-color-base-border);

	/* -- Tooltip ------------------------------------------------------------------------------- */

	--ck-color-tooltip-background: 								var(--ck-color-base-text);
	--ck-color-tooltip-text: 									var(--ck-color-base-background);

	/* -- Engine -------------------------------------------------------------------------------- */

	--ck-color-engine-placeholder-text: 						hsl(0, 0%, 44%);

	/* -- Upload -------------------------------------------------------------------------------- */

	--ck-color-upload-bar-background:		 					hsl(209, 92%, 70%);

	/* -- Link -------------------------------------------------------------------------------- */

	--ck-color-link-default:									hsl(240, 100%, 47%);
	--ck-color-link-selected-background:						hsla(201, 100%, 56%, 0.1);
	--ck-color-link-fake-selection:								hsla(201, 100%, 56%, 0.3);

	/* -- Search result highlight ---------------------------------------------------------------- */

	--ck-color-highlight-background:							hsl(60, 100%, 50%)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * An opacity value of disabled UI item.
	 */
	--ck-disabled-opacity: .5;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * The geometry of the of focused element's outer shadow.
	 */
	--ck-focus-outer-shadow-geometry: 0 0 0 3px;

	/**
	 * A visual style of focused element's outer shadow.
	 */
	--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);

	/**
	 * A visual style of focused element's outer shadow (when disabled).
	 */
	--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);

	/**
	 * A visual style of focused element's outer shadow (when has errors).
	 */
	--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);

	/**
	 * A visual style of focused element's border or outline.
	 */
	--ck-focus-ring: 1px solid var(--ck-color-focus-border);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-font-size-base: 13px;
	--ck-line-height-base: 1.84615;
	--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;

	--ck-font-size-tiny: 0.7em;
	--ck-font-size-small: 0.75em;
	--ck-font-size-normal: 1em;
	--ck-font-size-big: 1.4em;
	--ck-font-size-large: 1.8em;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* This is super-important. This is **manually** adjusted so a button without an icon
	is never smaller than a button with icon, additionally making sure that text-less buttons
	are perfect squares. The value is also shared by other components which should stay "in-line"
	with buttons. */
	--ck-ui-component-min-height: 2.3em;
}

/**
 * Resets an element, ignoring its children.
 */
.ck.ck-reset,
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	/* Do not include inheritable rules here. */
	margin: 0;
	padding: 0;
	border: 0;
	background: transparent;
	text-decoration: none;
	vertical-align: middle;
	transition: none;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */
	word-wrap: break-word;
}

/**
 * Resets an element AND its children.
 */
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	/* These are rule inherited by all children elements. */
	border-collapse: collapse;
	font: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);
	color: var(--ck-color-text);
	text-align: left;
	white-space: nowrap;
	cursor: auto;
	float: none;
}

.ck-reset_all {
	& .ck-rtl *:not(.ck-reset_all-excluded *) {
		text-align: right;
	}

	& iframe:not(.ck-reset_all-excluded *) {
		/* For IE */
		vertical-align: inherit;
	}

	& textarea:not(.ck-reset_all-excluded *) {
		white-space: pre-wrap;
	}

	& textarea:not(.ck-reset_all-excluded *),
	& input[type="text"]:not(.ck-reset_all-excluded *),
	& input[type="password"]:not(.ck-reset_all-excluded *) {
		cursor: text;
	}

	& textarea[disabled]:not(.ck-reset_all-excluded *),
	& input[type="text"][disabled]:not(.ck-reset_all-excluded *),
	& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {
		cursor: default;
	}

	& fieldset:not(.ck-reset_all-excluded *) {
		padding: 10px;
		border: 2px groove hsl(255, 7%, 88%);
	}

	& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {
		/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */
		padding: 0;
		border: 0
	}
}

/**
 * Default UI rules for RTL languages.
 */
.ck[dir="rtl"],
.ck[dir="rtl"] .ck {
	text-align: right;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Default border-radius value.
 */
:root{
	--ck-border-radius: 2px;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * A visual style of element's inner shadow (i.e. input).
	 */
	--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;

	/**
	 * A visual style of element's drop shadow (i.e. panel).
	 */
	--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);

	/**
	 * A visual style of element's active shadow (i.e. comment or suggestion).
	 */
	--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-spacing-unit: 						0.6em;
	--ck-spacing-large: 					calc(var(--ck-spacing-unit) * 1.5);
	--ck-spacing-standard: 					var(--ck-spacing-unit);
	--ck-spacing-medium: 					calc(var(--ck-spacing-unit) * 0.8);
	--ck-spacing-small: 					calc(var(--ck-spacing-unit) * 0.5);
	--ck-spacing-tiny: 						calc(var(--ck-spacing-unit) * 0.3);
	--ck-spacing-extra-tiny: 				calc(var(--ck-spacing-unit) * 0.16);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 3488: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widget.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-resizer: var(--ck-color-focus-border);
	--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);
	--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);

	--ck-resizer-border-radius: var(--ck-border-radius);
	--ck-resizer-tooltip-offset: 10px;
	--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);
}

.ck .ck-widget {
	/* This is neccessary for type around UI to be positioned properly. */
	position: relative;
}

.ck .ck-widget.ck-widget_with-selection-handle {
	/* Make the widget wrapper a relative positioning container for the drag handle. */
	position: relative;

	& .ck-widget__selection-handle {
		position: absolute;

		& .ck-icon {
			/* Make sure the icon in not a subject to font-size or line-height to avoid
			unnecessary spacing around it. */
			display: block;
		}
	}

	/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */
	&:hover > .ck-widget__selection-handle {
		visibility: visible;
	}

	/* Show the selection handle when the widget is selected, but not for nested widgets. */
	&.ck-widget_selected > .ck-widget__selection-handle {
		visibility: visible;
	}
}

.ck .ck-size-view {
	background: var(--ck-color-resizer-tooltip-background);
	color: var(--ck-color-resizer-tooltip-text);
	border: 1px solid var(--ck-color-resizer-tooltip-text);
	border-radius: var(--ck-resizer-border-radius);
	font-size: var(--ck-font-size-tiny);
	display: block;
	padding: 0 var(--ck-spacing-small);
	height: var(--ck-resizer-tooltip-height);
	line-height: var(--ck-resizer-tooltip-height);

	&.ck-orientation-top-left,
	&.ck-orientation-top-right,
	&.ck-orientation-bottom-right,
	&.ck-orientation-bottom-left,
	&.ck-orientation-above-center {
		position: absolute;
	}

	&.ck-orientation-top-left {
		top: var(--ck-resizer-tooltip-offset);
		left: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-top-right {
		top: var(--ck-resizer-tooltip-offset);
		right: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-bottom-right {
		bottom: var(--ck-resizer-tooltip-offset);
		right: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-bottom-left {
		bottom: var(--ck-resizer-tooltip-offset);
		left: var(--ck-resizer-tooltip-offset);
	}

	/* Class applied if the widget is too small to contain the size label */
	&.ck-orientation-above-center {
		top: calc(var(--ck-resizer-tooltip-height) * -1);
		left: 50%;
		transform: translate(-50%);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";

:root {
	--ck-widget-outline-thickness: 3px;
	--ck-widget-handler-icon-size: 16px;
	--ck-widget-handler-animation-duration: 200ms;
	--ck-widget-handler-animation-curve: ease;

	--ck-color-widget-blurred-border: hsl(0, 0%, 87%);
	--ck-color-widget-hover-border: hsl(43, 100%, 62%);
	--ck-color-widget-editable-focus-background: var(--ck-color-base-background);
	--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);
}

.ck .ck-widget {
	outline-width: var(--ck-widget-outline-thickness);
	outline-style: solid;
	outline-color: transparent;
	transition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);
	}

	&:hover {
		outline-color: var(--ck-color-widget-hover-border);
	}
}

.ck .ck-editor__nested-editable {
	border: 1px solid transparent;

	/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.
	These styles show a different border for a blink of an eye, so \`:focus\` need to have same styles applied. */
	&.ck-editor__nested-editable_focused,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);

		background-color: var(--ck-color-widget-editable-focus-background);
	}
}

.ck .ck-widget.ck-widget_with-selection-handle {
	& .ck-widget__selection-handle {
		padding: 4px;
		box-sizing: border-box;

		/* Background and opacity will be animated as the handler shows up or the widget gets selected. */
		background-color: transparent;
		opacity: 0;

		/* Transition:
		   * background-color for the .ck-widget_selected state change,
		   * visibility for hiding the handler,
		   * opacity for the proper look of the icon when the handler disappears. */
		transition:
			background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),
			visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),
			opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		/* Make only top corners round. */
		border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;

		/* Place the drag handler outside the widget wrapper. */
		transform: translateY(-100%);
		left: calc(0px - var(--ck-widget-outline-thickness));
		top: 0;

		& .ck-icon {
			/* Make sure the dimensions of the icon are independent of the fon-size of the content. */
			width: var(--ck-widget-handler-icon-size);
			height: var(--ck-widget-handler-icon-size);
			color: var(--ck-color-widget-drag-handler-icon-color);

			/* The "selected" part of the icon is invisible by default */
			& .ck-icon__selected-indicator {
				opacity: 0;

				/* Note: The animation is longer on purpose. Simply feels better. */
				transition: opacity 300ms var(--ck-widget-handler-animation-curve);
			}
		}

		/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */
		&:hover .ck-icon .ck-icon__selected-indicator {
			opacity: 1;
		}
	}

	/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */
	&:hover > .ck-widget__selection-handle {
		opacity: 1;
		background-color: var(--ck-color-widget-hover-border);
	}

	/* Show the selection handler when the widget is selected, but not for nested widgets. */
	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		& > .ck-widget__selection-handle {
			opacity: 1;
			background-color: var(--ck-color-focus-border);

			/* When the widget is selected, notify the user using the proper look of the icon. */
			& .ck-icon .ck-icon__selected-indicator {
				opacity: 1;
			}
		}
	}
}

/* In a RTL environment, align the selection handler to the right side of the widget */
/* stylelint-disable-next-line no-descending-specificity */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {
	left: auto;
	right: calc(0px - var(--ck-widget-outline-thickness));
}

/* https://github.com/ckeditor/ckeditor5/issues/6415 */
.ck.ck-editor__editable.ck-read-only .ck-widget {
	/* Prevent the :hover outline from showing up because of the used outline-color transition. */
	transition: none;

	&:not(.ck-widget_selected) {
		/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.
		 * See: https://github.com/ckeditor/ckeditor5/issues/1261
		 *
		 * Leave the unit because this custom property is used in calc() by other features.
		 * See: https://github.com/ckeditor/ckeditor5/issues/6775
		 */
		--ck-widget-outline-thickness: 0px;
	}

	&.ck-widget_with-selection-handle {
		& .ck-widget__selection-handle,
		& .ck-widget__selection-handle:hover {
			background: var(--ck-color-widget-blurred-border);
		}
	}
}

/* Style the widget when it's selected but the editable it belongs to lost focus. */
/* stylelint-disable-next-line no-descending-specificity */
.ck.ck-editor__editable.ck-blurred .ck-widget {
	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		outline-color: var(--ck-color-widget-blurred-border);

		&.ck-widget_with-selection-handle {
			& > .ck-widget__selection-handle,
			& > .ck-widget__selection-handle:hover {
				background: var(--ck-color-widget-blurred-border);
			}
		}
	}
}

.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,
.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {
	/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.
	In fact, anything with overflow: hidden.
	https://github.com/ckeditor/ckeditor5-block-quote/issues/28
	https://github.com/ckeditor/ckeditor5-widget/issues/44
	https://github.com/ckeditor/ckeditor5-widget/issues/66 */
	margin-top: calc(1em + var(--ck-widget-handler-icon-size));
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = b;
    }, 8506: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widgetresize.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"], names: [], mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget_with-resizer {
	/* Make the widget wrapper a relative positioning container for the drag handle. */
	position: relative;
}

.ck .ck-widget__resizer {
	display: none;
	position: absolute;

	/* The wrapper itself should not interfere with the pointer device, only the handles should. */
	pointer-events: none;

	left: 0;
	top: 0;
}

.ck-focused .ck-widget_with-resizer.ck-widget_selected {
	& > .ck-widget__resizer {
		display: block;
	}
}

.ck .ck-widget__resizer__handle {
	position: absolute;

	/* Resizers are the only UI elements that should interfere with a pointer device. */
	pointer-events: all;

	&.ck-widget__resizer__handle-top-left,
	&.ck-widget__resizer__handle-bottom-right {
		cursor: nwse-resize;
	}

	&.ck-widget__resizer__handle-top-right,
	&.ck-widget__resizer__handle-bottom-left {
		cursor: nesw-resize;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-resizer-size: 10px;

	/* Set the resizer with a 50% offset. */
	--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);
	--ck-resizer-border-width: 1px;
}

.ck .ck-widget__resizer {
	outline: 1px solid var(--ck-color-resizer);
}

.ck .ck-widget__resizer__handle {
	width: var(--ck-resizer-size);
	height: var(--ck-resizer-size);
	background: var(--ck-color-focus-border);
	border: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);
	border-radius: var(--ck-resizer-border-radius);

	&.ck-widget__resizer__handle-top-left {
		top: var(--ck-resizer-offset);
		left: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-top-right {
		top: var(--ck-resizer-offset);
		right: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-bottom-right {
		bottom: var(--ck-resizer-offset);
		right: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-bottom-left {
		bottom: var(--ck-resizer-offset);
		left: var(--ck-resizer-offset);
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 4921: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widgettypearound.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"], names: [], mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		display: block;
		position: absolute;
		overflow: hidden;
		z-index: var(--ck-z-default);

		& svg {
			position: absolute;
			top: 50%;
			left: 50%;
			z-index: calc(var(--ck-z-default) + 2);
		}

		&.ck-widget__type-around__button_before {
			/* Place it in the middle of the outline */
			top: calc(-0.5 * var(--ck-widget-outline-thickness));
			left: min(10%, 30px);

			transform: translateY(-50%);
		}

		&.ck-widget__type-around__button_after {
			/* Place it in the middle of the outline */
			bottom: calc(-0.5 * var(--ck-widget-outline-thickness));
			right: min(10%, 30px);

			transform: translateY(50%);
		}
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		&::after {
			content: "";
			display: block;
			position: absolute;
			top: 1px;
			left: 1px;
			z-index: calc(var(--ck-z-default) + 1);
		}
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		display: none;
		position: absolute;
		left: 0;
		right: 0;
	}

	/*
	 * When the widget is hovered the "fake caret" would normally be narrower than the
	 * extra outline displayed around the widget. Let's extend the "fake caret" to match
	 * the full width of the widget.
	 */
	&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		left: calc( -1 * var(--ck-widget-outline-thickness) );
		right: calc( -1 * var(--ck-widget-outline-thickness) );
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		top: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		bottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}
}

/*
 * Integration with the read-only mode of the editor.
 */
.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the restricted editing mode (feature) of the editor.
 */
.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the #isEnabled property of the WidgetTypeAround plugin.
 */
.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-widget-type-around-button-size: 20px;
	--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);
	--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);
	--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);
	--ck-color-widget-type-around-button-radar-start-alpha: 0;
	--ck-color-widget-type-around-button-radar-end-alpha: .3;
	--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);
}

@define-mixin ck-widget-type-around-button-visible {
	opacity: 1;
	pointer-events: auto;
}

@define-mixin ck-widget-type-around-button-hidden {
	opacity: 0;
	pointer-events: none;
}

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		width: var(--ck-widget-type-around-button-size);
		height: var(--ck-widget-type-around-button-size);
		background: var(--ck-color-widget-type-around-button);
		border-radius: 100px;
		transition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		@mixin ck-widget-type-around-button-hidden;

		& svg {
			width: 10px;
			height: 8px;
			transform: translate(-50%,-50%);
			transition: transform .5s ease;
			margin-top: 1px;

			& * {
				stroke-dasharray: 10;
				stroke-dashoffset: 0;

				fill: none;
				stroke: var(--ck-color-widget-type-around-button-icon);
				stroke-width: 1.5px;
				stroke-linecap: round;
				stroke-linejoin: round;
			}

			& line {
				stroke-dasharray: 7;
			}
		}

		&:hover {
			/*
			 * Display the "sonar" around the button when hovered.
			 */
			animation: ck-widget-type-around-button-sonar 1s ease infinite;

			/*
			 * Animate active button's icon.
			 */
			& svg {
				& polyline {
					animation: ck-widget-type-around-arrow-dash 2s linear;
				}

				& line {
					animation: ck-widget-type-around-arrow-tip-dash 2s linear;
				}
			}
		}
	}

	/*
	 * Show type around buttons when the widget gets selected or being hovered.
	 */
	&.ck-widget_selected,
	&:hover {
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-visible;
		}
	}

	/*
	 * Styles for the buttons when the widget is NOT selected (but the buttons are visible
	 * and still can be hovered).
	 */
	&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {
		background: var(--ck-color-widget-type-around-button-hover);
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		background: var(--ck-color-widget-type-around-button-active);

		&::after {
			width: calc(var(--ck-widget-type-around-button-size) - 2px);
			height: calc(var(--ck-widget-type-around-button-size) - 2px);
			border-radius: 100px;
			background: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);
		}
	}

	/*
	 * Styles for the "before" button when the widget has a selection handle. Because some space
	 * is consumed by the handle, the button must be moved slightly to the right to let it breathe.
	 */
	&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {
		margin-left: 20px;
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& .ck-widget__type-around__fake-caret {
		pointer-events: none;
		height: 1px;
		animation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;

		/*
		 * The semi-transparent-outline+background combo improves the contrast
		 * when the background underneath the fake caret is dark.
		 */
		outline: solid 1px hsla(0, 0%, 100%, .5);
		background: var(--ck-color-base-text);
	}

	/*
	 * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).
	 * Despite the widget being physically selected in the model, its outline should disappear.
	 */
	&.ck-widget_selected {
		&.ck-widget_type-around_show-fake-caret_before,
		&.ck-widget_type-around_show-fake-caret_after {
			outline-color: transparent;
		}
	}

	&.ck-widget_type-around_show-fake-caret_before,
	&.ck-widget_type-around_show-fake-caret_after {
		/*
		 * When the "fake caret" is visible we simulate that the widget is not selected
		 * (despite being physically selected), so the outline color should be for the
		 * unselected widget.
		 */
		&.ck-widget_selected:hover {
			outline-color: var(--ck-color-widget-hover-border);
		}

		/*
		 * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).
		 * In this state, the type around buttons would collide with the fake carets so they should disappear.
		 */
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-hidden;
		}

		/*
		 * Fake horizontal caret integration with the selection handle. When the caret is visible, simply
		 * hide the handle because it intersects with the caret (and does not make much sense anyway).
		 */
		&.ck-widget_with-selection-handle {
			&.ck-widget_selected,
			&.ck-widget_selected:hover {
				& > .ck-widget__selection-handle {
					opacity: 0
				}
			}
		}

		/*
		 * Fake horizontal caret integration with the resize UI. When the caret is visible, simply
		 * hide the resize UI because it creates too much noise. It can be visible when the user
		 * hovers the widget, though.
		 */
		&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {
			opacity: 0
		}
	}
}

/*
 * Styles for the "before" button when the widget has a selection handle in an RTL environment.
 * The selection handler is aligned to the right side of the widget so there is no need to create
 * additional space for it next to the "before" button.
 */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {
	margin-left: 0;
	margin-right: 20px;
}

/*
 * Hide type around buttons when the widget is selected as a child of a selected
 * nested editable (e.g. mulit-cell table selection).
 *
 * See https://github.com/ckeditor/ckeditor5/issues/7263.
 */
.ck-editor__nested-editable.ck-editor__editable_selected {
	& .ck-widget {
		&.ck-widget_selected,
		&:hover {
			& > .ck-widget__type-around > .ck-widget__type-around__button {
				@mixin ck-widget-type-around-button-hidden;
			}
		}
	}
}

/*
 * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).
 */
.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {
	background: var(--ck-color-widget-type-around-button-blurred-editable);

	& svg * {
		stroke: hsl(0,0%,60%);
	}
}

@keyframes ck-widget-type-around-arrow-dash {
	0% {
		stroke-dashoffset: 10;
	}
	20%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-arrow-tip-dash {
	0%, 20% {
		stroke-dashoffset: 7;
	}
	40%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-button-sonar {
	0% {
		box-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
	50% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));
	}
	100% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
}

@keyframes ck-widget-type-around-fake-caret-pulse {
	0% {
		opacity: 1;
	}
	49% {
		opacity: 1;
	}
	50% {
		opacity: 0;
	}
	99% {
		opacity: 0;
	}
	100% {
		opacity: 1;
	}
}
`], sourceRoot: "" }]);
      const A = b;
    }, 2245: (v, x, p) => {
      p.d(x, { Z: () => A });
      var D = p(1799), y = p.n(D), C = p(2609), b = p.n(C)()(y());
      b.push([v.id, ".viur-txt-align--left{text-align:left}.viur-txt-align--right{text-align:right}.viur-txt-align--center{text-align:center}.viur-txt-align--justify{text-align:justify}.viur-txt-indent--1{margin-left:1em}.viur-txt-indent--2{margin-left:2em}.viur-txt-indent--3{margin-left:3em}.viur-txt-indent--4{margin-left:4em}.viur-txt-indent--5{margin-left:5em}.viur-txt-indent--6{margin-left:6em}.viur-txt-indent--7{margin-left:7em}.viur-txt-indent--8{margin-left:8em}.viur-txt-indent--9{margin-left:9em}.viur-txt-indent--10{margin-left:10em}", "", { version: 3, sources: ["webpack://./../viur/theme.css"], names: [], mappings: "AAKA,sBACC,eACD,CACA,uBACC,gBACD,CACA,wBACC,iBACD,CACA,yBACC,kBACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,qBACC,gBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.viur-txt-align--left{
	text-align: left;
}
.viur-txt-align--right{
	text-align: right;
}
.viur-txt-align--center{
	text-align: center;
}
.viur-txt-align--justify{
	text-align: justify;
}
.viur-txt-indent--1{
	margin-left: 1em;
}
.viur-txt-indent--2{
	margin-left: 2em;
}
.viur-txt-indent--3{
	margin-left: 3em;
}
.viur-txt-indent--4{
	margin-left: 4em;
}
.viur-txt-indent--5{
	margin-left: 5em;
}
.viur-txt-indent--6{
	margin-left: 6em;
}
.viur-txt-indent--7{
	margin-left: 7em;
}
.viur-txt-indent--8{
	margin-left: 8em;
}
.viur-txt-indent--9{
	margin-left: 9em;
}
.viur-txt-indent--10{
	margin-left: 10em;
}

`], sourceRoot: "" }]);
      const A = b;
    }, 2609: (v) => {
      v.exports = function(x) {
        var p = [];
        return p.toString = function() {
          return this.map(function(D) {
            var y = x(D);
            return D[2] ? "@media ".concat(D[2], " {").concat(y, "}") : y;
          }).join("");
        }, p.i = function(D, y, C) {
          typeof D == "string" && (D = [[null, D, ""]]);
          var b = {};
          if (C)
            for (var A = 0; A < this.length; A++) {
              var P = this[A][0];
              P != null && (b[P] = !0);
            }
          for (var R = 0; R < D.length; R++) {
            var z = [].concat(D[R]);
            C && b[z[0]] || (y && (z[2] ? z[2] = "".concat(y, " and ").concat(z[2]) : z[2] = y), p.push(z));
          }
        }, p;
      };
    }, 1799: (v) => {
      function x(D, y) {
        return function(C) {
          if (Array.isArray(C))
            return C;
        }(D) || function(C, b) {
          var A = C && (typeof Symbol < "u" && C[Symbol.iterator] || C["@@iterator"]);
          if (A != null) {
            var P, R, z = [], F = !0, L = !1;
            try {
              for (A = A.call(C); !(F = (P = A.next()).done) && (z.push(P.value), !b || z.length !== b); F = !0)
                ;
            } catch (U) {
              L = !0, R = U;
            } finally {
              try {
                F || A.return == null || A.return();
              } finally {
                if (L)
                  throw R;
              }
            }
            return z;
          }
        }(D, y) || function(C, b) {
          if (C) {
            if (typeof C == "string")
              return p(C, b);
            var A = Object.prototype.toString.call(C).slice(8, -1);
            if (A === "Object" && C.constructor && (A = C.constructor.name), A === "Map" || A === "Set")
              return Array.from(C);
            if (A === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(A))
              return p(C, b);
          }
        }(D, y) || function() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }();
      }
      function p(D, y) {
        (y == null || y > D.length) && (y = D.length);
        for (var C = 0, b = new Array(y); C < y; C++)
          b[C] = D[C];
        return b;
      }
      v.exports = function(D) {
        var y = x(D, 4), C = y[1], b = y[3];
        if (!b)
          return C;
        if (typeof btoa == "function") {
          var A = btoa(unescape(encodeURIComponent(JSON.stringify(b)))), P = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(A), R = "/*# ".concat(P, " */"), z = b.sources.map(function(F) {
            return "/*# sourceURL=".concat(b.sourceRoot || "").concat(F, " */");
          });
          return [C].concat(z).concat([R]).join(`
`);
        }
        return [C].join(`
`);
      };
    }, 6062: (v, x, p) => {
      var D, y = function() {
        return D === void 0 && (D = !!(window && document && document.all && !window.atob)), D;
      }, C = /* @__PURE__ */ function() {
        var ee = {};
        return function(de) {
          if (ee[de] === void 0) {
            var I = document.querySelector(de);
            if (window.HTMLIFrameElement && I instanceof window.HTMLIFrameElement)
              try {
                I = I.contentDocument.head;
              } catch {
                I = null;
              }
            ee[de] = I;
          }
          return ee[de];
        };
      }(), b = [];
      function A(ee) {
        for (var de = -1, I = 0; I < b.length; I++)
          if (b[I].identifier === ee) {
            de = I;
            break;
          }
        return de;
      }
      function P(ee, de) {
        for (var I = {}, ne = [], He = 0; He < ee.length; He++) {
          var Ke = ee[He], Me = de.base ? Ke[0] + de.base : Ke[0], Yt = I[Me] || 0, At = "".concat(Me, " ").concat(Yt);
          I[Me] = Yt + 1;
          var Tt = A(At), Ut = { css: Ke[1], media: Ke[2], sourceMap: Ke[3] };
          Tt !== -1 ? (b[Tt].references++, b[Tt].updater(Ut)) : b.push({ identifier: At, updater: ce(Ut, de), references: 1 }), ne.push(At);
        }
        return ne;
      }
      function R(ee) {
        var de = document.createElement("style"), I = ee.attributes || {};
        if (I.nonce === void 0) {
          var ne = p.nc;
          ne && (I.nonce = ne);
        }
        if (Object.keys(I).forEach(function(Ke) {
          de.setAttribute(Ke, I[Ke]);
        }), typeof ee.insert == "function")
          ee.insert(de);
        else {
          var He = C(ee.insert || "head");
          if (!He)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          He.appendChild(de);
        }
        return de;
      }
      var z, F = (z = [], function(ee, de) {
        return z[ee] = de, z.filter(Boolean).join(`
`);
      });
      function L(ee, de, I, ne) {
        var He = I ? "" : ne.media ? "@media ".concat(ne.media, " {").concat(ne.css, "}") : ne.css;
        if (ee.styleSheet)
          ee.styleSheet.cssText = F(de, He);
        else {
          var Ke = document.createTextNode(He), Me = ee.childNodes;
          Me[de] && ee.removeChild(Me[de]), Me.length ? ee.insertBefore(Ke, Me[de]) : ee.appendChild(Ke);
        }
      }
      function U(ee, de, I) {
        var ne = I.css, He = I.media, Ke = I.sourceMap;
        if (He ? ee.setAttribute("media", He) : ee.removeAttribute("media"), Ke && typeof btoa < "u" && (ne += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(Ke)))), " */")), ee.styleSheet)
          ee.styleSheet.cssText = ne;
        else {
          for (; ee.firstChild; )
            ee.removeChild(ee.firstChild);
          ee.appendChild(document.createTextNode(ne));
        }
      }
      var J = null, ie = 0;
      function ce(ee, de) {
        var I, ne, He;
        if (de.singleton) {
          var Ke = ie++;
          I = J || (J = R(de)), ne = L.bind(null, I, Ke, !1), He = L.bind(null, I, Ke, !0);
        } else
          I = R(de), ne = U.bind(null, I, de), He = function() {
            (function(Me) {
              if (Me.parentNode === null)
                return !1;
              Me.parentNode.removeChild(Me);
            })(I);
          };
        return ne(ee), function(Me) {
          if (Me) {
            if (Me.css === ee.css && Me.media === ee.media && Me.sourceMap === ee.sourceMap)
              return;
            ne(ee = Me);
          } else
            He();
        };
      }
      v.exports = function(ee, de) {
        (de = de || {}).singleton || typeof de.singleton == "boolean" || (de.singleton = y());
        var I = P(ee = ee || [], de);
        return function(ne) {
          if (ne = ne || [], Object.prototype.toString.call(ne) === "[object Array]") {
            for (var He = 0; He < I.length; He++) {
              var Ke = A(I[He]);
              b[Ke].references--;
            }
            for (var Me = P(ne, de), Yt = 0; Yt < I.length; Yt++) {
              var At = A(I[Yt]);
              b[At].references === 0 && (b[At].updater(), b.splice(At, 1));
            }
            I = Me;
          }
        };
      };
    } }, w = {};
    function k(v) {
      var x = w[v];
      if (x !== void 0)
        return x.exports;
      var p = w[v] = { id: v, exports: {} };
      return g[v](p, p.exports, k), p.exports;
    }
    k.n = (v) => {
      var x = v && v.__esModule ? () => v.default : () => v;
      return k.d(x, { a: x }), x;
    }, k.d = (v, x) => {
      for (var p in x)
        k.o(x, p) && !k.o(v, p) && Object.defineProperty(v, p, { enumerable: !0, get: x[p] });
    }, k.g = function() {
      if (typeof globalThis == "object")
        return globalThis;
      try {
        return this || new Function("return this")();
      } catch {
        if (typeof window == "object")
          return window;
      }
    }(), k.o = (v, x) => Object.prototype.hasOwnProperty.call(v, x), k.nc = void 0;
    var S = {};
    return (() => {
      function v({ emitter: o, activator: e, callback: t, contextElements: n }) {
        o.listenTo(document, "mousedown", (i, r) => {
          if (!e())
            return;
          const s = typeof r.composedPath == "function" ? r.composedPath() : [], a = typeof n == "function" ? n() : n;
          for (const l of a)
            if (l.contains(r.target) || s.includes(l))
              return;
          t();
        });
      }
      function x(o) {
        return class extends o {
          disableCssTransitions() {
            this._isCssTransitionsDisabled = !0;
          }
          enableCssTransitions() {
            this._isCssTransitionsDisabled = !1;
          }
          constructor(...e) {
            super(...e), this.set("_isCssTransitionsDisabled", !1), this.initializeCssTransitionDisablerMixin();
          }
          initializeCssTransitionDisablerMixin() {
            this.extendTemplate({ attributes: { class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")] } });
          }
        };
      }
      function p({ view: o }) {
        o.listenTo(o.element, "submit", (e, t) => {
          t.preventDefault(), o.fire("submit");
        }, { useCapture: !0 });
      }
      k.d(S, { default: () => lc });
      const D = function() {
        try {
          return navigator.userAgent.toLowerCase();
        } catch {
          return "";
        }
      }(), y = { isMac: A(D), isWindows: (C = D, C.indexOf("windows") > -1), isGecko: function(o) {
        return !!o.match(/gecko\/\d+/);
      }(D), isSafari: function(o) {
        return o.indexOf(" applewebkit/") > -1 && o.indexOf("chrome") === -1;
      }(D), isiOS: function(o) {
        return !!o.match(/iphone|ipad/i) || A(o) && navigator.maxTouchPoints > 0;
      }(D), isAndroid: function(o) {
        return o.indexOf("android") > -1;
      }(D), isBlink: function(o) {
        return o.indexOf("chrome/") > -1 && o.indexOf("edge/") < 0;
      }(D), features: { isRegExpUnicodePropertySupported: function() {
        let o = !1;
        try {
          o = "ć".search(new RegExp("[\\p{L}]", "u")) === 0;
        } catch {
        }
        return o;
      }() } };
      var C;
      const b = y;
      function A(o) {
        return o.indexOf("macintosh") > -1;
      }
      function P(o, e, t, n) {
        t = t || function(l, d) {
          return l === d;
        };
        const i = Array.isArray(o) ? o : Array.prototype.slice.call(o), r = Array.isArray(e) ? e : Array.prototype.slice.call(e), s = function(l, d, h) {
          const m = R(l, d, h);
          if (m === -1)
            return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
          const f = z(l, m), _ = z(d, m), E = R(f, _, h), B = l.length - E, T = d.length - E;
          return { firstIndex: m, lastIndexOld: B, lastIndexNew: T };
        }(i, r, t);
        return n ? function(l, d) {
          const { firstIndex: h, lastIndexOld: m, lastIndexNew: f } = l;
          if (h === -1)
            return Array(d).fill("equal");
          let _ = [];
          return h > 0 && (_ = _.concat(Array(h).fill("equal"))), f - h > 0 && (_ = _.concat(Array(f - h).fill("insert"))), m - h > 0 && (_ = _.concat(Array(m - h).fill("delete"))), f < d && (_ = _.concat(Array(d - f).fill("equal"))), _;
        }(s, r.length) : function(l, d) {
          const h = [], { firstIndex: m, lastIndexOld: f, lastIndexNew: _ } = d;
          return _ - m > 0 && h.push({ index: m, type: "insert", values: l.slice(m, _) }), f - m > 0 && h.push({ index: m + (_ - m), type: "delete", howMany: f - m }), h;
        }(r, s);
      }
      function R(o, e, t) {
        for (let n = 0; n < Math.max(o.length, e.length); n++)
          if (o[n] === void 0 || e[n] === void 0 || !t(o[n], e[n]))
            return n;
        return -1;
      }
      function z(o, e) {
        return o.slice(e).reverse();
      }
      function F(o, e, t) {
        t = t || function(B, T) {
          return B === T;
        };
        const n = o.length, i = e.length;
        if (n > 200 || i > 200 || n + i > 300)
          return F.fastDiff(o, e, t, !0);
        let r, s;
        if (i < n) {
          const B = o;
          o = e, e = B, r = "delete", s = "insert";
        } else
          r = "insert", s = "delete";
        const a = o.length, l = e.length, d = l - a, h = {}, m = {};
        function f(B) {
          const T = (m[B - 1] !== void 0 ? m[B - 1] : -1) + 1, O = m[B + 1] !== void 0 ? m[B + 1] : -1, N = T > O ? -1 : 1;
          h[B + N] && (h[B] = h[B + N].slice(0)), h[B] || (h[B] = []), h[B].push(T > O ? r : s);
          let H = Math.max(T, O), X = H - B;
          for (; X < a && H < l && t(o[X], e[H]); )
            X++, H++, h[B].push("equal");
          return H;
        }
        let _, E = 0;
        do {
          for (_ = -E; _ < d; _++)
            m[_] = f(_);
          for (_ = d + E; _ > d; _--)
            m[_] = f(_);
          m[d] = f(d), E++;
        } while (m[d] !== l);
        return h[d].slice(1);
      }
      F.fastDiff = P;
      const L = function() {
        return function o() {
          o.called = !0;
        };
      };
      class U {
        constructor(e, t) {
          this.source = e, this.name = t, this.path = [], this.stop = L(), this.off = L();
        }
      }
      const J = new Array(256).fill("").map((o, e) => ("0" + e.toString(16)).slice(-2));
      function ie() {
        const o = 4294967296 * Math.random() >>> 0, e = 4294967296 * Math.random() >>> 0, t = 4294967296 * Math.random() >>> 0, n = 4294967296 * Math.random() >>> 0;
        return "e" + J[o >> 0 & 255] + J[o >> 8 & 255] + J[o >> 16 & 255] + J[o >> 24 & 255] + J[e >> 0 & 255] + J[e >> 8 & 255] + J[e >> 16 & 255] + J[e >> 24 & 255] + J[t >> 0 & 255] + J[t >> 8 & 255] + J[t >> 16 & 255] + J[t >> 24 & 255] + J[n >> 0 & 255] + J[n >> 8 & 255] + J[n >> 16 & 255] + J[n >> 24 & 255];
      }
      const ce = { get(o = "normal") {
        return typeof o != "number" ? this[o] || this.normal : o;
      }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5 };
      function ee(o, e) {
        const t = ce.get(e.priority);
        for (let n = 0; n < o.length; n++)
          if (ce.get(o[n].priority) < t)
            return void o.splice(n, 0, e);
        o.push(e);
      }
      const de = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
      class I extends Error {
        constructor(e, t, n) {
          super(function(i, r) {
            const s = /* @__PURE__ */ new WeakSet(), a = (h, m) => {
              if (typeof m == "object" && m !== null) {
                if (s.has(m))
                  return `[object ${m.constructor.name}]`;
                s.add(m);
              }
              return m;
            }, l = r ? ` ${JSON.stringify(r, a)}` : "", d = He(i);
            return i + l + d;
          }(e, n)), this.name = "CKEditorError", this.context = t, this.data = n;
        }
        is(e) {
          return e === "CKEditorError";
        }
        static rethrowUnexpectedError(e, t) {
          if (e.is && e.is("CKEditorError"))
            throw e;
          const n = new I(e.message, t);
          throw n.stack = e.stack, n;
        }
      }
      function ne(o, e) {
        console.warn(...Ke(o, e));
      }
      function He(o) {
        return `
Read more: ${de}#error-${o}`;
      }
      function Ke(o, e) {
        const t = He(o);
        return e ? [o, e, t] : [o, t];
      }
      const Me = "38.0.1", Yt = new Date(2023, 4, 23), At = typeof window == "object" ? window : k.g;
      if (At.CKEDITOR_VERSION)
        throw new I("ckeditor-duplicated-modules", null);
      At.CKEDITOR_VERSION = Me;
      const Tt = Symbol("listeningTo"), Ut = Symbol("emitterId"), Pt = Symbol("delegations"), gr = De(Object);
      function De(o) {
        return o ? class extends o {
          on(e, t, n) {
            this.listenTo(this, e, t, n);
          }
          once(e, t, n) {
            let i = !1;
            this.listenTo(this, e, (r, ...s) => {
              i || (i = !0, r.off(), t.call(this, r, ...s));
            }, n);
          }
          off(e, t) {
            this.stopListening(this, e, t);
          }
          listenTo(e, t, n, i = {}) {
            let r, s;
            this[Tt] || (this[Tt] = {});
            const a = this[Tt];
            Hn(e) || pi(e);
            const l = Hn(e);
            (r = a[l]) || (r = a[l] = { emitter: e, callbacks: {} }), (s = r.callbacks[t]) || (s = r.callbacks[t] = []), s.push(n), function(d, h, m, f, _) {
              h._addEventListener ? h._addEventListener(m, f, _) : d._addEventListener.call(h, m, f, _);
            }(this, e, t, n, i);
          }
          stopListening(e, t, n) {
            const i = this[Tt];
            let r = e && Hn(e);
            const s = i && r ? i[r] : void 0, a = s && t ? s.callbacks[t] : void 0;
            if (!(!i || e && !s || t && !a))
              if (n)
                V(this, e, t, n), a.indexOf(n) !== -1 && (a.length === 1 ? delete s.callbacks[t] : V(this, e, t, n));
              else if (a) {
                for (; n = a.pop(); )
                  V(this, e, t, n);
                delete s.callbacks[t];
              } else if (s) {
                for (t in s.callbacks)
                  this.stopListening(e, t);
                delete i[r];
              } else {
                for (r in i)
                  this.stopListening(i[r].emitter);
                delete this[Tt];
              }
          }
          fire(e, ...t) {
            try {
              const n = e instanceof U ? e : new U(this, e), i = n.name;
              let r = fi(this, i);
              if (n.path.push(this), r) {
                const a = [n, ...t];
                r = Array.from(r);
                for (let l = 0; l < r.length && (r[l].callback.apply(this, a), n.off.called && (delete n.off.called, this._removeEventListener(i, r[l].callback)), !n.stop.called); l++)
                  ;
              }
              const s = this[Pt];
              if (s) {
                const a = s.get(i), l = s.get("*");
                a && dn(a, n, t), l && dn(l, n, t);
              }
              return n.return;
            } catch (n) {
              I.rethrowUnexpectedError(n, this);
            }
          }
          delegate(...e) {
            return { to: (t, n) => {
              this[Pt] || (this[Pt] = /* @__PURE__ */ new Map()), e.forEach((i) => {
                const r = this[Pt].get(i);
                r ? r.set(t, n) : this[Pt].set(i, /* @__PURE__ */ new Map([[t, n]]));
              });
            } };
          }
          stopDelegating(e, t) {
            if (this[Pt])
              if (e)
                if (t) {
                  const n = this[Pt].get(e);
                  n && n.delete(t);
                } else
                  this[Pt].delete(e);
              else
                this[Pt].clear();
          }
          _addEventListener(e, t, n) {
            (function(s, a) {
              const l = xo(s);
              if (l[a])
                return;
              let d = a, h = null;
              const m = [];
              for (; d !== "" && !l[d]; )
                l[d] = { callbacks: [], childEvents: [] }, m.push(l[d]), h && l[d].childEvents.push(h), h = d, d = d.substr(0, d.lastIndexOf(":"));
              if (d !== "") {
                for (const f of m)
                  f.callbacks = l[d].callbacks.slice();
                l[d].childEvents.push(h);
              }
            })(this, e);
            const i = xn(this, e), r = { callback: t, priority: ce.get(n.priority) };
            for (const s of i)
              ee(s, r);
          }
          _removeEventListener(e, t) {
            const n = xn(this, e);
            for (const i of n)
              for (let r = 0; r < i.length; r++)
                i[r].callback == t && (i.splice(r, 1), r--);
          }
        } : gr;
      }
      function pi(o, e) {
        o[Ut] || (o[Ut] = e || ie());
      }
      function Hn(o) {
        return o[Ut];
      }
      function xo(o) {
        return o._events || Object.defineProperty(o, "_events", { value: {} }), o._events;
      }
      function xn(o, e) {
        const t = xo(o)[e];
        if (!t)
          return [];
        let n = [t.callbacks];
        for (let i = 0; i < t.childEvents.length; i++) {
          const r = xn(o, t.childEvents[i]);
          n = n.concat(r);
        }
        return n;
      }
      function fi(o, e) {
        let t;
        return o._events && (t = o._events[e]) && t.callbacks.length ? t.callbacks : e.indexOf(":") > -1 ? fi(o, e.substr(0, e.lastIndexOf(":"))) : null;
      }
      function dn(o, e, t) {
        for (let [n, i] of o) {
          i ? typeof i == "function" && (i = i(e.name)) : i = e.name;
          const r = new U(e.source, i);
          r.path = [...e.path], n.fire(r, ...t);
        }
      }
      function V(o, e, t, n) {
        e._removeEventListener ? e._removeEventListener(t, n) : o._removeEventListener.call(e, t, n);
      }
      ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
        De[o] = gr.prototype[o];
      });
      const K = function(o) {
        var e = typeof o;
        return o != null && (e == "object" || e == "function");
      }, Y = Symbol("observableProperties"), te = Symbol("boundObservables"), ke = Symbol("boundProperties"), Ve = Symbol("decoratedMethods"), ge = Symbol("decoratedOriginal"), ue = oe(De());
      function oe(o) {
        return o ? class extends o {
          set(e, t) {
            if (K(e))
              return void Object.keys(e).forEach((i) => {
                this.set(i, e[i]);
              }, this);
            qt(this);
            const n = this[Y];
            if (e in this && !n.has(e))
              throw new I("observable-set-cannot-override", this);
            Object.defineProperty(this, e, { enumerable: !0, configurable: !0, get: () => n.get(e), set(i) {
              const r = n.get(e);
              let s = this.fire(`set:${e}`, e, i, r);
              s === void 0 && (s = i), r === s && n.has(e) || (n.set(e, s), this.fire(`change:${e}`, e, s, r));
            } }), this[e] = t;
          }
          bind(...e) {
            if (!e.length || !Wc(e))
              throw new I("observable-bind-wrong-properties", this);
            if (new Set(e).size !== e.length)
              throw new I("observable-bind-duplicate-properties", this);
            qt(this);
            const t = this[ke];
            e.forEach((i) => {
              if (t.has(i))
                throw new I("observable-bind-rebind", this);
            });
            const n = /* @__PURE__ */ new Map();
            return e.forEach((i) => {
              const r = { property: i, to: [] };
              t.set(i, r), n.set(i, r);
            }), { to: pt, toMany: b0, _observable: this, _bindProperties: e, _to: [], _bindings: n };
          }
          unbind(...e) {
            if (!this[Y])
              return;
            const t = this[ke], n = this[te];
            if (e.length) {
              if (!Wc(e))
                throw new I("observable-unbind-wrong-properties", this);
              e.forEach((i) => {
                const r = t.get(i);
                r && (r.to.forEach(([s, a]) => {
                  const l = n.get(s), d = l[a];
                  d.delete(r), d.size || delete l[a], Object.keys(l).length || (n.delete(s), this.stopListening(s, "change"));
                }), t.delete(i));
              });
            } else
              n.forEach((i, r) => {
                this.stopListening(r, "change");
              }), n.clear(), t.clear();
          }
          decorate(e) {
            qt(this);
            const t = this[e];
            if (!t)
              throw new I("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: e });
            this.on(e, (n, i) => {
              n.return = t.apply(this, i);
            }), this[e] = function(...n) {
              return this.fire(e, n);
            }, this[e][ge] = t, this[Ve] || (this[Ve] = []), this[Ve].push(e);
          }
          stopListening(e, t, n) {
            if (!e && this[Ve]) {
              for (const i of this[Ve])
                this[i] = this[i][ge];
              delete this[Ve];
            }
            super.stopListening(e, t, n);
          }
        } : ue;
      }
      function qt(o) {
        o[Y] || (Object.defineProperty(o, Y, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(o, te, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(o, ke, { value: /* @__PURE__ */ new Map() }));
      }
      function pt(...o) {
        const e = function(...r) {
          if (!r.length)
            throw new I("observable-bind-to-parse-error", null);
          const s = { to: [] };
          let a;
          return typeof r[r.length - 1] == "function" && (s.callback = r.pop()), r.forEach((l) => {
            if (typeof l == "string")
              a.properties.push(l);
            else {
              if (typeof l != "object")
                throw new I("observable-bind-to-parse-error", null);
              a = { observable: l, properties: [] }, s.to.push(a);
            }
          }), s;
        }(...o), t = Array.from(this._bindings.keys()), n = t.length;
        if (!e.callback && e.to.length > 1)
          throw new I("observable-bind-to-no-callback", this);
        if (n > 1 && e.callback)
          throw new I("observable-bind-to-extra-callback", this);
        var i;
        e.to.forEach((r) => {
          if (r.properties.length && r.properties.length !== n)
            throw new I("observable-bind-to-properties-length", this);
          r.properties.length || (r.properties = this._bindProperties);
        }), this._to = e.to, e.callback && (this._bindings.get(t[0]).callback = e.callback), i = this._observable, this._to.forEach((r) => {
          const s = i[te];
          let a;
          s.get(r.observable) || i.listenTo(r.observable, "change", (l, d) => {
            a = s.get(r.observable)[d], a && a.forEach((h) => {
              Gc(i, h.property);
            });
          });
        }), function(r) {
          let s;
          r._bindings.forEach((a, l) => {
            r._to.forEach((d) => {
              s = d.properties[a.callback ? 0 : r._bindProperties.indexOf(l)], a.to.push([d.observable, s]), function(h, m, f, _) {
                const E = h[te], B = E.get(f), T = B || {};
                T[_] || (T[_] = /* @__PURE__ */ new Set()), T[_].add(m), B || E.set(f, T);
              }(r._observable, a, d.observable, s);
            });
          });
        }(this), this._bindProperties.forEach((r) => {
          Gc(this._observable, r);
        });
      }
      function b0(o, e, t) {
        if (this._bindings.size > 1)
          throw new I("observable-bind-to-many-not-one-binding", this);
        this.to(...function(n, i) {
          const r = n.map((s) => [s, i]);
          return Array.prototype.concat.apply([], r);
        }(o, e), t);
      }
      function Wc(o) {
        return o.every((e) => typeof e == "string");
      }
      function Gc(o, e) {
        const t = o[ke].get(e);
        let n;
        t.callback ? n = t.callback.apply(o, t.to.map((i) => i[0][i[1]])) : (n = t.to[0], n = n[0][n[1]]), Object.prototype.hasOwnProperty.call(o, e) ? o[e] = n : o.set(e, n);
      }
      ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
        oe[o] = ue.prototype[o];
      });
      class Kc {
        constructor() {
          this._replacedElements = [];
        }
        replace(e, t) {
          this._replacedElements.push({ element: e, newElement: t }), e.style.display = "none", t && e.parentNode.insertBefore(t, e.nextSibling);
        }
        restore() {
          this._replacedElements.forEach(({ element: e, newElement: t }) => {
            e.style.display = "", t && t.remove();
          }), this._replacedElements = [];
        }
      }
      function Fs(o) {
        let e = 0;
        for (const t of o)
          e++;
        return e;
      }
      function vt(o, e) {
        const t = Math.min(o.length, e.length);
        for (let n = 0; n < t; n++)
          if (o[n] != e[n])
            return n;
        return o.length == e.length ? "same" : o.length < e.length ? "prefix" : "extension";
      }
      function It(o) {
        return !(!o || !o[Symbol.iterator]);
      }
      const Zc = typeof ys == "object" && ys && ys.Object === Object && ys;
      var k0 = typeof self == "object" && self && self.Object === Object && self;
      const Wt = Zc || k0 || Function("return this")(), Qt = Wt.Symbol;
      var Jc = Object.prototype, w0 = Jc.hasOwnProperty, v0 = Jc.toString, bi = Qt ? Qt.toStringTag : void 0;
      const _0 = function(o) {
        var e = w0.call(o, bi), t = o[bi];
        try {
          o[bi] = void 0;
          var n = !0;
        } catch {
        }
        var i = v0.call(o);
        return n && (e ? o[bi] = t : delete o[bi]), i;
      };
      var A0 = Object.prototype.toString;
      const C0 = function(o) {
        return A0.call(o);
      };
      var Yc = Qt ? Qt.toStringTag : void 0;
      const Sn = function(o) {
        return o == null ? o === void 0 ? "[object Undefined]" : "[object Null]" : Yc && Yc in Object(o) ? _0(o) : C0(o);
      }, _t = Array.isArray, Lt = function(o) {
        return o != null && typeof o == "object";
      }, Qc = function(o) {
        return typeof o == "string" || !_t(o) && Lt(o) && Sn(o) == "[object String]";
      };
      function $s(o, e, t = {}, n = []) {
        const i = t && t.xmlns, r = i ? o.createElementNS(i, e) : o.createElement(e);
        for (const s in t)
          r.setAttribute(s, t[s]);
        !Qc(n) && It(n) || (n = [n]);
        for (let s of n)
          Qc(s) && (s = o.createTextNode(s)), r.appendChild(s);
        return r;
      }
      const Xc = function(o, e) {
        return function(t) {
          return o(e(t));
        };
      }, Ls = Xc(Object.getPrototypeOf, Object);
      var y0 = Function.prototype, E0 = Object.prototype, ed = y0.toString, x0 = E0.hasOwnProperty, S0 = ed.call(Object);
      const Ct = function(o) {
        if (!Lt(o) || Sn(o) != "[object Object]")
          return !1;
        var e = Ls(o);
        if (e === null)
          return !0;
        var t = x0.call(e, "constructor") && e.constructor;
        return typeof t == "function" && t instanceof t && ed.call(t) == S0;
      }, D0 = function() {
        this.__data__ = [], this.size = 0;
      }, ki = function(o, e) {
        return o === e || o != o && e != e;
      }, mr = function(o, e) {
        for (var t = o.length; t--; )
          if (ki(o[t][0], e))
            return t;
        return -1;
      };
      var B0 = Array.prototype.splice;
      const T0 = function(o) {
        var e = this.__data__, t = mr(e, o);
        return !(t < 0) && (t == e.length - 1 ? e.pop() : B0.call(e, t, 1), --this.size, !0);
      }, P0 = function(o) {
        var e = this.__data__, t = mr(e, o);
        return t < 0 ? void 0 : e[t][1];
      }, I0 = function(o) {
        return mr(this.__data__, o) > -1;
      }, O0 = function(o, e) {
        var t = this.__data__, n = mr(t, o);
        return n < 0 ? (++this.size, t.push([o, e])) : t[n][1] = e, this;
      };
      function So(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.clear(); ++e < t; ) {
          var n = o[e];
          this.set(n[0], n[1]);
        }
      }
      So.prototype.clear = D0, So.prototype.delete = T0, So.prototype.get = P0, So.prototype.has = I0, So.prototype.set = O0;
      const pr = So, R0 = function() {
        this.__data__ = new pr(), this.size = 0;
      }, z0 = function(o) {
        var e = this.__data__, t = e.delete(o);
        return this.size = e.size, t;
      }, M0 = function(o) {
        return this.__data__.get(o);
      }, N0 = function(o) {
        return this.__data__.has(o);
      }, Un = function(o) {
        if (!K(o))
          return !1;
        var e = Sn(o);
        return e == "[object Function]" || e == "[object GeneratorFunction]" || e == "[object AsyncFunction]" || e == "[object Proxy]";
      }, Vs = Wt["__core-js_shared__"];
      var td = function() {
        var o = /[^.]+$/.exec(Vs && Vs.keys && Vs.keys.IE_PROTO || "");
        return o ? "Symbol(src)_1." + o : "";
      }();
      const F0 = function(o) {
        return !!td && td in o;
      };
      var $0 = Function.prototype.toString;
      const qn = function(o) {
        if (o != null) {
          try {
            return $0.call(o);
          } catch {
          }
          try {
            return o + "";
          } catch {
          }
        }
        return "";
      };
      var L0 = /^\[object .+?Constructor\]$/, V0 = Function.prototype, j0 = Object.prototype, H0 = V0.toString, U0 = j0.hasOwnProperty, q0 = RegExp("^" + H0.call(U0).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      const W0 = function(o) {
        return !(!K(o) || F0(o)) && (Un(o) ? q0 : L0).test(qn(o));
      }, G0 = function(o, e) {
        return o == null ? void 0 : o[e];
      }, Wn = function(o, e) {
        var t = G0(o, e);
        return W0(t) ? t : void 0;
      }, wi = Wn(Wt, "Map"), vi = Wn(Object, "create"), K0 = function() {
        this.__data__ = vi ? vi(null) : {}, this.size = 0;
      }, Z0 = function(o) {
        var e = this.has(o) && delete this.__data__[o];
        return this.size -= e ? 1 : 0, e;
      };
      var J0 = Object.prototype.hasOwnProperty;
      const Y0 = function(o) {
        var e = this.__data__;
        if (vi) {
          var t = e[o];
          return t === "__lodash_hash_undefined__" ? void 0 : t;
        }
        return J0.call(e, o) ? e[o] : void 0;
      };
      var Q0 = Object.prototype.hasOwnProperty;
      const X0 = function(o) {
        var e = this.__data__;
        return vi ? e[o] !== void 0 : Q0.call(e, o);
      }, ev = function(o, e) {
        var t = this.__data__;
        return this.size += this.has(o) ? 0 : 1, t[o] = vi && e === void 0 ? "__lodash_hash_undefined__" : e, this;
      };
      function Do(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.clear(); ++e < t; ) {
          var n = o[e];
          this.set(n[0], n[1]);
        }
      }
      Do.prototype.clear = K0, Do.prototype.delete = Z0, Do.prototype.get = Y0, Do.prototype.has = X0, Do.prototype.set = ev;
      const nd = Do, tv = function() {
        this.size = 0, this.__data__ = { hash: new nd(), map: new (wi || pr)(), string: new nd() };
      }, nv = function(o) {
        var e = typeof o;
        return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? o !== "__proto__" : o === null;
      }, fr = function(o, e) {
        var t = o.__data__;
        return nv(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
      }, ov = function(o) {
        var e = fr(this, o).delete(o);
        return this.size -= e ? 1 : 0, e;
      }, iv = function(o) {
        return fr(this, o).get(o);
      }, rv = function(o) {
        return fr(this, o).has(o);
      }, sv = function(o, e) {
        var t = fr(this, o), n = t.size;
        return t.set(o, e), this.size += t.size == n ? 0 : 1, this;
      };
      function Bo(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.clear(); ++e < t; ) {
          var n = o[e];
          this.set(n[0], n[1]);
        }
      }
      Bo.prototype.clear = tv, Bo.prototype.delete = ov, Bo.prototype.get = iv, Bo.prototype.has = rv, Bo.prototype.set = sv;
      const br = Bo, av = function(o, e) {
        var t = this.__data__;
        if (t instanceof pr) {
          var n = t.__data__;
          if (!wi || n.length < 199)
            return n.push([o, e]), this.size = ++t.size, this;
          t = this.__data__ = new br(n);
        }
        return t.set(o, e), this.size = t.size, this;
      };
      function To(o) {
        var e = this.__data__ = new pr(o);
        this.size = e.size;
      }
      To.prototype.clear = R0, To.prototype.delete = z0, To.prototype.get = M0, To.prototype.has = N0, To.prototype.set = av;
      const _i = To, lv = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length; ++t < n && e(o[t], t, o) !== !1; )
          ;
        return o;
      }, kr = function() {
        try {
          var o = Wn(Object, "defineProperty");
          return o({}, "", {}), o;
        } catch {
        }
      }(), js = function(o, e, t) {
        e == "__proto__" && kr ? kr(o, e, { configurable: !0, enumerable: !0, value: t, writable: !0 }) : o[e] = t;
      };
      var cv = Object.prototype.hasOwnProperty;
      const Hs = function(o, e, t) {
        var n = o[e];
        cv.call(o, e) && ki(n, t) && (t !== void 0 || e in o) || js(o, e, t);
      }, Po = function(o, e, t, n) {
        var i = !t;
        t || (t = {});
        for (var r = -1, s = e.length; ++r < s; ) {
          var a = e[r], l = n ? n(t[a], o[a], a, t, o) : void 0;
          l === void 0 && (l = o[a]), i ? js(t, a, l) : Hs(t, a, l);
        }
        return t;
      }, dv = function(o, e) {
        for (var t = -1, n = Array(o); ++t < o; )
          n[t] = e(t);
        return n;
      }, od = function(o) {
        return Lt(o) && Sn(o) == "[object Arguments]";
      };
      var id = Object.prototype, uv = id.hasOwnProperty, hv = id.propertyIsEnumerable;
      const Us = od(/* @__PURE__ */ function() {
        return arguments;
      }()) ? od : function(o) {
        return Lt(o) && uv.call(o, "callee") && !hv.call(o, "callee");
      }, gv = function() {
        return !1;
      };
      var rd = u && !u.nodeType && u, sd = rd && !0 && c && !c.nodeType && c, ad = sd && sd.exports === rd ? Wt.Buffer : void 0;
      const Ai = (ad ? ad.isBuffer : void 0) || gv;
      var mv = /^(?:0|[1-9]\d*)$/;
      const qs = function(o, e) {
        var t = typeof o;
        return !!(e = e ?? 9007199254740991) && (t == "number" || t != "symbol" && mv.test(o)) && o > -1 && o % 1 == 0 && o < e;
      }, ld = function(o) {
        return typeof o == "number" && o > -1 && o % 1 == 0 && o <= 9007199254740991;
      };
      var We = {};
      We["[object Float32Array]"] = We["[object Float64Array]"] = We["[object Int8Array]"] = We["[object Int16Array]"] = We["[object Int32Array]"] = We["[object Uint8Array]"] = We["[object Uint8ClampedArray]"] = We["[object Uint16Array]"] = We["[object Uint32Array]"] = !0, We["[object Arguments]"] = We["[object Array]"] = We["[object ArrayBuffer]"] = We["[object Boolean]"] = We["[object DataView]"] = We["[object Date]"] = We["[object Error]"] = We["[object Function]"] = We["[object Map]"] = We["[object Number]"] = We["[object Object]"] = We["[object RegExp]"] = We["[object Set]"] = We["[object String]"] = We["[object WeakMap]"] = !1;
      const pv = function(o) {
        return Lt(o) && ld(o.length) && !!We[Sn(o)];
      }, wr = function(o) {
        return function(e) {
          return o(e);
        };
      };
      var cd = u && !u.nodeType && u, Ci = cd && !0 && c && !c.nodeType && c, Ws = Ci && Ci.exports === cd && Zc.process;
      const Io = function() {
        try {
          var o = Ci && Ci.require && Ci.require("util").types;
          return o || Ws && Ws.binding && Ws.binding("util");
        } catch {
        }
      }();
      var dd = Io && Io.isTypedArray;
      const Gs = dd ? wr(dd) : pv;
      var fv = Object.prototype.hasOwnProperty;
      const ud = function(o, e) {
        var t = _t(o), n = !t && Us(o), i = !t && !n && Ai(o), r = !t && !n && !i && Gs(o), s = t || n || i || r, a = s ? dv(o.length, String) : [], l = a.length;
        for (var d in o)
          !e && !fv.call(o, d) || s && (d == "length" || i && (d == "offset" || d == "parent") || r && (d == "buffer" || d == "byteLength" || d == "byteOffset") || qs(d, l)) || a.push(d);
        return a;
      };
      var bv = Object.prototype;
      const Ks = function(o) {
        var e = o && o.constructor;
        return o === (typeof e == "function" && e.prototype || bv);
      }, kv = Xc(Object.keys, Object);
      var wv = Object.prototype.hasOwnProperty;
      const vv = function(o) {
        if (!Ks(o))
          return kv(o);
        var e = [];
        for (var t in Object(o))
          wv.call(o, t) && t != "constructor" && e.push(t);
        return e;
      }, vr = function(o) {
        return o != null && ld(o.length) && !Un(o);
      }, Zs = function(o) {
        return vr(o) ? ud(o) : vv(o);
      }, _v = function(o, e) {
        return o && Po(e, Zs(e), o);
      }, Av = function(o) {
        var e = [];
        if (o != null)
          for (var t in Object(o))
            e.push(t);
        return e;
      };
      var Cv = Object.prototype.hasOwnProperty;
      const yv = function(o) {
        if (!K(o))
          return Av(o);
        var e = Ks(o), t = [];
        for (var n in o)
          (n != "constructor" || !e && Cv.call(o, n)) && t.push(n);
        return t;
      }, Oo = function(o) {
        return vr(o) ? ud(o, !0) : yv(o);
      }, Ev = function(o, e) {
        return o && Po(e, Oo(e), o);
      };
      var hd = u && !u.nodeType && u, gd = hd && !0 && c && !c.nodeType && c, md = gd && gd.exports === hd ? Wt.Buffer : void 0, pd = md ? md.allocUnsafe : void 0;
      const fd = function(o, e) {
        if (e)
          return o.slice();
        var t = o.length, n = pd ? pd(t) : new o.constructor(t);
        return o.copy(n), n;
      }, Js = function(o, e) {
        var t = -1, n = o.length;
        for (e || (e = Array(n)); ++t < n; )
          e[t] = o[t];
        return e;
      }, xv = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length, i = 0, r = []; ++t < n; ) {
          var s = o[t];
          e(s, t, o) && (r[i++] = s);
        }
        return r;
      }, bd = function() {
        return [];
      };
      var Sv = Object.prototype.propertyIsEnumerable, kd = Object.getOwnPropertySymbols;
      const Ys = kd ? function(o) {
        return o == null ? [] : (o = Object(o), xv(kd(o), function(e) {
          return Sv.call(o, e);
        }));
      } : bd, Dv = function(o, e) {
        return Po(o, Ys(o), e);
      }, wd = function(o, e) {
        for (var t = -1, n = e.length, i = o.length; ++t < n; )
          o[i + t] = e[t];
        return o;
      }, vd = Object.getOwnPropertySymbols ? function(o) {
        for (var e = []; o; )
          wd(e, Ys(o)), o = Ls(o);
        return e;
      } : bd, Bv = function(o, e) {
        return Po(o, vd(o), e);
      }, _d = function(o, e, t) {
        var n = e(o);
        return _t(o) ? n : wd(n, t(o));
      }, Qs = function(o) {
        return _d(o, Zs, Ys);
      }, Tv = function(o) {
        return _d(o, Oo, vd);
      }, Xs = Wn(Wt, "DataView"), ea = Wn(Wt, "Promise"), ta = Wn(Wt, "Set"), na = Wn(Wt, "WeakMap");
      var Ad = "[object Map]", Cd = "[object Promise]", yd = "[object Set]", Ed = "[object WeakMap]", xd = "[object DataView]", Pv = qn(Xs), Iv = qn(wi), Ov = qn(ea), Rv = qn(ta), zv = qn(na), Gn = Sn;
      (Xs && Gn(new Xs(new ArrayBuffer(1))) != xd || wi && Gn(new wi()) != Ad || ea && Gn(ea.resolve()) != Cd || ta && Gn(new ta()) != yd || na && Gn(new na()) != Ed) && (Gn = function(o) {
        var e = Sn(o), t = e == "[object Object]" ? o.constructor : void 0, n = t ? qn(t) : "";
        if (n)
          switch (n) {
            case Pv:
              return xd;
            case Iv:
              return Ad;
            case Ov:
              return Cd;
            case Rv:
              return yd;
            case zv:
              return Ed;
          }
        return e;
      });
      const yi = Gn;
      var Mv = Object.prototype.hasOwnProperty;
      const Nv = function(o) {
        var e = o.length, t = new o.constructor(e);
        return e && typeof o[0] == "string" && Mv.call(o, "index") && (t.index = o.index, t.input = o.input), t;
      }, _r = Wt.Uint8Array, oa = function(o) {
        var e = new o.constructor(o.byteLength);
        return new _r(e).set(new _r(o)), e;
      }, Fv = function(o, e) {
        var t = e ? oa(o.buffer) : o.buffer;
        return new o.constructor(t, o.byteOffset, o.byteLength);
      };
      var $v = /\w*$/;
      const Lv = function(o) {
        var e = new o.constructor(o.source, $v.exec(o));
        return e.lastIndex = o.lastIndex, e;
      };
      var Sd = Qt ? Qt.prototype : void 0, Dd = Sd ? Sd.valueOf : void 0;
      const Vv = function(o) {
        return Dd ? Object(Dd.call(o)) : {};
      }, Bd = function(o, e) {
        var t = e ? oa(o.buffer) : o.buffer;
        return new o.constructor(t, o.byteOffset, o.length);
      }, jv = function(o, e, t) {
        var n = o.constructor;
        switch (e) {
          case "[object ArrayBuffer]":
            return oa(o);
          case "[object Boolean]":
          case "[object Date]":
            return new n(+o);
          case "[object DataView]":
            return Fv(o, t);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return Bd(o, t);
          case "[object Map]":
          case "[object Set]":
            return new n();
          case "[object Number]":
          case "[object String]":
            return new n(o);
          case "[object RegExp]":
            return Lv(o);
          case "[object Symbol]":
            return Vv(o);
        }
      };
      var Td = Object.create;
      const Hv = /* @__PURE__ */ function() {
        function o() {
        }
        return function(e) {
          if (!K(e))
            return {};
          if (Td)
            return Td(e);
          o.prototype = e;
          var t = new o();
          return o.prototype = void 0, t;
        };
      }(), Pd = function(o) {
        return typeof o.constructor != "function" || Ks(o) ? {} : Hv(Ls(o));
      }, Uv = function(o) {
        return Lt(o) && yi(o) == "[object Map]";
      };
      var Id = Io && Io.isMap;
      const qv = Id ? wr(Id) : Uv, Wv = function(o) {
        return Lt(o) && yi(o) == "[object Set]";
      };
      var Od = Io && Io.isSet;
      const Gv = Od ? wr(Od) : Wv;
      var Rd = "[object Arguments]", zd = "[object Function]", Md = "[object Object]", Ue = {};
      Ue[Rd] = Ue["[object Array]"] = Ue["[object ArrayBuffer]"] = Ue["[object DataView]"] = Ue["[object Boolean]"] = Ue["[object Date]"] = Ue["[object Float32Array]"] = Ue["[object Float64Array]"] = Ue["[object Int8Array]"] = Ue["[object Int16Array]"] = Ue["[object Int32Array]"] = Ue["[object Map]"] = Ue["[object Number]"] = Ue[Md] = Ue["[object RegExp]"] = Ue["[object Set]"] = Ue["[object String]"] = Ue["[object Symbol]"] = Ue["[object Uint8Array]"] = Ue["[object Uint8ClampedArray]"] = Ue["[object Uint16Array]"] = Ue["[object Uint32Array]"] = !0, Ue["[object Error]"] = Ue[zd] = Ue["[object WeakMap]"] = !1;
      const ia = function o(e, t, n, i, r, s) {
        var a, l = 1 & t, d = 2 & t, h = 4 & t;
        if (n && (a = r ? n(e, i, r, s) : n(e)), a !== void 0)
          return a;
        if (!K(e))
          return e;
        var m = _t(e);
        if (m) {
          if (a = Nv(e), !l)
            return Js(e, a);
        } else {
          var f = yi(e), _ = f == zd || f == "[object GeneratorFunction]";
          if (Ai(e))
            return fd(e, l);
          if (f == Md || f == Rd || _ && !r) {
            if (a = d || _ ? {} : Pd(e), !l)
              return d ? Bv(e, Ev(a, e)) : Dv(e, _v(a, e));
          } else {
            if (!Ue[f])
              return r ? e : {};
            a = jv(e, f, l);
          }
        }
        s || (s = new _i());
        var E = s.get(e);
        if (E)
          return E;
        s.set(e, a), Gv(e) ? e.forEach(function(T) {
          a.add(o(T, t, n, T, e, s));
        }) : qv(e) && e.forEach(function(T, O) {
          a.set(O, o(T, t, n, O, e, s));
        });
        var B = m ? void 0 : (h ? d ? Tv : Qs : d ? Oo : Zs)(e);
        return lv(B || e, function(T, O) {
          B && (T = e[O = T]), Hs(a, O, o(T, t, n, O, e, s));
        }), a;
      }, ra = function(o, e) {
        return ia(o, 5, e = typeof e == "function" ? e : void 0);
      }, Ro = function(o) {
        return Lt(o) && o.nodeType === 1 && !Ct(o);
      };
      class Nd {
        constructor(e, t) {
          this._config = {}, t && this.define(Fd(t)), e && this._setObjectToTarget(this._config, e);
        }
        set(e, t) {
          this._setToTarget(this._config, e, t);
        }
        define(e, t) {
          this._setToTarget(this._config, e, t, !0);
        }
        get(e) {
          return this._getFromSource(this._config, e);
        }
        *names() {
          for (const e of Object.keys(this._config))
            yield e;
        }
        _setToTarget(e, t, n, i = !1) {
          if (Ct(t))
            return void this._setObjectToTarget(e, t, i);
          const r = t.split(".");
          t = r.pop();
          for (const s of r)
            Ct(e[s]) || (e[s] = {}), e = e[s];
          if (Ct(n))
            return Ct(e[t]) || (e[t] = {}), e = e[t], void this._setObjectToTarget(e, n, i);
          i && e[t] !== void 0 || (e[t] = n);
        }
        _getFromSource(e, t) {
          const n = t.split(".");
          t = n.pop();
          for (const i of n) {
            if (!Ct(e[i])) {
              e = null;
              break;
            }
            e = e[i];
          }
          return e ? Fd(e[t]) : void 0;
        }
        _setObjectToTarget(e, t, n) {
          Object.keys(t).forEach((i) => {
            this._setToTarget(e, i, t[i], n);
          });
        }
      }
      function Fd(o) {
        return ra(o, Kv);
      }
      function Kv(o) {
        return Ro(o) ? o : void 0;
      }
      function Dn(o) {
        if (o) {
          if (o.defaultView)
            return o instanceof o.defaultView.Document;
          if (o.ownerDocument && o.ownerDocument.defaultView)
            return o instanceof o.ownerDocument.defaultView.Node;
        }
        return !1;
      }
      function Ar(o) {
        const e = Object.prototype.toString.apply(o);
        return e == "[object Window]" || e == "[object global]";
      }
      const $d = Bn(De());
      function Bn(o) {
        return o ? class extends o {
          listenTo(e, t, n, i = {}) {
            if (Dn(e) || Ar(e)) {
              const r = { capture: !!i.useCapture, passive: !!i.usePassive }, s = this._getProxyEmitter(e, r) || new Zv(e, r);
              this.listenTo(s, t, n, i);
            } else
              super.listenTo(e, t, n, i);
          }
          stopListening(e, t, n) {
            if (Dn(e) || Ar(e)) {
              const i = this._getAllProxyEmitters(e);
              for (const r of i)
                this.stopListening(r, t, n);
            } else
              super.stopListening(e, t, n);
          }
          _getProxyEmitter(e, t) {
            return function(n, i) {
              const r = n[Tt];
              return r && r[i] ? r[i].emitter : null;
            }(this, Ld(e, t));
          }
          _getAllProxyEmitters(e) {
            return [{ capture: !1, passive: !1 }, { capture: !1, passive: !0 }, { capture: !0, passive: !1 }, { capture: !0, passive: !0 }].map((t) => this._getProxyEmitter(e, t)).filter((t) => !!t);
          }
        } : $d;
      }
      ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
        Bn[o] = $d.prototype[o];
      });
      class Zv extends De() {
        constructor(e, t) {
          super(), pi(this, Ld(e, t)), this._domNode = e, this._options = t;
        }
        attach(e) {
          if (this._domListeners && this._domListeners[e])
            return;
          const t = this._createDomListener(e);
          this._domNode.addEventListener(e, t, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[e] = t;
        }
        detach(e) {
          let t;
          !this._domListeners[e] || (t = this._events[e]) && t.callbacks.length || this._domListeners[e].removeListener();
        }
        _addEventListener(e, t, n) {
          this.attach(e), De().prototype._addEventListener.call(this, e, t, n);
        }
        _removeEventListener(e, t) {
          De().prototype._removeEventListener.call(this, e, t), this.detach(e);
        }
        _createDomListener(e) {
          const t = (n) => {
            this.fire(e, n);
          };
          return t.removeListener = () => {
            this._domNode.removeEventListener(e, t, this._options), delete this._domListeners[e];
          }, t;
        }
      }
      function Ld(o, e) {
        let t = function(n) {
          return n["data-ck-expando"] || (n["data-ck-expando"] = ie());
        }(o);
        for (const n of Object.keys(e).sort())
          e[n] && (t += "-" + n);
        return t;
      }
      let sa;
      try {
        sa = { window, document };
      } catch {
        sa = { window: {}, document: {} };
      }
      const fe = sa;
      function Vd(o) {
        const e = [];
        let t = o;
        for (; t && t.nodeType != Node.DOCUMENT_NODE; )
          e.unshift(t), t = t.parentNode;
        return e;
      }
      function Qe(o) {
        return Object.prototype.toString.call(o) == "[object Text]";
      }
      function Cr(o) {
        return Object.prototype.toString.apply(o) == "[object Range]";
      }
      function jd(o) {
        const e = o.ownerDocument.defaultView.getComputedStyle(o);
        return { top: parseInt(e.borderTopWidth, 10), right: parseInt(e.borderRightWidth, 10), bottom: parseInt(e.borderBottomWidth, 10), left: parseInt(e.borderLeftWidth, 10) };
      }
      const Hd = ["top", "right", "bottom", "left", "width", "height"];
      class Ze {
        constructor(e) {
          const t = Cr(e);
          if (Object.defineProperty(this, "_source", { value: e._source || e, writable: !0, enumerable: !1 }), qd(e) || t)
            if (t) {
              const n = Ze.getDomRangeRects(e);
              yr(this, Ze.getBoundingRect(n));
            } else
              yr(this, e.getBoundingClientRect());
          else if (Ar(e)) {
            const { innerWidth: n, innerHeight: i } = e;
            yr(this, { top: 0, right: n, bottom: i, left: 0, width: n, height: i });
          } else
            yr(this, e);
        }
        clone() {
          return new Ze(this);
        }
        moveTo(e, t) {
          return this.top = t, this.right = e + this.width, this.bottom = t + this.height, this.left = e, this;
        }
        moveBy(e, t) {
          return this.top += t, this.right += e, this.left += e, this.bottom += t, this;
        }
        getIntersection(e) {
          const t = { top: Math.max(this.top, e.top), right: Math.min(this.right, e.right), bottom: Math.min(this.bottom, e.bottom), left: Math.max(this.left, e.left), width: 0, height: 0 };
          return t.width = t.right - t.left, t.height = t.bottom - t.top, t.width < 0 || t.height < 0 ? null : new Ze(t);
        }
        getIntersectionArea(e) {
          const t = this.getIntersection(e);
          return t ? t.getArea() : 0;
        }
        getArea() {
          return this.width * this.height;
        }
        getVisible() {
          const e = this._source;
          let t = this.clone();
          if (!Ud(e)) {
            let n = e.parentNode || e.commonAncestorContainer;
            for (; n && !Ud(n); ) {
              const i = new Ze(n), r = t.getIntersection(i);
              if (!r)
                return null;
              r.getArea() < t.getArea() && (t = r), n = n.parentNode;
            }
          }
          return t;
        }
        isEqual(e) {
          for (const t of Hd)
            if (this[t] !== e[t])
              return !1;
          return !0;
        }
        contains(e) {
          const t = this.getIntersection(e);
          return !(!t || !t.isEqual(e));
        }
        excludeScrollbarsAndBorders() {
          const e = this._source;
          let t, n, i;
          if (Ar(e))
            t = e.innerWidth - e.document.documentElement.clientWidth, n = e.innerHeight - e.document.documentElement.clientHeight, i = e.getComputedStyle(e.document.documentElement).direction;
          else {
            const r = jd(e);
            t = e.offsetWidth - e.clientWidth - r.left - r.right, n = e.offsetHeight - e.clientHeight - r.top - r.bottom, i = e.ownerDocument.defaultView.getComputedStyle(e).direction, this.left += r.left, this.top += r.top, this.right -= r.right, this.bottom -= r.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
          }
          return this.width -= t, i === "ltr" ? this.right -= t : this.left += t, this.height -= n, this.bottom -= n, this;
        }
        static getDomRangeRects(e) {
          const t = [], n = Array.from(e.getClientRects());
          if (n.length)
            for (const i of n)
              t.push(new Ze(i));
          else {
            let i = e.startContainer;
            Qe(i) && (i = i.parentNode);
            const r = new Ze(i.getBoundingClientRect());
            r.right = r.left, r.width = 0, t.push(r);
          }
          return t;
        }
        static getBoundingRect(e) {
          const t = { left: Number.POSITIVE_INFINITY, top: Number.POSITIVE_INFINITY, right: Number.NEGATIVE_INFINITY, bottom: Number.NEGATIVE_INFINITY, width: 0, height: 0 };
          let n = 0;
          for (const i of e)
            n++, t.left = Math.min(t.left, i.left), t.top = Math.min(t.top, i.top), t.right = Math.max(t.right, i.right), t.bottom = Math.max(t.bottom, i.bottom);
          return n == 0 ? null : (t.width = t.right - t.left, t.height = t.bottom - t.top, new Ze(t));
        }
      }
      function yr(o, e) {
        for (const t of Hd)
          o[t] = e[t];
      }
      function Ud(o) {
        return !!qd(o) && o === o.ownerDocument.body;
      }
      function qd(o) {
        return o !== null && typeof o == "object" && o.nodeType === 1 && typeof o.getBoundingClientRect == "function";
      }
      const ot = class {
        constructor(o, e) {
          ot._observerInstance || ot._createObserver(), this._element = o, this._callback = e, ot._addElementCallback(o, e), ot._observerInstance.observe(o);
        }
        destroy() {
          ot._deleteElementCallback(this._element, this._callback);
        }
        static _addElementCallback(o, e) {
          ot._elementCallbacks || (ot._elementCallbacks = /* @__PURE__ */ new Map());
          let t = ot._elementCallbacks.get(o);
          t || (t = /* @__PURE__ */ new Set(), ot._elementCallbacks.set(o, t)), t.add(e);
        }
        static _deleteElementCallback(o, e) {
          const t = ot._getElementCallbacks(o);
          t && (t.delete(e), t.size || (ot._elementCallbacks.delete(o), ot._observerInstance.unobserve(o))), ot._elementCallbacks && !ot._elementCallbacks.size && (ot._observerInstance = null, ot._elementCallbacks = null);
        }
        static _getElementCallbacks(o) {
          return ot._elementCallbacks ? ot._elementCallbacks.get(o) : null;
        }
        static _createObserver() {
          ot._observerInstance = new fe.window.ResizeObserver((o) => {
            for (const e of o) {
              const t = ot._getElementCallbacks(e.target);
              if (t)
                for (const n of t)
                  n(e);
            }
          });
        }
      };
      let Er = ot;
      function Jv(o, e) {
        o instanceof HTMLTextAreaElement && (o.value = e), o.innerHTML = e;
      }
      function aa(o) {
        return (e) => e + o;
      }
      function xr(o) {
        let e = 0;
        for (; o.previousSibling; )
          o = o.previousSibling, e++;
        return e;
      }
      function Wd(o, e, t) {
        o.insertBefore(t, o.childNodes[e] || null);
      }
      function zo(o) {
        return o && o.nodeType === Node.COMMENT_NODE;
      }
      function Gd(o) {
        try {
          fe.document.createAttribute(o);
        } catch {
          return !1;
        }
        return !0;
      }
      function Kn(o) {
        return !!(o && o.getClientRects && o.getClientRects().length);
      }
      Er._observerInstance = null, Er._elementCallbacks = null;
      var Kd = Math.pow;
      function Zd({ element: o, target: e, positions: t, limiter: n, fitInViewport: i, viewportOffsetConfig: r }) {
        Un(e) && (e = e()), Un(n) && (n = n());
        const s = function(f) {
          return f && f.parentNode ? f.offsetParent === fe.document.body ? null : f.offsetParent : null;
        }(o), a = new Ze(o), l = new Ze(e);
        let d;
        const h = i && function(f) {
          f = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, f);
          const _ = new Ze(fe.window);
          return _.top += f.top, _.height -= f.top, _.bottom -= f.bottom, _.height -= f.bottom, _;
        }(r) || null, m = { targetRect: l, elementRect: a, positionedElementAncestor: s, viewportRect: h };
        if (n || i) {
          const f = n && new Ze(n).getVisible();
          Object.assign(m, { limiterRect: f, viewportRect: h }), d = function(_, E) {
            const { elementRect: B } = E, T = B.getArea(), O = _.map((X) => new la(X, E)).filter((X) => !!X.name);
            let N = 0, H = null;
            for (const X of O) {
              const { limiterIntersectionArea: be, viewportIntersectionArea: Ge } = X;
              if (be === T)
                return X;
              const Pe = Kd(Ge, 2) + Kd(be, 2);
              Pe > N && (N = Pe, H = X);
            }
            return H;
          }(t, m) || new la(t[0], m);
        } else
          d = new la(t[0], m);
        return d;
      }
      function Jd(o) {
        const { scrollX: e, scrollY: t } = fe.window;
        return o.clone().moveBy(e, t);
      }
      class la {
        constructor(e, t) {
          const n = e(t.targetRect, t.elementRect, t.viewportRect);
          if (!n)
            return;
          const { left: i, top: r, name: s, config: a } = n;
          this.name = s, this.config = a, this._positioningFunctionCorrdinates = { left: i, top: r }, this._options = t;
        }
        get left() {
          return this._absoluteRect.left;
        }
        get top() {
          return this._absoluteRect.top;
        }
        get limiterIntersectionArea() {
          const e = this._options.limiterRect;
          if (e) {
            const t = this._options.viewportRect;
            if (!t)
              return e.getIntersectionArea(this._rect);
            {
              const n = e.getIntersection(t);
              if (n)
                return n.getIntersectionArea(this._rect);
            }
          }
          return 0;
        }
        get viewportIntersectionArea() {
          const e = this._options.viewportRect;
          return e ? e.getIntersectionArea(this._rect) : 0;
        }
        get _rect() {
          return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top)), this._cachedRect;
        }
        get _absoluteRect() {
          return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = Jd(this._rect), this._options.positionedElementAncestor && function(e, t) {
            const n = Jd(new Ze(t)), i = jd(t);
            let r = 0, s = 0;
            r -= n.left, s -= n.top, r += t.scrollLeft, s += t.scrollTop, r -= i.left, s -= i.top, e.moveBy(r, s);
          }(this._cachedAbsoluteRect, this._options.positionedElementAncestor)), this._cachedAbsoluteRect;
        }
      }
      function Yd(o) {
        const e = o.parentNode;
        e && e.removeChild(o);
      }
      function Yv({ window: o, rect: e, alignToTop: t, forceScroll: n, viewportOffset: i }) {
        const r = e.clone().moveBy(0, i), s = e.clone().moveBy(0, -i), a = new Ze(o).excludeScrollbarsAndBorders(), l = t && n, d = [s, r].every((E) => a.contains(E));
        let { scrollX: h, scrollY: m } = o;
        const f = h, _ = m;
        l ? m -= a.top - e.top + i : d || (Xd(s, a) ? m -= a.top - e.top + i : Qd(r, a) && (m += t ? e.top - a.top - i : e.bottom - a.bottom + i)), d || (eu(e, a) ? h -= a.left - e.left + i : tu(e, a) && (h += e.right - a.right + i)), h == f && m === _ || o.scrollTo(h, m);
      }
      function Qv({ parent: o, getRect: e, alignToTop: t, forceScroll: n, ancestorOffset: i = 0 }) {
        const r = ca(o), s = t && n;
        let a, l, d;
        for (; o != r.document.body; )
          l = e(), a = new Ze(o).excludeScrollbarsAndBorders(), d = a.contains(l), s ? o.scrollTop -= a.top - l.top + i : d || (Xd(l, a) ? o.scrollTop -= a.top - l.top + i : Qd(l, a) && (o.scrollTop += t ? l.top - a.top - i : l.bottom - a.bottom + i)), d || (eu(l, a) ? o.scrollLeft -= a.left - l.left + i : tu(l, a) && (o.scrollLeft += l.right - a.right + i)), o = o.parentNode;
      }
      function Qd(o, e) {
        return o.bottom > e.bottom;
      }
      function Xd(o, e) {
        return o.top < e.top;
      }
      function eu(o, e) {
        return o.left < e.left;
      }
      function tu(o, e) {
        return o.right > e.right;
      }
      function ca(o) {
        return Cr(o) ? o.startContainer.ownerDocument.defaultView : o.ownerDocument.defaultView;
      }
      function Xv(o) {
        if (Cr(o)) {
          let e = o.commonAncestorContainer;
          return Qe(e) && (e = e.parentNode), e;
        }
        return o.parentNode;
      }
      function nu(o, e) {
        const t = ca(o), n = new Ze(o);
        if (t === e)
          return n;
        {
          let i = t;
          for (; i != e; ) {
            const r = i.frameElement, s = new Ze(r).excludeScrollbarsAndBorders();
            n.moveBy(s.left, s.top), i = i.parent;
          }
        }
        return n;
      }
      const e_ = { ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧" }, t_ = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" }, Ae = function() {
        const o = { arrowleft: 37, arrowup: 38, arrowright: 39, arrowdown: 40, backspace: 8, delete: 46, enter: 13, space: 32, esc: 27, tab: 9, ctrl: 1114112, shift: 2228224, alt: 4456448, cmd: 8912896 };
        for (let e = 65; e <= 90; e++)
          o[String.fromCharCode(e).toLowerCase()] = e;
        for (let e = 48; e <= 57; e++)
          o[e - 48] = e;
        for (let e = 112; e <= 123; e++)
          o["f" + (e - 111)] = e;
        for (const e of "`-=[];',./\\")
          o[e] = e.charCodeAt(0);
        return o;
      }(), n_ = Object.fromEntries(Object.entries(Ae).map(([o, e]) => [e, o.charAt(0).toUpperCase() + o.slice(1)]));
      function Mo(o) {
        let e;
        if (typeof o == "string") {
          if (e = Ae[o.toLowerCase()], !e)
            throw new I("keyboard-unknown-key", null, { key: o });
        } else
          e = o.keyCode + (o.altKey ? Ae.alt : 0) + (o.ctrlKey ? Ae.ctrl : 0) + (o.shiftKey ? Ae.shift : 0) + (o.metaKey ? Ae.cmd : 0);
        return e;
      }
      function Sr(o) {
        return typeof o == "string" && (o = function(e) {
          return e.split("+").map((t) => t.trim());
        }(o)), o.map((e) => typeof e == "string" ? function(t) {
          if (t.endsWith("!"))
            return Mo(t.slice(0, -1));
          const n = Mo(t);
          return b.isMac && n == Ae.ctrl ? Ae.cmd : n;
        }(e) : e).reduce((e, t) => t + e, 0);
      }
      function ou(o) {
        let e = Sr(o);
        return Object.entries(b.isMac ? e_ : t_).reduce((t, [n, i]) => (e & Ae[n] && (e &= ~Ae[n], t += i), t), "") + (e ? n_[e] : "");
      }
      function da(o, e) {
        const t = e === "ltr";
        switch (o) {
          case Ae.arrowleft:
            return t ? "left" : "right";
          case Ae.arrowright:
            return t ? "right" : "left";
          case Ae.arrowup:
            return "up";
          case Ae.arrowdown:
            return "down";
        }
      }
      function Xe(o) {
        return Array.isArray(o) ? o : [o];
      }
      function o_(o, e, t = 1) {
        if (typeof t != "number")
          throw new I("translation-service-quantity-not-a-number", null, { quantity: t });
        const n = Object.keys(fe.window.CKEDITOR_TRANSLATIONS).length;
        n === 1 && (o = Object.keys(fe.window.CKEDITOR_TRANSLATIONS)[0]);
        const i = e.id || e.string;
        if (n === 0 || !function(l, d) {
          return !!fe.window.CKEDITOR_TRANSLATIONS[l] && !!fe.window.CKEDITOR_TRANSLATIONS[l].dictionary[d];
        }(o, i))
          return t !== 1 ? e.plural : e.string;
        const r = fe.window.CKEDITOR_TRANSLATIONS[o].dictionary, s = fe.window.CKEDITOR_TRANSLATIONS[o].getPluralForm || ((l) => l === 1 ? 0 : 1), a = r[i];
        return typeof a == "string" ? a : a[Number(s(t))];
      }
      fe.window.CKEDITOR_TRANSLATIONS || (fe.window.CKEDITOR_TRANSLATIONS = {});
      const i_ = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];
      function iu(o) {
        return i_.includes(o) ? "rtl" : "ltr";
      }
      class r_ {
        constructor({ uiLanguage: e = "en", contentLanguage: t } = {}) {
          this.uiLanguage = e, this.contentLanguage = t || this.uiLanguage, this.uiLanguageDirection = iu(this.uiLanguage), this.contentLanguageDirection = iu(this.contentLanguage), this.t = (n, i) => this._t(n, i);
        }
        get language() {
          return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
        }
        _t(e, t = []) {
          t = Xe(t), typeof e == "string" && (e = { string: e });
          const n = e.plural ? t[0] : 1;
          return function(i, r) {
            return i.replace(/%(\d+)/g, (s, a) => a < r.length ? r[a] : s);
          }(o_(this.uiLanguage, e, n), t);
        }
      }
      class Vt extends De() {
        constructor(e = {}, t = {}) {
          super();
          const n = It(e);
          if (n || (t = e), this._items = [], this._itemMap = /* @__PURE__ */ new Map(), this._idProperty = t.idProperty || "id", this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap(), this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap(), this._skippedIndexesFromExternal = [], n)
            for (const i of e)
              this._items.push(i), this._itemMap.set(this._getItemIdBeforeAdding(i), i);
        }
        get length() {
          return this._items.length;
        }
        get first() {
          return this._items[0] || null;
        }
        get last() {
          return this._items[this.length - 1] || null;
        }
        add(e, t) {
          return this.addMany([e], t);
        }
        addMany(e, t) {
          if (t === void 0)
            t = this._items.length;
          else if (t > this._items.length || t < 0)
            throw new I("collection-add-item-invalid-index", this);
          let n = 0;
          for (const i of e) {
            const r = this._getItemIdBeforeAdding(i), s = t + n;
            this._items.splice(s, 0, i), this._itemMap.set(r, i), this.fire("add", i, s), n++;
          }
          return this.fire("change", { added: e, removed: [], index: t }), this;
        }
        get(e) {
          let t;
          if (typeof e == "string")
            t = this._itemMap.get(e);
          else {
            if (typeof e != "number")
              throw new I("collection-get-invalid-arg", this);
            t = this._items[e];
          }
          return t || null;
        }
        has(e) {
          if (typeof e == "string")
            return this._itemMap.has(e);
          {
            const t = e[this._idProperty];
            return t && this._itemMap.has(t);
          }
        }
        getIndex(e) {
          let t;
          return t = typeof e == "string" ? this._itemMap.get(e) : e, t ? this._items.indexOf(t) : -1;
        }
        remove(e) {
          const [t, n] = this._remove(e);
          return this.fire("change", { added: [], removed: [t], index: n }), t;
        }
        map(e, t) {
          return this._items.map(e, t);
        }
        find(e, t) {
          return this._items.find(e, t);
        }
        filter(e, t) {
          return this._items.filter(e, t);
        }
        clear() {
          this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
          const e = Array.from(this._items);
          for (; this.length; )
            this._remove(0);
          this.fire("change", { added: [], removed: e, index: 0 });
        }
        bindTo(e) {
          if (this._bindToCollection)
            throw new I("collection-bind-to-rebind", this);
          return this._bindToCollection = e, { as: (t) => {
            this._setUpBindToBinding((n) => new t(n));
          }, using: (t) => {
            typeof t == "function" ? this._setUpBindToBinding(t) : this._setUpBindToBinding((n) => n[t]);
          } };
        }
        _setUpBindToBinding(e) {
          const t = this._bindToCollection, n = (i, r, s) => {
            const a = t._bindToCollection == this, l = t._bindToInternalToExternalMap.get(r);
            if (a && l)
              this._bindToExternalToInternalMap.set(r, l), this._bindToInternalToExternalMap.set(l, r);
            else {
              const d = e(r);
              if (!d)
                return void this._skippedIndexesFromExternal.push(s);
              let h = s;
              for (const m of this._skippedIndexesFromExternal)
                s > m && h--;
              for (const m of t._skippedIndexesFromExternal)
                h >= m && h++;
              this._bindToExternalToInternalMap.set(r, d), this._bindToInternalToExternalMap.set(d, r), this.add(d, h);
              for (let m = 0; m < t._skippedIndexesFromExternal.length; m++)
                h <= t._skippedIndexesFromExternal[m] && t._skippedIndexesFromExternal[m]++;
            }
          };
          for (const i of t)
            n(0, i, t.getIndex(i));
          this.listenTo(t, "add", n), this.listenTo(t, "remove", (i, r, s) => {
            const a = this._bindToExternalToInternalMap.get(r);
            a && this.remove(a), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((l, d) => (s < d && l.push(d - 1), s > d && l.push(d), l), []);
          });
        }
        _getItemIdBeforeAdding(e) {
          const t = this._idProperty;
          let n;
          if (t in e) {
            if (n = e[t], typeof n != "string")
              throw new I("collection-add-invalid-id", this);
            if (this.get(n))
              throw new I("collection-add-item-already-exists", this);
          } else
            e[t] = n = ie();
          return n;
        }
        _remove(e) {
          let t, n, i, r = !1;
          const s = this._idProperty;
          if (typeof e == "string" ? (n = e, i = this._itemMap.get(n), r = !i, i && (t = this._items.indexOf(i))) : typeof e == "number" ? (t = e, i = this._items[t], r = !i, i && (n = i[s])) : (i = e, n = i[s], t = this._items.indexOf(i), r = t == -1 || !this._itemMap.get(n)), r)
            throw new I("collection-remove-404", this);
          this._items.splice(t, 1), this._itemMap.delete(n);
          const a = this._bindToInternalToExternalMap.get(i);
          return this._bindToInternalToExternalMap.delete(i), this._bindToExternalToInternalMap.delete(a), this.fire("remove", i, t), [i, t];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
      }
      function it(o) {
        const e = o.next();
        return e.done ? null : e.value;
      }
      class Gt extends Bn(oe()) {
        constructor() {
          super(), this._elements = /* @__PURE__ */ new Set(), this._nextEventLoopTimeout = null, this.set("isFocused", !1), this.set("focusedElement", null);
        }
        add(e) {
          if (this._elements.has(e))
            throw new I("focustracker-add-element-already-exist", this);
          this.listenTo(e, "focus", () => this._focus(e), { useCapture: !0 }), this.listenTo(e, "blur", () => this._blur(), { useCapture: !0 }), this._elements.add(e);
        }
        remove(e) {
          e === this.focusedElement && this._blur(), this._elements.has(e) && (this.stopListening(e), this._elements.delete(e));
        }
        destroy() {
          this.stopListening();
        }
        _focus(e) {
          clearTimeout(this._nextEventLoopTimeout), this.focusedElement = e, this.isFocused = !0;
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null, this.isFocused = !1;
          }, 0);
        }
      }
      class un {
        constructor() {
          this._listener = new (Bn())();
        }
        listenTo(e) {
          this._listener.listenTo(e, "keydown", (t, n) => {
            this._listener.fire("_keydown:" + Mo(n), n);
          });
        }
        set(e, t, n = {}) {
          const i = Sr(e), r = n.priority;
          this._listener.listenTo(this._listener, "_keydown:" + i, (s, a) => {
            t(a, () => {
              a.preventDefault(), a.stopPropagation(), s.stop();
            }), s.return = !0;
          }, { priority: r });
        }
        press(e) {
          return !!this._listener.fire("_keydown:" + Mo(e), e);
        }
        stopListening(e) {
          this._listener.stopListening(e);
        }
        destroy() {
          this.stopListening();
        }
      }
      function hn(o) {
        return It(o) ? new Map(o) : function(e) {
          const t = /* @__PURE__ */ new Map();
          for (const n in e)
            t.set(n, e[n]);
          return t;
        }(o);
      }
      function ua(o, e) {
        let t;
        function n(...i) {
          n.cancel(), t = setTimeout(() => o(...i), e);
        }
        return n.cancel = () => {
          clearTimeout(t);
        }, n;
      }
      function ha(o, e) {
        return !!(t = o.charAt(e - 1)) && t.length == 1 && /[\ud800-\udbff]/.test(t) && function(n) {
          return !!n && n.length == 1 && /[\udc00-\udfff]/.test(n);
        }(o.charAt(e));
        var t;
      }
      function ga(o, e) {
        return !!(t = o.charAt(e)) && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t);
        var t;
      }
      const s_ = function() {
        const o = [new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}", "u"), new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")], e = new RegExp("\\p{Regional_Indicator}{2}", "u").source, t = "(?:" + o.map((n) => n.source).join("|") + ")";
        return new RegExp(`${e}|${t}(?:‍${t})*`, "ug");
      }();
      function ru(o, e) {
        const t = String(o).matchAll(s_);
        return Array.from(t).some((n) => n.index < e && e < n.index + n[0].length);
      }
      class Zn extends Vt {
        constructor(e = []) {
          super(e, { idProperty: "viewUid" }), this.on("add", (t, n, i) => {
            this._renderViewIntoCollectionParent(n, i);
          }), this.on("remove", (t, n) => {
            n.element && this._parentElement && n.element.remove();
          }), this._parentElement = null;
        }
        destroy() {
          this.map((e) => e.destroy());
        }
        setParent(e) {
          this._parentElement = e;
          for (const t of this)
            this._renderViewIntoCollectionParent(t);
        }
        delegate(...e) {
          if (!e.length || !e.every((t) => typeof t == "string"))
            throw new I("ui-viewcollection-delegate-wrong-events", this);
          return { to: (t) => {
            for (const n of this)
              for (const i of e)
                n.delegate(i).to(t);
            this.on("add", (n, i) => {
              for (const r of e)
                i.delegate(r).to(t);
            }), this.on("remove", (n, i) => {
              for (const r of e)
                i.stopDelegating(r, t);
            });
          } };
        }
        _renderViewIntoCollectionParent(e, t) {
          e.isRendered || e.render(), e.element && this._parentElement && this._parentElement.insertBefore(e.element, this._parentElement.children[t]);
        }
        remove(e) {
          return super.remove(e);
        }
      }
      var a_ = k(6062), Q = k.n(a_), su = k(4793), l_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(su.Z, l_), su.Z.locals;
      class we extends Bn(oe()) {
        constructor(e) {
          super(), this.element = null, this.isRendered = !1, this.locale = e, this.t = e && e.t, this._viewCollections = new Vt(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (t, n) => {
            n.locale = e, n.t = e && e.t;
          }), this.decorate("render");
        }
        get bindTemplate() {
          return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Xt.bind(this, this);
        }
        createCollection(e) {
          const t = new Zn(e);
          return this._viewCollections.add(t), t;
        }
        registerChild(e) {
          It(e) || (e = [e]);
          for (const t of e)
            this._unboundChildren.add(t);
        }
        deregisterChild(e) {
          It(e) || (e = [e]);
          for (const t of e)
            this._unboundChildren.remove(t);
        }
        setTemplate(e) {
          this.template = new Xt(e);
        }
        extendTemplate(e) {
          Xt.extend(this.template, e);
        }
        render() {
          if (this.isRendered)
            throw new I("ui-view-render-already-rendered", this);
          this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = !0;
        }
        destroy() {
          this.stopListening(), this._viewCollections.map((e) => e.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
        }
      }
      class Xt extends De() {
        constructor(e) {
          super(), Object.assign(this, du(cu(e))), this._isRendered = !1, this._revertData = null;
        }
        render() {
          const e = this._renderNode({ intoFragment: !0 });
          return this._isRendered = !0, e;
        }
        apply(e) {
          return this._revertData = { children: [], bindings: [], attributes: {} }, this._renderNode({ node: e, intoFragment: !1, isApplying: !0, revertData: this._revertData }), e;
        }
        revert(e) {
          if (!this._revertData)
            throw new I("ui-template-revert-not-applied", [this, e]);
          this._revertTemplateFromNode(e, this._revertData);
        }
        *getViews() {
          yield* function* e(t) {
            if (t.children)
              for (const n of t.children)
                Br(n) ? yield n : ma(n) && (yield* e(n));
          }(this);
        }
        static bind(e, t) {
          return { to: (n, i) => new c_({ eventNameOrFunction: n, attribute: n, observable: e, emitter: t, callback: i }), if: (n, i, r) => new au({ observable: e, emitter: t, attribute: n, valueIfTrue: i, callback: r }) };
        }
        static extend(e, t) {
          if (e._isRendered)
            throw new I("template-extend-render", [this, e]);
          mu(e, du(cu(t)));
        }
        _renderNode(e) {
          let t;
          if (t = e.node ? this.tag && this.text : this.tag ? this.text : !this.text, t)
            throw new I("ui-template-wrong-syntax", this);
          return this.text ? this._renderText(e) : this._renderElement(e);
        }
        _renderElement(e) {
          let t = e.node;
          return t || (t = e.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(e), this._renderElementChildren(e), this._setUpListeners(e), t;
        }
        _renderText(e) {
          let t = e.node;
          return t ? e.revertData.text = t.textContent : t = e.node = document.createTextNode(""), Dr(this.text) ? this._bindToObservable({ schema: this.text, updater: d_(t), data: e }) : t.textContent = this.text.join(""), t;
        }
        _renderAttributes(e) {
          if (!this.attributes)
            return;
          const t = e.node, n = e.revertData;
          for (const i in this.attributes) {
            const r = t.getAttribute(i), s = this.attributes[i];
            n && (n.attributes[i] = r);
            const a = pu(s) ? s[0].ns : null;
            if (Dr(s)) {
              const l = pu(s) ? s[0].value : s;
              n && fu(i) && l.unshift(r), this._bindToObservable({ schema: l, updater: u_(t, i, a), data: e });
            } else if (i == "style" && typeof s[0] != "string")
              this._renderStyleAttribute(s[0], e);
            else {
              n && r && fu(i) && s.unshift(r);
              const l = s.map((d) => d && d.value || d).reduce((d, h) => d.concat(h), []).reduce(hu, "");
              No(l) || t.setAttributeNS(a, i, l);
            }
          }
        }
        _renderStyleAttribute(e, t) {
          const n = t.node;
          for (const i in e) {
            const r = e[i];
            Dr(r) ? this._bindToObservable({ schema: [r], updater: h_(n, i), data: t }) : n.style[i] = r;
          }
        }
        _renderElementChildren(e) {
          const t = e.node, n = e.intoFragment ? document.createDocumentFragment() : t, i = e.isApplying;
          let r = 0;
          for (const s of this.children)
            if (pa(s)) {
              if (!i) {
                s.setParent(t);
                for (const a of s)
                  n.appendChild(a.element);
              }
            } else if (Br(s))
              i || (s.isRendered || s.render(), n.appendChild(s.element));
            else if (Dn(s))
              n.appendChild(s);
            else if (i) {
              const a = { children: [], bindings: [], attributes: {} };
              e.revertData.children.push(a), s._renderNode({ intoFragment: !1, node: n.childNodes[r++], isApplying: !0, revertData: a });
            } else
              n.appendChild(s.render());
          e.intoFragment && t.appendChild(n);
        }
        _setUpListeners(e) {
          if (this.eventListeners)
            for (const t in this.eventListeners) {
              const n = this.eventListeners[t].map((i) => {
                const [r, s] = t.split("@");
                return i.activateDomEventListener(r, s, e);
              });
              e.revertData && e.revertData.bindings.push(n);
            }
        }
        _bindToObservable({ schema: e, updater: t, data: n }) {
          const i = n.revertData;
          lu(e, t, n);
          const r = e.filter((s) => !No(s)).filter((s) => s.observable).map((s) => s.activateAttributeListener(e, t, n));
          i && i.bindings.push(r);
        }
        _revertTemplateFromNode(e, t) {
          for (const i of t.bindings)
            for (const r of i)
              r();
          if (t.text)
            return void (e.textContent = t.text);
          const n = e;
          for (const i in t.attributes) {
            const r = t.attributes[i];
            r === null ? n.removeAttribute(i) : n.setAttribute(i, r);
          }
          for (let i = 0; i < t.children.length; ++i)
            this._revertTemplateFromNode(n.childNodes[i], t.children[i]);
        }
      }
      class Ei {
        constructor(e) {
          this.attribute = e.attribute, this.observable = e.observable, this.emitter = e.emitter, this.callback = e.callback;
        }
        getValue(e) {
          const t = this.observable[this.attribute];
          return this.callback ? this.callback(t, e) : t;
        }
        activateAttributeListener(e, t, n) {
          const i = () => lu(e, t, n);
          return this.emitter.listenTo(this.observable, `change:${this.attribute}`, i), () => {
            this.emitter.stopListening(this.observable, `change:${this.attribute}`, i);
          };
        }
      }
      class c_ extends Ei {
        constructor(e) {
          super(e), this.eventNameOrFunction = e.eventNameOrFunction;
        }
        activateDomEventListener(e, t, n) {
          const i = (r, s) => {
            t && !s.target.matches(t) || (typeof this.eventNameOrFunction == "function" ? this.eventNameOrFunction(s) : this.observable.fire(this.eventNameOrFunction, s));
          };
          return this.emitter.listenTo(n.node, e, i), () => {
            this.emitter.stopListening(n.node, e, i);
          };
        }
      }
      class au extends Ei {
        constructor(e) {
          super(e), this.valueIfTrue = e.valueIfTrue;
        }
        getValue(e) {
          return !No(super.getValue(e)) && (this.valueIfTrue || !0);
        }
      }
      function Dr(o) {
        return !!o && (o.value && (o = o.value), Array.isArray(o) ? o.some(Dr) : o instanceof Ei);
      }
      function lu(o, e, { node: t }) {
        const n = function(r, s) {
          return r.map((a) => a instanceof Ei ? a.getValue(s) : a);
        }(o, t);
        let i;
        i = o.length == 1 && o[0] instanceof au ? n[0] : n.reduce(hu, ""), No(i) ? e.remove() : e.set(i);
      }
      function d_(o) {
        return { set(e) {
          o.textContent = e;
        }, remove() {
          o.textContent = "";
        } };
      }
      function u_(o, e, t) {
        return { set(n) {
          o.setAttributeNS(t, e, n);
        }, remove() {
          o.removeAttributeNS(t, e);
        } };
      }
      function h_(o, e) {
        return { set(t) {
          o.style[e] = t;
        }, remove() {
          o.style[e] = null;
        } };
      }
      function cu(o) {
        return ra(o, (e) => {
          if (e && (e instanceof Ei || ma(e) || Br(e) || pa(e)))
            return e;
        });
      }
      function du(o) {
        if (typeof o == "string" ? o = /* @__PURE__ */ function(e) {
          return { text: [e] };
        }(o) : o.text && function(e) {
          e.text = Xe(e.text);
        }(o), o.on && (o.eventListeners = function(e) {
          for (const t in e)
            uu(e, t);
          return e;
        }(o.on), delete o.on), !o.text) {
          o.attributes && function(t) {
            for (const n in t)
              t[n].value && (t[n].value = Xe(t[n].value)), uu(t, n);
          }(o.attributes);
          const e = [];
          if (o.children)
            if (pa(o.children))
              e.push(o.children);
            else
              for (const t of o.children)
                ma(t) || Br(t) || Dn(t) ? e.push(t) : e.push(new Xt(t));
          o.children = e;
        }
        return o;
      }
      function uu(o, e) {
        o[e] = Xe(o[e]);
      }
      function hu(o, e) {
        return No(e) ? o : No(o) ? e : `${o} ${e}`;
      }
      function gu(o, e) {
        for (const t in e)
          o[t] ? o[t].push(...e[t]) : o[t] = e[t];
      }
      function mu(o, e) {
        if (e.attributes && (o.attributes || (o.attributes = {}), gu(o.attributes, e.attributes)), e.eventListeners && (o.eventListeners || (o.eventListeners = {}), gu(o.eventListeners, e.eventListeners)), e.text && o.text.push(...e.text), e.children && e.children.length) {
          if (o.children.length != e.children.length)
            throw new I("ui-template-extend-children-mismatch", o);
          let t = 0;
          for (const n of e.children)
            mu(o.children[t++], n);
        }
      }
      function No(o) {
        return !o && o !== 0;
      }
      function Br(o) {
        return o instanceof we;
      }
      function ma(o) {
        return o instanceof Xt;
      }
      function pa(o) {
        return o instanceof Zn;
      }
      function pu(o) {
        return K(o[0]) && o[0].ns;
      }
      function fu(o) {
        return o == "class" || o == "style";
      }
      class g_ extends Zn {
        constructor(e, t = []) {
          super(t), this.locale = e;
        }
        attachToDom() {
          this._bodyCollectionContainer = new Xt({ tag: "div", attributes: { class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"], dir: this.locale.uiLanguageDirection }, children: this }).render();
          let e = document.querySelector(".ck-body-wrapper");
          e || (e = $s(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(e)), e.appendChild(this._bodyCollectionContainer);
        }
        detachFromDom() {
          super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
          const e = document.querySelector(".ck-body-wrapper");
          e && e.childElementCount == 0 && e.remove();
        }
      }
      var bu = k(6574), m_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(bu.Z, m_), bu.Z.locals;
      const ku = class extends we {
        constructor() {
          super();
          const o = this.bindTemplate;
          this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", !0), this.setTemplate({ tag: "svg", ns: "http://www.w3.org/2000/svg", attributes: { class: ["ck", "ck-icon", "ck-reset_all-excluded", o.if("isColorInherited", "ck-icon_inherit-color")], viewBox: o.to("viewBox") } });
        }
        render() {
          super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
            this._updateXMLContent(), this._colorFillPaths();
          }), this.on("change:fillColor", () => {
            this._colorFillPaths();
          });
        }
        _updateXMLContent() {
          if (this.content) {
            const o = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"), e = o.getAttribute("viewBox");
            e && (this.viewBox = e);
            for (const { name: t, value: n } of Array.from(o.attributes))
              ku.presentationalAttributeNames.includes(t) && this.element.setAttribute(t, n);
            for (; this.element.firstChild; )
              this.element.removeChild(this.element.firstChild);
            for (; o.childNodes.length > 0; )
              this.element.appendChild(o.childNodes[0]);
          }
        }
        _colorFillPaths() {
          this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((o) => {
            o.style.fill = this.fillColor;
          });
        }
      };
      let xi = ku;
      xi.presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"];
      var wu = k(4906), p_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(wu.Z, p_), wu.Z.locals;
      class je extends we {
        constructor(e) {
          super(e), this._focusDelayed = null;
          const t = this.bindTemplate, n = ie();
          this.set("ariaChecked", void 0), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", `ck-editor__aria-label_${n}`), this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isVisible", !0), this.set("isToggleable", !1), this.set("keystroke", void 0), this.set("label", void 0), this.set("role", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.set("withKeystroke", !1), this.children = this.createCollection(), this.labelView = this._createLabelView(), this.iconView = new xi(), this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
          const i = { tag: "button", attributes: { class: ["ck", "ck-button", t.to("class"), t.if("isEnabled", "ck-disabled", (r) => !r), t.if("isVisible", "ck-hidden", (r) => !r), t.to("isOn", (r) => r ? "ck-on" : "ck-off"), t.if("withText", "ck-button_with-text"), t.if("withKeystroke", "ck-button_with-keystroke")], role: t.to("role"), type: t.to("type", (r) => r || "button"), tabindex: t.to("tabindex"), "aria-label": t.to("ariaLabel"), "aria-labelledby": t.to("ariaLabelledBy"), "aria-disabled": t.if("isEnabled", !0, (r) => !r), "aria-checked": t.to("isOn"), "aria-pressed": t.to("isOn", (r) => !!this.isToggleable && String(!!r)), "data-cke-tooltip-text": t.to("_tooltipString"), "data-cke-tooltip-position": t.to("tooltipPosition") }, children: this.children, on: { click: t.to((r) => {
            this.isEnabled ? this.fire("execute") : r.preventDefault();
          }) } };
          b.isSafari && (this._focusDelayed || (this._focusDelayed = ua(() => this.focus(), 0)), i.on.mousedown = t.to(() => {
            this._focusDelayed();
          }), i.on.mouseup = t.to(() => {
            this._focusDelayed.cancel();
          })), this.setTemplate(i);
        }
        render() {
          super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView);
        }
        focus() {
          this.element.focus();
        }
        destroy() {
          this._focusDelayed && this._focusDelayed.cancel(), super.destroy();
        }
        _createLabelView() {
          const e = new we(), t = this.bindTemplate;
          return e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__label"], style: t.to("labelStyle"), id: this.ariaLabelledBy }, children: [{ text: t.to("label") }] }), e;
        }
        _createKeystrokeView() {
          const e = new we();
          return e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__keystroke"] }, children: [{ text: this.bindTemplate.to("keystroke", (t) => ou(t)) }] }), e;
        }
        _getTooltipString(e, t, n) {
          return e ? typeof e == "string" ? e : (n && (n = ou(n)), e instanceof Function ? e(t, n) : `${t}${n ? ` (${n})` : ""}`) : "";
        }
      }
      var vu = k(6758), f_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(vu.Z, f_), vu.Z.locals;
      class Tr extends je {
        constructor(e) {
          super(e), this.isToggleable = !0, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
        }
        render() {
          super.render(), this.children.add(this.toggleSwitchView);
        }
        _createToggleView() {
          const e = new we();
          return e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__toggle"] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }] }), e;
        }
      }
      var _u = k(6781), b_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(_u.Z, b_), _u.Z.locals, k(1103), k(841);
      var Au = k(3662), k_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Au.Z, k_), Au.Z.locals;
      class Cu extends we {
        constructor(e) {
          super(e), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${ie()}`;
          const t = this.bindTemplate;
          this.setTemplate({ tag: "label", attributes: { class: ["ck", "ck-label"], id: this.id, for: t.to("for") }, children: [{ text: t.to("text") }] });
        }
      }
      var yu = k(2577), w_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(yu.Z, w_), yu.Z.locals;
      class Eu extends we {
        constructor(e, t) {
          super(e);
          const n = `ck-labeled-field-view-${ie()}`, i = `ck-labeled-field-view-status-${ie()}`;
          this.fieldView = t(this, n, i), this.set("label", void 0), this.set("isEnabled", !0), this.set("isEmpty", !0), this.set("isFocused", !1), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(n), this.statusView = this._createStatusView(i), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", (s, a) => s || a);
          const r = this.bindTemplate;
          this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view", r.to("class"), r.if("isEnabled", "ck-disabled", (s) => !s), r.if("isEmpty", "ck-labeled-field-view_empty"), r.if("isFocused", "ck-labeled-field-view_focused"), r.if("placeholder", "ck-labeled-field-view_placeholder"), r.if("errorText", "ck-error")] }, children: [{ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] }, children: this.fieldWrapperChildren }, this.statusView] });
        }
        _createLabelView(e) {
          const t = new Cu(this.locale);
          return t.for = e, t.bind("text").to(this, "label"), t;
        }
        _createStatusView(e) {
          const t = new we(this.locale), n = this.bindTemplate;
          return t.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__status", n.if("errorText", "ck-labeled-field-view__status_error"), n.if("_statusText", "ck-hidden", (i) => !i)], id: e, role: n.if("errorText", "alert") }, children: [{ text: n.to("_statusText") }] }), t;
        }
        focus() {
          this.fieldView.focus();
        }
      }
      var xu = k(4879), v_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(xu.Z, v_), xu.Z.locals;
      class __ extends we {
        constructor(e) {
          super(e), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("isReadOnly", !1), this.set("hasError", !1), this.set("ariaDescribedById", void 0), this.focusTracker = new Gt(), this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", !0), this.set("inputMode", "text");
          const t = this.bindTemplate;
          this.setTemplate({ tag: "input", attributes: { class: ["ck", "ck-input", t.if("isFocused", "ck-input_focused"), t.if("isEmpty", "ck-input-text_empty"), t.if("hasError", "ck-error")], id: t.to("id"), placeholder: t.to("placeholder"), readonly: t.to("isReadOnly"), inputmode: t.to("inputMode"), "aria-invalid": t.if("hasError", !0), "aria-describedby": t.to("ariaDescribedById") }, on: { input: t.to((...n) => {
            this.fire("input", ...n), this._updateIsEmpty();
          }), change: t.to(this._updateIsEmpty.bind(this)) } });
        }
        render() {
          super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (e, t, n) => {
            this._setDomElementValue(n), this._updateIsEmpty();
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy();
        }
        select() {
          this.element.select();
        }
        focus() {
          this.element.focus();
        }
        _updateIsEmpty() {
          this.isEmpty = !this.element.value;
        }
        _setDomElementValue(e) {
          this.element.value = e || e === 0 ? e : "";
        }
      }
      class A_ extends __ {
        constructor(e) {
          super(e), this.extendTemplate({ attributes: { type: "text", class: ["ck-input-text"] } });
        }
      }
      class C_ extends we {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-dropdown__panel", t.to("position", (n) => `ck-dropdown__panel_${n}`), t.if("isVisible", "ck-dropdown__panel-visible")] }, children: this.children, on: { selectstart: t.to((n) => {
            n.target.tagName.toLocaleLowerCase() !== "input" && n.preventDefault();
          }) } });
        }
        focus() {
          if (this.children.length) {
            const e = this.children.first;
            typeof e.focus == "function" ? e.focus() : ne("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this });
          }
        }
        focusLast() {
          if (this.children.length) {
            const e = this.children.last;
            typeof e.focusLast == "function" ? e.focusLast() : e.focus();
          }
        }
      }
      var Su = k(5485), y_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Su.Z, y_), Su.Z.locals;
      const fa = class extends we {
        constructor(o, e, t) {
          super(o);
          const n = this.bindTemplate;
          this.buttonView = e, this.panelView = t, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.keystrokes = new un(), this.focusTracker = new Gt(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dropdown", n.to("class"), n.if("isEnabled", "ck-disabled", (i) => !i)], id: n.to("id"), "aria-describedby": n.to("ariaDescribedById") }, children: [e, t] }), e.extendTemplate({ attributes: { class: ["ck-dropdown__button"], "data-cke-tooltip-disabled": n.to("isOpen") } });
        }
        render() {
          super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", () => {
            this.isOpen = !this.isOpen;
          }), this.panelView.bind("isVisible").to(this, "isOpen"), this.on("change:isOpen", (e, t, n) => {
            n && (this.panelPosition === "auto" ? this.panelView.position = fa._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: !0, positions: this._panelPositions }).name : this.panelView.position = this.panelPosition);
          }), this.keystrokes.listenTo(this.element);
          const o = (e, t) => {
            this.isOpen && (this.isOpen = !1, t());
          };
          this.keystrokes.set("arrowdown", (e, t) => {
            this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0, t());
          }), this.keystrokes.set("arrowright", (e, t) => {
            this.isOpen && t();
          }), this.keystrokes.set("arrowleft", o), this.keystrokes.set("esc", o);
        }
        focus() {
          this.buttonView.focus();
        }
        get _panelPositions() {
          const { south: o, north: e, southEast: t, southWest: n, northEast: i, northWest: r, southMiddleEast: s, southMiddleWest: a, northMiddleEast: l, northMiddleWest: d } = fa.defaultPanelPositions;
          return this.locale.uiLanguageDirection !== "rtl" ? [t, n, s, a, o, i, r, l, d, e] : [n, t, a, s, o, r, i, d, l, e];
        }
      };
      let ba = fa;
      ba.defaultPanelPositions = { south: (o, e) => ({ top: o.bottom, left: o.left - (e.width - o.width) / 2, name: "s" }), southEast: (o) => ({ top: o.bottom, left: o.left, name: "se" }), southWest: (o, e) => ({ top: o.bottom, left: o.left - e.width + o.width, name: "sw" }), southMiddleEast: (o, e) => ({ top: o.bottom, left: o.left - (e.width - o.width) / 4, name: "sme" }), southMiddleWest: (o, e) => ({ top: o.bottom, left: o.left - 3 * (e.width - o.width) / 4, name: "smw" }), north: (o, e) => ({ top: o.top - e.height, left: o.left - (e.width - o.width) / 2, name: "n" }), northEast: (o, e) => ({ top: o.top - e.height, left: o.left, name: "ne" }), northWest: (o, e) => ({ top: o.top - e.height, left: o.left - e.width + o.width, name: "nw" }), northMiddleEast: (o, e) => ({ top: o.top - e.height, left: o.left - (e.width - o.width) / 4, name: "nme" }), northMiddleWest: (o, e) => ({ top: o.top - e.height, left: o.left - 3 * (e.width - o.width) / 4, name: "nmw" }) }, ba._getOptimalPosition = Zd;
      const Du = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
      class Bu extends je {
        constructor(e) {
          super(e), this.arrowView = this._createArrowView(), this.extendTemplate({ attributes: { "aria-haspopup": !0, "aria-expanded": this.bindTemplate.to("isOn", (t) => String(t)) } }), this.delegate("execute").to(this, "open");
        }
        render() {
          super.render(), this.children.add(this.arrowView);
        }
        _createArrowView() {
          const e = new xi();
          return e.content = Du, e.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }), e;
        }
      }
      class Si {
        constructor(e) {
          if (this.focusables = e.focusables, this.focusTracker = e.focusTracker, this.keystrokeHandler = e.keystrokeHandler, this.actions = e.actions, e.actions && e.keystrokeHandler)
            for (const t in e.actions) {
              let n = e.actions[t];
              typeof n == "string" && (n = [n]);
              for (const i of n)
                e.keystrokeHandler.set(i, (r, s) => {
                  this[t](), s();
                });
            }
        }
        get first() {
          return this.focusables.find(ka) || null;
        }
        get last() {
          return this.focusables.filter(ka).slice(-1)[0] || null;
        }
        get next() {
          return this._getFocusableItem(1);
        }
        get previous() {
          return this._getFocusableItem(-1);
        }
        get current() {
          let e = null;
          return this.focusTracker.focusedElement === null ? null : (this.focusables.find((t, n) => {
            const i = t.element === this.focusTracker.focusedElement;
            return i && (e = n), i;
          }), e);
        }
        focusFirst() {
          this._focus(this.first);
        }
        focusLast() {
          this._focus(this.last);
        }
        focusNext() {
          this._focus(this.next);
        }
        focusPrevious() {
          this._focus(this.previous);
        }
        _focus(e) {
          e && e.focus();
        }
        _getFocusableItem(e) {
          const t = this.current, n = this.focusables.length;
          if (!n)
            return null;
          if (t === null)
            return this[e === 1 ? "first" : "last"];
          let i = (t + n + e) % n;
          do {
            const r = this.focusables.get(i);
            if (ka(r))
              return r;
            i = (i + n + e) % n;
          } while (i !== t);
          return null;
        }
      }
      function ka(o) {
        return !(!o.focus || !Kn(o.element));
      }
      class Tu extends we {
        constructor(e) {
          super(e), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } });
        }
      }
      class E_ extends we {
        constructor(e) {
          super(e), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__line-break"] } });
        }
      }
      function Pu(o) {
        return Array.isArray(o) ? { items: o, removeItems: [] } : o ? Object.assign({ items: [], removeItems: [] }, o) : { items: [], removeItems: [] };
      }
      class G extends oe() {
        constructor(e) {
          super(), this._disableStack = /* @__PURE__ */ new Set(), this.editor = e, this.set("isEnabled", !0);
        }
        forceDisabled(e) {
          this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", Iu, { priority: "highest" }), this.isEnabled = !1);
        }
        clearForceDisabled(e) {
          this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", Iu), this.isEnabled = !0);
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return !1;
        }
      }
      function Iu(o) {
        o.return = !1, o.stop();
      }
      class pe extends oe() {
        constructor(e) {
          super(), this.editor = e, this.set("value", void 0), this.set("isEnabled", !1), this._affectsData = !0, this._isEnabledBasedOnSelection = !0, this._disableStack = /* @__PURE__ */ new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
            this.refresh();
          }), this.listenTo(e, "change:isReadOnly", () => {
            this.refresh();
          }), this.on("set:isEnabled", (t) => {
            this.affectsData && (e.isReadOnly || this._isEnabledBasedOnSelection && !e.model.canEditAt(e.model.document.selection)) && (t.return = !1, t.stop());
          }, { priority: "highest" }), this.on("execute", (t) => {
            this.isEnabled || t.stop();
          }, { priority: "high" });
        }
        get affectsData() {
          return this._affectsData;
        }
        set affectsData(e) {
          this._affectsData = e;
        }
        refresh() {
          this.isEnabled = !0;
        }
        forceDisabled(e) {
          this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", Ou, { priority: "highest" }), this.isEnabled = !1);
        }
        clearForceDisabled(e) {
          this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", Ou), this.refresh());
        }
        execute(...e) {
        }
        destroy() {
          this.stopListening();
        }
      }
      function Ou(o) {
        o.return = !1, o.stop();
      }
      class Ru extends pe {
        constructor() {
          super(...arguments), this._childCommandsDefinitions = [];
        }
        refresh() {
        }
        execute(...e) {
          const t = this._getFirstEnabledCommand();
          return !!t && t.execute(e);
        }
        registerChildCommand(e, t = {}) {
          ee(this._childCommandsDefinitions, { command: e, priority: t.priority || "normal" }), e.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled();
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand();
        }
        _getFirstEnabledCommand() {
          const e = this._childCommandsDefinitions.find(({ command: t }) => t.isEnabled);
          return e && e.command;
        }
      }
      class zu extends De() {
        constructor(e, t = [], n = []) {
          super(), this._plugins = /* @__PURE__ */ new Map(), this._context = e, this._availablePlugins = /* @__PURE__ */ new Map();
          for (const i of t)
            i.pluginName && this._availablePlugins.set(i.pluginName, i);
          this._contextPlugins = /* @__PURE__ */ new Map();
          for (const [i, r] of n)
            this._contextPlugins.set(i, r), this._contextPlugins.set(r, i), i.pluginName && this._availablePlugins.set(i.pluginName, i);
        }
        *[Symbol.iterator]() {
          for (const e of this._plugins)
            typeof e[0] == "function" && (yield e);
        }
        get(e) {
          const t = this._plugins.get(e);
          if (!t) {
            let n = e;
            throw typeof e == "function" && (n = e.pluginName || e.name), new I("plugincollection-plugin-not-loaded", this._context, { plugin: n });
          }
          return t;
        }
        has(e) {
          return this._plugins.has(e);
        }
        init(e, t = [], n = []) {
          const i = this, r = this._context;
          (function E(B, T = /* @__PURE__ */ new Set()) {
            B.forEach((O) => {
              l(O) && (T.has(O) || (T.add(O), O.pluginName && !i._availablePlugins.has(O.pluginName) && i._availablePlugins.set(O.pluginName, O), O.requires && E(O.requires, T)));
            });
          })(e), f(e);
          const s = [...function E(B, T = /* @__PURE__ */ new Set()) {
            return B.map((O) => l(O) ? O : i._availablePlugins.get(O)).reduce((O, N) => T.has(N) ? O : (T.add(N), N.requires && (f(N.requires, N), E(N.requires, T).forEach((H) => O.add(H))), O.add(N)), /* @__PURE__ */ new Set());
          }(e.filter((E) => !h(E, t)))];
          (function(E, B) {
            for (const T of B) {
              if (typeof T != "function")
                throw new I("plugincollection-replace-plugin-invalid-type", null, { pluginItem: T });
              const O = T.pluginName;
              if (!O)
                throw new I("plugincollection-replace-plugin-missing-name", null, { pluginItem: T });
              if (T.requires && T.requires.length)
                throw new I("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: O });
              const N = i._availablePlugins.get(O);
              if (!N)
                throw new I("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: O });
              const H = E.indexOf(N);
              if (H === -1) {
                if (i._contextPlugins.has(N))
                  return;
                throw new I("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: O });
              }
              if (N.requires && N.requires.length)
                throw new I("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: O });
              E.splice(H, 1, T), i._availablePlugins.set(O, T);
            }
          })(s, n);
          const a = s.map((E) => {
            let B = i._contextPlugins.get(E);
            return B = B || new E(r), i._add(E, B), B;
          });
          return _(a, "init").then(() => _(a, "afterInit")).then(() => a);
          function l(E) {
            return typeof E == "function";
          }
          function d(E) {
            return l(E) && !!E.isContextPlugin;
          }
          function h(E, B) {
            return B.some((T) => T === E || m(E) === T || m(T) === E);
          }
          function m(E) {
            return l(E) ? E.pluginName || E.name : E;
          }
          function f(E, B = null) {
            E.map((T) => l(T) ? T : i._availablePlugins.get(T) || T).forEach((T) => {
              (function(O, N) {
                if (!l(O))
                  throw N ? new I("plugincollection-soft-required", r, { missingPlugin: O, requiredBy: m(N) }) : new I("plugincollection-plugin-not-found", r, { plugin: O });
              })(T, B), function(O, N) {
                if (d(N) && !d(O))
                  throw new I("plugincollection-context-required", r, { plugin: m(O), requiredBy: m(N) });
              }(T, B), function(O, N) {
                if (N && h(O, t))
                  throw new I("plugincollection-required", r, { plugin: m(O), requiredBy: m(N) });
              }(T, B);
            });
          }
          function _(E, B) {
            return E.reduce((T, O) => O[B] ? i._contextPlugins.has(O) ? T : T.then(O[B].bind(O)) : T, Promise.resolve());
          }
        }
        destroy() {
          const e = [];
          for (const [, t] of this)
            typeof t.destroy != "function" || this._contextPlugins.has(t) || e.push(t.destroy());
          return Promise.all(e);
        }
        _add(e, t) {
          this._plugins.set(e, t);
          const n = e.pluginName;
          if (n) {
            if (this._plugins.has(n))
              throw new I("plugincollection-plugin-name-conflict", null, { pluginName: n, plugin1: this._plugins.get(n).constructor, plugin2: e });
            this._plugins.set(n, t);
          }
        }
      }
      class Mu {
        constructor(e) {
          this._contextOwner = null, this.config = new Nd(e, this.constructor.defaultConfig);
          const t = this.constructor.builtinPlugins;
          this.config.define("plugins", t), this.plugins = new zu(this, t);
          const n = this.config.get("language") || {};
          this.locale = new r_({ uiLanguage: typeof n == "string" ? n : n.ui, contentLanguage: this.config.get("language.content") }), this.t = this.locale.t, this.editors = new Vt();
        }
        initPlugins() {
          const e = this.config.get("plugins") || [], t = this.config.get("substitutePlugins") || [];
          for (const n of e.concat(t)) {
            if (typeof n != "function")
              throw new I("context-initplugins-constructor-only", null, { Plugin: n });
            if (n.isContextPlugin !== !0)
              throw new I("context-initplugins-invalid-plugin", null, { Plugin: n });
          }
          return this.plugins.init(e, [], t);
        }
        destroy() {
          return Promise.all(Array.from(this.editors, (e) => e.destroy())).then(() => this.plugins.destroy());
        }
        _addEditor(e, t) {
          if (this._contextOwner)
            throw new I("context-addeditor-private-context");
          this.editors.add(e), t && (this._contextOwner = e);
        }
        _removeEditor(e) {
          return this.editors.has(e) && this.editors.remove(e), this._contextOwner === e ? this.destroy() : Promise.resolve();
        }
        _getEditorConfig() {
          const e = {};
          for (const t of this.config.names())
            ["plugins", "removePlugins", "extraPlugins"].includes(t) || (e[t] = this.config.get(t));
          return e;
        }
        static create(e) {
          return new Promise((t) => {
            const n = new this(e);
            t(n.initPlugins().then(() => n));
          });
        }
      }
      class Pr extends oe() {
        constructor(e) {
          super(), this.context = e;
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return !0;
        }
      }
      class x_ extends un {
        constructor(e) {
          super(), this.editor = e;
        }
        set(e, t, n = {}) {
          if (typeof t == "string") {
            const i = t;
            t = (r, s) => {
              this.editor.execute(i), s();
            };
          }
          super.set(e, t, n);
        }
      }
      var Nu = k(4717), S_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Nu.Z, S_), Nu.Z.locals;
      const Ir = /* @__PURE__ */ new WeakMap();
      function D_(o, e) {
        return !!e.hasClass("ck-placeholder") && (o.removeClass("ck-placeholder", e), !0);
      }
      function wa(o, e) {
        const t = Ir.get(o), n = [];
        let i = !1;
        for (const [r, s] of t)
          s.isDirectHost && (n.push(r), Fu(e, r, s) && (i = !0));
        for (const [r, s] of t) {
          if (s.isDirectHost)
            continue;
          const a = B_(r);
          a && (n.includes(a) || (s.hostElement = a, Fu(e, r, s) && (i = !0)));
        }
        return i;
      }
      function Fu(o, e, t) {
        const { text: n, isDirectHost: i, hostElement: r } = t;
        let s = !1;
        return r.getAttribute("data-placeholder") !== n && (o.setAttribute("data-placeholder", n, r), s = !0), (i || e.childCount == 1) && function(a, l) {
          if (!a.isAttached() || Array.from(a.getChildren()).some((m) => !m.is("uiElement")))
            return !1;
          const d = a.document, h = d.selection.anchor;
          return !(d.isComposing && h && h.parent === a || !l && d.isFocused && (!h || h.parent === a));
        }(r, t.keepOnFocus) ? function(a, l) {
          return !l.hasClass("ck-placeholder") && (a.addClass("ck-placeholder", l), !0);
        }(o, r) && (s = !0) : D_(o, r) && (s = !0), s;
      }
      function B_(o) {
        if (o.childCount) {
          const e = o.getChild(0);
          if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement"))
            return e;
        }
        return null;
      }
      class Jn {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      const $u = function(o) {
        return ia(o, 4);
      };
      class Yn extends De(Jn) {
        constructor(e) {
          super(), this.document = e, this.parent = null;
        }
        get index() {
          let e;
          if (!this.parent)
            return null;
          if ((e = this.parent.getChildIndex(this)) == -1)
            throw new I("view-node-not-found-in-parent", this);
          return e;
        }
        get nextSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e + 1) || null;
        }
        get previousSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e - 1) || null;
        }
        get root() {
          let e = this;
          for (; e.parent; )
            e = e.parent;
          return e;
        }
        isAttached() {
          return this.root.is("rootElement");
        }
        getPath() {
          const e = [];
          let t = this;
          for (; t.parent; )
            e.unshift(t.index), t = t.parent;
          return e;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this : this.parent;
          for (; n; )
            t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
        getCommonAncestor(e, t = {}) {
          const n = this.getAncestors(t), i = e.getAncestors(t);
          let r = 0;
          for (; n[r] == i[r] && n[r]; )
            r++;
          return r === 0 ? null : n[r - 1];
        }
        isBefore(e) {
          if (this == e || this.root !== e.root)
            return !1;
          const t = this.getPath(), n = e.getPath(), i = vt(t, n);
          switch (i) {
            case "prefix":
              return !0;
            case "extension":
              return !1;
            default:
              return t[i] < n[i];
          }
        }
        isAfter(e) {
          return this != e && this.root === e.root && !this.isBefore(e);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _fireChange(e, t) {
          this.fire(`change:${e}`, t), this.parent && this.parent._fireChange(e, t);
        }
        toJSON() {
          const e = $u(this);
          return delete e.parent, e;
        }
      }
      Yn.prototype.is = function(o) {
        return o === "node" || o === "view:node";
      };
      class Ne extends Yn {
        constructor(e, t) {
          super(e), this._textData = t;
        }
        get data() {
          return this._textData;
        }
        get _data() {
          return this.data;
        }
        set _data(e) {
          this._fireChange("text", this), this._textData = e;
        }
        isSimilar(e) {
          return e instanceof Ne && (this === e || this.data === e.data);
        }
        _clone() {
          return new Ne(this.document, this.data);
        }
      }
      Ne.prototype.is = function(o) {
        return o === "$text" || o === "view:$text" || o === "text" || o === "view:text" || o === "node" || o === "view:node";
      };
      class en extends Jn {
        constructor(e, t, n) {
          if (super(), this.textNode = e, t < 0 || t > e.data.length)
            throw new I("view-textproxy-wrong-offsetintext", this);
          if (n < 0 || t + n > e.data.length)
            throw new I("view-textproxy-wrong-length", this);
          this.data = e.data.substring(t, t + n), this.offsetInText = t;
        }
        get offsetSize() {
          return this.data.length;
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        get document() {
          return this.textNode.document;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this.textNode : this.parent;
          for (; n !== null; )
            t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
      }
      en.prototype.is = function(o) {
        return o === "$textProxy" || o === "view:$textProxy" || o === "textProxy" || o === "view:textProxy";
      };
      class Fo {
        constructor(...e) {
          this._patterns = [], this.add(...e);
        }
        add(...e) {
          for (let t of e)
            (typeof t == "string" || t instanceof RegExp) && (t = { name: t }), this._patterns.push(t);
        }
        match(...e) {
          for (const t of e)
            for (const n of this._patterns) {
              const i = Lu(t, n);
              if (i)
                return { element: t, pattern: n, match: i };
            }
          return null;
        }
        matchAll(...e) {
          const t = [];
          for (const n of e)
            for (const i of this._patterns) {
              const r = Lu(n, i);
              r && t.push({ element: n, pattern: i, match: r });
            }
          return t.length > 0 ? t : null;
        }
        getElementName() {
          if (this._patterns.length !== 1)
            return null;
          const e = this._patterns[0], t = e.name;
          return typeof e == "function" || !t || t instanceof RegExp ? null : t;
        }
      }
      function Lu(o, e) {
        if (typeof e == "function")
          return e(o);
        const t = {};
        return e.name && (t.name = function(n, i) {
          return n instanceof RegExp ? !!i.match(n) : n === i;
        }(e.name, o.name), !t.name) || e.attributes && (t.attributes = function(n, i) {
          const r = new Set(i.getAttributeKeys());
          return Ct(n) ? (n.style !== void 0 && ne("matcher-pattern-deprecated-attributes-style-key", n), n.class !== void 0 && ne("matcher-pattern-deprecated-attributes-class-key", n)) : (r.delete("style"), r.delete("class")), va(n, r, (s) => i.getAttribute(s));
        }(e.attributes, o), !t.attributes) || e.classes && (t.classes = function(n, i) {
          return va(n, i.getClassNames(), () => {
          });
        }(e.classes, o), !t.classes) || e.styles && (t.styles = function(n, i) {
          return va(n, i.getStyleNames(!0), (r) => i.getStyle(r));
        }(e.styles, o), !t.styles) ? null : t;
      }
      function va(o, e, t) {
        const n = function(s) {
          return Array.isArray(s) ? s.map((a) => Ct(a) ? (a.key !== void 0 && a.value !== void 0 || ne("matcher-pattern-missing-key-or-value", a), [a.key, a.value]) : [a, !0]) : Ct(s) ? Object.entries(s) : [[s, !0]];
        }(o), i = Array.from(e), r = [];
        if (n.forEach(([s, a]) => {
          i.forEach((l) => {
            (function(d, h) {
              return d === !0 || d === h || d instanceof RegExp && h.match(d);
            })(s, l) && function(d, h, m) {
              if (d === !0)
                return !0;
              const f = m(h);
              return d === f || d instanceof RegExp && !!String(f).match(d);
            }(a, l, t) && r.push(l);
          });
        }), n.length && !(r.length < n.length))
          return r;
      }
      const Or = function(o) {
        return typeof o == "symbol" || Lt(o) && Sn(o) == "[object Symbol]";
      };
      var T_ = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, P_ = /^\w*$/;
      const I_ = function(o, e) {
        if (_t(o))
          return !1;
        var t = typeof o;
        return !(t != "number" && t != "symbol" && t != "boolean" && o != null && !Or(o)) || P_.test(o) || !T_.test(o) || e != null && o in Object(e);
      };
      function _a(o, e) {
        if (typeof o != "function" || e != null && typeof e != "function")
          throw new TypeError("Expected a function");
        var t = function() {
          var n = arguments, i = e ? e.apply(this, n) : n[0], r = t.cache;
          if (r.has(i))
            return r.get(i);
          var s = o.apply(this, n);
          return t.cache = r.set(i, s) || r, s;
        };
        return t.cache = new (_a.Cache || br)(), t;
      }
      _a.Cache = br;
      const O_ = _a, R_ = function(o) {
        var e = O_(o, function(n) {
          return t.size === 500 && t.clear(), n;
        }), t = e.cache;
        return e;
      };
      var z_ = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, M_ = /\\(\\)?/g, N_ = R_(function(o) {
        var e = [];
        return o.charCodeAt(0) === 46 && e.push(""), o.replace(z_, function(t, n, i, r) {
          e.push(i ? r.replace(M_, "$1") : n || t);
        }), e;
      });
      const F_ = N_, Vu = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length, i = Array(n); ++t < n; )
          i[t] = e(o[t], t, o);
        return i;
      };
      var ju = Qt ? Qt.prototype : void 0, Hu = ju ? ju.toString : void 0;
      const $_ = function o(e) {
        if (typeof e == "string")
          return e;
        if (_t(e))
          return Vu(e, o) + "";
        if (Or(e))
          return Hu ? Hu.call(e) : "";
        var t = e + "";
        return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
      }, Aa = function(o) {
        return o == null ? "" : $_(o);
      }, Ca = function(o, e) {
        return _t(o) ? o : I_(o, e) ? [o] : F_(Aa(o));
      }, L_ = function(o) {
        var e = o == null ? 0 : o.length;
        return e ? o[e - 1] : void 0;
      }, ya = function(o) {
        if (typeof o == "string" || Or(o))
          return o;
        var e = o + "";
        return e == "0" && 1 / o == -1 / 0 ? "-0" : e;
      }, Uu = function(o, e) {
        for (var t = 0, n = (e = Ca(e, o)).length; o != null && t < n; )
          o = o[ya(e[t++])];
        return t && t == n ? o : void 0;
      }, qu = function(o, e, t) {
        var n = -1, i = o.length;
        e < 0 && (e = -e > i ? 0 : i + e), (t = t > i ? i : t) < 0 && (t += i), i = e > t ? 0 : t - e >>> 0, e >>>= 0;
        for (var r = Array(i); ++n < i; )
          r[n] = o[n + e];
        return r;
      }, V_ = function(o, e) {
        return e.length < 2 ? o : Uu(o, qu(e, 0, -1));
      }, j_ = function(o, e) {
        return e = Ca(e, o), (o = V_(o, e)) == null || delete o[ya(L_(e))];
      }, H_ = function(o, e) {
        return o == null || j_(o, e);
      }, Rr = function(o, e, t) {
        var n = o == null ? void 0 : Uu(o, e);
        return n === void 0 ? t : n;
      }, Ea = function(o, e, t) {
        (t !== void 0 && !ki(o[e], t) || t === void 0 && !(e in o)) && js(o, e, t);
      }, U_ = /* @__PURE__ */ function(o) {
        return function(e, t, n) {
          for (var i = -1, r = Object(e), s = n(e), a = s.length; a--; ) {
            var l = s[o ? a : ++i];
            if (t(r[l], l, r) === !1)
              break;
          }
          return e;
        };
      }(), q_ = function(o) {
        return Lt(o) && vr(o);
      }, xa = function(o, e) {
        if ((e !== "constructor" || typeof o[e] != "function") && e != "__proto__")
          return o[e];
      }, W_ = function(o) {
        return Po(o, Oo(o));
      }, G_ = function(o, e, t, n, i, r, s) {
        var a = xa(o, t), l = xa(e, t), d = s.get(l);
        if (d)
          Ea(o, t, d);
        else {
          var h = r ? r(a, l, t + "", o, e, s) : void 0, m = h === void 0;
          if (m) {
            var f = _t(l), _ = !f && Ai(l), E = !f && !_ && Gs(l);
            h = l, f || _ || E ? _t(a) ? h = a : q_(a) ? h = Js(a) : _ ? (m = !1, h = fd(l, !0)) : E ? (m = !1, h = Bd(l, !0)) : h = [] : Ct(l) || Us(l) ? (h = a, Us(a) ? h = W_(a) : K(a) && !Un(a) || (h = Pd(l))) : m = !1;
          }
          m && (s.set(l, h), i(h, l, n, r, s), s.delete(l)), Ea(o, t, h);
        }
      }, Wu = function o(e, t, n, i, r) {
        e !== t && U_(t, function(s, a) {
          if (r || (r = new _i()), K(s))
            G_(e, t, a, n, o, i, r);
          else {
            var l = i ? i(xa(e, a), s, a + "", e, t, r) : void 0;
            l === void 0 && (l = s), Ea(e, a, l);
          }
        }, Oo);
      }, Qn = function(o) {
        return o;
      }, K_ = function(o, e, t) {
        switch (t.length) {
          case 0:
            return o.call(e);
          case 1:
            return o.call(e, t[0]);
          case 2:
            return o.call(e, t[0], t[1]);
          case 3:
            return o.call(e, t[0], t[1], t[2]);
        }
        return o.apply(e, t);
      };
      var Gu = Math.max;
      const Z_ = function(o, e, t) {
        return e = Gu(e === void 0 ? o.length - 1 : e, 0), function() {
          for (var n = arguments, i = -1, r = Gu(n.length - e, 0), s = Array(r); ++i < r; )
            s[i] = n[e + i];
          i = -1;
          for (var a = Array(e + 1); ++i < e; )
            a[i] = n[i];
          return a[e] = t(s), K_(o, this, a);
        };
      }, J_ = function(o) {
        return function() {
          return o;
        };
      }, Y_ = kr ? function(o, e) {
        return kr(o, "toString", { configurable: !0, enumerable: !1, value: J_(e), writable: !0 });
      } : Qn;
      var Q_ = Date.now;
      const X_ = function(o) {
        var e = 0, t = 0;
        return function() {
          var n = Q_(), i = 16 - (n - t);
          if (t = n, i > 0) {
            if (++e >= 800)
              return arguments[0];
          } else
            e = 0;
          return o.apply(void 0, arguments);
        };
      }(Y_), Ku = function(o, e) {
        return X_(Z_(o, e, Qn), o + "");
      }, eA = function(o, e, t) {
        if (!K(t))
          return !1;
        var n = typeof e;
        return !!(n == "number" ? vr(t) && qs(e, t.length) : n == "string" && e in t) && ki(t[e], o);
      }, Sa = function(o) {
        return Ku(function(e, t) {
          var n = -1, i = t.length, r = i > 1 ? t[i - 1] : void 0, s = i > 2 ? t[2] : void 0;
          for (r = o.length > 3 && typeof r == "function" ? (i--, r) : void 0, s && eA(t[0], t[1], s) && (r = i < 3 ? void 0 : r, i = 1), e = Object(e); ++n < i; ) {
            var a = t[n];
            a && o(e, a, n, r);
          }
          return e;
        });
      }, Zu = Sa(function(o, e, t) {
        Wu(o, e, t);
      }), tA = function(o, e, t, n) {
        if (!K(o))
          return o;
        for (var i = -1, r = (e = Ca(e, o)).length, s = r - 1, a = o; a != null && ++i < r; ) {
          var l = ya(e[i]), d = t;
          if (l === "__proto__" || l === "constructor" || l === "prototype")
            return o;
          if (i != s) {
            var h = a[l];
            (d = n ? n(h, l, a) : void 0) === void 0 && (d = K(h) ? h : qs(e[i + 1]) ? [] : {});
          }
          Hs(a, l, d), a = a[l];
        }
        return o;
      }, nA = function(o, e, t) {
        return o == null ? o : tA(o, e, t);
      };
      class oA {
        constructor(e) {
          this._styles = {}, this._styleProcessor = e;
        }
        get isEmpty() {
          const e = Object.entries(this._styles);
          return !Array.from(e).length;
        }
        get size() {
          return this.isEmpty ? 0 : this.getStyleNames().length;
        }
        setTo(e) {
          this.clear();
          const t = Array.from(function(n) {
            let i = null, r = 0, s = 0, a = null;
            const l = /* @__PURE__ */ new Map();
            if (n === "")
              return l;
            n.charAt(n.length - 1) != ";" && (n += ";");
            for (let d = 0; d < n.length; d++) {
              const h = n.charAt(d);
              if (i === null)
                switch (h) {
                  case ":":
                    a || (a = n.substr(r, d - r), s = d + 1);
                    break;
                  case '"':
                  case "'":
                    i = h;
                    break;
                  case ";": {
                    const m = n.substr(s, d - s);
                    a && l.set(a.trim(), m.trim()), a = null, r = d + 1;
                    break;
                  }
                }
              else
                h === i && (i = null);
            }
            return l;
          }(e).entries());
          for (const [n, i] of t)
            this._styleProcessor.toNormalizedForm(n, i, this._styles);
        }
        has(e) {
          if (this.isEmpty)
            return !1;
          const t = this._styleProcessor.getReducedForm(e, this._styles).find(([n]) => n === e);
          return Array.isArray(t);
        }
        set(e, t) {
          if (K(e))
            for (const [n, i] of Object.entries(e))
              this._styleProcessor.toNormalizedForm(n, i, this._styles);
          else
            this._styleProcessor.toNormalizedForm(e, t, this._styles);
        }
        remove(e) {
          const t = Da(e);
          H_(this._styles, t), delete this._styles[e], this._cleanEmptyObjectsOnPath(t);
        }
        getNormalized(e) {
          return this._styleProcessor.getNormalized(e, this._styles);
        }
        toString() {
          return this.isEmpty ? "" : this._getStylesEntries().map((e) => e.join(":")).sort().join(";") + ";";
        }
        getAsString(e) {
          if (this.isEmpty)
            return;
          if (this._styles[e] && !K(this._styles[e]))
            return this._styles[e];
          const t = this._styleProcessor.getReducedForm(e, this._styles).find(([n]) => n === e);
          return Array.isArray(t) ? t[1] : void 0;
        }
        getStyleNames(e = !1) {
          return this.isEmpty ? [] : e ? this._styleProcessor.getStyleNames(this._styles) : this._getStylesEntries().map(([t]) => t);
        }
        clear() {
          this._styles = {};
        }
        _getStylesEntries() {
          const e = [], t = Object.keys(this._styles);
          for (const n of t)
            e.push(...this._styleProcessor.getReducedForm(n, this._styles));
          return e;
        }
        _cleanEmptyObjectsOnPath(e) {
          const t = e.split(".");
          if (!(t.length > 1))
            return;
          const n = t.splice(0, t.length - 1).join("."), i = Rr(this._styles, n);
          i && !Array.from(Object.keys(i)).length && this.remove(n);
        }
      }
      class iA {
        constructor() {
          this._normalizers = /* @__PURE__ */ new Map(), this._extractors = /* @__PURE__ */ new Map(), this._reducers = /* @__PURE__ */ new Map(), this._consumables = /* @__PURE__ */ new Map();
        }
        toNormalizedForm(e, t, n) {
          if (K(t))
            Ba(n, Da(e), t);
          else if (this._normalizers.has(e)) {
            const i = this._normalizers.get(e), { path: r, value: s } = i(t);
            Ba(n, r, s);
          } else
            Ba(n, e, t);
        }
        getNormalized(e, t) {
          if (!e)
            return Zu({}, t);
          if (t[e] !== void 0)
            return t[e];
          if (this._extractors.has(e)) {
            const n = this._extractors.get(e);
            if (typeof n == "string")
              return Rr(t, n);
            const i = n(e, t);
            if (i)
              return i;
          }
          return Rr(t, Da(e));
        }
        getReducedForm(e, t) {
          const n = this.getNormalized(e, t);
          return n === void 0 ? [] : this._reducers.has(e) ? this._reducers.get(e)(n) : [[e, n]];
        }
        getStyleNames(e) {
          const t = Array.from(this._consumables.keys()).filter((i) => {
            const r = this.getNormalized(i, e);
            return r && typeof r == "object" ? Object.keys(r).length : r;
          }), n = /* @__PURE__ */ new Set([...t, ...Object.keys(e)]);
          return Array.from(n.values());
        }
        getRelatedStyles(e) {
          return this._consumables.get(e) || [];
        }
        setNormalizer(e, t) {
          this._normalizers.set(e, t);
        }
        setExtractor(e, t) {
          this._extractors.set(e, t);
        }
        setReducer(e, t) {
          this._reducers.set(e, t);
        }
        setStyleRelation(e, t) {
          this._mapStyleNames(e, t);
          for (const n of t)
            this._mapStyleNames(n, [e]);
        }
        _mapStyleNames(e, t) {
          this._consumables.has(e) || this._consumables.set(e, []), this._consumables.get(e).push(...t);
        }
      }
      function Da(o) {
        return o.replace("-", ".");
      }
      function Ba(o, e, t) {
        let n = t;
        K(t) && (n = Zu({}, Rr(o, e), t)), nA(o, e, n);
      }
      class Ot extends Yn {
        constructor(e, t, n, i) {
          if (super(e), this._unsafeAttributesToRender = [], this._customProperties = /* @__PURE__ */ new Map(), this.name = t, this._attrs = function(r) {
            const s = hn(r);
            for (const [a, l] of s)
              l === null ? s.delete(a) : typeof l != "string" && s.set(a, String(l));
            return s;
          }(n), this._children = [], i && this._insertChild(0, i), this._classes = /* @__PURE__ */ new Set(), this._attrs.has("class")) {
            const r = this._attrs.get("class");
            Ju(this._classes, r), this._attrs.delete("class");
          }
          this._styles = new oA(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style"));
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this._children.length === 0;
        }
        getChild(e) {
          return this._children[e];
        }
        getChildIndex(e) {
          return this._children.indexOf(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        *getAttributeKeys() {
          this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys();
        }
        *getAttributes() {
          yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
        }
        getAttribute(e) {
          if (e == "class")
            return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
          if (e == "style") {
            const t = this._styles.toString();
            return t == "" ? void 0 : t;
          }
          return this._attrs.get(e);
        }
        hasAttribute(e) {
          return e == "class" ? this._classes.size > 0 : e == "style" ? !this._styles.isEmpty : this._attrs.has(e);
        }
        isSimilar(e) {
          if (!(e instanceof Ot))
            return !1;
          if (this === e)
            return !0;
          if (this.name != e.name || this._attrs.size !== e._attrs.size || this._classes.size !== e._classes.size || this._styles.size !== e._styles.size)
            return !1;
          for (const [t, n] of this._attrs)
            if (!e._attrs.has(t) || e._attrs.get(t) !== n)
              return !1;
          for (const t of this._classes)
            if (!e._classes.has(t))
              return !1;
          for (const t of this._styles.getStyleNames())
            if (!e._styles.has(t) || e._styles.getAsString(t) !== this._styles.getAsString(t))
              return !1;
          return !0;
        }
        hasClass(...e) {
          for (const t of e)
            if (!this._classes.has(t))
              return !1;
          return !0;
        }
        getClassNames() {
          return this._classes.keys();
        }
        getStyle(e) {
          return this._styles.getAsString(e);
        }
        getNormalizedStyle(e) {
          return this._styles.getNormalized(e);
        }
        getStyleNames(e) {
          return this._styles.getStyleNames(e);
        }
        hasStyle(...e) {
          for (const t of e)
            if (!this._styles.has(t))
              return !1;
          return !0;
        }
        findAncestor(...e) {
          const t = new Fo(...e);
          let n = this.parent;
          for (; n && !n.is("documentFragment"); ) {
            if (t.match(n))
              return n;
            n = n.parent;
          }
          return null;
        }
        getCustomProperty(e) {
          return this._customProperties.get(e);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        getIdentity() {
          const e = Array.from(this._classes).sort().join(","), t = this._styles.toString(), n = Array.from(this._attrs).map((i) => `${i[0]}="${i[1]}"`).sort().join(" ");
          return this.name + (e == "" ? "" : ` class="${e}"`) + (t ? ` style="${t}"` : "") + (n == "" ? "" : ` ${n}`);
        }
        shouldRenderUnsafeAttribute(e) {
          return this._unsafeAttributesToRender.includes(e);
        }
        _clone(e = !1) {
          const t = [];
          if (e)
            for (const i of this.getChildren())
              t.push(i._clone(e));
          const n = new this.constructor(this.document, this.name, this._attrs, t);
          return n._classes = new Set(this._classes), n._styles.set(this._styles.getNormalized()), n._customProperties = new Map(this._customProperties), n.getFillerOffset = this.getFillerOffset, n._unsafeAttributesToRender = this._unsafeAttributesToRender, n;
        }
        _appendChild(e) {
          return this._insertChild(this.childCount, e);
        }
        _insertChild(e, t) {
          this._fireChange("children", this);
          let n = 0;
          const i = function(r, s) {
            return typeof s == "string" ? [new Ne(r, s)] : (It(s) || (s = [s]), Array.from(s).map((a) => typeof a == "string" ? new Ne(r, a) : a instanceof en ? new Ne(r, a.data) : a));
          }(this.document, t);
          for (const r of i)
            r.parent !== null && r._remove(), r.parent = this, r.document = this.document, this._children.splice(e, 0, r), e++, n++;
          return n;
        }
        _removeChildren(e, t = 1) {
          this._fireChange("children", this);
          for (let n = e; n < e + t; n++)
            this._children[n].parent = null;
          return this._children.splice(e, t);
        }
        _setAttribute(e, t) {
          const n = String(t);
          this._fireChange("attributes", this), e == "class" ? Ju(this._classes, n) : e == "style" ? this._styles.setTo(n) : this._attrs.set(e, n);
        }
        _removeAttribute(e) {
          return this._fireChange("attributes", this), e == "class" ? this._classes.size > 0 && (this._classes.clear(), !0) : e == "style" ? !this._styles.isEmpty && (this._styles.clear(), !0) : this._attrs.delete(e);
        }
        _addClass(e) {
          this._fireChange("attributes", this);
          for (const t of Xe(e))
            this._classes.add(t);
        }
        _removeClass(e) {
          this._fireChange("attributes", this);
          for (const t of Xe(e))
            this._classes.delete(t);
        }
        _setStyle(e, t) {
          this._fireChange("attributes", this), typeof e != "string" ? this._styles.set(e) : this._styles.set(e, t);
        }
        _removeStyle(e) {
          this._fireChange("attributes", this);
          for (const t of Xe(e))
            this._styles.remove(t);
        }
        _setCustomProperty(e, t) {
          this._customProperties.set(e, t);
        }
        _removeCustomProperty(e) {
          return this._customProperties.delete(e);
        }
      }
      function Ju(o, e) {
        const t = e.split(/\s+/);
        o.clear(), t.forEach((n) => o.add(n));
      }
      Ot.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "element" || o === "view:element") : o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Di extends Ot {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = Yu;
        }
      }
      function Yu() {
        const o = [...this.getChildren()], e = o[this.childCount - 1];
        if (e && e.is("element", "br"))
          return this.childCount;
        for (const t of o)
          if (!t.is("uiElement"))
            return null;
        return this.childCount;
      }
      Di.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class zr extends oe(Di) {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.set("isReadOnly", !1), this.set("isFocused", !1), this.bind("isReadOnly").to(e), this.bind("isFocused").to(e, "isFocused", (r) => r && e.selection.editableElement == this), this.listenTo(e.selection, "change", () => {
            this.isFocused = e.isFocused && e.selection.editableElement == this;
          });
        }
        destroy() {
          this.stopListening();
        }
      }
      zr.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      const Qu = Symbol("rootName");
      class Xu extends zr {
        constructor(e, t) {
          super(e, t), this.rootName = "main";
        }
        get rootName() {
          return this.getCustomProperty(Qu);
        }
        set rootName(e) {
          this._setCustomProperty(Qu, e);
        }
        set _name(e) {
          this.name = e;
        }
      }
      Xu.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "rootElement" || o === "view:rootElement" || o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "rootElement" || o === "view:rootElement" || o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Xn {
        constructor(e = {}) {
          if (!e.boundaries && !e.startPosition)
            throw new I("view-tree-walker-no-start-position", null);
          if (e.direction && e.direction != "forward" && e.direction != "backward")
            throw new I("view-tree-walker-unknown-direction", e.startPosition, { direction: e.direction });
          this.boundaries = e.boundaries || null, e.startPosition ? this._position = Z._createAt(e.startPosition) : this._position = Z._createAt(e.boundaries[e.direction == "backward" ? "end" : "start"]), this.direction = e.direction || "forward", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(e) {
          let t, n;
          do
            n = this.position, t = this.next();
          while (!t.done && e(t.value));
          t.done || (this._position = n);
        }
        next() {
          return this.direction == "forward" ? this._next() : this._previous();
        }
        _next() {
          let e = this.position.clone();
          const t = this.position, n = e.parent;
          if (n.parent === null && e.offset === n.childCount)
            return { done: !0, value: void 0 };
          if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset)
            return { done: !0, value: void 0 };
          let i;
          if (n instanceof Ne) {
            if (e.isAtEnd)
              return this._position = Z._createAfter(n), this._next();
            i = n.data[e.offset];
          } else
            i = n.getChild(e.offset);
          if (i instanceof Ot)
            return this.shallow ? e.offset++ : e = new Z(i, 0), this._position = e, this._formatReturnValue("elementStart", i, t, e, 1);
          if (i instanceof Ne) {
            if (this.singleCharacters)
              return e = new Z(i, 0), this._position = e, this._next();
            {
              let r, s = i.data.length;
              return i == this._boundaryEndParent ? (s = this.boundaries.end.offset, r = new en(i, 0, s), e = Z._createAfter(r)) : (r = new en(i, 0, i.data.length), e.offset++), this._position = e, this._formatReturnValue("text", r, t, e, s);
            }
          }
          if (typeof i == "string") {
            let r;
            this.singleCharacters ? r = 1 : r = (n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length) - e.offset;
            const s = new en(n, e.offset, r);
            return e.offset += r, this._position = e, this._formatReturnValue("text", s, t, e, r);
          }
          return e = Z._createAfter(n), this._position = e, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n, t, e);
        }
        _previous() {
          let e = this.position.clone();
          const t = this.position, n = e.parent;
          if (n.parent === null && e.offset === 0)
            return { done: !0, value: void 0 };
          if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset)
            return { done: !0, value: void 0 };
          let i;
          if (n instanceof Ne) {
            if (e.isAtStart)
              return this._position = Z._createBefore(n), this._previous();
            i = n.data[e.offset - 1];
          } else
            i = n.getChild(e.offset - 1);
          if (i instanceof Ot)
            return this.shallow ? (e.offset--, this._position = e, this._formatReturnValue("elementStart", i, t, e, 1)) : (e = new Z(i, i.childCount), this._position = e, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", i, t, e));
          if (i instanceof Ne) {
            if (this.singleCharacters)
              return e = new Z(i, i.data.length), this._position = e, this._previous();
            {
              let r, s = i.data.length;
              if (i == this._boundaryStartParent) {
                const a = this.boundaries.start.offset;
                r = new en(i, a, i.data.length - a), s = r.data.length, e = Z._createBefore(r);
              } else
                r = new en(i, 0, i.data.length), e.offset--;
              return this._position = e, this._formatReturnValue("text", r, t, e, s);
            }
          }
          if (typeof i == "string") {
            let r;
            if (this.singleCharacters)
              r = 1;
            else {
              const a = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
              r = e.offset - a;
            }
            e.offset -= r;
            const s = new en(n, e.offset, r);
            return this._position = e, this._formatReturnValue("text", s, t, e, r);
          }
          return e = Z._createBefore(n), this._position = e, this._formatReturnValue("elementStart", n, t, e, 1);
        }
        _formatReturnValue(e, t, n, i, r) {
          return t instanceof en && (t.offsetInText + t.data.length == t.textNode.data.length && (this.direction != "forward" || this.boundaries && this.boundaries.end.isEqual(this.position) ? n = Z._createAfter(t.textNode) : (i = Z._createAfter(t.textNode), this._position = i)), t.offsetInText === 0 && (this.direction != "backward" || this.boundaries && this.boundaries.start.isEqual(this.position) ? n = Z._createBefore(t.textNode) : (i = Z._createBefore(t.textNode), this._position = i))), { done: !1, value: { type: e, item: t, previousPosition: n, nextPosition: i, length: r } };
        }
      }
      class Z extends Jn {
        constructor(e, t) {
          super(), this.parent = e, this.offset = t;
        }
        get nodeAfter() {
          return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null;
        }
        get nodeBefore() {
          return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null;
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          const e = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
          return this.offset === e;
        }
        get root() {
          return this.parent.root;
        }
        get editableElement() {
          let e = this.parent;
          for (; !(e instanceof zr); ) {
            if (!e.parent)
              return null;
            e = e.parent;
          }
          return e;
        }
        getShiftedBy(e) {
          const t = Z._createAt(this), n = t.offset + e;
          return t.offset = n < 0 ? 0 : n, t;
        }
        getLastMatchingPosition(e, t = {}) {
          t.startPosition = this;
          const n = new Xn(t);
          return n.skip(e), n.position;
        }
        getAncestors() {
          return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: !0 });
        }
        getCommonAncestor(e) {
          const t = this.getAncestors(), n = e.getAncestors();
          let i = 0;
          for (; t[i] == n[i] && t[i]; )
            i++;
          return i === 0 ? null : t[i - 1];
        }
        isEqual(e) {
          return this.parent == e.parent && this.offset == e.offset;
        }
        isBefore(e) {
          return this.compareWith(e) == "before";
        }
        isAfter(e) {
          return this.compareWith(e) == "after";
        }
        compareWith(e) {
          if (this.root !== e.root)
            return "different";
          if (this.isEqual(e))
            return "same";
          const t = this.parent.is("node") ? this.parent.getPath() : [], n = e.parent.is("node") ? e.parent.getPath() : [];
          t.push(this.offset), n.push(e.offset);
          const i = vt(t, n);
          switch (i) {
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return t[i] < n[i] ? "before" : "after";
          }
        }
        getWalker(e = {}) {
          return e.startPosition = this, new Xn(e);
        }
        clone() {
          return new Z(this.parent, this.offset);
        }
        static _createAt(e, t) {
          if (e instanceof Z)
            return new this(e.parent, e.offset);
          {
            const n = e;
            if (t == "end")
              t = n.is("$text") ? n.data.length : n.childCount;
            else {
              if (t == "before")
                return this._createBefore(n);
              if (t == "after")
                return this._createAfter(n);
              if (t !== 0 && !t)
                throw new I("view-createpositionat-offset-required", n);
            }
            return new Z(n, t);
          }
        }
        static _createAfter(e) {
          if (e.is("$textProxy"))
            return new Z(e.textNode, e.offsetInText + e.data.length);
          if (!e.parent)
            throw new I("view-position-after-root", e, { root: e });
          return new Z(e.parent, e.index + 1);
        }
        static _createBefore(e) {
          if (e.is("$textProxy"))
            return new Z(e.textNode, e.offsetInText);
          if (!e.parent)
            throw new I("view-position-before-root", e, { root: e });
          return new Z(e.parent, e.index);
        }
      }
      Z.prototype.is = function(o) {
        return o === "position" || o === "view:position";
      };
      class re extends Jn {
        constructor(e, t = null) {
          super(), this.start = e.clone(), this.end = t ? t.clone() : e.clone();
        }
        *[Symbol.iterator]() {
          yield* new Xn({ boundaries: this, ignoreElementEnd: !0 });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return this.start.parent === this.end.parent;
        }
        get root() {
          return this.start.root;
        }
        getEnlarged() {
          let e = this.start.getLastMatchingPosition(Mr, { direction: "backward" }), t = this.end.getLastMatchingPosition(Mr);
          return e.parent.is("$text") && e.isAtStart && (e = Z._createBefore(e.parent)), t.parent.is("$text") && t.isAtEnd && (t = Z._createAfter(t.parent)), new re(e, t);
        }
        getTrimmed() {
          let e = this.start.getLastMatchingPosition(Mr);
          if (e.isAfter(this.end) || e.isEqual(this.end))
            return new re(e, e);
          let t = this.end.getLastMatchingPosition(Mr, { direction: "backward" });
          const n = e.nodeAfter, i = t.nodeBefore;
          return n && n.is("$text") && (e = new Z(n, 0)), i && i.is("$text") && (t = new Z(i, i.data.length)), new re(e, t);
        }
        isEqual(e) {
          return this == e || this.start.isEqual(e.start) && this.end.isEqual(e.end);
        }
        containsPosition(e) {
          return e.isAfter(this.start) && e.isBefore(this.end);
        }
        containsRange(e, t = !1) {
          e.isCollapsed && (t = !1);
          const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start), i = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
          return n && i;
        }
        getDifference(e) {
          const t = [];
          return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new re(this.start, e.start)), this.containsPosition(e.end) && t.push(new re(e.end, this.end))) : t.push(this.clone()), t;
        }
        getIntersection(e) {
          if (this.isIntersecting(e)) {
            let t = this.start, n = this.end;
            return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new re(t, n);
          }
          return null;
        }
        getWalker(e = {}) {
          return e.boundaries = this, new Xn(e);
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed)
            return null;
          let e = this.start.nodeAfter, t = this.end.nodeBefore;
          return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (e = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (t = this.end.parent.previousSibling), e && e.is("element") && e === t ? e : null;
        }
        clone() {
          return new re(this.start, this.end);
        }
        *getItems(e = {}) {
          e.boundaries = this, e.ignoreElementEnd = !0;
          const t = new Xn(e);
          for (const n of t)
            yield n.item;
        }
        *getPositions(e = {}) {
          e.boundaries = this;
          const t = new Xn(e);
          yield t.position;
          for (const n of t)
            yield n.nextPosition;
        }
        isIntersecting(e) {
          return this.start.isBefore(e.end) && this.end.isAfter(e.start);
        }
        static _createFromParentsAndOffsets(e, t, n, i) {
          return new this(new Z(e, t), new Z(n, i));
        }
        static _createFromPositionAndShift(e, t) {
          const n = e, i = e.getShiftedBy(t);
          return t > 0 ? new this(n, i) : new this(i, n);
        }
        static _createIn(e) {
          return this._createFromParentsAndOffsets(e, 0, e, e.childCount);
        }
        static _createOn(e) {
          const t = e.is("$textProxy") ? e.offsetSize : 1;
          return this._createFromPositionAndShift(Z._createBefore(e), t);
        }
      }
      function Mr(o) {
        return !(!o.item.is("attributeElement") && !o.item.is("uiElement"));
      }
      re.prototype.is = function(o) {
        return o === "range" || o === "view:range";
      };
      class tn extends De(Jn) {
        constructor(...e) {
          super(), this._ranges = [], this._lastRangeBackward = !1, this._isFake = !1, this._fakeSelectionLabel = "", e.length && this.setTo(...e);
        }
        get isFake() {
          return this._isFake;
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel;
        }
        get anchor() {
          if (!this._ranges.length)
            return null;
          const e = this._ranges[this._ranges.length - 1];
          return (this._lastRangeBackward ? e.end : e.start).clone();
        }
        get focus() {
          if (!this._ranges.length)
            return null;
          const e = this._ranges[this._ranges.length - 1];
          return (this._lastRangeBackward ? e.start : e.end).clone();
        }
        get isCollapsed() {
          return this.rangeCount === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        get editableElement() {
          return this.anchor ? this.anchor.editableElement : null;
        }
        *getRanges() {
          for (const e of this._ranges)
            yield e.clone();
        }
        getFirstRange() {
          let e = null;
          for (const t of this._ranges)
            e && !t.start.isBefore(e.start) || (e = t);
          return e ? e.clone() : null;
        }
        getLastRange() {
          let e = null;
          for (const t of this._ranges)
            e && !t.end.isAfter(e.end) || (e = t);
          return e ? e.clone() : null;
        }
        getFirstPosition() {
          const e = this.getFirstRange();
          return e ? e.start.clone() : null;
        }
        getLastPosition() {
          const e = this.getLastRange();
          return e ? e.end.clone() : null;
        }
        isEqual(e) {
          if (this.isFake != e.isFake || this.isFake && this.fakeSelectionLabel != e.fakeSelectionLabel || this.rangeCount != e.rangeCount)
            return !1;
          if (this.rangeCount === 0)
            return !0;
          if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
            return !1;
          for (const t of this._ranges) {
            let n = !1;
            for (const i of e._ranges)
              if (t.isEqual(i)) {
                n = !0;
                break;
              }
            if (!n)
              return !1;
          }
          return !0;
        }
        isSimilar(e) {
          if (this.isBackward != e.isBackward)
            return !1;
          const t = Fs(this.getRanges());
          if (t != Fs(e.getRanges()))
            return !1;
          if (t == 0)
            return !0;
          for (let n of this.getRanges()) {
            n = n.getTrimmed();
            let i = !1;
            for (let r of e.getRanges())
              if (r = r.getTrimmed(), n.start.isEqual(r.start) && n.end.isEqual(r.end)) {
                i = !0;
                break;
              }
            if (!i)
              return !1;
          }
          return !0;
        }
        getSelectedElement() {
          return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
        }
        setTo(...e) {
          let [t, n, i] = e;
          if (typeof n == "object" && (i = n, n = void 0), t === null)
            this._setRanges([]), this._setFakeOptions(i);
          else if (t instanceof tn || t instanceof Ta)
            this._setRanges(t.getRanges(), t.isBackward), this._setFakeOptions({ fake: t.isFake, label: t.fakeSelectionLabel });
          else if (t instanceof re)
            this._setRanges([t], i && i.backward), this._setFakeOptions(i);
          else if (t instanceof Z)
            this._setRanges([new re(t)]), this._setFakeOptions(i);
          else if (t instanceof Yn) {
            const r = !!i && !!i.backward;
            let s;
            if (n === void 0)
              throw new I("view-selection-setto-required-second-parameter", this);
            s = n == "in" ? re._createIn(t) : n == "on" ? re._createOn(t) : new re(Z._createAt(t, n)), this._setRanges([s], r), this._setFakeOptions(i);
          } else {
            if (!It(t))
              throw new I("view-selection-setto-not-selectable", this);
            this._setRanges(t, i && i.backward), this._setFakeOptions(i);
          }
          this.fire("change");
        }
        setFocus(e, t) {
          if (this.anchor === null)
            throw new I("view-selection-setfocus-no-ranges", this);
          const n = Z._createAt(e, t);
          if (n.compareWith(this.focus) == "same")
            return;
          const i = this.anchor;
          this._ranges.pop(), n.compareWith(i) == "before" ? this._addRange(new re(n, i), !0) : this._addRange(new re(i, n)), this.fire("change");
        }
        _setRanges(e, t = !1) {
          e = Array.from(e), this._ranges = [];
          for (const n of e)
            this._addRange(n);
          this._lastRangeBackward = !!t;
        }
        _setFakeOptions(e = {}) {
          this._isFake = !!e.fake, this._fakeSelectionLabel = e.fake && e.label || "";
        }
        _addRange(e, t = !1) {
          if (!(e instanceof re))
            throw new I("view-selection-add-range-not-range", this);
          this._pushRange(e), this._lastRangeBackward = !!t;
        }
        _pushRange(e) {
          for (const t of this._ranges)
            if (e.isIntersecting(t))
              throw new I("view-selection-range-intersects", this, { addedRange: e, intersectingRange: t });
          this._ranges.push(new re(e.start, e.end));
        }
      }
      tn.prototype.is = function(o) {
        return o === "selection" || o === "view:selection";
      };
      class Ta extends De(Jn) {
        constructor(...e) {
          super(), this._selection = new tn(), this._selection.delegate("change").to(this), e.length && this._selection.setTo(...e);
        }
        get isFake() {
          return this._selection.isFake;
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get editableElement() {
          return this._selection.editableElement;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        *getRanges() {
          yield* this._selection.getRanges();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        isEqual(e) {
          return this._selection.isEqual(e);
        }
        isSimilar(e) {
          return this._selection.isSimilar(e);
        }
        _setTo(...e) {
          this._selection.setTo(...e);
        }
        _setFocus(e, t) {
          this._selection.setFocus(e, t);
        }
      }
      Ta.prototype.is = function(o) {
        return o === "selection" || o == "documentSelection" || o == "view:selection" || o == "view:documentSelection";
      };
      class $o extends U {
        constructor(e, t, n) {
          super(e, t), this.startRange = n, this._eventPhase = "none", this._currentTarget = null;
        }
        get eventPhase() {
          return this._eventPhase;
        }
        get currentTarget() {
          return this._currentTarget;
        }
      }
      const Pa = Symbol("bubbling contexts");
      function Ia(o) {
        return class extends o {
          fire(e, ...t) {
            try {
              const n = e instanceof U ? e : new U(this, e), i = Oa(this);
              if (!i.size)
                return;
              if (Bi(n, "capturing", this), Lo(i, "$capture", n, ...t))
                return n.return;
              const r = n.startRange || this.selection.getFirstRange(), s = r ? r.getContainedElement() : null, a = !!s && !!eh(i, s);
              let l = s || function(d) {
                if (!d)
                  return null;
                const h = d.start.parent, m = d.end.parent, f = h.getPath(), _ = m.getPath();
                return f.length > _.length ? h : m;
              }(r);
              if (Bi(n, "atTarget", l), !a) {
                if (Lo(i, "$text", n, ...t))
                  return n.return;
                Bi(n, "bubbling", l);
              }
              for (; l; ) {
                if (l.is("rootElement")) {
                  if (Lo(i, "$root", n, ...t))
                    return n.return;
                } else if (l.is("element") && Lo(i, l.name, n, ...t))
                  return n.return;
                if (Lo(i, l, n, ...t))
                  return n.return;
                l = l.parent, Bi(n, "bubbling", l);
              }
              return Bi(n, "bubbling", this), Lo(i, "$document", n, ...t), n.return;
            } catch (n) {
              I.rethrowUnexpectedError(n, this);
            }
          }
          _addEventListener(e, t, n) {
            const i = Xe(n.context || "$document"), r = Oa(this);
            for (const s of i) {
              let a = r.get(s);
              a || (a = new (De())(), r.set(s, a)), this.listenTo(a, e, t, n);
            }
          }
          _removeEventListener(e, t) {
            const n = Oa(this);
            for (const i of n.values())
              this.stopListening(i, e, t);
          }
        };
      }
      {
        const o = Ia(Object);
        ["fire", "_addEventListener", "_removeEventListener"].forEach((e) => {
          Ia[e] = o.prototype[e];
        });
      }
      function Bi(o, e, t) {
        o instanceof $o && (o._eventPhase = e, o._currentTarget = t);
      }
      function Lo(o, e, t, ...n) {
        const i = typeof e == "string" ? o.get(e) : eh(o, e);
        return !!i && (i.fire(t, ...n), t.stop.called);
      }
      function eh(o, e) {
        for (const [t, n] of o)
          if (typeof t == "function" && t(e))
            return n;
        return null;
      }
      function Oa(o) {
        return o[Pa] || (o[Pa] = /* @__PURE__ */ new Map()), o[Pa];
      }
      class th extends Ia(oe()) {
        constructor(e) {
          super(), this._postFixers = /* @__PURE__ */ new Set(), this.selection = new Ta(), this.roots = new Vt({ idProperty: "rootName" }), this.stylesProcessor = e, this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1);
        }
        getRoot(e = "main") {
          return this.roots.get(e);
        }
        registerPostFixer(e) {
          this._postFixers.add(e);
        }
        destroy() {
          this.roots.map((e) => e.destroy()), this.stopListening();
        }
        _callPostFixers(e) {
          let t = !1;
          do
            for (const n of this._postFixers)
              if (t = n(e), t)
                break;
          while (t);
        }
      }
      class eo extends Ot {
        constructor(e, t, n, i) {
          super(e, t, n, i), this._priority = 10, this._id = null, this._clonesGroup = null, this.getFillerOffset = rA;
        }
        get priority() {
          return this._priority;
        }
        get id() {
          return this._id;
        }
        getElementsWithSameId() {
          if (this.id === null)
            throw new I("attribute-element-get-elements-with-same-id-no-id", this);
          return new Set(this._clonesGroup);
        }
        isSimilar(e) {
          return this.id !== null || e.id !== null ? this.id === e.id : super.isSimilar(e) && this.priority == e.priority;
        }
        _clone(e = !1) {
          const t = super._clone(e);
          return t._priority = this._priority, t._id = this._id, t;
        }
      }
      function rA() {
        if (Ra(this))
          return null;
        let o = this.parent;
        for (; o && o.is("attributeElement"); ) {
          if (Ra(o) > 1)
            return null;
          o = o.parent;
        }
        return !o || Ra(o) > 1 ? null : this.childCount;
      }
      function Ra(o) {
        return Array.from(o.getChildren()).filter((e) => !e.is("uiElement")).length;
      }
      eo.DEFAULT_PRIORITY = 10, eo.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "attributeElement" || o === "view:attributeElement" || o === "element" || o === "view:element") : o === "attributeElement" || o === "view:attributeElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class za extends Ot {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = sA;
        }
        _insertChild(e, t) {
          if (t && (t instanceof Yn || Array.from(t).length > 0))
            throw new I("view-emptyelement-cannot-add", [this, t]);
          return 0;
        }
      }
      function sA() {
        return null;
      }
      za.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "emptyElement" || o === "view:emptyElement" || o === "element" || o === "view:element") : o === "emptyElement" || o === "view:emptyElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Nr extends Ot {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = lA;
        }
        _insertChild(e, t) {
          if (t && (t instanceof Yn || Array.from(t).length > 0))
            throw new I("view-uielement-cannot-add", [this, t]);
          return 0;
        }
        render(e, t) {
          return this.toDomElement(e);
        }
        toDomElement(e) {
          const t = e.createElement(this.name);
          for (const n of this.getAttributeKeys())
            t.setAttribute(n, this.getAttribute(n));
          return t;
        }
      }
      function aA(o) {
        o.document.on("arrowKey", (e, t) => function(n, i, r) {
          if (i.keyCode == Ae.arrowright) {
            const s = i.domTarget.ownerDocument.defaultView.getSelection(), a = s.rangeCount == 1 && s.getRangeAt(0).collapsed;
            if (a || i.shiftKey) {
              const l = s.focusNode, d = s.focusOffset, h = r.domPositionToView(l, d);
              if (h === null)
                return;
              let m = !1;
              const f = h.getLastMatchingPosition((_) => (_.item.is("uiElement") && (m = !0), !(!_.item.is("uiElement") && !_.item.is("attributeElement"))));
              if (m) {
                const _ = r.viewPositionToDom(f);
                a ? s.collapse(_.parent, _.offset) : s.extend(_.parent, _.offset);
              }
            }
          }
        }(0, t, o.domConverter), { priority: "low" });
      }
      function lA() {
        return null;
      }
      Nr.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "uiElement" || o === "view:uiElement" || o === "element" || o === "view:element") : o === "uiElement" || o === "view:uiElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Ma extends Ot {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = cA;
        }
        _insertChild(e, t) {
          if (t && (t instanceof Yn || Array.from(t).length > 0))
            throw new I("view-rawelement-cannot-add", [this, t]);
          return 0;
        }
        render(e, t) {
        }
      }
      function cA() {
        return null;
      }
      Ma.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "rawElement" || o === "view:rawElement" || o === "element" || o === "view:element") : o === "rawElement" || o === "view:rawElement" || o === this.name || o === "view:" + this.name || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class to extends De(Jn) {
        constructor(e, t) {
          super(), this._children = [], this._customProperties = /* @__PURE__ */ new Map(), this.document = e, t && this._insertChild(0, t);
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]();
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get name() {
        }
        getCustomProperty(e) {
          return this._customProperties.get(e);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        _appendChild(e) {
          return this._insertChild(this.childCount, e);
        }
        getChild(e) {
          return this._children[e];
        }
        getChildIndex(e) {
          return this._children.indexOf(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        _insertChild(e, t) {
          this._fireChange("children", this);
          let n = 0;
          const i = function(r, s) {
            return typeof s == "string" ? [new Ne(r, s)] : (It(s) || (s = [s]), Array.from(s).map((a) => typeof a == "string" ? new Ne(r, a) : a instanceof en ? new Ne(r, a.data) : a));
          }(this.document, t);
          for (const r of i)
            r.parent !== null && r._remove(), r.parent = this, this._children.splice(e, 0, r), e++, n++;
          return n;
        }
        _removeChildren(e, t = 1) {
          this._fireChange("children", this);
          for (let n = e; n < e + t; n++)
            this._children[n].parent = null;
          return this._children.splice(e, t);
        }
        _fireChange(e, t) {
          this.fire("change:" + e, t);
        }
        _setCustomProperty(e, t) {
          this._customProperties.set(e, t);
        }
        _removeCustomProperty(e) {
          return this._customProperties.delete(e);
        }
      }
      to.prototype.is = function(o) {
        return o === "documentFragment" || o === "view:documentFragment";
      };
      class nh {
        constructor(e) {
          this._cloneGroups = /* @__PURE__ */ new Map(), this._slotFactory = null, this.document = e;
        }
        setSelection(...e) {
          this.document.selection._setTo(...e);
        }
        setSelectionFocus(e, t) {
          this.document.selection._setFocus(e, t);
        }
        createDocumentFragment(e) {
          return new to(this.document, e);
        }
        createText(e) {
          return new Ne(this.document, e);
        }
        createAttributeElement(e, t, n = {}) {
          const i = new eo(this.document, e, t);
          return typeof n.priority == "number" && (i._priority = n.priority), n.id && (i._id = n.id), n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i;
        }
        createContainerElement(e, t, n = {}, i = {}) {
          let r = null;
          Ct(n) ? i = n : r = n;
          const s = new Di(this.document, e, t, r);
          return i.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), s;
        }
        createEditableElement(e, t, n = {}) {
          const i = new zr(this.document, e, t);
          return n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i;
        }
        createEmptyElement(e, t, n = {}) {
          const i = new za(this.document, e, t);
          return n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i;
        }
        createUIElement(e, t, n) {
          const i = new Nr(this.document, e, t);
          return n && (i.render = n), i;
        }
        createRawElement(e, t, n, i = {}) {
          const r = new Ma(this.document, e, t);
          return n && (r.render = n), i.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), r;
        }
        setAttribute(e, t, n) {
          n._setAttribute(e, t);
        }
        removeAttribute(e, t) {
          t._removeAttribute(e);
        }
        addClass(e, t) {
          t._addClass(e);
        }
        removeClass(e, t) {
          t._removeClass(e);
        }
        setStyle(e, t, n) {
          Ct(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t);
        }
        removeStyle(e, t) {
          t._removeStyle(e);
        }
        setCustomProperty(e, t, n) {
          n._setCustomProperty(e, t);
        }
        removeCustomProperty(e, t) {
          return t._removeCustomProperty(e);
        }
        breakAttributes(e) {
          return e instanceof Z ? this._breakAttributes(e) : this._breakAttributesRange(e);
        }
        breakContainer(e) {
          const t = e.parent;
          if (!t.is("containerElement"))
            throw new I("view-writer-break-non-container-element", this.document);
          if (!t.parent)
            throw new I("view-writer-break-root", this.document);
          if (e.isAtStart)
            return Z._createBefore(t);
          if (!e.isAtEnd) {
            const n = t._clone(!1);
            this.insert(Z._createAfter(t), n);
            const i = new re(e, Z._createAt(t, "end")), r = new Z(n, 0);
            this.move(i, r);
          }
          return Z._createAfter(t);
        }
        mergeAttributes(e) {
          const t = e.offset, n = e.parent;
          if (n.is("$text"))
            return e;
          if (n.is("attributeElement") && n.childCount === 0) {
            const s = n.parent, a = n.index;
            return n._remove(), this._removeFromClonedElementsGroup(n), this.mergeAttributes(new Z(s, a));
          }
          const i = n.getChild(t - 1), r = n.getChild(t);
          if (!i || !r)
            return e;
          if (i.is("$text") && r.is("$text"))
            return ih(i, r);
          if (i.is("attributeElement") && r.is("attributeElement") && i.isSimilar(r)) {
            const s = i.childCount;
            return i._appendChild(r.getChildren()), r._remove(), this._removeFromClonedElementsGroup(r), this.mergeAttributes(new Z(i, s));
          }
          return e;
        }
        mergeContainers(e) {
          const t = e.nodeBefore, n = e.nodeAfter;
          if (!(t && n && t.is("containerElement") && n.is("containerElement")))
            throw new I("view-writer-merge-containers-invalid-position", this.document);
          const i = t.getChild(t.childCount - 1), r = i instanceof Ne ? Z._createAt(i, "end") : Z._createAt(t, "end");
          return this.move(re._createIn(n), Z._createAt(t, "end")), this.remove(re._createOn(n)), r;
        }
        insert(e, t) {
          rh(t = It(t) ? [...t] : [t], this.document);
          const n = t.reduce((s, a) => {
            const l = s[s.length - 1], d = !a.is("uiElement");
            return l && l.breakAttributes == d ? l.nodes.push(a) : s.push({ breakAttributes: d, nodes: [a] }), s;
          }, []);
          let i = null, r = e;
          for (const { nodes: s, breakAttributes: a } of n) {
            const l = this._insertNodes(r, s, a);
            i || (i = l.start), r = l.end;
          }
          return i ? new re(i, r) : new re(e);
        }
        remove(e) {
          const t = e instanceof re ? e : re._createOn(e);
          if (Ti(t, this.document), t.isCollapsed)
            return new to(this.document);
          const { start: n, end: i } = this._breakAttributesRange(t, !0), r = n.parent, s = i.offset - n.offset, a = r._removeChildren(n.offset, s);
          for (const d of a)
            this._removeFromClonedElementsGroup(d);
          const l = this.mergeAttributes(n);
          return t.start = l, t.end = l.clone(), new to(this.document, a);
        }
        clear(e, t) {
          Ti(e, this.document);
          const n = e.getWalker({ direction: "backward", ignoreElementEnd: !0 });
          for (const i of n) {
            const r = i.item;
            let s;
            if (r.is("element") && t.isSimilar(r))
              s = re._createOn(r);
            else if (!i.nextPosition.isAfter(e.start) && r.is("$textProxy")) {
              const a = r.getAncestors().find((l) => l.is("element") && t.isSimilar(l));
              a && (s = re._createIn(a));
            }
            s && (s.end.isAfter(e.end) && (s.end = e.end), s.start.isBefore(e.start) && (s.start = e.start), this.remove(s));
          }
        }
        move(e, t) {
          let n;
          if (t.isAfter(e.end)) {
            const i = (t = this._breakAttributes(t, !0)).parent, r = i.childCount;
            e = this._breakAttributesRange(e, !0), n = this.remove(e), t.offset += i.childCount - r;
          } else
            n = this.remove(e);
          return this.insert(t, n);
        }
        wrap(e, t) {
          if (!(t instanceof eo))
            throw new I("view-writer-wrap-invalid-attribute", this.document);
          if (Ti(e, this.document), e.isCollapsed) {
            let i = e.start;
            i.parent.is("element") && (n = i.parent, !Array.from(n.getChildren()).some((s) => !s.is("uiElement"))) && (i = i.getLastMatchingPosition((s) => s.item.is("uiElement"))), i = this._wrapPosition(i, t);
            const r = this.document.selection;
            return r.isCollapsed && r.getFirstPosition().isEqual(e.start) && this.setSelection(i), new re(i);
          }
          return this._wrapRange(e, t);
          var n;
        }
        unwrap(e, t) {
          if (!(t instanceof eo))
            throw new I("view-writer-unwrap-invalid-attribute", this.document);
          if (Ti(e, this.document), e.isCollapsed)
            return e;
          const { start: n, end: i } = this._breakAttributesRange(e, !0), r = n.parent, s = this._unwrapChildren(r, n.offset, i.offset, t), a = this.mergeAttributes(s.start);
          a.isEqual(s.start) || s.end.offset--;
          const l = this.mergeAttributes(s.end);
          return new re(a, l);
        }
        rename(e, t) {
          const n = new Di(this.document, e, t.getAttributes());
          return this.insert(Z._createAfter(t), n), this.move(re._createIn(t), Z._createAt(n, 0)), this.remove(re._createOn(t)), n;
        }
        clearClonedElementsGroup(e) {
          this._cloneGroups.delete(e);
        }
        createPositionAt(e, t) {
          return Z._createAt(e, t);
        }
        createPositionAfter(e) {
          return Z._createAfter(e);
        }
        createPositionBefore(e) {
          return Z._createBefore(e);
        }
        createRange(e, t) {
          return new re(e, t);
        }
        createRangeOn(e) {
          return re._createOn(e);
        }
        createRangeIn(e) {
          return re._createIn(e);
        }
        createSelection(...e) {
          return new tn(...e);
        }
        createSlot(e = "children") {
          if (!this._slotFactory)
            throw new I("view-writer-invalid-create-slot-context", this.document);
          return this._slotFactory(this, e);
        }
        _registerSlotFactory(e) {
          this._slotFactory = e;
        }
        _clearSlotFactory() {
          this._slotFactory = null;
        }
        _insertNodes(e, t, n) {
          let i, r;
          if (i = n ? Na(e) : e.parent.is("$text") ? e.parent.parent : e.parent, !i)
            throw new I("view-writer-invalid-position-container", this.document);
          r = n ? this._breakAttributes(e, !0) : e.parent.is("$text") ? Fa(e) : e;
          const s = i._insertChild(r.offset, t);
          for (const h of t)
            this._addToClonedElementsGroup(h);
          const a = r.getShiftedBy(s), l = this.mergeAttributes(r);
          l.isEqual(r) || a.offset--;
          const d = this.mergeAttributes(a);
          return new re(l, d);
        }
        _wrapChildren(e, t, n, i) {
          let r = t;
          const s = [];
          for (; r < n; ) {
            const l = e.getChild(r), d = l.is("$text"), h = l.is("attributeElement");
            if (h && this._wrapAttributeElement(i, l))
              s.push(new Z(e, r));
            else if (d || !h || dA(i, l)) {
              const m = i._clone();
              l._remove(), m._appendChild(l), e._insertChild(r, m), this._addToClonedElementsGroup(m), s.push(new Z(e, r));
            } else
              this._wrapChildren(l, 0, l.childCount, i);
            r++;
          }
          let a = 0;
          for (const l of s)
            l.offset -= a, l.offset != t && (this.mergeAttributes(l).isEqual(l) || (a++, n--));
          return re._createFromParentsAndOffsets(e, t, e, n);
        }
        _unwrapChildren(e, t, n, i) {
          let r = t;
          const s = [];
          for (; r < n; ) {
            const l = e.getChild(r);
            if (l.is("attributeElement"))
              if (l.isSimilar(i)) {
                const d = l.getChildren(), h = l.childCount;
                l._remove(), e._insertChild(r, d), this._removeFromClonedElementsGroup(l), s.push(new Z(e, r), new Z(e, r + h)), r += h, n += h - 1;
              } else
                this._unwrapAttributeElement(i, l) ? (s.push(new Z(e, r), new Z(e, r + 1)), r++) : (this._unwrapChildren(l, 0, l.childCount, i), r++);
            else
              r++;
          }
          let a = 0;
          for (const l of s)
            l.offset -= a, !(l.offset == t || l.offset == n) && (this.mergeAttributes(l).isEqual(l) || (a++, n--));
          return re._createFromParentsAndOffsets(e, t, e, n);
        }
        _wrapRange(e, t) {
          const { start: n, end: i } = this._breakAttributesRange(e, !0), r = n.parent, s = this._wrapChildren(r, n.offset, i.offset, t), a = this.mergeAttributes(s.start);
          a.isEqual(s.start) || s.end.offset--;
          const l = this.mergeAttributes(s.end);
          return new re(a, l);
        }
        _wrapPosition(e, t) {
          if (t.isSimilar(e.parent))
            return oh(e.clone());
          e.parent.is("$text") && (e = Fa(e));
          const n = this.createAttributeElement("_wrapPosition-fake-element");
          n._priority = Number.POSITIVE_INFINITY, n.isSimilar = () => !1, e.parent._insertChild(e.offset, n);
          const i = new re(e, e.getShiftedBy(1));
          this.wrap(i, t);
          const r = new Z(n.parent, n.index);
          n._remove();
          const s = r.nodeBefore, a = r.nodeAfter;
          return s instanceof Ne && a instanceof Ne ? ih(s, a) : oh(r);
        }
        _wrapAttributeElement(e, t) {
          if (!sh(e, t) || e.name !== t.name || e.priority !== t.priority)
            return !1;
          for (const n of e.getAttributeKeys())
            if (n !== "class" && n !== "style" && t.hasAttribute(n) && t.getAttribute(n) !== e.getAttribute(n))
              return !1;
          for (const n of e.getStyleNames())
            if (t.hasStyle(n) && t.getStyle(n) !== e.getStyle(n))
              return !1;
          for (const n of e.getAttributeKeys())
            n !== "class" && n !== "style" && (t.hasAttribute(n) || this.setAttribute(n, e.getAttribute(n), t));
          for (const n of e.getStyleNames())
            t.hasStyle(n) || this.setStyle(n, e.getStyle(n), t);
          for (const n of e.getClassNames())
            t.hasClass(n) || this.addClass(n, t);
          return !0;
        }
        _unwrapAttributeElement(e, t) {
          if (!sh(e, t) || e.name !== t.name || e.priority !== t.priority)
            return !1;
          for (const n of e.getAttributeKeys())
            if (n !== "class" && n !== "style" && (!t.hasAttribute(n) || t.getAttribute(n) !== e.getAttribute(n)))
              return !1;
          if (!t.hasClass(...e.getClassNames()))
            return !1;
          for (const n of e.getStyleNames())
            if (!t.hasStyle(n) || t.getStyle(n) !== e.getStyle(n))
              return !1;
          for (const n of e.getAttributeKeys())
            n !== "class" && n !== "style" && this.removeAttribute(n, t);
          return this.removeClass(Array.from(e.getClassNames()), t), this.removeStyle(Array.from(e.getStyleNames()), t), !0;
        }
        _breakAttributesRange(e, t = !1) {
          const n = e.start, i = e.end;
          if (Ti(e, this.document), e.isCollapsed) {
            const l = this._breakAttributes(e.start, t);
            return new re(l, l);
          }
          const r = this._breakAttributes(i, t), s = r.parent.childCount, a = this._breakAttributes(n, t);
          return r.offset += r.parent.childCount - s, new re(a, r);
        }
        _breakAttributes(e, t = !1) {
          const n = e.offset, i = e.parent;
          if (e.parent.is("emptyElement"))
            throw new I("view-writer-cannot-break-empty-element", this.document);
          if (e.parent.is("uiElement"))
            throw new I("view-writer-cannot-break-ui-element", this.document);
          if (e.parent.is("rawElement"))
            throw new I("view-writer-cannot-break-raw-element", this.document);
          if (!t && i.is("$text") && $a(i.parent) || $a(i))
            return e.clone();
          if (i.is("$text"))
            return this._breakAttributes(Fa(e), t);
          if (n == i.childCount) {
            const r = new Z(i.parent, i.index + 1);
            return this._breakAttributes(r, t);
          }
          if (n === 0) {
            const r = new Z(i.parent, i.index);
            return this._breakAttributes(r, t);
          }
          {
            const r = i.index + 1, s = i._clone();
            i.parent._insertChild(r, s), this._addToClonedElementsGroup(s);
            const a = i.childCount - n, l = i._removeChildren(n, a);
            s._appendChild(l);
            const d = new Z(i.parent, r);
            return this._breakAttributes(d, t);
          }
        }
        _addToClonedElementsGroup(e) {
          if (!e.root.is("rootElement"))
            return;
          if (e.is("element"))
            for (const i of e.getChildren())
              this._addToClonedElementsGroup(i);
          const t = e.id;
          if (!t)
            return;
          let n = this._cloneGroups.get(t);
          n || (n = /* @__PURE__ */ new Set(), this._cloneGroups.set(t, n)), n.add(e), e._clonesGroup = n;
        }
        _removeFromClonedElementsGroup(e) {
          if (e.is("element"))
            for (const i of e.getChildren())
              this._removeFromClonedElementsGroup(i);
          const t = e.id;
          if (!t)
            return;
          const n = this._cloneGroups.get(t);
          n && n.delete(e);
        }
      }
      function Na(o) {
        let e = o.parent;
        for (; !$a(e); ) {
          if (!e)
            return;
          e = e.parent;
        }
        return e;
      }
      function dA(o, e) {
        return o.priority < e.priority || !(o.priority > e.priority) && o.getIdentity() < e.getIdentity();
      }
      function oh(o) {
        const e = o.nodeBefore;
        if (e && e.is("$text"))
          return new Z(e, e.data.length);
        const t = o.nodeAfter;
        return t && t.is("$text") ? new Z(t, 0) : o;
      }
      function Fa(o) {
        if (o.offset == o.parent.data.length)
          return new Z(o.parent.parent, o.parent.index + 1);
        if (o.offset === 0)
          return new Z(o.parent.parent, o.parent.index);
        const e = o.parent.data.slice(o.offset);
        return o.parent._data = o.parent.data.slice(0, o.offset), o.parent.parent._insertChild(o.parent.index + 1, new Ne(o.root.document, e)), new Z(o.parent.parent, o.parent.index + 1);
      }
      function ih(o, e) {
        const t = o.data.length;
        return o._data += e.data, e._remove(), new Z(o, t);
      }
      const uA = [Ne, eo, Di, za, Ma, Nr];
      function rh(o, e) {
        for (const t of o) {
          if (!uA.some((n) => t instanceof n))
            throw new I("view-writer-insert-invalid-node-type", e);
          t.is("$text") || rh(t.getChildren(), e);
        }
      }
      function $a(o) {
        return o && (o.is("containerElement") || o.is("documentFragment"));
      }
      function Ti(o, e) {
        const t = Na(o.start), n = Na(o.end);
        if (!t || !n || t !== n)
          throw new I("view-writer-invalid-range-container", e);
      }
      function sh(o, e) {
        return o.id === null && e.id === null;
      }
      const ah = (o) => o.createTextNode(" "), lh = (o) => {
        const e = o.createElement("span");
        return e.dataset.ckeFiller = "true", e.innerText = " ", e;
      }, ch = (o) => {
        const e = o.createElement("br");
        return e.dataset.ckeFiller = "true", e;
      }, nn = 7, Fr = "⁠".repeat(nn);
      function Rt(o) {
        return Qe(o) && o.data.substr(0, nn) === Fr;
      }
      function Pi(o) {
        return o.data.length == nn && Rt(o);
      }
      function dh(o) {
        return Rt(o) ? o.data.slice(nn) : o.data;
      }
      function hA(o, e) {
        if (e.keyCode == Ae.arrowleft) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection();
          if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
            const n = t.getRangeAt(0).startContainer, i = t.getRangeAt(0).startOffset;
            Rt(n) && i <= nn && t.collapse(n, 0);
          }
        }
      }
      var uh = k(9315), gA = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(uh.Z, gA), uh.Z.locals;
      class mA extends oe() {
        constructor(e, t) {
          super(), this.domDocuments = /* @__PURE__ */ new Set(), this.markedAttributes = /* @__PURE__ */ new Set(), this.markedChildren = /* @__PURE__ */ new Set(), this.markedTexts = /* @__PURE__ */ new Set(), this._inlineFiller = null, this._fakeSelectionContainer = null, this.domConverter = e, this.selection = t, this.set("isFocused", !1), this.set("isSelecting", !1), b.isBlink && !b.isAndroid && this.on("change:isSelecting", () => {
            this.isSelecting || this.render();
          }), this.set("isComposing", !1), this.on("change:isComposing", () => {
            this.isComposing || this.render();
          });
        }
        markToSync(e, t) {
          if (e === "text")
            this.domConverter.mapViewToDom(t.parent) && this.markedTexts.add(t);
          else {
            if (!this.domConverter.mapViewToDom(t))
              return;
            if (e === "attributes")
              this.markedAttributes.add(t);
            else {
              if (e !== "children")
                throw new I("view-renderer-unknown-type", this);
              this.markedChildren.add(t);
            }
          }
        }
        render() {
          if (this.isComposing && !b.isAndroid)
            return;
          let e = null;
          const t = !(b.isBlink && !b.isAndroid) || !this.isSelecting;
          for (const n of this.markedChildren)
            this._updateChildrenMappings(n);
          t ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? e = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (e = this.selection.getFirstPosition(), this.markedChildren.add(e.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (e = this.domConverter.domPositionToView(this._inlineFiller), e && e.parent.is("$text") && (e = Z._createBefore(e.parent)));
          for (const n of this.markedAttributes)
            this._updateAttrs(n);
          for (const n of this.markedChildren)
            this._updateChildren(n, { inlineFillerPosition: e });
          for (const n of this.markedTexts)
            !this.markedChildren.has(n.parent) && this.domConverter.mapViewToDom(n.parent) && this._updateText(n, { inlineFillerPosition: e });
          if (t)
            if (e) {
              const n = this.domConverter.viewPositionToDom(e), i = n.parent.ownerDocument;
              Rt(n.parent) ? this._inlineFiller = n.parent : this._inlineFiller = hh(i, n.parent, n.offset);
            } else
              this._inlineFiller = null;
          this._updateFocus(), this._updateSelection(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
        }
        _updateChildrenMappings(e) {
          if (!this.domConverter.mapViewToDom(e))
            return;
          const t = Array.from(this.domConverter.mapViewToDom(e).childNodes), n = Array.from(this.domConverter.viewChildrenToDom(e, { withChildren: !1 })), i = this._diffNodeLists(t, n), r = this._findUpdateActions(i, t, n, pA);
          if (r.indexOf("update") !== -1) {
            const s = { equal: 0, insert: 0, delete: 0 };
            for (const a of r)
              if (a === "update") {
                const l = s.equal + s.insert, d = s.equal + s.delete, h = e.getChild(l);
                !h || h.is("uiElement") || h.is("rawElement") || this._updateElementMappings(h, t[d]), Yd(n[l]), s.equal++;
              } else
                s[a]++;
          }
        }
        _updateElementMappings(e, t) {
          this.domConverter.unbindDomElement(t), this.domConverter.bindElements(t, e), this.markedChildren.add(e), this.markedAttributes.add(e);
        }
        _getInlineFillerPosition() {
          const e = this.selection.getFirstPosition();
          return e.parent.is("$text") ? Z._createBefore(e.parent) : e;
        }
        _isSelectionInInlineFiller() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
            return !1;
          const e = this.selection.getFirstPosition(), t = this.domConverter.viewPositionToDom(e);
          return !!(t && Qe(t.parent) && Rt(t.parent));
        }
        _removeInlineFiller() {
          const e = this._inlineFiller;
          if (!Rt(e))
            throw new I("view-renderer-filler-was-lost", this);
          Pi(e) ? e.remove() : e.data = e.data.substr(nn), this._inlineFiller = null;
        }
        _needsInlineFillerAtSelection() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
            return !1;
          const e = this.selection.getFirstPosition(), t = e.parent, n = e.offset;
          if (!this.domConverter.mapViewToDom(t.root) || !t.is("element") || !function(s) {
            if (s.getAttribute("contenteditable") == "false")
              return !1;
            const a = s.findAncestor((l) => l.hasAttribute("contenteditable"));
            return !a || a.getAttribute("contenteditable") == "true";
          }(t) || n === t.getFillerOffset())
            return !1;
          const i = e.nodeBefore, r = e.nodeAfter;
          return !(i instanceof Ne || r instanceof Ne) && (!b.isAndroid || !i && !r);
        }
        _updateText(e, t) {
          const n = this.domConverter.findCorrespondingDomText(e);
          let i = this.domConverter.viewToDom(e).data;
          const r = t.inlineFillerPosition;
          r && r.parent == e.parent && r.offset == e.index && (i = Fr + i), gh(n, i);
        }
        _updateAttrs(e) {
          const t = this.domConverter.mapViewToDom(e);
          if (!t)
            return;
          const n = Array.from(t.attributes).map((r) => r.name), i = e.getAttributeKeys();
          for (const r of i)
            this.domConverter.setDomElementAttribute(t, r, e.getAttribute(r), e);
          for (const r of n)
            e.hasAttribute(r) || this.domConverter.removeDomElementAttribute(t, r);
        }
        _updateChildren(e, t) {
          const n = this.domConverter.mapViewToDom(e);
          if (!n)
            return;
          if (b.isAndroid) {
            let m = null;
            for (const f of Array.from(n.childNodes)) {
              if (m && Qe(m) && Qe(f)) {
                n.normalize();
                break;
              }
              m = f;
            }
          }
          const i = t.inlineFillerPosition, r = n.childNodes, s = Array.from(this.domConverter.viewChildrenToDom(e, { bind: !0 }));
          i && i.parent === e && hh(n.ownerDocument, s, i.offset);
          const a = this._diffNodeLists(r, s), l = this._findUpdateActions(a, r, s, fA);
          let d = 0;
          const h = /* @__PURE__ */ new Set();
          for (const m of l)
            m === "delete" ? (h.add(r[d]), Yd(r[d])) : m !== "equal" && m !== "update" || d++;
          d = 0;
          for (const m of l)
            m === "insert" ? (Wd(n, d, s[d]), d++) : m === "update" ? (gh(r[d], s[d].data), d++) : m === "equal" && (this._markDescendantTextToSync(this.domConverter.domToView(s[d])), d++);
          for (const m of h)
            m.parentNode || this.domConverter.unbindDomElement(m);
        }
        _diffNodeLists(e, t) {
          return e = function(n, i) {
            const r = Array.from(n);
            return r.length == 0 || !i || r[r.length - 1] == i && r.pop(), r;
          }(e, this._fakeSelectionContainer), F(e, t, bA.bind(null, this.domConverter));
        }
        _findUpdateActions(e, t, n, i) {
          if (e.indexOf("insert") === -1 || e.indexOf("delete") === -1)
            return e;
          let r = [], s = [], a = [];
          const l = { equal: 0, insert: 0, delete: 0 };
          for (const d of e)
            d === "insert" ? a.push(n[l.equal + l.insert]) : d === "delete" ? s.push(t[l.equal + l.delete]) : (r = r.concat(F(s, a, i).map((h) => h === "equal" ? "update" : h)), r.push("equal"), s = [], a = []), l[d]++;
          return r.concat(F(s, a, i).map((d) => d === "equal" ? "update" : d));
        }
        _markDescendantTextToSync(e) {
          if (e) {
            if (e.is("$text"))
              this.markedTexts.add(e);
            else if (e.is("element"))
              for (const t of e.getChildren())
                this._markDescendantTextToSync(t);
          }
        }
        _updateSelection() {
          if (b.isBlink && !b.isAndroid && this.isSelecting && !this.markedChildren.size)
            return;
          if (this.selection.rangeCount === 0)
            return this._removeDomSelection(), void this._removeFakeSelection();
          const e = this.domConverter.mapViewToDom(this.selection.editableElement);
          this.isFocused && e && (this.selection.isFake ? this._updateFakeSelection(e) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(e)) : this.isComposing && b.isAndroid || this._updateDomSelection(e));
        }
        _updateFakeSelection(e) {
          const t = e.ownerDocument;
          this._fakeSelectionContainer || (this._fakeSelectionContainer = function(s) {
            const a = s.createElement("div");
            return a.className = "ck-fake-selection-container", Object.assign(a.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" }), a.textContent = " ", a;
          }(t));
          const n = this._fakeSelectionContainer;
          if (this.domConverter.bindFakeSelection(n, this.selection), !this._fakeSelectionNeedsUpdate(e))
            return;
          n.parentElement && n.parentElement == e || e.appendChild(n), n.textContent = this.selection.fakeSelectionLabel || " ";
          const i = t.getSelection(), r = t.createRange();
          i.removeAllRanges(), r.selectNodeContents(n), i.addRange(r);
        }
        _updateDomSelection(e) {
          const t = e.ownerDocument.defaultView.getSelection();
          if (!this._domSelectionNeedsUpdate(t))
            return;
          const n = this.domConverter.viewPositionToDom(this.selection.anchor), i = this.domConverter.viewPositionToDom(this.selection.focus);
          t.collapse(n.parent, n.offset), t.extend(i.parent, i.offset), b.isGecko && function(r, s) {
            const a = r.parent;
            if (a.nodeType != Node.ELEMENT_NODE || r.offset != a.childNodes.length - 1)
              return;
            const l = a.childNodes[r.offset];
            l && l.tagName == "BR" && s.addRange(s.getRangeAt(0));
          }(i, t);
        }
        _domSelectionNeedsUpdate(e) {
          if (!this.domConverter.isDomSelectionCorrect(e))
            return !0;
          const t = e && this.domConverter.domSelectionToView(e);
          return (!t || !this.selection.isEqual(t)) && !(!this.selection.isCollapsed && this.selection.isSimilar(t));
        }
        _fakeSelectionNeedsUpdate(e) {
          const t = this._fakeSelectionContainer, n = e.ownerDocument.getSelection();
          return !t || t.parentElement !== e || n.anchorNode !== t && !t.contains(n.anchorNode) || t.textContent !== this.selection.fakeSelectionLabel;
        }
        _removeDomSelection() {
          for (const e of this.domDocuments) {
            const t = e.getSelection();
            if (t.rangeCount) {
              const n = e.activeElement, i = this.domConverter.mapDomToView(n);
              n && i && t.removeAllRanges();
            }
          }
        }
        _removeFakeSelection() {
          const e = this._fakeSelectionContainer;
          e && e.remove();
        }
        _updateFocus() {
          if (this.isFocused) {
            const e = this.selection.editableElement;
            e && this.domConverter.focus(e);
          }
        }
      }
      function hh(o, e, t) {
        const n = e instanceof Array ? e : e.childNodes, i = n[t];
        if (Qe(i))
          return i.data = Fr + i.data, i;
        {
          const r = o.createTextNode(Fr);
          return Array.isArray(e) ? n.splice(t, 0, r) : Wd(e, t, r), r;
        }
      }
      function pA(o, e) {
        return Dn(o) && Dn(e) && !Qe(o) && !Qe(e) && !zo(o) && !zo(e) && o.tagName.toLowerCase() === e.tagName.toLowerCase();
      }
      function fA(o, e) {
        return Dn(o) && Dn(e) && Qe(o) && Qe(e);
      }
      function bA(o, e, t) {
        return e === t || (Qe(e) && Qe(t) ? e.data === t.data : !(!o.isBlockFiller(e) || !o.isBlockFiller(t)));
      }
      function gh(o, e) {
        const t = o.data;
        if (t == e)
          return;
        const n = P(t, e);
        for (const i of n)
          i.type === "insert" ? o.insertData(i.index, i.values.join("")) : o.deleteData(i.index, i.howMany);
      }
      const kA = ch(fe.document), wA = ah(fe.document), vA = lh(fe.document), $r = "data-ck-unsafe-attribute-", mh = "data-ck-unsafe-element";
      class ph {
        constructor(e, { blockFillerMode: t, renderingMode: n = "editing" } = {}) {
          this._domToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToDomMapping = /* @__PURE__ */ new WeakMap(), this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap(), this._rawContentElementMatcher = new Fo(), this._encounteredRawContentDomNodes = /* @__PURE__ */ new WeakSet(), this.document = e, this.renderingMode = n, this.blockFillerMode = t || (n === "editing" ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this.unsafeElements = ["script", "style"], this._domDocument = this.renderingMode === "editing" ? fe.document : fe.document.implementation.createHTMLDocument("");
        }
        bindFakeSelection(e, t) {
          this._fakeSelectionMapping.set(e, new tn(t));
        }
        fakeSelectionToView(e) {
          return this._fakeSelectionMapping.get(e);
        }
        bindElements(e, t) {
          this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
        }
        unbindDomElement(e) {
          const t = this._domToViewMapping.get(e);
          if (t) {
            this._domToViewMapping.delete(e), this._viewToDomMapping.delete(t);
            for (const n of Array.from(e.children))
              this.unbindDomElement(n);
          }
        }
        bindDocumentFragments(e, t) {
          this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
        }
        shouldRenderAttribute(e, t, n) {
          return this.renderingMode === "data" || !(e = e.toLowerCase()).startsWith("on") && (e !== "srcdoc" || !t.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) && (n === "img" && (e === "src" || e === "srcset") || n === "source" && e === "srcset" || !t.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i));
        }
        setContentOf(e, t) {
          if (this.renderingMode === "data")
            return void (e.innerHTML = t);
          const n = new DOMParser().parseFromString(t, "text/html"), i = n.createDocumentFragment(), r = n.body.childNodes;
          for (; r.length > 0; )
            i.appendChild(r[0]);
          const s = n.createTreeWalker(i, NodeFilter.SHOW_ELEMENT), a = [];
          let l;
          for (; l = s.nextNode(); )
            a.push(l);
          for (const d of a) {
            for (const m of d.getAttributeNames())
              this.setDomElementAttribute(d, m, d.getAttribute(m));
            const h = d.tagName.toLowerCase();
            this._shouldRenameElement(h) && (kh(h), d.replaceWith(this._createReplacementDomElement(h, d)));
          }
          for (; e.firstChild; )
            e.firstChild.remove();
          e.append(i);
        }
        viewToDom(e, t = {}) {
          if (e.is("$text")) {
            const n = this._processDataFromViewText(e);
            return this._domDocument.createTextNode(n);
          }
          {
            if (this.mapViewToDom(e))
              return this.mapViewToDom(e);
            let n;
            if (e.is("documentFragment"))
              n = this._domDocument.createDocumentFragment(), t.bind && this.bindDocumentFragments(n, e);
            else {
              if (e.is("uiElement"))
                return n = e.name === "$comment" ? this._domDocument.createComment(e.getCustomProperty("$rawContent")) : e.render(this._domDocument, this), t.bind && this.bindElements(n, e), n;
              this._shouldRenameElement(e.name) ? (kh(e.name), n = this._createReplacementDomElement(e.name)) : n = e.hasAttribute("xmlns") ? this._domDocument.createElementNS(e.getAttribute("xmlns"), e.name) : this._domDocument.createElement(e.name), e.is("rawElement") && e.render(n, this), t.bind && this.bindElements(n, e);
              for (const i of e.getAttributeKeys())
                this.setDomElementAttribute(n, i, e.getAttribute(i), e);
            }
            if (t.withChildren !== !1)
              for (const i of this.viewChildrenToDom(e, t))
                n.appendChild(i);
            return n;
          }
        }
        setDomElementAttribute(e, t, n, i) {
          const r = this.shouldRenderAttribute(t, n, e.tagName.toLowerCase()) || i && i.shouldRenderUnsafeAttribute(t);
          r || ne("domconverter-unsafe-attribute-detected", { domElement: e, key: t, value: n }), Gd(t) ? (e.hasAttribute(t) && !r ? e.removeAttribute(t) : e.hasAttribute($r + t) && r && e.removeAttribute($r + t), e.setAttribute(r ? t : $r + t, n)) : ne("domconverter-invalid-attribute-detected", { domElement: e, key: t, value: n });
        }
        removeDomElementAttribute(e, t) {
          t != mh && (e.removeAttribute(t), e.removeAttribute($r + t));
        }
        *viewChildrenToDom(e, t = {}) {
          const n = e.getFillerOffset && e.getFillerOffset();
          let i = 0;
          for (const r of e.getChildren()) {
            n === i && (yield this._getBlockFiller());
            const s = r.is("element") && !!r.getCustomProperty("dataPipeline:transparentRendering") && !it(r.getAttributes());
            s && this.renderingMode == "data" ? yield* this.viewChildrenToDom(r, t) : (s && ne("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: r }), yield this.viewToDom(r, t)), i++;
          }
          n === i && (yield this._getBlockFiller());
        }
        viewRangeToDom(e) {
          const t = this.viewPositionToDom(e.start), n = this.viewPositionToDom(e.end), i = this._domDocument.createRange();
          return i.setStart(t.parent, t.offset), i.setEnd(n.parent, n.offset), i;
        }
        viewPositionToDom(e) {
          const t = e.parent;
          if (t.is("$text")) {
            const n = this.findCorrespondingDomText(t);
            if (!n)
              return null;
            let i = e.offset;
            return Rt(n) && (i += nn), { parent: n, offset: i };
          }
          {
            let n, i, r;
            if (e.offset === 0) {
              if (n = this.mapViewToDom(t), !n)
                return null;
              r = n.childNodes[0];
            } else {
              const s = e.nodeBefore;
              if (i = s.is("$text") ? this.findCorrespondingDomText(s) : this.mapViewToDom(s), !i)
                return null;
              n = i.parentNode, r = i.nextSibling;
            }
            return Qe(r) && Rt(r) ? { parent: r, offset: nn } : { parent: n, offset: i ? xr(i) + 1 : 0 };
          }
        }
        domToView(e, t = {}) {
          if (this.isBlockFiller(e))
            return null;
          const n = this.getHostViewElement(e);
          if (n)
            return n;
          if (zo(e) && t.skipComments)
            return null;
          if (Qe(e)) {
            if (Pi(e))
              return null;
            {
              const i = this._processDataFromDomText(e);
              return i === "" ? null : new Ne(this.document, i);
            }
          }
          {
            if (this.mapDomToView(e))
              return this.mapDomToView(e);
            let i;
            if (this.isDocumentFragment(e))
              i = new to(this.document), t.bind && this.bindDocumentFragments(e, i);
            else {
              i = this._createViewElement(e, t), t.bind && this.bindElements(e, i);
              const r = e.attributes;
              if (r)
                for (let s = r.length, a = 0; a < s; a++)
                  i._setAttribute(r[a].name, r[a].value);
              if (this._isViewElementWithRawContent(i, t) || zo(e)) {
                const s = zo(e) ? e.data : e.innerHTML;
                return i._setCustomProperty("$rawContent", s), this._encounteredRawContentDomNodes.add(e), i;
              }
            }
            if (t.withChildren !== !1)
              for (const r of this.domChildrenToView(e, t))
                i._appendChild(r);
            return i;
          }
        }
        *domChildrenToView(e, t) {
          for (let n = 0; n < e.childNodes.length; n++) {
            const i = e.childNodes[n], r = this.domToView(i, t);
            r !== null && (yield r);
          }
        }
        domSelectionToView(e) {
          if (e.rangeCount === 1) {
            let i = e.getRangeAt(0).startContainer;
            Qe(i) && (i = i.parentNode);
            const r = this.fakeSelectionToView(i);
            if (r)
              return r;
          }
          const t = this.isDomSelectionBackward(e), n = [];
          for (let i = 0; i < e.rangeCount; i++) {
            const r = e.getRangeAt(i), s = this.domRangeToView(r);
            s && n.push(s);
          }
          return new tn(n, { backward: t });
        }
        domRangeToView(e) {
          const t = this.domPositionToView(e.startContainer, e.startOffset), n = this.domPositionToView(e.endContainer, e.endOffset);
          return t && n ? new re(t, n) : null;
        }
        domPositionToView(e, t = 0) {
          if (this.isBlockFiller(e))
            return this.domPositionToView(e.parentNode, xr(e));
          const n = this.mapDomToView(e);
          if (n && (n.is("uiElement") || n.is("rawElement")))
            return Z._createBefore(n);
          if (Qe(e)) {
            if (Pi(e))
              return this.domPositionToView(e.parentNode, xr(e));
            const i = this.findCorrespondingViewText(e);
            let r = t;
            return i ? (Rt(e) && (r -= nn, r = r < 0 ? 0 : r), new Z(i, r)) : null;
          }
          if (t === 0) {
            const i = this.mapDomToView(e);
            if (i)
              return new Z(i, 0);
          } else {
            const i = e.childNodes[t - 1];
            if (Qe(i) && Pi(i) || i && this.isBlockFiller(i))
              return this.domPositionToView(i.parentNode, xr(i));
            const r = Qe(i) ? this.findCorrespondingViewText(i) : this.mapDomToView(i);
            if (r && r.parent)
              return new Z(r.parent, r.index + 1);
          }
          return null;
        }
        mapDomToView(e) {
          return this.getHostViewElement(e) || this._domToViewMapping.get(e);
        }
        findCorrespondingViewText(e) {
          if (Pi(e))
            return null;
          const t = this.getHostViewElement(e);
          if (t)
            return t;
          const n = e.previousSibling;
          if (n) {
            if (!this.isElement(n))
              return null;
            const i = this.mapDomToView(n);
            if (i) {
              const r = i.nextSibling;
              return r instanceof Ne ? r : null;
            }
          } else {
            const i = this.mapDomToView(e.parentNode);
            if (i) {
              const r = i.getChild(0);
              return r instanceof Ne ? r : null;
            }
          }
          return null;
        }
        mapViewToDom(e) {
          return this._viewToDomMapping.get(e);
        }
        findCorrespondingDomText(e) {
          const t = e.previousSibling;
          return t && this.mapViewToDom(t) ? this.mapViewToDom(t).nextSibling : !t && e.parent && this.mapViewToDom(e.parent) ? this.mapViewToDom(e.parent).childNodes[0] : null;
        }
        focus(e) {
          const t = this.mapViewToDom(e);
          if (t && t.ownerDocument.activeElement !== t) {
            const { scrollX: n, scrollY: i } = fe.window, r = [];
            fh(t, (s) => {
              const { scrollLeft: a, scrollTop: l } = s;
              r.push([a, l]);
            }), t.focus(), fh(t, (s) => {
              const [a, l] = r.shift();
              s.scrollLeft = a, s.scrollTop = l;
            }), fe.window.scrollTo(n, i);
          }
        }
        isElement(e) {
          return e && e.nodeType == Node.ELEMENT_NODE;
        }
        isDocumentFragment(e) {
          return e && e.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
        }
        isBlockFiller(e) {
          return this.blockFillerMode == "br" ? e.isEqualNode(kA) : !(e.tagName !== "BR" || !bh(e, this.blockElements) || e.parentNode.childNodes.length !== 1) || e.isEqualNode(vA) || function(t, n) {
            return t.isEqualNode(wA) && bh(t, n) && t.parentNode.childNodes.length === 1;
          }(e, this.blockElements);
        }
        isDomSelectionBackward(e) {
          if (e.isCollapsed)
            return !1;
          const t = this._domDocument.createRange();
          try {
            t.setStart(e.anchorNode, e.anchorOffset), t.setEnd(e.focusNode, e.focusOffset);
          } catch {
            return !1;
          }
          const n = t.collapsed;
          return t.detach(), n;
        }
        getHostViewElement(e) {
          const t = Vd(e);
          for (t.pop(); t.length; ) {
            const n = t.pop(), i = this._domToViewMapping.get(n);
            if (i && (i.is("uiElement") || i.is("rawElement")))
              return i;
          }
          return null;
        }
        isDomSelectionCorrect(e) {
          return this._isDomSelectionPositionCorrect(e.anchorNode, e.anchorOffset) && this._isDomSelectionPositionCorrect(e.focusNode, e.focusOffset);
        }
        registerRawContentMatcher(e) {
          this._rawContentElementMatcher.add(e);
        }
        _getBlockFiller() {
          switch (this.blockFillerMode) {
            case "nbsp":
              return ah(this._domDocument);
            case "markedNbsp":
              return lh(this._domDocument);
            case "br":
              return ch(this._domDocument);
          }
        }
        _isDomSelectionPositionCorrect(e, t) {
          if (Qe(e) && Rt(e) && t < nn || this.isElement(e) && Rt(e.childNodes[t]))
            return !1;
          const n = this.mapDomToView(e);
          return !n || !n.is("uiElement") && !n.is("rawElement");
        }
        _processDataFromViewText(e) {
          let t = e.data;
          if (e.getAncestors().some((n) => this.preElements.includes(n.name)))
            return t;
          if (t.charAt(0) == " ") {
            const n = this._getTouchingInlineViewNode(e, !1);
            !(n && n.is("$textProxy") && this._nodeEndsWithSpace(n)) && n || (t = " " + t.substr(1));
          }
          if (t.charAt(t.length - 1) == " ") {
            const n = this._getTouchingInlineViewNode(e, !0), i = n && n.is("$textProxy") && n.data.charAt(0) == " ";
            t.charAt(t.length - 2) != " " && n && !i || (t = t.substr(0, t.length - 1) + " ");
          }
          return t.replace(/ {2}/g, "  ");
        }
        _nodeEndsWithSpace(e) {
          if (e.getAncestors().some((n) => this.preElements.includes(n.name)))
            return !1;
          const t = this._processDataFromViewText(e);
          return t.charAt(t.length - 1) == " ";
        }
        _processDataFromDomText(e) {
          let t = e.data;
          if (function(d, h) {
            return Vd(d).some((f) => f.tagName && h.includes(f.tagName.toLowerCase()));
          }(e, this.preElements))
            return dh(e);
          t = t.replace(/[ \n\t\r]{1,}/g, " ");
          const n = this._getTouchingInlineDomNode(e, !1), i = this._getTouchingInlineDomNode(e, !0), r = this._checkShouldLeftTrimDomText(e, n), s = this._checkShouldRightTrimDomText(e, i);
          r && (t = t.replace(/^ /, "")), s && (t = t.replace(/ $/, "")), t = dh(new Text(t)), t = t.replace(/ \u00A0/g, "  ");
          const a = i && this.isElement(i) && i.tagName != "BR", l = i && Qe(i) && i.data.charAt(0) == " ";
          return (/( |\u00A0)\u00A0$/.test(t) || !i || a || l) && (t = t.replace(/\u00A0$/, " ")), (r || n && this.isElement(n) && n.tagName != "BR") && (t = t.replace(/^\u00A0/, " ")), t;
        }
        _checkShouldLeftTrimDomText(e, t) {
          return !t || (this.isElement(t) ? t.tagName === "BR" : !this._encounteredRawContentDomNodes.has(e.previousSibling) && /[^\S\u00A0]/.test(t.data.charAt(t.data.length - 1)));
        }
        _checkShouldRightTrimDomText(e, t) {
          return !t && !Rt(e);
        }
        _getTouchingInlineViewNode(e, t) {
          const n = new Xn({ startPosition: t ? Z._createAfter(e) : Z._createBefore(e), direction: t ? "forward" : "backward" });
          for (const i of n) {
            if (i.item.is("element") && this.inlineObjectElements.includes(i.item.name))
              return i.item;
            if (i.item.is("containerElement") || i.item.is("element", "br"))
              return null;
            if (i.item.is("$textProxy"))
              return i.item;
          }
          return null;
        }
        _getTouchingInlineDomNode(e, t) {
          if (!e.parentNode)
            return null;
          const n = t ? "firstChild" : "lastChild", i = t ? "nextSibling" : "previousSibling";
          let r = !0, s = e;
          do
            if (!r && s[n] ? s = s[n] : s[i] ? (s = s[i], r = !1) : (s = s.parentNode, r = !0), !s || this._isBlockElement(s))
              return null;
          while (!Qe(s) && s.tagName != "BR" && !this._isInlineObjectElement(s));
          return s;
        }
        _isBlockElement(e) {
          return this.isElement(e) && this.blockElements.includes(e.tagName.toLowerCase());
        }
        _isInlineObjectElement(e) {
          return this.isElement(e) && this.inlineObjectElements.includes(e.tagName.toLowerCase());
        }
        _createViewElement(e, t) {
          if (zo(e))
            return new Nr(this.document, "$comment");
          const n = t.keepOriginalCase ? e.tagName : e.tagName.toLowerCase();
          return new Ot(this.document, n);
        }
        _isViewElementWithRawContent(e, t) {
          return t.withChildren !== !1 && !!this._rawContentElementMatcher.match(e);
        }
        _shouldRenameElement(e) {
          const t = e.toLowerCase();
          return this.renderingMode === "editing" && this.unsafeElements.includes(t);
        }
        _createReplacementDomElement(e, t) {
          const n = this._domDocument.createElement("span");
          if (n.setAttribute(mh, e), t) {
            for (; t.firstChild; )
              n.appendChild(t.firstChild);
            for (const i of t.getAttributeNames())
              n.setAttribute(i, t.getAttribute(i));
          }
          return n;
        }
      }
      function fh(o, e) {
        let t = o;
        for (; t; )
          e(t), t = t.parentElement;
      }
      function bh(o, e) {
        const t = o.parentNode;
        return !!t && !!t.tagName && e.includes(t.tagName.toLowerCase());
      }
      function kh(o) {
        o === "script" && ne("domconverter-unsafe-script-element-detected"), o === "style" && ne("domconverter-unsafe-style-element-detected");
      }
      class on extends Bn() {
        constructor(e) {
          super(), this._isEnabled = !1, this.view = e, this.document = e.document;
        }
        get isEnabled() {
          return this._isEnabled;
        }
        enable() {
          this._isEnabled = !0;
        }
        disable() {
          this._isEnabled = !1;
        }
        destroy() {
          this.disable(), this.stopListening();
        }
        checkShouldIgnoreEventFromTarget(e) {
          return e && e.nodeType === 3 && (e = e.parentNode), !(!e || e.nodeType !== 1) && e.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
        }
      }
      const wh = Sa(function(o, e) {
        Po(e, Oo(e), o);
      });
      class Vo {
        constructor(e, t, n) {
          this.view = e, this.document = e.document, this.domEvent = t, this.domTarget = t.target, wh(this, n);
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget);
        }
        preventDefault() {
          this.domEvent.preventDefault();
        }
        stopPropagation() {
          this.domEvent.stopPropagation();
        }
      }
      class Tn extends on {
        constructor() {
          super(...arguments), this.useCapture = !1;
        }
        observe(e) {
          (typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType).forEach((t) => {
            this.listenTo(e, t, (n, i) => {
              this.isEnabled && !this.checkShouldIgnoreEventFromTarget(i.target) && this.onDomEvent(i);
            }, { useCapture: this.useCapture });
          });
        }
        stopObserving(e) {
          this.stopListening(e);
        }
        fire(e, t, n) {
          this.isEnabled && this.document.fire(e, new Vo(this.view, t, n));
        }
      }
      class _A extends Tn {
        constructor() {
          super(...arguments), this.domEventType = ["keydown", "keyup"];
        }
        onDomEvent(e) {
          const t = { keyCode: e.keyCode, altKey: e.altKey, ctrlKey: e.ctrlKey, shiftKey: e.shiftKey, metaKey: e.metaKey, get keystroke() {
            return Mo(this);
          } };
          this.fire(e.type, e, t);
        }
      }
      const La = function() {
        return Wt.Date.now();
      };
      var AA = /\s/;
      const CA = function(o) {
        for (var e = o.length; e-- && AA.test(o.charAt(e)); )
          ;
        return e;
      };
      var yA = /^\s+/;
      const EA = function(o) {
        return o && o.slice(0, CA(o) + 1).replace(yA, "");
      };
      var xA = /^[-+]0x[0-9a-f]+$/i, SA = /^0b[01]+$/i, DA = /^0o[0-7]+$/i, BA = parseInt;
      const vh = function(o) {
        if (typeof o == "number")
          return o;
        if (Or(o))
          return NaN;
        if (K(o)) {
          var e = typeof o.valueOf == "function" ? o.valueOf() : o;
          o = K(e) ? e + "" : e;
        }
        if (typeof o != "string")
          return o === 0 ? o : +o;
        o = EA(o);
        var t = SA.test(o);
        return t || DA.test(o) ? BA(o.slice(2), t ? 2 : 8) : xA.test(o) ? NaN : +o;
      };
      var TA = Math.max, PA = Math.min;
      const Ii = function(o, e, t) {
        var n, i, r, s, a, l, d = 0, h = !1, m = !1, f = !0;
        if (typeof o != "function")
          throw new TypeError("Expected a function");
        function _(N) {
          var H = n, X = i;
          return n = i = void 0, d = N, s = o.apply(X, H);
        }
        function E(N) {
          var H = N - l;
          return l === void 0 || H >= e || H < 0 || m && N - d >= r;
        }
        function B() {
          var N = La();
          if (E(N))
            return T(N);
          a = setTimeout(B, function(H) {
            var X = e - (H - l);
            return m ? PA(X, r - (H - d)) : X;
          }(N));
        }
        function T(N) {
          return a = void 0, f && n ? _(N) : (n = i = void 0, s);
        }
        function O() {
          var N = La(), H = E(N);
          if (n = arguments, i = this, l = N, H) {
            if (a === void 0)
              return function(X) {
                return d = X, a = setTimeout(B, e), h ? _(X) : s;
              }(l);
            if (m)
              return clearTimeout(a), a = setTimeout(B, e), _(l);
          }
          return a === void 0 && (a = setTimeout(B, e)), s;
        }
        return e = vh(e) || 0, K(t) && (h = !!t.leading, r = (m = "maxWait" in t) ? TA(vh(t.maxWait) || 0, e) : r, f = "trailing" in t ? !!t.trailing : f), O.cancel = function() {
          a !== void 0 && clearTimeout(a), d = 0, n = l = i = a = void 0;
        }, O.flush = function() {
          return a === void 0 ? s : T(La());
        }, O;
      };
      class IA extends on {
        constructor(e) {
          super(e), this._fireSelectionChangeDoneDebounced = Ii((t) => {
            this.document.fire("selectionChangeDone", t);
          }, 200);
        }
        observe() {
          const e = this.document;
          e.on("arrowKey", (t, n) => {
            e.selection.isFake && this.isEnabled && n.preventDefault();
          }, { context: "$capture" }), e.on("arrowKey", (t, n) => {
            e.selection.isFake && this.isEnabled && this._handleSelectionMove(n.keyCode);
          }, { priority: "lowest" });
        }
        stopObserving() {
        }
        destroy() {
          super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionMove(e) {
          const t = this.document.selection, n = new tn(t.getRanges(), { backward: t.isBackward, fake: !1 });
          e != Ae.arrowleft && e != Ae.arrowup || n.setTo(n.getFirstPosition()), e != Ae.arrowright && e != Ae.arrowdown || n.setTo(n.getLastPosition());
          const i = { oldSelection: t, newSelection: n, domSelection: null };
          this.document.fire("selectionChange", i), this._fireSelectionChangeDoneDebounced(i);
        }
      }
      const OA = function(o) {
        return this.__data__.set(o, "__lodash_hash_undefined__"), this;
      }, RA = function(o) {
        return this.__data__.has(o);
      };
      function Lr(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.__data__ = new br(); ++e < t; )
          this.add(o[e]);
      }
      Lr.prototype.add = Lr.prototype.push = OA, Lr.prototype.has = RA;
      const zA = Lr, MA = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length; ++t < n; )
          if (e(o[t], t, o))
            return !0;
        return !1;
      }, NA = function(o, e) {
        return o.has(e);
      }, _h = function(o, e, t, n, i, r) {
        var s = 1 & t, a = o.length, l = e.length;
        if (a != l && !(s && l > a))
          return !1;
        var d = r.get(o), h = r.get(e);
        if (d && h)
          return d == e && h == o;
        var m = -1, f = !0, _ = 2 & t ? new zA() : void 0;
        for (r.set(o, e), r.set(e, o); ++m < a; ) {
          var E = o[m], B = e[m];
          if (n)
            var T = s ? n(B, E, m, e, o, r) : n(E, B, m, o, e, r);
          if (T !== void 0) {
            if (T)
              continue;
            f = !1;
            break;
          }
          if (_) {
            if (!MA(e, function(O, N) {
              if (!NA(_, N) && (E === O || i(E, O, t, n, r)))
                return _.push(N);
            })) {
              f = !1;
              break;
            }
          } else if (E !== B && !i(E, B, t, n, r)) {
            f = !1;
            break;
          }
        }
        return r.delete(o), r.delete(e), f;
      }, FA = function(o) {
        var e = -1, t = Array(o.size);
        return o.forEach(function(n, i) {
          t[++e] = [i, n];
        }), t;
      }, $A = function(o) {
        var e = -1, t = Array(o.size);
        return o.forEach(function(n) {
          t[++e] = n;
        }), t;
      };
      var Ah = Qt ? Qt.prototype : void 0, Va = Ah ? Ah.valueOf : void 0;
      const LA = function(o, e, t, n, i, r, s) {
        switch (t) {
          case "[object DataView]":
            if (o.byteLength != e.byteLength || o.byteOffset != e.byteOffset)
              return !1;
            o = o.buffer, e = e.buffer;
          case "[object ArrayBuffer]":
            return !(o.byteLength != e.byteLength || !r(new _r(o), new _r(e)));
          case "[object Boolean]":
          case "[object Date]":
          case "[object Number]":
            return ki(+o, +e);
          case "[object Error]":
            return o.name == e.name && o.message == e.message;
          case "[object RegExp]":
          case "[object String]":
            return o == e + "";
          case "[object Map]":
            var a = FA;
          case "[object Set]":
            var l = 1 & n;
            if (a || (a = $A), o.size != e.size && !l)
              return !1;
            var d = s.get(o);
            if (d)
              return d == e;
            n |= 2, s.set(o, e);
            var h = _h(a(o), a(e), n, i, r, s);
            return s.delete(o), h;
          case "[object Symbol]":
            if (Va)
              return Va.call(o) == Va.call(e);
        }
        return !1;
      };
      var VA = Object.prototype.hasOwnProperty;
      const jA = function(o, e, t, n, i, r) {
        var s = 1 & t, a = Qs(o), l = a.length;
        if (l != Qs(e).length && !s)
          return !1;
        for (var d = l; d--; ) {
          var h = a[d];
          if (!(s ? h in e : VA.call(e, h)))
            return !1;
        }
        var m = r.get(o), f = r.get(e);
        if (m && f)
          return m == e && f == o;
        var _ = !0;
        r.set(o, e), r.set(e, o);
        for (var E = s; ++d < l; ) {
          var B = o[h = a[d]], T = e[h];
          if (n)
            var O = s ? n(T, B, h, e, o, r) : n(B, T, h, o, e, r);
          if (!(O === void 0 ? B === T || i(B, T, t, n, r) : O)) {
            _ = !1;
            break;
          }
          E || (E = h == "constructor");
        }
        if (_ && !E) {
          var N = o.constructor, H = e.constructor;
          N == H || !("constructor" in o) || !("constructor" in e) || typeof N == "function" && N instanceof N && typeof H == "function" && H instanceof H || (_ = !1);
        }
        return r.delete(o), r.delete(e), _;
      };
      var Ch = "[object Arguments]", yh = "[object Array]", Vr = "[object Object]", Eh = Object.prototype.hasOwnProperty;
      const HA = function(o, e, t, n, i, r) {
        var s = _t(o), a = _t(e), l = s ? yh : yi(o), d = a ? yh : yi(e), h = (l = l == Ch ? Vr : l) == Vr, m = (d = d == Ch ? Vr : d) == Vr, f = l == d;
        if (f && Ai(o)) {
          if (!Ai(e))
            return !1;
          s = !0, h = !1;
        }
        if (f && !h)
          return r || (r = new _i()), s || Gs(o) ? _h(o, e, t, n, i, r) : LA(o, e, l, t, n, i, r);
        if (!(1 & t)) {
          var _ = h && Eh.call(o, "__wrapped__"), E = m && Eh.call(e, "__wrapped__");
          if (_ || E) {
            var B = _ ? o.value() : o, T = E ? e.value() : e;
            return r || (r = new _i()), i(B, T, t, n, r);
          }
        }
        return !!f && (r || (r = new _i()), jA(o, e, t, n, i, r));
      }, xh = function o(e, t, n, i, r) {
        return e === t || (e == null || t == null || !Lt(e) && !Lt(t) ? e != e && t != t : HA(e, t, n, i, o, r));
      }, UA = function(o, e, t) {
        var n = (t = typeof t == "function" ? t : void 0) ? t(o, e) : void 0;
        return n === void 0 ? xh(o, e, void 0, t) : !!n;
      };
      class Sh extends on {
        constructor(e) {
          super(e), this._config = { childList: !0, characterData: !0, subtree: !0 }, this.domConverter = e.domConverter, this.renderer = e._renderer, this._domElements = /* @__PURE__ */ new Set(), this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords());
        }
        observe(e) {
          this._domElements.add(e), this.isEnabled && this._mutationObserver.observe(e, this._config);
        }
        stopObserving(e) {
          if (this._domElements.delete(e), this.isEnabled) {
            this._mutationObserver.disconnect();
            for (const t of this._domElements)
              this._mutationObserver.observe(t, this._config);
          }
        }
        enable() {
          super.enable();
          for (const e of this._domElements)
            this._mutationObserver.observe(e, this._config);
        }
        disable() {
          super.disable(), this._mutationObserver.disconnect();
        }
        destroy() {
          super.destroy(), this._mutationObserver.disconnect();
        }
        _onMutations(e) {
          if (e.length === 0)
            return;
          const t = this.domConverter, n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
          for (const s of e) {
            const a = t.mapDomToView(s.target);
            a && (a.is("uiElement") || a.is("rawElement") || s.type !== "childList" || this._isBogusBrMutation(s) || i.add(a));
          }
          for (const s of e) {
            const a = t.mapDomToView(s.target);
            if ((!a || !a.is("uiElement") && !a.is("rawElement")) && s.type === "characterData") {
              const l = t.findCorrespondingViewText(s.target);
              l && !i.has(l.parent) ? n.add(l) : !l && Rt(s.target) && i.add(t.mapDomToView(s.target.parentNode));
            }
          }
          let r = !1;
          for (const s of n)
            r = !0, this.renderer.markToSync("text", s);
          for (const s of i) {
            const a = t.mapViewToDom(s), l = Array.from(s.getChildren()), d = Array.from(t.domChildrenToView(a, { withChildren: !1 }));
            UA(l, d, qA) || (r = !0, this.renderer.markToSync("children", s));
          }
          r && this.view.forceRender();
        }
        _isBogusBrMutation(e) {
          let t = null;
          return e.nextSibling === null && e.removedNodes.length === 0 && e.addedNodes.length == 1 && (t = this.domConverter.domToView(e.addedNodes[0], { withChildren: !1 })), t && t.is("element", "br");
        }
      }
      function qA(o, e) {
        if (!Array.isArray(o))
          return o === e || !(!o.is("$text") || !e.is("$text")) && o.data === e.data;
      }
      class ja extends Tn {
        constructor(e) {
          super(e), this._isFocusChanging = !1, this.domEventType = ["focus", "blur"], this.useCapture = !0;
          const t = this.document;
          t.on("focus", () => {
            this._isFocusChanging = !0, this._renderTimeoutId = setTimeout(() => {
              this.flush(), e.change(() => {
              });
            }, 50);
          }), t.on("blur", (n, i) => {
            const r = t.selection.editableElement;
            r !== null && r !== i.target || (t.isFocused = !1, this._isFocusChanging = !1, e.change(() => {
            }));
          });
        }
        flush() {
          this._isFocusChanging && (this._isFocusChanging = !1, this.document.isFocused = !0);
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
        destroy() {
          this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
        }
      }
      class WA extends on {
        constructor(e) {
          super(e), this.mutationObserver = e.getObserver(Sh), this.focusObserver = e.getObserver(ja), this.selection = this.document.selection, this.domConverter = e.domConverter, this._documents = /* @__PURE__ */ new WeakSet(), this._fireSelectionChangeDoneDebounced = Ii((t) => {
            this.document.fire("selectionChangeDone", t);
          }, 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = Ii(() => this.document.isSelecting = !1, 5e3), this._loopbackCounter = 0;
        }
        observe(e) {
          const t = e.ownerDocument, n = () => {
            this.document.isSelecting && (this._handleSelectionChange(null, t), this.document.isSelecting = !1, this._documentIsSelectingInactivityTimeoutDebounced.cancel());
          };
          this.listenTo(e, "selectstart", () => {
            this.document.isSelecting = !0, this._documentIsSelectingInactivityTimeoutDebounced();
          }, { priority: "highest" }), this.listenTo(e, "keydown", n, { priority: "highest", useCapture: !0 }), this.listenTo(e, "keyup", n, { priority: "highest", useCapture: !0 }), this._documents.has(t) || (this.listenTo(t, "mouseup", n, { priority: "highest", useCapture: !0 }), this.listenTo(t, "selectionchange", (i, r) => {
            this.document.isComposing && !b.isAndroid || (this._handleSelectionChange(r, t), this._documentIsSelectingInactivityTimeoutDebounced());
          }), this._documents.add(t));
        }
        stopObserving(e) {
          this.stopListening(e);
        }
        destroy() {
          super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel();
        }
        _reportInfiniteLoop() {
        }
        _handleSelectionChange(e, t) {
          if (!this.isEnabled)
            return;
          const n = t.defaultView.getSelection();
          if (this.checkShouldIgnoreEventFromTarget(n.anchorNode))
            return;
          this.mutationObserver.flush();
          const i = this.domConverter.domSelectionToView(n);
          if (i.rangeCount != 0) {
            if (this.view.hasDomSelection = !0, !this.selection.isEqual(i) || !this.domConverter.isDomSelectionCorrect(n))
              if (++this._loopbackCounter > 60)
                this._reportInfiniteLoop();
              else if (this.focusObserver.flush(), this.selection.isSimilar(i))
                this.view.forceRender();
              else {
                const r = { oldSelection: this.selection, newSelection: i, domSelection: n };
                this.document.fire("selectionChange", r), this._fireSelectionChangeDoneDebounced(r);
              }
          } else
            this.view.hasDomSelection = !1;
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0;
        }
      }
      class GA extends Tn {
        constructor(e) {
          super(e), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
          const t = this.document;
          t.on("compositionstart", () => {
            t.isComposing = !0;
          }, { priority: "low" }), t.on("compositionend", () => {
            t.isComposing = !1;
          }, { priority: "low" });
        }
        onDomEvent(e) {
          this.fire(e.type, e, { data: e.data });
        }
      }
      class Dh {
        constructor(e, t = {}) {
          this._files = t.cacheFiles ? Bh(e) : null, this._native = e;
        }
        get files() {
          return this._files || (this._files = Bh(this._native)), this._files;
        }
        get types() {
          return this._native.types;
        }
        getData(e) {
          return this._native.getData(e);
        }
        setData(e, t) {
          this._native.setData(e, t);
        }
        set effectAllowed(e) {
          this._native.effectAllowed = e;
        }
        get effectAllowed() {
          return this._native.effectAllowed;
        }
        set dropEffect(e) {
          this._native.dropEffect = e;
        }
        get dropEffect() {
          return this._native.dropEffect;
        }
        setDragImage(e, t, n) {
          this._native.setDragImage(e, t, n);
        }
        get isCanceled() {
          return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
        }
      }
      function Bh(o) {
        const e = Array.from(o.files || []), t = Array.from(o.items || []);
        return e.length ? e : t.filter((n) => n.kind === "file").map((n) => n.getAsFile());
      }
      class KA extends Tn {
        constructor() {
          super(...arguments), this.domEventType = "beforeinput";
        }
        onDomEvent(e) {
          const t = e.getTargetRanges(), n = this.view, i = n.document;
          let r = null, s = null, a = [];
          if (e.dataTransfer && (r = new Dh(e.dataTransfer)), e.data !== null ? s = e.data : r && (s = r.getData("text/plain")), i.selection.isFake)
            a = Array.from(i.selection.getRanges());
          else if (t.length)
            a = t.map((l) => n.domConverter.domRangeToView(l));
          else if (b.isAndroid) {
            const l = e.target.ownerDocument.defaultView.getSelection();
            a = Array.from(n.domConverter.domSelectionToView(l).getRanges());
          }
          if (b.isAndroid && e.inputType == "insertCompositionText" && s && s.endsWith(`
`))
            this.fire(e.type, e, { inputType: "insertParagraph", targetRanges: [n.createRange(a[0].end)] });
          else if (e.inputType == "insertText" && s && s.includes(`
`)) {
            const l = s.split(/\n{1,2}/g);
            let d = a;
            for (let h = 0; h < l.length; h++) {
              const m = l[h];
              m != "" && (this.fire(e.type, e, { data: m, dataTransfer: r, targetRanges: d, inputType: e.inputType, isComposing: e.isComposing }), d = [i.selection.getFirstRange()]), h + 1 < l.length && (this.fire(e.type, e, { inputType: "insertParagraph", targetRanges: d }), d = [i.selection.getFirstRange()]);
            }
          } else
            this.fire(e.type, e, { data: s, dataTransfer: r, targetRanges: a, inputType: e.inputType, isComposing: e.isComposing });
        }
      }
      class ZA extends on {
        constructor(e) {
          super(e), this.document.on("keydown", (t, n) => {
            if (this.isEnabled && ((i = n.keyCode) == Ae.arrowright || i == Ae.arrowleft || i == Ae.arrowup || i == Ae.arrowdown)) {
              const r = new $o(this.document, "arrowKey", this.document.selection.getFirstRange());
              this.document.fire(r, n), r.stop.called && t.stop();
            }
            var i;
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class JA extends on {
        constructor(e) {
          super(e);
          const t = this.document;
          t.on("keydown", (n, i) => {
            if (!this.isEnabled || i.keyCode != Ae.tab || i.ctrlKey)
              return;
            const r = new $o(t, "tab", t.selection.getFirstRange());
            t.fire(r, i), r.stop.called && n.stop();
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class YA extends oe() {
        constructor(e) {
          super(), this.domRoots = /* @__PURE__ */ new Map(), this._initialDomRootAttributes = /* @__PURE__ */ new WeakMap(), this._observers = /* @__PURE__ */ new Map(), this._ongoingChange = !1, this._postFixersInProgress = !1, this._renderingDisabled = !1, this._hasChangedSinceTheLastRendering = !1, this.document = new th(e), this.domConverter = new ph(this.document), this.set("isRenderingInProgress", !1), this.set("hasDomSelection", !1), this._renderer = new mA(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new nh(this.document), this.addObserver(Sh), this.addObserver(ja), this.addObserver(WA), this.addObserver(_A), this.addObserver(IA), this.addObserver(GA), this.addObserver(ZA), this.addObserver(KA), this.addObserver(JA), this.document.on("arrowKey", hA, { priority: "low" }), aA(this), this.on("render", () => {
            this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = !1;
          }), this.listenTo(this.document.selection, "change", () => {
            this._hasChangedSinceTheLastRendering = !0;
          }), this.listenTo(this.document, "change:isFocused", () => {
            this._hasChangedSinceTheLastRendering = !0;
          });
        }
        attachDomRoot(e, t = "main") {
          const n = this.document.getRoot(t);
          n._name = e.tagName.toLowerCase();
          const i = {};
          for (const { name: s, value: a } of Array.from(e.attributes))
            i[s] = a, s === "class" ? this._writer.addClass(a.split(" "), n) : this._writer.setAttribute(s, a, n);
          this._initialDomRootAttributes.set(e, i);
          const r = () => {
            this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n), n.isReadOnly ? this._writer.addClass("ck-read-only", n) : this._writer.removeClass("ck-read-only", n);
          };
          r(), this.domRoots.set(t, e), this.domConverter.bindElements(e, n), this._renderer.markToSync("children", n), this._renderer.markToSync("attributes", n), this._renderer.domDocuments.add(e.ownerDocument), n.on("change:children", (s, a) => this._renderer.markToSync("children", a)), n.on("change:attributes", (s, a) => this._renderer.markToSync("attributes", a)), n.on("change:text", (s, a) => this._renderer.markToSync("text", a)), n.on("change:isReadOnly", () => this.change(r)), n.on("change", () => {
            this._hasChangedSinceTheLastRendering = !0;
          });
          for (const s of this._observers.values())
            s.observe(e, t);
        }
        detachDomRoot(e) {
          const t = this.domRoots.get(e);
          Array.from(t.attributes).forEach(({ name: i }) => t.removeAttribute(i));
          const n = this._initialDomRootAttributes.get(t);
          for (const i in n)
            t.setAttribute(i, n[i]);
          this.domRoots.delete(e), this.domConverter.unbindDomElement(t);
          for (const i of this._observers.values())
            i.stopObserving(t);
        }
        getDomRoot(e = "main") {
          return this.domRoots.get(e);
        }
        addObserver(e) {
          let t = this._observers.get(e);
          if (t)
            return t;
          t = new e(this), this._observers.set(e, t);
          for (const [n, i] of this.domRoots)
            t.observe(i, n);
          return t.enable(), t;
        }
        getObserver(e) {
          return this._observers.get(e);
        }
        disableObservers() {
          for (const e of this._observers.values())
            e.disable();
        }
        enableObservers() {
          for (const e of this._observers.values())
            e.enable();
        }
        scrollToTheSelection({ alignToTop: e, forceScroll: t, viewportOffset: n = 20, ancestorOffset: i = 20 } = {}) {
          const r = this.document.selection.getFirstRange();
          r && function({ target: s, viewportOffset: a = 0, ancestorOffset: l = 0, alignToTop: d, forceScroll: h }) {
            const m = ca(s);
            let f = m, _ = null;
            for (; f; ) {
              let E;
              E = Xv(f == m ? s : _), Qv({ parent: E, getRect: () => nu(s, f), alignToTop: d, ancestorOffset: l, forceScroll: h });
              const B = nu(s, f);
              if (Yv({ window: f, rect: B, viewportOffset: a, alignToTop: d, forceScroll: h }), f.parent != f) {
                if (_ = f.frameElement, f = f.parent, !_)
                  return;
              } else
                f = null;
            }
          }({ target: this.domConverter.viewRangeToDom(r), viewportOffset: n, ancestorOffset: i, alignToTop: e, forceScroll: t });
        }
        focus() {
          if (!this.document.isFocused) {
            const e = this.document.selection.editableElement;
            e && (this.domConverter.focus(e), this.forceRender());
          }
        }
        change(e) {
          if (this.isRenderingInProgress || this._postFixersInProgress)
            throw new I("cannot-change-view-tree", this);
          try {
            if (this._ongoingChange)
              return e(this._writer);
            this._ongoingChange = !0;
            const t = e(this._writer);
            return this._ongoingChange = !1, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0, this.document._callPostFixers(this._writer), this._postFixersInProgress = !1, this.fire("render")), t;
          } catch (t) {
            I.rethrowUnexpectedError(t, this);
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = !0, this.getObserver(ja).flush(), this.change(() => {
          });
        }
        destroy() {
          for (const e of this._observers.values())
            e.destroy();
          this.document.destroy(), this.stopListening();
        }
        createPositionAt(e, t) {
          return Z._createAt(e, t);
        }
        createPositionAfter(e) {
          return Z._createAfter(e);
        }
        createPositionBefore(e) {
          return Z._createBefore(e);
        }
        createRange(e, t) {
          return new re(e, t);
        }
        createRangeOn(e) {
          return re._createOn(e);
        }
        createRangeIn(e) {
          return re._createIn(e);
        }
        createSelection(...e) {
          return new tn(...e);
        }
        _disableRendering(e) {
          this._renderingDisabled = e, e == 0 && this.change(() => {
          });
        }
        _render() {
          this.isRenderingInProgress = !0, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = !1;
        }
      }
      class Pn {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      class no extends Pn {
        constructor(e) {
          super(), this.parent = null, this._attrs = hn(e);
        }
        get document() {
          return null;
        }
        get index() {
          let e;
          if (!this.parent)
            return null;
          if ((e = this.parent.getChildIndex(this)) === null)
            throw new I("model-node-not-found-in-parent", this);
          return e;
        }
        get startOffset() {
          let e;
          if (!this.parent)
            return null;
          if ((e = this.parent.getChildStartOffset(this)) === null)
            throw new I("model-node-not-found-in-parent", this);
          return e;
        }
        get offsetSize() {
          return 1;
        }
        get endOffset() {
          return this.parent ? this.startOffset + this.offsetSize : null;
        }
        get nextSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e + 1) || null;
        }
        get previousSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e - 1) || null;
        }
        get root() {
          let e = this;
          for (; e.parent; )
            e = e.parent;
          return e;
        }
        isAttached() {
          return this.parent !== null && this.root.isAttached();
        }
        getPath() {
          const e = [];
          let t = this;
          for (; t.parent; )
            e.unshift(t.startOffset), t = t.parent;
          return e;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this : this.parent;
          for (; n; )
            t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
        getCommonAncestor(e, t = {}) {
          const n = this.getAncestors(t), i = e.getAncestors(t);
          let r = 0;
          for (; n[r] == i[r] && n[r]; )
            r++;
          return r === 0 ? null : n[r - 1];
        }
        isBefore(e) {
          if (this == e || this.root !== e.root)
            return !1;
          const t = this.getPath(), n = e.getPath(), i = vt(t, n);
          switch (i) {
            case "prefix":
              return !0;
            case "extension":
              return !1;
            default:
              return t[i] < n[i];
          }
        }
        isAfter(e) {
          return this != e && this.root === e.root && !this.isBefore(e);
        }
        hasAttribute(e) {
          return this._attrs.has(e);
        }
        getAttribute(e) {
          return this._attrs.get(e);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        toJSON() {
          const e = {};
          return this._attrs.size && (e.attributes = Array.from(this._attrs).reduce((t, n) => (t[n[0]] = n[1], t), {})), e;
        }
        _clone(e) {
          return new this.constructor(this._attrs);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _setAttribute(e, t) {
          this._attrs.set(e, t);
        }
        _setAttributesTo(e) {
          this._attrs = hn(e);
        }
        _removeAttribute(e) {
          return this._attrs.delete(e);
        }
        _clearAttributes() {
          this._attrs.clear();
        }
      }
      no.prototype.is = function(o) {
        return o === "node" || o === "model:node";
      };
      class Oi {
        constructor(e) {
          this._nodes = [], e && this._insertNodes(0, e);
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]();
        }
        get length() {
          return this._nodes.length;
        }
        get maxOffset() {
          return this._nodes.reduce((e, t) => e + t.offsetSize, 0);
        }
        getNode(e) {
          return this._nodes[e] || null;
        }
        getNodeIndex(e) {
          const t = this._nodes.indexOf(e);
          return t == -1 ? null : t;
        }
        getNodeStartOffset(e) {
          const t = this.getNodeIndex(e);
          return t === null ? null : this._nodes.slice(0, t).reduce((n, i) => n + i.offsetSize, 0);
        }
        indexToOffset(e) {
          if (e == this._nodes.length)
            return this.maxOffset;
          const t = this._nodes[e];
          if (!t)
            throw new I("model-nodelist-index-out-of-bounds", this);
          return this.getNodeStartOffset(t);
        }
        offsetToIndex(e) {
          let t = 0;
          for (const n of this._nodes) {
            if (e >= t && e < t + n.offsetSize)
              return this.getNodeIndex(n);
            t += n.offsetSize;
          }
          if (t != e)
            throw new I("model-nodelist-offset-out-of-bounds", this, { offset: e, nodeList: this });
          return this.length;
        }
        _insertNodes(e, t) {
          for (const n of t)
            if (!(n instanceof no))
              throw new I("model-nodelist-insertnodes-not-node", this);
          this._nodes = function(n, i, r, s) {
            if (Math.max(i.length, n.length) > 1e4)
              return n.slice(0, r).concat(i).concat(n.slice(r + s, n.length));
            {
              const a = Array.from(n);
              return a.splice(r, s, ...i), a;
            }
          }(this._nodes, Array.from(t), e, 0);
        }
        _removeNodes(e, t = 1) {
          return this._nodes.splice(e, t);
        }
        toJSON() {
          return this._nodes.map((e) => e.toJSON());
        }
      }
      class Fe extends no {
        constructor(e, t) {
          super(t), this._data = e || "";
        }
        get offsetSize() {
          return this.data.length;
        }
        get data() {
          return this._data;
        }
        toJSON() {
          const e = super.toJSON();
          return e.data = this.data, e;
        }
        _clone() {
          return new Fe(this.data, this.getAttributes());
        }
        static fromJSON(e) {
          return new Fe(e.data, e.attributes);
        }
      }
      Fe.prototype.is = function(o) {
        return o === "$text" || o === "model:$text" || o === "text" || o === "model:text" || o === "node" || o === "model:node";
      };
      class Kt extends Pn {
        constructor(e, t, n) {
          if (super(), this.textNode = e, t < 0 || t > e.offsetSize)
            throw new I("model-textproxy-wrong-offsetintext", this);
          if (n < 0 || t + n > e.offsetSize)
            throw new I("model-textproxy-wrong-length", this);
          this.data = e.data.substring(t, t + n), this.offsetInText = t;
        }
        get startOffset() {
          return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
        }
        get offsetSize() {
          return this.data.length;
        }
        get endOffset() {
          return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        getPath() {
          const e = this.textNode.getPath();
          return e.length > 0 && (e[e.length - 1] += this.offsetInText), e;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this : this.parent;
          for (; n; )
            t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
        hasAttribute(e) {
          return this.textNode.hasAttribute(e);
        }
        getAttribute(e) {
          return this.textNode.getAttribute(e);
        }
        getAttributes() {
          return this.textNode.getAttributes();
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys();
        }
      }
      Kt.prototype.is = function(o) {
        return o === "$textProxy" || o === "model:$textProxy" || o === "textProxy" || o === "model:textProxy";
      };
      class $e extends no {
        constructor(e, t, n) {
          super(t), this._children = new Oi(), this.name = e, n && this._insertChild(0, n);
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        getChild(e) {
          return this._children.getNode(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(e) {
          return this._children.getNodeIndex(e);
        }
        getChildStartOffset(e) {
          return this._children.getNodeStartOffset(e);
        }
        offsetToIndex(e) {
          return this._children.offsetToIndex(e);
        }
        getNodeByPath(e) {
          let t = this;
          for (const n of e)
            t = t.getChild(t.offsetToIndex(n));
          return t;
        }
        findAncestor(e, t = {}) {
          let n = t.includeSelf ? this : this.parent;
          for (; n; ) {
            if (n.name === e)
              return n;
            n = n.parent;
          }
          return null;
        }
        toJSON() {
          const e = super.toJSON();
          if (e.name = this.name, this._children.length > 0) {
            e.children = [];
            for (const t of this._children)
              e.children.push(t.toJSON());
          }
          return e;
        }
        _clone(e = !1) {
          const t = e ? Array.from(this._children).map((n) => n._clone(!0)) : void 0;
          return new $e(this.name, this.getAttributes(), t);
        }
        _appendChild(e) {
          this._insertChild(this.childCount, e);
        }
        _insertChild(e, t) {
          const n = function(i) {
            return typeof i == "string" ? [new Fe(i)] : (It(i) || (i = [i]), Array.from(i).map((r) => typeof r == "string" ? new Fe(r) : r instanceof Kt ? new Fe(r.data, r.getAttributes()) : r));
          }(t);
          for (const i of n)
            i.parent !== null && i._remove(), i.parent = this;
          this._children._insertNodes(e, n);
        }
        _removeChildren(e, t = 1) {
          const n = this._children._removeNodes(e, t);
          for (const i of n)
            i.parent = null;
          return n;
        }
        static fromJSON(e) {
          let t;
          if (e.children) {
            t = [];
            for (const n of e.children)
              n.name ? t.push($e.fromJSON(n)) : t.push(Fe.fromJSON(n));
          }
          return new $e(e.name, e.attributes, t);
        }
      }
      $e.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "element" || o === "model:element") : o === "element" || o === "model:element" || o === "node" || o === "model:node";
      };
      class rn {
        constructor(e) {
          if (!e || !e.boundaries && !e.startPosition)
            throw new I("model-tree-walker-no-start-position", null);
          const t = e.direction || "forward";
          if (t != "forward" && t != "backward")
            throw new I("model-tree-walker-unknown-direction", e, { direction: t });
          this.direction = t, this.boundaries = e.boundaries || null, e.startPosition ? this._position = e.startPosition.clone() : this._position = W._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(e) {
          let t, n, i, r;
          do
            i = this.position, r = this._visitedParent, { done: t, value: n } = this.next();
          while (!t && e(n));
          t || (this._position = i, this._visitedParent = r);
        }
        next() {
          return this.direction == "forward" ? this._next() : this._previous();
        }
        _next() {
          const e = this.position, t = this.position.clone(), n = this._visitedParent;
          if (n.parent === null && t.offset === n.maxOffset)
            return { done: !0, value: void 0 };
          if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset)
            return { done: !0, value: void 0 };
          const i = Ri(t, n), r = i || Th(t, n, i);
          if (r instanceof $e)
            return this.shallow ? t.offset++ : (t.path.push(0), this._visitedParent = r), this._position = t, oo("elementStart", r, e, t, 1);
          if (r instanceof Fe) {
            let s;
            if (this.singleCharacters)
              s = 1;
            else {
              let d = r.endOffset;
              this._boundaryEndParent == n && this.boundaries.end.offset < d && (d = this.boundaries.end.offset), s = d - t.offset;
            }
            const a = t.offset - r.startOffset, l = new Kt(r, a, s);
            return t.offset += s, this._position = t, oo("text", l, e, t, s);
          }
          return t.path.pop(), t.offset++, this._position = t, this._visitedParent = n.parent, this.ignoreElementEnd ? this._next() : oo("elementEnd", n, e, t);
        }
        _previous() {
          const e = this.position, t = this.position.clone(), n = this._visitedParent;
          if (n.parent === null && t.offset === 0)
            return { done: !0, value: void 0 };
          if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset)
            return { done: !0, value: void 0 };
          const i = t.parent, r = Ri(t, i), s = r || Ph(t, i, r);
          if (s instanceof $e)
            return t.offset--, this.shallow ? (this._position = t, oo("elementStart", s, e, t, 1)) : (t.path.push(s.maxOffset), this._position = t, this._visitedParent = s, this.ignoreElementEnd ? this._previous() : oo("elementEnd", s, e, t));
          if (s instanceof Fe) {
            let a;
            if (this.singleCharacters)
              a = 1;
            else {
              let h = s.startOffset;
              this._boundaryStartParent == n && this.boundaries.start.offset > h && (h = this.boundaries.start.offset), a = t.offset - h;
            }
            const l = t.offset - s.startOffset, d = new Kt(s, l - a, a);
            return t.offset -= a, this._position = t, oo("text", d, e, t, a);
          }
          return t.path.pop(), this._position = t, this._visitedParent = n.parent, oo("elementStart", n, e, t, 1);
        }
      }
      function oo(o, e, t, n, i) {
        return { done: !1, value: { type: o, item: e, previousPosition: t, nextPosition: n, length: i } };
      }
      class W extends Pn {
        constructor(e, t, n = "toNone") {
          if (super(), !e.is("element") && !e.is("documentFragment"))
            throw new I("model-position-root-invalid", e);
          if (!(t instanceof Array) || t.length === 0)
            throw new I("model-position-path-incorrect-format", e, { path: t });
          e.is("rootElement") ? t = t.slice() : (t = [...e.getPath(), ...t], e = e.root), this.root = e, this.path = t, this.stickiness = n;
        }
        get offset() {
          return this.path[this.path.length - 1];
        }
        set offset(e) {
          this.path[this.path.length - 1] = e;
        }
        get parent() {
          let e = this.root;
          for (let t = 0; t < this.path.length - 1; t++)
            if (e = e.getChild(e.offsetToIndex(this.path[t])), !e)
              throw new I("model-position-path-incorrect", this, { position: this });
          if (e.is("$text"))
            throw new I("model-position-path-incorrect", this, { position: this });
          return e;
        }
        get index() {
          return this.parent.offsetToIndex(this.offset);
        }
        get textNode() {
          return Ri(this, this.parent);
        }
        get nodeAfter() {
          const e = this.parent;
          return Th(this, e, Ri(this, e));
        }
        get nodeBefore() {
          const e = this.parent;
          return Ph(this, e, Ri(this, e));
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset;
        }
        compareWith(e) {
          if (this.root != e.root)
            return "different";
          const t = vt(this.path, e.path);
          switch (t) {
            case "same":
              return "same";
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return this.path[t] < e.path[t] ? "before" : "after";
          }
        }
        getLastMatchingPosition(e, t = {}) {
          t.startPosition = this;
          const n = new rn(t);
          return n.skip(e), n.position;
        }
        getParentPath() {
          return this.path.slice(0, -1);
        }
        getAncestors() {
          const e = this.parent;
          return e.is("documentFragment") ? [e] : e.getAncestors({ includeSelf: !0 });
        }
        findAncestor(e) {
          const t = this.parent;
          return t.is("element") ? t.findAncestor(e, { includeSelf: !0 }) : null;
        }
        getCommonPath(e) {
          if (this.root != e.root)
            return [];
          const t = vt(this.path, e.path), n = typeof t == "string" ? Math.min(this.path.length, e.path.length) : t;
          return this.path.slice(0, n);
        }
        getCommonAncestor(e) {
          const t = this.getAncestors(), n = e.getAncestors();
          let i = 0;
          for (; t[i] == n[i] && t[i]; )
            i++;
          return i === 0 ? null : t[i - 1];
        }
        getShiftedBy(e) {
          const t = this.clone(), n = t.offset + e;
          return t.offset = n < 0 ? 0 : n, t;
        }
        isAfter(e) {
          return this.compareWith(e) == "after";
        }
        isBefore(e) {
          return this.compareWith(e) == "before";
        }
        isEqual(e) {
          return this.compareWith(e) == "same";
        }
        isTouching(e) {
          if (this.root !== e.root)
            return !1;
          const t = Math.min(this.path.length, e.path.length);
          for (let n = 0; n < t; n++) {
            const i = this.path[n] - e.path[n];
            if (i < -1 || i > 1)
              return !1;
            if (i === 1)
              return Ih(e, this, n);
            if (i === -1)
              return Ih(this, e, n);
          }
          return this.path.length === e.path.length || (this.path.length > e.path.length ? Ha(this.path, t) : Ha(e.path, t));
        }
        hasSameParentAs(e) {
          return this.root !== e.root ? !1 : vt(this.getParentPath(), e.getParentPath()) == "same";
        }
        getTransformedByOperation(e) {
          let t;
          switch (e.type) {
            case "insert":
              t = this._getTransformedByInsertOperation(e);
              break;
            case "move":
            case "remove":
            case "reinsert":
              t = this._getTransformedByMoveOperation(e);
              break;
            case "split":
              t = this._getTransformedBySplitOperation(e);
              break;
            case "merge":
              t = this._getTransformedByMergeOperation(e);
              break;
            default:
              t = W._createAt(this);
          }
          return t;
        }
        _getTransformedByInsertOperation(e) {
          return this._getTransformedByInsertion(e.position, e.howMany);
        }
        _getTransformedByMoveOperation(e) {
          return this._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
        }
        _getTransformedBySplitOperation(e) {
          const t = e.movedRange;
          return t.containsPosition(this) || t.start.isEqual(this) && this.stickiness == "toNext" ? this._getCombined(e.splitPosition, e.moveTargetPosition) : e.graveyardPosition ? this._getTransformedByMove(e.graveyardPosition, e.insertionPosition, 1) : this._getTransformedByInsertion(e.insertionPosition, 1);
        }
        _getTransformedByMergeOperation(e) {
          const t = e.movedRange;
          let n;
          return t.containsPosition(this) || t.start.isEqual(this) ? (n = this._getCombined(e.sourcePosition, e.targetPosition), e.sourcePosition.isBefore(e.targetPosition) && (n = n._getTransformedByDeletion(e.deletionPosition, 1))) : n = this.isEqual(e.deletionPosition) ? W._createAt(e.deletionPosition) : this._getTransformedByMove(e.deletionPosition, e.graveyardPosition, 1), n;
        }
        _getTransformedByDeletion(e, t) {
          const n = W._createAt(this);
          if (this.root != e.root)
            return n;
          if (vt(e.getParentPath(), this.getParentPath()) == "same") {
            if (e.offset < this.offset) {
              if (e.offset + t > this.offset)
                return null;
              n.offset -= t;
            }
          } else if (vt(e.getParentPath(), this.getParentPath()) == "prefix") {
            const i = e.path.length - 1;
            if (e.offset <= this.path[i]) {
              if (e.offset + t > this.path[i])
                return null;
              n.path[i] -= t;
            }
          }
          return n;
        }
        _getTransformedByInsertion(e, t) {
          const n = W._createAt(this);
          if (this.root != e.root)
            return n;
          if (vt(e.getParentPath(), this.getParentPath()) == "same")
            (e.offset < this.offset || e.offset == this.offset && this.stickiness != "toPrevious") && (n.offset += t);
          else if (vt(e.getParentPath(), this.getParentPath()) == "prefix") {
            const i = e.path.length - 1;
            e.offset <= this.path[i] && (n.path[i] += t);
          }
          return n;
        }
        _getTransformedByMove(e, t, n) {
          if (t = t._getTransformedByDeletion(e, n), e.isEqual(t))
            return W._createAt(this);
          const i = this._getTransformedByDeletion(e, n);
          return i === null || e.isEqual(this) && this.stickiness == "toNext" || e.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious" ? this._getCombined(e, t) : i._getTransformedByInsertion(t, n);
        }
        _getCombined(e, t) {
          const n = e.path.length - 1, i = W._createAt(t);
          return i.stickiness = this.stickiness, i.offset = i.offset + this.path[n] - e.offset, i.path = [...i.path, ...this.path.slice(n + 1)], i;
        }
        toJSON() {
          return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness };
        }
        clone() {
          return new this.constructor(this.root, this.path, this.stickiness);
        }
        static _createAt(e, t, n = "toNone") {
          if (e instanceof W)
            return new W(e.root, e.path, e.stickiness);
          {
            const i = e;
            if (t == "end")
              t = i.maxOffset;
            else {
              if (t == "before")
                return this._createBefore(i, n);
              if (t == "after")
                return this._createAfter(i, n);
              if (t !== 0 && !t)
                throw new I("model-createpositionat-offset-required", [this, e]);
            }
            if (!i.is("element") && !i.is("documentFragment"))
              throw new I("model-position-parent-incorrect", [this, e]);
            const r = i.getPath();
            return r.push(t), new this(i.root, r, n);
          }
        }
        static _createAfter(e, t) {
          if (!e.parent)
            throw new I("model-position-after-root", [this, e], { root: e });
          return this._createAt(e.parent, e.endOffset, t);
        }
        static _createBefore(e, t) {
          if (!e.parent)
            throw new I("model-position-before-root", e, { root: e });
          return this._createAt(e.parent, e.startOffset, t);
        }
        static fromJSON(e, t) {
          if (e.root === "$graveyard") {
            const n = new W(t.graveyard, e.path);
            return n.stickiness = e.stickiness, n;
          }
          if (!t.getRoot(e.root))
            throw new I("model-position-fromjson-no-root", t, { rootName: e.root });
          return new W(t.getRoot(e.root), e.path, e.stickiness);
        }
      }
      function Ri(o, e) {
        const t = e.getChild(e.offsetToIndex(o.offset));
        return t && t.is("$text") && t.startOffset < o.offset ? t : null;
      }
      function Th(o, e, t) {
        return t !== null ? null : e.getChild(e.offsetToIndex(o.offset));
      }
      function Ph(o, e, t) {
        return t !== null ? null : e.getChild(e.offsetToIndex(o.offset) - 1);
      }
      function Ih(o, e, t) {
        return t + 1 !== o.path.length && !!Ha(e.path, t + 1) && !!function(n, i) {
          let r = n.parent, s = n.path.length - 1, a = 0;
          for (; s >= i; ) {
            if (n.path[s] + a !== r.maxOffset)
              return !1;
            a = 1, s--, r = r.parent;
          }
          return !0;
        }(o, t + 1);
      }
      function Ha(o, e) {
        for (; e < o.length; ) {
          if (o[e] !== 0)
            return !1;
          e++;
        }
        return !0;
      }
      W.prototype.is = function(o) {
        return o === "position" || o === "model:position";
      };
      class $ extends Pn {
        constructor(e, t) {
          super(), this.start = W._createAt(e), this.end = t ? W._createAt(t) : W._createAt(e), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
        }
        *[Symbol.iterator]() {
          yield* new rn({ boundaries: this, ignoreElementEnd: !0 });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return vt(this.start.getParentPath(), this.end.getParentPath()) == "same";
        }
        get root() {
          return this.start.root;
        }
        containsPosition(e) {
          return e.isAfter(this.start) && e.isBefore(this.end);
        }
        containsRange(e, t = !1) {
          e.isCollapsed && (t = !1);
          const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start), i = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
          return n && i;
        }
        containsItem(e) {
          const t = W._createBefore(e);
          return this.containsPosition(t) || this.start.isEqual(t);
        }
        isEqual(e) {
          return this.start.isEqual(e.start) && this.end.isEqual(e.end);
        }
        isIntersecting(e) {
          return this.start.isBefore(e.end) && this.end.isAfter(e.start);
        }
        getDifference(e) {
          const t = [];
          return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new $(this.start, e.start)), this.containsPosition(e.end) && t.push(new $(e.end, this.end))) : t.push(new $(this.start, this.end)), t;
        }
        getIntersection(e) {
          if (this.isIntersecting(e)) {
            let t = this.start, n = this.end;
            return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new $(t, n);
          }
          return null;
        }
        getJoined(e, t = !1) {
          let n = this.isIntersecting(e);
          if (n || (n = this.start.isBefore(e.start) ? t ? this.end.isTouching(e.start) : this.end.isEqual(e.start) : t ? e.end.isTouching(this.start) : e.end.isEqual(this.start)), !n)
            return null;
          let i = this.start, r = this.end;
          return e.start.isBefore(i) && (i = e.start), e.end.isAfter(r) && (r = e.end), new $(i, r);
        }
        getMinimalFlatRanges() {
          const e = [], t = this.start.getCommonPath(this.end).length, n = W._createAt(this.start);
          let i = n.parent;
          for (; n.path.length > t + 1; ) {
            const r = i.maxOffset - n.offset;
            r !== 0 && e.push(new $(n, n.getShiftedBy(r))), n.path = n.path.slice(0, -1), n.offset++, i = i.parent;
          }
          for (; n.path.length <= this.end.path.length; ) {
            const r = this.end.path[n.path.length - 1], s = r - n.offset;
            s !== 0 && e.push(new $(n, n.getShiftedBy(s))), n.offset = r, n.path.push(0);
          }
          return e;
        }
        getWalker(e = {}) {
          return e.boundaries = this, new rn(e);
        }
        *getItems(e = {}) {
          e.boundaries = this, e.ignoreElementEnd = !0;
          const t = new rn(e);
          for (const n of t)
            yield n.item;
        }
        *getPositions(e = {}) {
          e.boundaries = this;
          const t = new rn(e);
          yield t.position;
          for (const n of t)
            yield n.nextPosition;
        }
        getTransformedByOperation(e) {
          switch (e.type) {
            case "insert":
              return this._getTransformedByInsertOperation(e);
            case "move":
            case "remove":
            case "reinsert":
              return this._getTransformedByMoveOperation(e);
            case "split":
              return [this._getTransformedBySplitOperation(e)];
            case "merge":
              return [this._getTransformedByMergeOperation(e)];
          }
          return [new $(this.start, this.end)];
        }
        getTransformedByOperations(e) {
          const t = [new $(this.start, this.end)];
          for (const n of e)
            for (let i = 0; i < t.length; i++) {
              const r = t[i].getTransformedByOperation(n);
              t.splice(i, 1, ...r), i += r.length - 1;
            }
          for (let n = 0; n < t.length; n++) {
            const i = t[n];
            for (let r = n + 1; r < t.length; r++) {
              const s = t[r];
              (i.containsRange(s) || s.containsRange(i) || i.isEqual(s)) && t.splice(r, 1);
            }
          }
          return t;
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed)
            return null;
          const e = this.start.nodeAfter, t = this.end.nodeBefore;
          return e && e.is("element") && e === t ? e : null;
        }
        toJSON() {
          return { start: this.start.toJSON(), end: this.end.toJSON() };
        }
        clone() {
          return new this.constructor(this.start, this.end);
        }
        _getTransformedByInsertOperation(e, t = !1) {
          return this._getTransformedByInsertion(e.position, e.howMany, t);
        }
        _getTransformedByMoveOperation(e, t = !1) {
          const n = e.sourcePosition, i = e.howMany, r = e.targetPosition;
          return this._getTransformedByMove(n, r, i, t);
        }
        _getTransformedBySplitOperation(e) {
          const t = this.start._getTransformedBySplitOperation(e);
          let n = this.end._getTransformedBySplitOperation(e);
          return this.end.isEqual(e.insertionPosition) && (n = this.end.getShiftedBy(1)), t.root != n.root && (n = this.end.getShiftedBy(-1)), new $(t, n);
        }
        _getTransformedByMergeOperation(e) {
          if (this.start.isEqual(e.targetPosition) && this.end.isEqual(e.deletionPosition))
            return new $(this.start);
          let t = this.start._getTransformedByMergeOperation(e), n = this.end._getTransformedByMergeOperation(e);
          return t.root != n.root && (n = this.end.getShiftedBy(-1)), t.isAfter(n) ? (e.sourcePosition.isBefore(e.targetPosition) ? (t = W._createAt(n), t.offset = 0) : (e.deletionPosition.isEqual(t) || (n = e.deletionPosition), t = e.targetPosition), new $(t, n)) : new $(t, n);
        }
        _getTransformedByInsertion(e, t, n = !1) {
          if (n && this.containsPosition(e))
            return [new $(this.start, e), new $(e.getShiftedBy(t), this.end._getTransformedByInsertion(e, t))];
          {
            const i = new $(this.start, this.end);
            return i.start = i.start._getTransformedByInsertion(e, t), i.end = i.end._getTransformedByInsertion(e, t), [i];
          }
        }
        _getTransformedByMove(e, t, n, i = !1) {
          if (this.isCollapsed) {
            const m = this.start._getTransformedByMove(e, t, n);
            return [new $(m)];
          }
          const r = $._createFromPositionAndShift(e, n), s = t._getTransformedByDeletion(e, n);
          if (this.containsPosition(t) && !i && (r.containsPosition(this.start) || r.containsPosition(this.end))) {
            const m = this.start._getTransformedByMove(e, t, n), f = this.end._getTransformedByMove(e, t, n);
            return [new $(m, f)];
          }
          let a;
          const l = this.getDifference(r);
          let d = null;
          const h = this.getIntersection(r);
          if (l.length == 1 ? d = new $(l[0].start._getTransformedByDeletion(e, n), l[0].end._getTransformedByDeletion(e, n)) : l.length == 2 && (d = new $(this.start, this.end._getTransformedByDeletion(e, n))), a = d ? d._getTransformedByInsertion(s, n, h !== null || i) : [], h) {
            const m = new $(h.start._getCombined(r.start, s), h.end._getCombined(r.start, s));
            a.length == 2 ? a.splice(1, 0, m) : a.push(m);
          }
          return a;
        }
        _getTransformedByDeletion(e, t) {
          let n = this.start._getTransformedByDeletion(e, t), i = this.end._getTransformedByDeletion(e, t);
          return n == null && i == null ? null : (n == null && (n = e), i == null && (i = e), new $(n, i));
        }
        static _createFromPositionAndShift(e, t) {
          const n = e, i = e.getShiftedBy(t);
          return t > 0 ? new this(n, i) : new this(i, n);
        }
        static _createIn(e) {
          return new this(W._createAt(e, 0), W._createAt(e, e.maxOffset));
        }
        static _createOn(e) {
          return this._createFromPositionAndShift(W._createBefore(e), e.offsetSize);
        }
        static _createFromRanges(e) {
          if (e.length === 0)
            throw new I("range-create-from-ranges-empty-array", null);
          if (e.length == 1)
            return e[0].clone();
          const t = e[0];
          e.sort((r, s) => r.start.isAfter(s.start) ? 1 : -1);
          const n = e.indexOf(t), i = new this(t.start, t.end);
          if (n > 0)
            for (let r = n - 1; e[r].end.isEqual(i.start); r++)
              i.start = W._createAt(e[r].start);
          for (let r = n + 1; r < e.length && e[r].start.isEqual(i.end); r++)
            i.end = W._createAt(e[r].end);
          return i;
        }
        static fromJSON(e, t) {
          return new this(W.fromJSON(e.start, t), W.fromJSON(e.end, t));
        }
      }
      $.prototype.is = function(o) {
        return o === "range" || o === "model:range";
      };
      class Oh extends De() {
        constructor() {
          super(), this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelLengthCallbacks = /* @__PURE__ */ new Map(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._deferredBindingRemovals = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this.on("modelToViewPosition", (e, t) => {
            if (t.viewPosition)
              return;
            const n = this._modelToViewMapping.get(t.modelPosition.parent);
            if (!n)
              throw new I("mapping-model-position-view-parent-not-found", this, { modelPosition: t.modelPosition });
            t.viewPosition = this.findPositionIn(n, t.modelPosition.offset);
          }, { priority: "low" }), this.on("viewToModelPosition", (e, t) => {
            if (t.modelPosition)
              return;
            const n = this.findMappedViewAncestor(t.viewPosition), i = this._viewToModelMapping.get(n), r = this._toModelOffset(t.viewPosition.parent, t.viewPosition.offset, n);
            t.modelPosition = W._createAt(i, r);
          }, { priority: "low" });
        }
        bindElements(e, t) {
          this._modelToViewMapping.set(e, t), this._viewToModelMapping.set(t, e);
        }
        unbindViewElement(e, t = {}) {
          const n = this.toModelElement(e);
          if (this._elementToMarkerNames.has(e))
            for (const i of this._elementToMarkerNames.get(e))
              this._unboundMarkerNames.add(i);
          t.defer ? this._deferredBindingRemovals.set(e, e.root) : (this._viewToModelMapping.delete(e), this._modelToViewMapping.get(n) == e && this._modelToViewMapping.delete(n));
        }
        unbindModelElement(e) {
          const t = this.toViewElement(e);
          this._modelToViewMapping.delete(e), this._viewToModelMapping.get(t) == e && this._viewToModelMapping.delete(t);
        }
        bindElementToMarker(e, t) {
          const n = this._markerNameToElements.get(t) || /* @__PURE__ */ new Set();
          n.add(e);
          const i = this._elementToMarkerNames.get(e) || /* @__PURE__ */ new Set();
          i.add(t), this._markerNameToElements.set(t, n), this._elementToMarkerNames.set(e, i);
        }
        unbindElementFromMarkerName(e, t) {
          const n = this._markerNameToElements.get(t);
          n && (n.delete(e), n.size == 0 && this._markerNameToElements.delete(t));
          const i = this._elementToMarkerNames.get(e);
          i && (i.delete(t), i.size == 0 && this._elementToMarkerNames.delete(e));
        }
        flushUnboundMarkerNames() {
          const e = Array.from(this._unboundMarkerNames);
          return this._unboundMarkerNames.clear(), e;
        }
        flushDeferredBindings() {
          for (const [e, t] of this._deferredBindingRemovals)
            e.root == t && this.unbindViewElement(e);
          this._deferredBindingRemovals = /* @__PURE__ */ new Map();
        }
        clearBindings() {
          this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this._deferredBindingRemovals = /* @__PURE__ */ new Map();
        }
        toModelElement(e) {
          return this._viewToModelMapping.get(e);
        }
        toViewElement(e) {
          return this._modelToViewMapping.get(e);
        }
        toModelRange(e) {
          return new $(this.toModelPosition(e.start), this.toModelPosition(e.end));
        }
        toViewRange(e) {
          return new re(this.toViewPosition(e.start), this.toViewPosition(e.end));
        }
        toModelPosition(e) {
          const t = { viewPosition: e, mapper: this };
          return this.fire("viewToModelPosition", t), t.modelPosition;
        }
        toViewPosition(e, t = {}) {
          const n = { modelPosition: e, mapper: this, isPhantom: t.isPhantom };
          return this.fire("modelToViewPosition", n), n.viewPosition;
        }
        markerNameToElements(e) {
          const t = this._markerNameToElements.get(e);
          if (!t)
            return null;
          const n = /* @__PURE__ */ new Set();
          for (const i of t)
            if (i.is("attributeElement"))
              for (const r of i.getElementsWithSameId())
                n.add(r);
            else
              n.add(i);
          return n;
        }
        registerViewToModelLength(e, t) {
          this._viewToModelLengthCallbacks.set(e, t);
        }
        findMappedViewAncestor(e) {
          let t = e.parent;
          for (; !this._viewToModelMapping.has(t); )
            t = t.parent;
          return t;
        }
        _toModelOffset(e, t, n) {
          if (n != e)
            return this._toModelOffset(e.parent, e.index, n) + this._toModelOffset(e, t, e);
          if (e.is("$text"))
            return t;
          let i = 0;
          for (let r = 0; r < t; r++)
            i += this.getModelLength(e.getChild(r));
          return i;
        }
        getModelLength(e) {
          if (this._viewToModelLengthCallbacks.get(e.name))
            return this._viewToModelLengthCallbacks.get(e.name)(e);
          if (this._viewToModelMapping.has(e))
            return 1;
          if (e.is("$text"))
            return e.data.length;
          if (e.is("uiElement"))
            return 0;
          {
            let t = 0;
            for (const n of e.getChildren())
              t += this.getModelLength(n);
            return t;
          }
        }
        findPositionIn(e, t) {
          let n, i = 0, r = 0, s = 0;
          if (e.is("$text"))
            return new Z(e, t);
          for (; r < t; )
            n = e.getChild(s), i = this.getModelLength(n), r += i, s++;
          return r == t ? this._moveViewPositionToTextNode(new Z(e, s)) : this.findPositionIn(n, t - (r - i));
        }
        _moveViewPositionToTextNode(e) {
          const t = e.nodeBefore, n = e.nodeAfter;
          return t instanceof Ne ? new Z(t, t.data.length) : n instanceof Ne ? new Z(n, 0) : e;
        }
      }
      class QA {
        constructor() {
          this._consumable = /* @__PURE__ */ new Map(), this._textProxyRegistry = /* @__PURE__ */ new Map();
        }
        add(e, t) {
          t = jr(t), e instanceof Kt && (e = this._getSymbolForTextProxy(e)), this._consumable.has(e) || this._consumable.set(e, /* @__PURE__ */ new Map()), this._consumable.get(e).set(t, !0);
        }
        consume(e, t) {
          return t = jr(t), e instanceof Kt && (e = this._getSymbolForTextProxy(e)), !!this.test(e, t) && (this._consumable.get(e).set(t, !1), !0);
        }
        test(e, t) {
          t = jr(t), e instanceof Kt && (e = this._getSymbolForTextProxy(e));
          const n = this._consumable.get(e);
          if (n === void 0)
            return null;
          const i = n.get(t);
          return i === void 0 ? null : i;
        }
        revert(e, t) {
          t = jr(t), e instanceof Kt && (e = this._getSymbolForTextProxy(e));
          const n = this.test(e, t);
          return n === !1 ? (this._consumable.get(e).set(t, !0), !0) : n !== !0 && null;
        }
        verifyAllConsumed(e) {
          const t = [];
          for (const [n, i] of this._consumable)
            for (const [r, s] of i) {
              const a = r.split(":")[0];
              s && e == a && t.push({ event: r, item: n.name || n.description });
            }
          if (t.length)
            throw new I("conversion-model-consumable-not-consumed", null, { items: t });
        }
        _getSymbolForTextProxy(e) {
          let t = null;
          const n = this._textProxyRegistry.get(e.startOffset);
          if (n) {
            const i = n.get(e.endOffset);
            i && (t = i.get(e.parent));
          }
          return t || (t = this._addSymbolForTextProxy(e)), t;
        }
        _addSymbolForTextProxy(e) {
          const t = e.startOffset, n = e.endOffset, i = e.parent, r = Symbol("$textProxy:" + e.data);
          let s, a;
          return s = this._textProxyRegistry.get(t), s || (s = /* @__PURE__ */ new Map(), this._textProxyRegistry.set(t, s)), a = s.get(n), a || (a = /* @__PURE__ */ new Map(), s.set(n, a)), a.set(i, r), r;
        }
      }
      function jr(o) {
        const e = o.split(":");
        return e[0] == "insert" ? e[0] : e[0] == "addMarker" || e[0] == "removeMarker" ? o : e.length > 1 ? e[0] + ":" + e[1] : e[0];
      }
      var XA = Object.defineProperty, eC = Object.defineProperties, tC = Object.getOwnPropertyDescriptors, Rh = Object.getOwnPropertySymbols, nC = Object.prototype.hasOwnProperty, oC = Object.prototype.propertyIsEnumerable, zh = (o, e, t) => e in o ? XA(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Ua = (o, e) => {
        for (var t in e || (e = {}))
          nC.call(e, t) && zh(o, t, e[t]);
        if (Rh)
          for (var t of Rh(e))
            oC.call(e, t) && zh(o, t, e[t]);
        return o;
      }, Mh = (o, e) => eC(o, tC(e));
      class Nh extends De() {
        constructor(e) {
          super(), this._conversionApi = Ua({ dispatcher: this }, e), this._firedEventsMap = /* @__PURE__ */ new WeakMap();
        }
        convertChanges(e, t, n) {
          const i = this._createConversionApi(n, e.getRefreshedItems());
          for (const s of e.getMarkersToRemove())
            this._convertMarkerRemove(s.name, s.range, i);
          const r = this._reduceChanges(e.getChanges());
          for (const s of r)
            s.type === "insert" ? this._convertInsert($._createFromPositionAndShift(s.position, s.length), i) : s.type === "reinsert" ? this._convertReinsert($._createFromPositionAndShift(s.position, s.length), i) : s.type === "remove" ? this._convertRemove(s.position, s.length, s.name, i) : this._convertAttribute(s.range, s.attributeKey, s.attributeOldValue, s.attributeNewValue, i);
          for (const s of i.mapper.flushUnboundMarkerNames()) {
            const a = t.get(s).getRange();
            this._convertMarkerRemove(s, a, i), this._convertMarkerAdd(s, a, i);
          }
          for (const s of e.getMarkersToAdd())
            this._convertMarkerAdd(s.name, s.range, i);
          i.mapper.flushDeferredBindings(), i.consumable.verifyAllConsumed("insert");
        }
        convert(e, t, n, i = {}) {
          const r = this._createConversionApi(n, void 0, i);
          this._convertInsert(e, r);
          for (const [s, a] of t)
            this._convertMarkerAdd(s, a, r);
          r.consumable.verifyAllConsumed("insert");
        }
        convertSelection(e, t, n) {
          const i = Array.from(t.getMarkersAtPosition(e.getFirstPosition())), r = this._createConversionApi(n);
          if (this._addConsumablesForSelection(r.consumable, e, i), this.fire("selection", { selection: e }, r), e.isCollapsed) {
            for (const s of i) {
              const a = s.getRange();
              if (!iC(e.getFirstPosition(), s, r.mapper))
                continue;
              const l = { item: e, markerName: s.name, markerRange: a };
              r.consumable.test(e, "addMarker:" + s.name) && this.fire(`addMarker:${s.name}`, l, r);
            }
            for (const s of e.getAttributeKeys()) {
              const a = { item: e, range: e.getFirstRange(), attributeKey: s, attributeOldValue: null, attributeNewValue: e.getAttribute(s) };
              r.consumable.test(e, "attribute:" + a.attributeKey) && this.fire(`attribute:${a.attributeKey}:$text`, a, r);
            }
          }
        }
        _convertInsert(e, t, n = {}) {
          n.doNotAddConsumables || this._addConsumablesForInsert(t.consumable, Array.from(e));
          for (const i of Array.from(e.getWalker({ shallow: !0 })).map(Fh))
            this._testAndFire("insert", i, t);
        }
        _convertRemove(e, t, n, i) {
          this.fire(`remove:${n}`, { position: e, length: t }, i);
        }
        _convertAttribute(e, t, n, i, r) {
          this._addConsumablesForRange(r.consumable, e, `attribute:${t}`);
          for (const s of e) {
            const a = { item: s.item, range: $._createFromPositionAndShift(s.previousPosition, s.length), attributeKey: t, attributeOldValue: n, attributeNewValue: i };
            this._testAndFire(`attribute:${t}`, a, r);
          }
        }
        _convertReinsert(e, t) {
          const n = Array.from(e.getWalker({ shallow: !0 }));
          this._addConsumablesForInsert(t.consumable, n);
          for (const i of n.map(Fh))
            this._testAndFire("insert", Mh(Ua({}, i), { reconversion: !0 }), t);
        }
        _convertMarkerAdd(e, t, n) {
          if (t.root.rootName == "$graveyard")
            return;
          const i = `addMarker:${e}`;
          if (n.consumable.add(t, i), this.fire(i, { markerName: e, markerRange: t }, n), n.consumable.consume(t, i)) {
            this._addConsumablesForRange(n.consumable, t, i);
            for (const r of t.getItems()) {
              if (!n.consumable.test(r, i))
                continue;
              const s = { item: r, range: $._createOn(r), markerName: e, markerRange: t };
              this.fire(i, s, n);
            }
          }
        }
        _convertMarkerRemove(e, t, n) {
          t.root.rootName != "$graveyard" && this.fire(`removeMarker:${e}`, { markerName: e, markerRange: t }, n);
        }
        _reduceChanges(e) {
          const t = { changes: e };
          return this.fire("reduceChanges", t), t.changes;
        }
        _addConsumablesForInsert(e, t) {
          for (const n of t) {
            const i = n.item;
            if (e.test(i, "insert") === null) {
              e.add(i, "insert");
              for (const r of i.getAttributeKeys())
                e.add(i, "attribute:" + r);
            }
          }
          return e;
        }
        _addConsumablesForRange(e, t, n) {
          for (const i of t.getItems())
            e.add(i, n);
          return e;
        }
        _addConsumablesForSelection(e, t, n) {
          e.add(t, "selection");
          for (const i of n)
            e.add(t, "addMarker:" + i.name);
          for (const i of t.getAttributeKeys())
            e.add(t, "attribute:" + i);
          return e;
        }
        _testAndFire(e, t, n) {
          const i = function(l, d) {
            const h = d.item.is("element") ? d.item.name : "$text";
            return `${l}:${h}`;
          }(e, t), r = t.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(t.item) : t.item, s = this._firedEventsMap.get(n), a = s.get(r);
          if (a) {
            if (a.has(i))
              return;
            a.add(i);
          } else
            s.set(r, /* @__PURE__ */ new Set([i]));
          this.fire(i, t, n);
        }
        _testAndFireAddAttributes(e, t) {
          const n = { item: e, range: $._createOn(e) };
          for (const i of n.item.getAttributeKeys())
            n.attributeKey = i, n.attributeOldValue = null, n.attributeNewValue = n.item.getAttribute(i), this._testAndFire(`attribute:${i}`, n, t);
        }
        _createConversionApi(e, t = /* @__PURE__ */ new Set(), n = {}) {
          const i = Mh(Ua({}, this._conversionApi), { consumable: new QA(), writer: e, options: n, convertItem: (r) => this._convertInsert($._createOn(r), i), convertChildren: (r) => this._convertInsert($._createIn(r), i, { doNotAddConsumables: !0 }), convertAttributes: (r) => this._testAndFireAddAttributes(r, i), canReuseView: (r) => !t.has(i.mapper.toModelElement(r)) });
          return this._firedEventsMap.set(i, /* @__PURE__ */ new Map()), i;
        }
      }
      function iC(o, e, t) {
        const n = e.getRange(), i = Array.from(o.getAncestors());
        return i.shift(), i.reverse(), !i.some((r) => {
          if (n.containsItem(r))
            return !!t.toViewElement(r).getCustomProperty("addHighlight");
        });
      }
      function Fh(o) {
        return { item: o.item, range: $._createFromPositionAndShift(o.previousPosition, o.length) };
      }
      class zt extends De(Pn) {
        constructor(...e) {
          super(), this._lastRangeBackward = !1, this._attrs = /* @__PURE__ */ new Map(), this._ranges = [], e.length && this.setTo(...e);
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const e = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? e.end : e.start;
          }
          return null;
        }
        get focus() {
          if (this._ranges.length > 0) {
            const e = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? e.start : e.end;
          }
          return null;
        }
        get isCollapsed() {
          return this._ranges.length === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        isEqual(e) {
          if (this.rangeCount != e.rangeCount)
            return !1;
          if (this.rangeCount === 0)
            return !0;
          if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
            return !1;
          for (const t of this._ranges) {
            let n = !1;
            for (const i of e._ranges)
              if (t.isEqual(i)) {
                n = !0;
                break;
              }
            if (!n)
              return !1;
          }
          return !0;
        }
        *getRanges() {
          for (const e of this._ranges)
            yield new $(e.start, e.end);
        }
        getFirstRange() {
          let e = null;
          for (const t of this._ranges)
            e && !t.start.isBefore(e.start) || (e = t);
          return e ? new $(e.start, e.end) : null;
        }
        getLastRange() {
          let e = null;
          for (const t of this._ranges)
            e && !t.end.isAfter(e.end) || (e = t);
          return e ? new $(e.start, e.end) : null;
        }
        getFirstPosition() {
          const e = this.getFirstRange();
          return e ? e.start.clone() : null;
        }
        getLastPosition() {
          const e = this.getLastRange();
          return e ? e.end.clone() : null;
        }
        setTo(...e) {
          let [t, n, i] = e;
          if (typeof n == "object" && (i = n, n = void 0), t === null)
            this._setRanges([]);
          else if (t instanceof zt)
            this._setRanges(t.getRanges(), t.isBackward);
          else if (t && typeof t.getRanges == "function")
            this._setRanges(t.getRanges(), t.isBackward);
          else if (t instanceof $)
            this._setRanges([t], !!i && !!i.backward);
          else if (t instanceof W)
            this._setRanges([new $(t)]);
          else if (t instanceof no) {
            const r = !!i && !!i.backward;
            let s;
            if (n == "in")
              s = $._createIn(t);
            else if (n == "on")
              s = $._createOn(t);
            else {
              if (n === void 0)
                throw new I("model-selection-setto-required-second-parameter", [this, t]);
              s = new $(W._createAt(t, n));
            }
            this._setRanges([s], r);
          } else {
            if (!It(t))
              throw new I("model-selection-setto-not-selectable", [this, t]);
            this._setRanges(t, i && !!i.backward);
          }
        }
        _setRanges(e, t = !1) {
          const n = Array.from(e), i = n.some((r) => {
            if (!(r instanceof $))
              throw new I("model-selection-set-ranges-not-range", [this, e]);
            return this._ranges.every((s) => !s.isEqual(r));
          });
          (n.length !== this._ranges.length || i) && (this._replaceAllRanges(n), this._lastRangeBackward = !!t, this.fire("change:range", { directChange: !0 }));
        }
        setFocus(e, t) {
          if (this.anchor === null)
            throw new I("model-selection-setfocus-no-ranges", [this, e]);
          const n = W._createAt(e, t);
          if (n.compareWith(this.focus) == "same")
            return;
          const i = this.anchor;
          this._ranges.length && this._popRange(), n.compareWith(i) == "before" ? (this._pushRange(new $(n, i)), this._lastRangeBackward = !0) : (this._pushRange(new $(i, n)), this._lastRangeBackward = !1), this.fire("change:range", { directChange: !0 });
        }
        getAttribute(e) {
          return this._attrs.get(e);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        hasAttribute(e) {
          return this._attrs.has(e);
        }
        removeAttribute(e) {
          this.hasAttribute(e) && (this._attrs.delete(e), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
        }
        setAttribute(e, t) {
          this.getAttribute(e) !== t && (this._attrs.set(e, t), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
        }
        getSelectedElement() {
          return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
        }
        *getSelectedBlocks() {
          const e = /* @__PURE__ */ new WeakSet();
          for (const t of this.getRanges()) {
            const n = Lh(t.start, e);
            sC(n, t) && (yield n);
            for (const r of t.getWalker()) {
              const s = r.item;
              r.type == "elementEnd" && rC(s, e, t) && (yield s);
            }
            const i = Lh(t.end, e);
            aC(i, t) && (yield i);
          }
        }
        containsEntireContent(e = this.anchor.root) {
          const t = W._createAt(e, 0), n = W._createAt(e, "end");
          return t.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition());
        }
        _pushRange(e) {
          this._checkRange(e), this._ranges.push(new $(e.start, e.end));
        }
        _checkRange(e) {
          for (let t = 0; t < this._ranges.length; t++)
            if (e.isIntersecting(this._ranges[t]))
              throw new I("model-selection-range-intersects", [this, e], { addedRange: e, intersectingRange: this._ranges[t] });
        }
        _replaceAllRanges(e) {
          this._removeAllRanges();
          for (const t of e)
            this._pushRange(t);
        }
        _removeAllRanges() {
          for (; this._ranges.length > 0; )
            this._popRange();
        }
        _popRange() {
          this._ranges.pop();
        }
      }
      function $h(o, e) {
        return !e.has(o) && (e.add(o), o.root.document.model.schema.isBlock(o) && !!o.parent);
      }
      function rC(o, e, t) {
        return $h(o, e) && qa(o, t);
      }
      function Lh(o, e) {
        const t = o.parent.root.document.model.schema, n = o.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
        let i = !1;
        const r = n.find((s) => !i && (i = t.isLimit(s), !i && $h(s, e)));
        return n.forEach((s) => e.add(s)), r;
      }
      function qa(o, e) {
        const t = function(n) {
          const i = n.root.document.model.schema;
          let r = n.parent;
          for (; r; ) {
            if (i.isBlock(r))
              return r;
            r = r.parent;
          }
        }(o);
        return t ? !e.containsRange($._createOn(t), !0) : !0;
      }
      function sC(o, e) {
        return !!o && (!(!e.isCollapsed && !o.isEmpty) || !e.start.isTouching(W._createAt(o, o.maxOffset)) && qa(o, e));
      }
      function aC(o, e) {
        return !!o && (!(!e.isCollapsed && !o.isEmpty) || !e.end.isTouching(W._createAt(o, 0)) && qa(o, e));
      }
      zt.prototype.is = function(o) {
        return o === "selection" || o === "model:selection";
      };
      class gn extends De($) {
        constructor(e, t) {
          super(e, t), lC.call(this);
        }
        detach() {
          this.stopListening();
        }
        toRange() {
          return new $(this.start, this.end);
        }
        static fromRange(e) {
          return new gn(e.start, e.end);
        }
      }
      function lC() {
        this.listenTo(this.root.document.model, "applyOperation", (o, e) => {
          const t = e[0];
          t.isDocumentOperation && cC.call(this, t);
        }, { priority: "low" });
      }
      function cC(o) {
        const e = this.getTransformedByOperation(o), t = $._createFromRanges(e), n = !t.isEqual(this), i = function(s, a) {
          switch (a.type) {
            case "insert":
              return s.containsPosition(a.position);
            case "move":
            case "remove":
            case "reinsert":
            case "merge":
              return s.containsPosition(a.sourcePosition) || s.start.isEqual(a.sourcePosition) || s.containsPosition(a.targetPosition);
            case "split":
              return s.containsPosition(a.splitPosition) || s.containsPosition(a.insertionPosition);
          }
          return !1;
        }(this, o);
        let r = null;
        if (n) {
          t.root.rootName == "$graveyard" && (r = o.type == "remove" ? o.sourcePosition : o.deletionPosition);
          const s = this.toRange();
          this.start = t.start, this.end = t.end, this.fire("change:range", s, { deletionPosition: r });
        } else
          i && this.fire("change:content", this.toRange(), { deletionPosition: r });
      }
      gn.prototype.is = function(o) {
        return o === "liveRange" || o === "model:liveRange" || o == "range" || o === "model:range";
      };
      const Hr = "selection:";
      class Zt extends De(Pn) {
        constructor(e) {
          super(), this._selection = new dC(e), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden;
        }
        get markers() {
          return this._selection.markers;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        getRanges() {
          return this._selection.getRanges();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        containsEntireContent(e) {
          return this._selection.containsEntireContent(e);
        }
        destroy() {
          this._selection.destroy();
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys();
        }
        getAttributes() {
          return this._selection.getAttributes();
        }
        getAttribute(e) {
          return this._selection.getAttribute(e);
        }
        hasAttribute(e) {
          return this._selection.hasAttribute(e);
        }
        refresh() {
          this._selection.updateMarkers(), this._selection._updateAttributes(!1);
        }
        observeMarkers(e) {
          this._selection.observeMarkers(e);
        }
        _setFocus(e, t) {
          this._selection.setFocus(e, t);
        }
        _setTo(...e) {
          this._selection.setTo(...e);
        }
        _setAttribute(e, t) {
          this._selection.setAttribute(e, t);
        }
        _removeAttribute(e) {
          this._selection.removeAttribute(e);
        }
        _getStoredAttributes() {
          return this._selection.getStoredAttributes();
        }
        _overrideGravity() {
          return this._selection.overrideGravity();
        }
        _restoreGravity(e) {
          this._selection.restoreGravity(e);
        }
        static _getStoreAttributeKey(e) {
          return Hr + e;
        }
        static _isStoreAttributeKey(e) {
          return e.startsWith(Hr);
        }
      }
      Zt.prototype.is = function(o) {
        return o === "selection" || o == "model:selection" || o == "documentSelection" || o == "model:documentSelection";
      };
      class dC extends zt {
        constructor(e) {
          super(), this.markers = new Vt({ idProperty: "name" }), this._attributePriority = /* @__PURE__ */ new Map(), this._selectionRestorePosition = null, this._hasChangedRange = !1, this._overriddenGravityRegister = /* @__PURE__ */ new Set(), this._observedMarkers = /* @__PURE__ */ new Set(), this._model = e.model, this._document = e, this.listenTo(this._model, "applyOperation", (t, n) => {
            const i = n[0];
            i.isDocumentOperation && i.type != "marker" && i.type != "rename" && i.type != "noop" && (this._ranges.length == 0 && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = !1, this.fire("change:range", { directChange: !1 })));
          }, { priority: "lowest" }), this.on("change:range", () => {
            this._validateSelectionRanges(this.getRanges());
          }), this.listenTo(this._model.markers, "update", (t, n, i, r) => {
            this._updateMarker(n, r);
          }), this.listenTo(this._document, "change", (t, n) => {
            (function(i, r) {
              const s = i.document.differ;
              for (const a of s.getChanges()) {
                if (a.type != "insert")
                  continue;
                const l = a.position.parent;
                a.length === l.maxOffset && i.enqueueChange(r, (d) => {
                  const h = Array.from(l.getAttributeKeys()).filter((m) => m.startsWith(Hr));
                  for (const m of h)
                    d.removeAttribute(m, l);
                });
              }
            })(this._model, n);
          });
        }
        get isCollapsed() {
          return this._ranges.length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
        }
        get anchor() {
          return super.anchor || this._document._getDefaultRange().start;
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end;
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1;
        }
        get hasOwnRange() {
          return this._ranges.length > 0;
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size;
        }
        destroy() {
          for (let e = 0; e < this._ranges.length; e++)
            this._ranges[e].detach();
          this.stopListening();
        }
        *getRanges() {
          this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
        }
        getFirstRange() {
          return super.getFirstRange() || this._document._getDefaultRange();
        }
        getLastRange() {
          return super.getLastRange() || this._document._getDefaultRange();
        }
        setTo(...e) {
          super.setTo(...e), this._updateAttributes(!0), this.updateMarkers();
        }
        setFocus(e, t) {
          super.setFocus(e, t), this._updateAttributes(!0), this.updateMarkers();
        }
        setAttribute(e, t) {
          if (this._setAttribute(e, t)) {
            const n = [e];
            this.fire("change:attribute", { attributeKeys: n, directChange: !0 });
          }
        }
        removeAttribute(e) {
          if (this._removeAttribute(e)) {
            const t = [e];
            this.fire("change:attribute", { attributeKeys: t, directChange: !0 });
          }
        }
        overrideGravity() {
          const e = ie();
          return this._overriddenGravityRegister.add(e), this._overriddenGravityRegister.size === 1 && this._updateAttributes(!0), e;
        }
        restoreGravity(e) {
          if (!this._overriddenGravityRegister.has(e))
            throw new I("document-selection-gravity-wrong-restore", this, { uid: e });
          this._overriddenGravityRegister.delete(e), this.isGravityOverridden || this._updateAttributes(!0);
        }
        observeMarkers(e) {
          this._observedMarkers.add(e), this.updateMarkers();
        }
        _replaceAllRanges(e) {
          this._validateSelectionRanges(e), super._replaceAllRanges(e);
        }
        _popRange() {
          this._ranges.pop().detach();
        }
        _pushRange(e) {
          const t = this._prepareRange(e);
          t && this._ranges.push(t);
        }
        _validateSelectionRanges(e) {
          for (const t of e)
            if (!this._document._validateSelectionRange(t))
              throw new I("document-selection-wrong-position", this, { range: t });
        }
        _prepareRange(e) {
          if (this._checkRange(e), e.root == this._document.graveyard)
            return;
          const t = gn.fromRange(e);
          return t.on("change:range", (n, i, r) => {
            if (this._hasChangedRange = !0, t.root == this._document.graveyard) {
              this._selectionRestorePosition = r.deletionPosition;
              const s = this._ranges.indexOf(t);
              this._ranges.splice(s, 1), t.detach();
            }
          }), t;
        }
        updateMarkers() {
          if (!this._observedMarkers.size)
            return;
          const e = [];
          let t = !1;
          for (const i of this._model.markers) {
            const r = i.name.split(":", 1)[0];
            if (!this._observedMarkers.has(r))
              continue;
            const s = i.getRange();
            for (const a of this.getRanges())
              s.containsRange(a, !a.isCollapsed) && e.push(i);
          }
          const n = Array.from(this.markers);
          for (const i of e)
            this.markers.has(i) || (this.markers.add(i), t = !0);
          for (const i of Array.from(this.markers))
            e.includes(i) || (this.markers.remove(i), t = !0);
          t && this.fire("change:marker", { oldMarkers: n, directChange: !1 });
        }
        _updateMarker(e, t) {
          const n = e.name.split(":", 1)[0];
          if (!this._observedMarkers.has(n))
            return;
          let i = !1;
          const r = Array.from(this.markers), s = this.markers.has(e);
          if (t) {
            let a = !1;
            for (const l of this.getRanges())
              if (t.containsRange(l, !l.isCollapsed)) {
                a = !0;
                break;
              }
            a && !s ? (this.markers.add(e), i = !0) : !a && s && (this.markers.remove(e), i = !0);
          } else
            s && (this.markers.remove(e), i = !0);
          i && this.fire("change:marker", { oldMarkers: r, directChange: !1 });
        }
        _updateAttributes(e) {
          const t = hn(this._getSurroundingAttributes()), n = hn(this.getAttributes());
          if (e)
            this._attributePriority = /* @__PURE__ */ new Map(), this._attrs = /* @__PURE__ */ new Map();
          else
            for (const [r, s] of this._attributePriority)
              s == "low" && (this._attrs.delete(r), this._attributePriority.delete(r));
          this._setAttributesTo(t);
          const i = [];
          for (const [r, s] of this.getAttributes())
            n.has(r) && n.get(r) === s || i.push(r);
          for (const [r] of n)
            this.hasAttribute(r) || i.push(r);
          i.length > 0 && this.fire("change:attribute", { attributeKeys: i, directChange: !1 });
        }
        _setAttribute(e, t, n = !0) {
          const i = n ? "normal" : "low";
          return i == "low" && this._attributePriority.get(e) == "normal" ? !1 : super.getAttribute(e) !== t && (this._attrs.set(e, t), this._attributePriority.set(e, i), !0);
        }
        _removeAttribute(e, t = !0) {
          const n = t ? "normal" : "low";
          return (n != "low" || this._attributePriority.get(e) != "normal") && (this._attributePriority.set(e, n), !!super.hasAttribute(e) && (this._attrs.delete(e), !0));
        }
        _setAttributesTo(e) {
          const t = /* @__PURE__ */ new Set();
          for (const [n, i] of this.getAttributes())
            e.get(n) !== i && this._removeAttribute(n, !1);
          for (const [n, i] of e)
            this._setAttribute(n, i, !1) && t.add(n);
          return t;
        }
        *getStoredAttributes() {
          const e = this.getFirstPosition().parent;
          if (this.isCollapsed && e.isEmpty)
            for (const t of e.getAttributeKeys())
              t.startsWith(Hr) && (yield [t.substr(10), e.getAttribute(t)]);
        }
        _getSurroundingAttributes() {
          const e = this.getFirstPosition(), t = this._model.schema;
          let n = null;
          if (this.isCollapsed) {
            const i = e.textNode ? e.textNode : e.nodeBefore, r = e.textNode ? e.textNode : e.nodeAfter;
            if (this.isGravityOverridden || (n = Ur(i)), n || (n = Ur(r)), !this.isGravityOverridden && !n) {
              let s = i;
              for (; s && !t.isInline(s) && !n; )
                s = s.previousSibling, n = Ur(s);
            }
            if (!n) {
              let s = r;
              for (; s && !t.isInline(s) && !n; )
                s = s.nextSibling, n = Ur(s);
            }
            n || (n = this.getStoredAttributes());
          } else {
            const i = this.getFirstRange();
            for (const r of i) {
              if (r.item.is("element") && t.isObject(r.item))
                break;
              if (r.type == "text") {
                n = r.item.getAttributes();
                break;
              }
            }
          }
          return n;
        }
        _fixGraveyardSelection(e) {
          const t = this._model.schema.getNearestSelectionRange(e);
          t && this._pushRange(t);
        }
      }
      function Ur(o) {
        return o instanceof Kt || o instanceof Fe ? o.getAttributes() : null;
      }
      class Vh {
        constructor(e) {
          this._dispatchers = e;
        }
        add(e) {
          for (const t of this._dispatchers)
            e(t);
          return this;
        }
      }
      const In = function(o) {
        return ia(o, 5);
      };
      class uC extends Vh {
        elementToElement(e) {
          return this.add(function(t) {
            const n = Uh(t.model), i = zi(t.view, "container");
            return n.attributes.length && (n.children = !0), (r) => {
              r.on(`insert:${n.name}`, /* @__PURE__ */ function(s, a = gC) {
                return (l, d, h) => {
                  if (!a(d.item, h.consumable, { preflight: !0 }))
                    return;
                  const m = s(d.item, h, d);
                  if (!m)
                    return;
                  a(d.item, h.consumable);
                  const f = h.mapper.toViewPosition(d.range.start);
                  h.mapper.bindElements(d.item, m), h.writer.insert(f, m), h.convertAttributes(d.item), Zh(m, d.item.getChildren(), h, { reconversion: d.reconversion });
                };
              }(i, Kh(n)), { priority: t.converterPriority || "normal" }), (n.children || n.attributes.length) && r.on("reduceChanges", Gh(n), { priority: "low" });
            };
          }(e));
        }
        elementToStructure(e) {
          return this.add(function(t) {
            const n = Uh(t.model), i = zi(t.view, "container");
            return n.children = !0, (r) => {
              if (r._conversionApi.schema.checkChild(n.name, "$text"))
                throw new I("conversion-element-to-structure-disallowed-text", r, { elementName: n.name });
              var s, a;
              r.on(`insert:${n.name}`, (s = i, a = Kh(n), (l, d, h) => {
                if (!a(d.item, h.consumable, { preflight: !0 }))
                  return;
                const m = /* @__PURE__ */ new Map();
                h.writer._registerSlotFactory(/* @__PURE__ */ function(E, B, T) {
                  return (O, N) => {
                    const H = O.createContainerElement("$slot");
                    let X = null;
                    if (N === "children")
                      X = Array.from(E.getChildren());
                    else {
                      if (typeof N != "function")
                        throw new I("conversion-slot-mode-unknown", T.dispatcher, { modeOrFilter: N });
                      X = Array.from(E.getChildren()).filter((be) => N(be));
                    }
                    return B.set(H, X), H;
                  };
                }(d.item, m, h));
                const f = s(d.item, h, d);
                if (h.writer._clearSlotFactory(), !f)
                  return;
                (function(E, B, T) {
                  const O = Array.from(B.values()).flat(), N = new Set(O);
                  if (N.size != O.length)
                    throw new I("conversion-slot-filter-overlap", T.dispatcher, { element: E });
                  if (N.size != E.childCount)
                    throw new I("conversion-slot-filter-incomplete", T.dispatcher, { element: E });
                })(d.item, m, h), a(d.item, h.consumable);
                const _ = h.mapper.toViewPosition(d.range.start);
                h.mapper.bindElements(d.item, f), h.writer.insert(_, f), h.convertAttributes(d.item), function(E, B, T, O) {
                  T.mapper.on("modelToViewPosition", X, { priority: "highest" });
                  let N = null, H = null;
                  for ([N, H] of B)
                    Zh(E, H, T, O), T.writer.move(T.writer.createRangeIn(N), T.writer.createPositionBefore(N)), T.writer.remove(N);
                  function X(be, Ge) {
                    const Pe = Ge.modelPosition.nodeAfter, _n = H.indexOf(Pe);
                    _n < 0 || (Ge.viewPosition = Ge.mapper.findPositionIn(N, _n));
                  }
                  T.mapper.off("modelToViewPosition", X);
                }(f, m, h, { reconversion: d.reconversion });
              }), { priority: t.converterPriority || "normal" }), r.on("reduceChanges", Gh(n), { priority: "low" });
            };
          }(e));
        }
        attributeToElement(e) {
          return this.add(function(t) {
            t = In(t);
            let n = t.model;
            typeof n == "string" && (n = { key: n });
            let i = `attribute:${n.key}`;
            if (n.name && (i += ":" + n.name), n.values)
              for (const s of n.values)
                t.view[s] = zi(t.view[s], "attribute");
            else
              t.view = zi(t.view, "attribute");
            const r = qh(t);
            return (s) => {
              s.on(i, /* @__PURE__ */ function(a) {
                return (l, d, h) => {
                  if (!h.consumable.test(d.item, l.name))
                    return;
                  const m = a(d.attributeOldValue, h, d), f = a(d.attributeNewValue, h, d);
                  if (!m && !f)
                    return;
                  h.consumable.consume(d.item, l.name);
                  const _ = h.writer, E = _.document.selection;
                  if (d.item instanceof zt || d.item instanceof Zt)
                    _.wrap(E.getFirstRange(), f);
                  else {
                    let B = h.mapper.toViewRange(d.range);
                    d.attributeOldValue !== null && m && (B = _.unwrap(B, m)), d.attributeNewValue !== null && f && _.wrap(B, f);
                  }
                };
              }(r), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        attributeToAttribute(e) {
          return this.add(function(t) {
            t = In(t);
            let n = t.model;
            typeof n == "string" && (n = { key: n });
            let i = `attribute:${n.key}`;
            if (n.name && (i += ":" + n.name), n.values)
              for (const s of n.values)
                t.view[s] = Wh(t.view[s]);
            else
              t.view = Wh(t.view);
            const r = qh(t);
            return (s) => {
              var a;
              s.on(i, (a = r, (l, d, h) => {
                if (!h.consumable.test(d.item, l.name))
                  return;
                const m = a(d.attributeOldValue, h, d), f = a(d.attributeNewValue, h, d);
                if (!m && !f)
                  return;
                h.consumable.consume(d.item, l.name);
                const _ = h.mapper.toViewElement(d.item), E = h.writer;
                if (!_)
                  throw new I("conversion-attribute-to-attribute-on-text", h.dispatcher, d);
                if (d.attributeOldValue !== null && m)
                  if (m.key == "class") {
                    const B = Xe(m.value);
                    for (const T of B)
                      E.removeClass(T, _);
                  } else if (m.key == "style") {
                    const B = Object.keys(m.value);
                    for (const T of B)
                      E.removeStyle(T, _);
                  } else
                    E.removeAttribute(m.key, _);
                if (d.attributeNewValue !== null && f)
                  if (f.key == "class") {
                    const B = Xe(f.value);
                    for (const T of B)
                      E.addClass(T, _);
                  } else if (f.key == "style") {
                    const B = Object.keys(f.value);
                    for (const T of B)
                      E.setStyle(T, f.value[T], _);
                  } else
                    E.setAttribute(f.key, f.value, _);
              }), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        markerToElement(e) {
          return this.add(function(t) {
            const n = zi(t.view, "ui");
            return (i) => {
              var r;
              i.on(`addMarker:${t.model}`, (r = n, (s, a, l) => {
                a.isOpening = !0;
                const d = r(a, l);
                a.isOpening = !1;
                const h = r(a, l);
                if (!d || !h)
                  return;
                const m = a.markerRange;
                if (m.isCollapsed && !l.consumable.consume(m, s.name))
                  return;
                for (const E of m)
                  if (!l.consumable.consume(E.item, s.name))
                    return;
                const f = l.mapper, _ = l.writer;
                _.insert(f.toViewPosition(m.start), d), l.mapper.bindElementToMarker(d, a.markerName), m.isCollapsed || (_.insert(f.toViewPosition(m.end), h), l.mapper.bindElementToMarker(h, a.markerName)), s.stop();
              }), { priority: t.converterPriority || "normal" }), i.on(`removeMarker:${t.model}`, (s, a, l) => {
                const d = l.mapper.markerNameToElements(a.markerName);
                if (d) {
                  for (const h of d)
                    l.mapper.unbindElementFromMarkerName(h, a.markerName), l.writer.clear(l.writer.createRangeOn(h), h);
                  l.writer.clearClonedElementsGroup(a.markerName), s.stop();
                }
              }, { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        markerToHighlight(e) {
          return this.add(/* @__PURE__ */ function(t) {
            return (n) => {
              var i;
              n.on(`addMarker:${t.model}`, (i = t.view, (r, s, a) => {
                if (!s.item || !(s.item instanceof zt || s.item instanceof Zt || s.item.is("$textProxy")))
                  return;
                const l = Wa(i, s, a);
                if (!l || !a.consumable.consume(s.item, r.name))
                  return;
                const d = a.writer, h = jh(d, l), m = d.document.selection;
                if (s.item instanceof zt || s.item instanceof Zt)
                  d.wrap(m.getFirstRange(), h);
                else {
                  const f = a.mapper.toViewRange(s.range), _ = d.wrap(f, h);
                  for (const E of _.getItems())
                    if (E.is("attributeElement") && E.isSimilar(h)) {
                      a.mapper.bindElementToMarker(E, s.markerName);
                      break;
                    }
                }
              }), { priority: t.converterPriority || "normal" }), n.on(`addMarker:${t.model}`, /* @__PURE__ */ function(r) {
                return (s, a, l) => {
                  if (!a.item || !(a.item instanceof $e))
                    return;
                  const d = Wa(r, a, l);
                  if (!d || !l.consumable.test(a.item, s.name))
                    return;
                  const h = l.mapper.toViewElement(a.item);
                  if (h && h.getCustomProperty("addHighlight")) {
                    l.consumable.consume(a.item, s.name);
                    for (const m of $._createIn(a.item))
                      l.consumable.consume(m.item, s.name);
                    h.getCustomProperty("addHighlight")(h, d, l.writer), l.mapper.bindElementToMarker(h, a.markerName);
                  }
                };
              }(t.view), { priority: t.converterPriority || "normal" }), n.on(`removeMarker:${t.model}`, /* @__PURE__ */ function(r) {
                return (s, a, l) => {
                  if (a.markerRange.isCollapsed)
                    return;
                  const d = Wa(r, a, l);
                  if (!d)
                    return;
                  const h = jh(l.writer, d), m = l.mapper.markerNameToElements(a.markerName);
                  if (m) {
                    for (const f of m)
                      l.mapper.unbindElementFromMarkerName(f, a.markerName), f.is("attributeElement") ? l.writer.unwrap(l.writer.createRangeOn(f), h) : f.getCustomProperty("removeHighlight")(f, d.id, l.writer);
                    l.writer.clearClonedElementsGroup(a.markerName), s.stop();
                  }
                };
              }(t.view), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        markerToData(e) {
          return this.add(function(t) {
            t = In(t);
            const n = t.model;
            let i = t.view;
            return i || (i = (r) => ({ group: n, name: r.substr(t.model.length + 1) })), (r) => {
              var s;
              r.on(`addMarker:${n}`, (s = i, (a, l, d) => {
                const h = s(l.markerName, d);
                if (!h)
                  return;
                const m = l.markerRange;
                d.consumable.consume(m, a.name) && (Hh(m, !1, d, l, h), Hh(m, !0, d, l, h), a.stop());
              }), { priority: t.converterPriority || "normal" }), r.on(`removeMarker:${n}`, /* @__PURE__ */ function(a) {
                return (l, d, h) => {
                  const m = a(d.markerName, h);
                  if (!m)
                    return;
                  const f = h.mapper.markerNameToElements(d.markerName);
                  if (f) {
                    for (const E of f)
                      h.mapper.unbindElementFromMarkerName(E, d.markerName), E.is("containerElement") ? (_(`data-${m.group}-start-before`, E), _(`data-${m.group}-start-after`, E), _(`data-${m.group}-end-before`, E), _(`data-${m.group}-end-after`, E)) : h.writer.clear(h.writer.createRangeOn(E), E);
                    h.writer.clearClonedElementsGroup(d.markerName), l.stop();
                  }
                  function _(E, B) {
                    if (B.hasAttribute(E)) {
                      const T = new Set(B.getAttribute(E).split(","));
                      T.delete(m.name), T.size == 0 ? h.writer.removeAttribute(E, B) : h.writer.setAttribute(E, Array.from(T).join(","), B);
                    }
                  }
                };
              }(i), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
      }
      function jh(o, e) {
        const t = o.createAttributeElement("span", e.attributes);
        return e.classes && t._addClass(e.classes), typeof e.priority == "number" && (t._priority = e.priority), t._id = e.id, t;
      }
      function Hh(o, e, t, n, i) {
        const r = e ? o.start : o.end, s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null, a = r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null;
        if (s || a) {
          let l, d;
          e && s || !e && !a ? (l = s, d = !0) : (l = a, d = !1);
          const h = t.mapper.toViewElement(l);
          if (h)
            return void function(m, f, _, E, B, T) {
              const O = `data-${T.group}-${f ? "start" : "end"}-${_ ? "before" : "after"}`, N = m.hasAttribute(O) ? m.getAttribute(O).split(",") : [];
              N.unshift(T.name), E.writer.setAttribute(O, N.join(","), m), E.mapper.bindElementToMarker(m, B.markerName);
            }(h, e, d, t, n, i);
        }
        (function(l, d, h, m, f) {
          const _ = `${f.group}-${d ? "start" : "end"}`, E = f.name ? { name: f.name } : null, B = h.writer.createUIElement(_, E);
          h.writer.insert(l, B), h.mapper.bindElementToMarker(B, m.markerName);
        })(t.mapper.toViewPosition(r), e, t, n, i);
      }
      function Uh(o) {
        return typeof o == "string" && (o = { name: o }), o.attributes ? Array.isArray(o.attributes) || (o.attributes = [o.attributes]) : o.attributes = [], o.children = !!o.children, o;
      }
      function zi(o, e) {
        return typeof o == "function" ? o : (t, n) => function(i, r, s) {
          typeof i == "string" && (i = { name: i });
          let a;
          const l = r.writer, d = Object.assign({}, i.attributes);
          if (s == "container")
            a = l.createContainerElement(i.name, d);
          else if (s == "attribute") {
            const h = { priority: i.priority || eo.DEFAULT_PRIORITY };
            a = l.createAttributeElement(i.name, d, h);
          } else
            a = l.createUIElement(i.name, d);
          if (i.styles) {
            const h = Object.keys(i.styles);
            for (const m of h)
              l.setStyle(m, i.styles[m], a);
          }
          if (i.classes) {
            const h = i.classes;
            if (typeof h == "string")
              l.addClass(h, a);
            else
              for (const m of h)
                l.addClass(m, a);
          }
          return a;
        }(o, n, e);
      }
      function qh(o) {
        return o.model.values ? (e, t, n) => {
          const i = o.view[e];
          return i ? i(e, t, n) : null;
        } : o.view;
      }
      function Wh(o) {
        return typeof o == "string" ? (e) => ({ key: o, value: e }) : typeof o == "object" ? o.value ? () => o : (e) => ({ key: o.key, value: e }) : o;
      }
      function Wa(o, e, t) {
        const n = typeof o == "function" ? o(e, t) : o;
        return n ? (n.priority || (n.priority = 10), n.id || (n.id = e.markerName), n) : null;
      }
      function Gh(o) {
        const e = /* @__PURE__ */ function(t) {
          return (n, i) => {
            if (!n.is("element", t.name))
              return !1;
            if (i.type == "attribute") {
              if (t.attributes.includes(i.attributeKey))
                return !0;
            } else if (t.children)
              return !0;
            return !1;
          };
        }(o);
        return (t, n) => {
          const i = [];
          n.reconvertedElements || (n.reconvertedElements = /* @__PURE__ */ new Set());
          for (const r of n.changes) {
            const s = r.type == "attribute" ? r.range.start.nodeAfter : r.position.parent;
            if (s && e(s, r)) {
              if (!n.reconvertedElements.has(s)) {
                n.reconvertedElements.add(s);
                const a = W._createBefore(s);
                let l = i.length;
                for (let d = i.length - 1; d >= 0; d--) {
                  const h = i[d], m = (h.type == "attribute" ? h.range.start : h.position).compareWith(a);
                  if (m == "before" || h.type == "remove" && m == "same")
                    break;
                  l = d;
                }
                i.splice(l, 0, { type: "remove", name: s.name, position: a, length: 1 }, { type: "reinsert", name: s.name, position: a, length: 1 });
              }
            } else
              i.push(r);
          }
          n.changes = i;
        };
      }
      function Kh(o) {
        return (e, t, n = {}) => {
          const i = ["insert"];
          for (const r of o.attributes)
            e.hasAttribute(r) && i.push(`attribute:${r}`);
          return !!i.every((r) => t.test(e, r)) && (n.preflight || i.forEach((r) => t.consume(e, r)), !0);
        };
      }
      function Zh(o, e, t, n) {
        for (const i of e)
          hC(o.root, i, t, n) || t.convertItem(i);
      }
      function hC(o, e, t, n) {
        const { writer: i, mapper: r } = t;
        if (!n.reconversion)
          return !1;
        const s = r.toViewElement(e);
        return !(!s || s.root == o) && !!t.canReuseView(s) && (i.move(i.createRangeOn(s), r.toViewPosition(W._createBefore(e))), !0);
      }
      function gC(o, e, { preflight: t } = {}) {
        return t ? e.test(o, "insert") : e.consume(o, "insert");
      }
      function Jh(o) {
        const { schema: e, document: t } = o.model;
        for (const n of t.getRootNames()) {
          const i = t.getRoot(n);
          if (i.isEmpty && !e.checkChild(i, "$text") && e.checkChild(i, "paragraph"))
            return o.insertElement("paragraph", i), !0;
        }
        return !1;
      }
      function Yh(o, e, t) {
        const n = t.createContext(o);
        return !!t.checkChild(n, "paragraph") && !!t.checkChild(n.push("paragraph"), e);
      }
      function Qh(o, e) {
        const t = e.createElement("paragraph");
        return e.insert(t, o), e.createPositionAt(t, 0);
      }
      var mC = Object.defineProperty, pC = Object.defineProperties, fC = Object.getOwnPropertyDescriptors, Xh = Object.getOwnPropertySymbols, bC = Object.prototype.hasOwnProperty, kC = Object.prototype.propertyIsEnumerable, eg = (o, e, t) => e in o ? mC(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class wC extends Vh {
        elementToElement(e) {
          return this.add(tg(e));
        }
        elementToAttribute(e) {
          return this.add(function(t) {
            t = In(t), ng(t);
            const n = og(t, !1), i = Ga(t.view), r = i ? `element:${i}` : "element";
            return (s) => {
              s.on(r, n, { priority: t.converterPriority || "low" });
            };
          }(e));
        }
        attributeToAttribute(e) {
          return this.add(function(t) {
            t = In(t);
            let n = null;
            (typeof t.view == "string" || t.view.key) && (n = function(r) {
              typeof r.view == "string" && (r.view = { key: r.view });
              const s = r.view.key;
              let a;
              return s == "class" || s == "style" ? a = { [s == "class" ? "classes" : "styles"]: r.view.value } : a = { attributes: { [s]: r.view.value === void 0 ? /[\s\S]*/ : r.view.value } }, r.view.name && (a.name = r.view.name), r.view = a, s;
            }(t)), ng(t, n);
            const i = og(t, !0);
            return (r) => {
              r.on("element", i, { priority: t.converterPriority || "low" });
            };
          }(e));
        }
        elementToMarker(e) {
          return this.add(function(t) {
            const n = /* @__PURE__ */ function(s) {
              return (a, l) => {
                const d = typeof s == "string" ? s : s(a, l);
                return l.writer.createElement("$marker", { "data-name": d });
              };
            }(t.model);
            return tg((i = ((s, a) => {
              for (var l in a || (a = {}))
                bC.call(a, l) && eg(s, l, a[l]);
              if (Xh)
                for (var l of Xh(a))
                  kC.call(a, l) && eg(s, l, a[l]);
              return s;
            })({}, t), r = { model: n }, pC(i, fC(r))));
            var i, r;
          }(e));
        }
        dataToMarker(e) {
          return this.add(function(t) {
            t = In(t), t.model || (t.model = (s) => s ? t.view + ":" + s : t.view);
            const n = { view: t.view, model: t.model }, i = Ka(ig(n, "start")), r = Ka(ig(n, "end"));
            return (s) => {
              s.on(`element:${t.view}-start`, i, { priority: t.converterPriority || "normal" }), s.on(`element:${t.view}-end`, r, { priority: t.converterPriority || "normal" });
              const a = ce.get("low"), l = ce.get("highest"), d = ce.get(t.converterPriority) / l;
              s.on("element", /* @__PURE__ */ function(h) {
                return (m, f, _) => {
                  const E = `data-${h.view}`;
                  function B(T, O) {
                    for (const N of O) {
                      const H = h.model(N, _), X = _.writer.createElement("$marker", { "data-name": H });
                      _.writer.insert(X, T), f.modelCursor.isEqual(T) ? f.modelCursor = f.modelCursor.getShiftedBy(1) : f.modelCursor = f.modelCursor._getTransformedByInsertion(T, 1), f.modelRange = f.modelRange._getTransformedByInsertion(T, 1)[0];
                    }
                  }
                  (_.consumable.test(f.viewItem, { attributes: E + "-end-after" }) || _.consumable.test(f.viewItem, { attributes: E + "-start-after" }) || _.consumable.test(f.viewItem, { attributes: E + "-end-before" }) || _.consumable.test(f.viewItem, { attributes: E + "-start-before" })) && (f.modelRange || Object.assign(f, _.convertChildren(f.viewItem, f.modelCursor)), _.consumable.consume(f.viewItem, { attributes: E + "-end-after" }) && B(f.modelRange.end, f.viewItem.getAttribute(E + "-end-after").split(",")), _.consumable.consume(f.viewItem, { attributes: E + "-start-after" }) && B(f.modelRange.end, f.viewItem.getAttribute(E + "-start-after").split(",")), _.consumable.consume(f.viewItem, { attributes: E + "-end-before" }) && B(f.modelRange.start, f.viewItem.getAttribute(E + "-end-before").split(",")), _.consumable.consume(f.viewItem, { attributes: E + "-start-before" }) && B(f.modelRange.start, f.viewItem.getAttribute(E + "-start-before").split(",")));
                };
              }(n), { priority: a + d });
            };
          }(e));
        }
      }
      function tg(o) {
        const e = Ka(o = In(o)), t = Ga(o.view), n = t ? `element:${t}` : "element";
        return (i) => {
          i.on(n, e, { priority: o.converterPriority || "normal" });
        };
      }
      function Ga(o) {
        return typeof o == "string" ? o : typeof o == "object" && typeof o.name == "string" ? o.name : null;
      }
      function Ka(o) {
        const e = new Fo(o.view);
        return (t, n, i) => {
          const r = e.match(n.viewItem);
          if (!r)
            return;
          const s = r.match;
          if (s.name = !0, !i.consumable.test(n.viewItem, s))
            return;
          const a = function(l, d, h) {
            return l instanceof Function ? l(d, h) : h.writer.createElement(l);
          }(o.model, n.viewItem, i);
          a && i.safeInsert(a, n.modelCursor) && (i.consumable.consume(n.viewItem, s), i.convertChildren(n.viewItem, a), i.updateConversionResult(a, n));
        };
      }
      function ng(o, e = null) {
        const t = e === null || ((r) => r.getAttribute(e)), n = typeof o.model != "object" ? o.model : o.model.key, i = typeof o.model != "object" || o.model.value === void 0 ? t : o.model.value;
        o.model = { key: n, value: i };
      }
      function og(o, e) {
        const t = new Fo(o.view);
        return (n, i, r) => {
          if (!i.modelRange && e)
            return;
          const s = t.match(i.viewItem);
          if (!s || (function(h, m) {
            const f = typeof h == "function" ? h(m) : h;
            return typeof f == "object" && !Ga(f) ? !1 : !f.classes && !f.attributes && !f.styles;
          }(o.view, i.viewItem) ? s.match.name = !0 : delete s.match.name, !r.consumable.test(i.viewItem, s.match)))
            return;
          const a = o.model.key, l = typeof o.model.value == "function" ? o.model.value(i.viewItem, r) : o.model.value;
          if (l === null)
            return;
          i.modelRange || Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor)), function(h, m, f, _) {
            let E = !1;
            for (const B of Array.from(h.getItems({ shallow: f })))
              _.schema.checkAttribute(B, m.key) && (E = !0, B.hasAttribute(m.key) || _.writer.setAttribute(m.key, m.value, B));
            return E;
          }(i.modelRange, { key: a, value: l }, e, r) && (r.consumable.test(i.viewItem, { name: !0 }) && (s.match.name = !0), r.consumable.consume(i.viewItem, s.match));
        };
      }
      function ig(o, e) {
        return { view: `${o.view}-${e}`, model: (t, n) => {
          const i = t.getAttribute("name"), r = o.model(i, n);
          return n.writer.createElement("$marker", { "data-name": r });
        } };
      }
      function vC(o) {
        o.document.registerPostFixer((e) => function(t, n) {
          const i = n.document.selection, r = n.schema, s = [];
          let a = !1;
          for (const l of i.getRanges()) {
            const d = rg(l, r);
            d && !d.isEqual(l) ? (s.push(d), a = !0) : s.push(l);
          }
          return a && t.setSelection(function(l) {
            const d = [...l], h = /* @__PURE__ */ new Set();
            let m = 1;
            for (; m < d.length; ) {
              const f = d[m], _ = d.slice(0, m);
              for (const [E, B] of _.entries())
                if (!h.has(E)) {
                  if (f.isEqual(B))
                    h.add(E);
                  else if (f.isIntersecting(B)) {
                    h.add(E), h.add(m);
                    const T = f.getJoined(B);
                    d.push(T);
                  }
                }
              m++;
            }
            return d.filter((f, _) => !h.has(_));
          }(s), { backward: i.isBackward }), !1;
        }(e, o));
      }
      function rg(o, e) {
        return o.isCollapsed ? function(t, n) {
          const i = t.start, r = n.getNearestSelectionRange(i);
          if (!r) {
            const a = i.getAncestors().reverse().find((l) => n.isObject(l));
            return a ? $._createOn(a) : null;
          }
          if (!r.isCollapsed)
            return r;
          const s = r.start;
          return i.isEqual(s) ? null : new $(s);
        }(o, e) : function(t, n) {
          const { start: i, end: r } = t, s = n.checkChild(i, "$text"), a = n.checkChild(r, "$text"), l = n.getLimitElement(i), d = n.getLimitElement(r);
          if (l === d) {
            if (s && a)
              return null;
            if (function(f, _, E) {
              const B = f.nodeAfter && !E.isLimit(f.nodeAfter) || E.checkChild(f, "$text"), T = _.nodeBefore && !E.isLimit(_.nodeBefore) || E.checkChild(_, "$text");
              return B || T;
            }(i, r, n)) {
              const f = i.nodeAfter && n.isSelectable(i.nodeAfter) ? null : n.getNearestSelectionRange(i, "forward"), _ = r.nodeBefore && n.isSelectable(r.nodeBefore) ? null : n.getNearestSelectionRange(r, "backward"), E = f ? f.start : i, B = _ ? _.end : r;
              return new $(E, B);
            }
          }
          const h = l && !l.is("rootElement"), m = d && !d.is("rootElement");
          if (h || m) {
            const f = i.nodeAfter && r.nodeBefore && i.nodeAfter.parent === r.nodeBefore.parent, _ = h && (!f || !ag(i.nodeAfter, n)), E = m && (!f || !ag(r.nodeBefore, n));
            let B = i, T = r;
            return _ && (B = W._createBefore(sg(l, n))), E && (T = W._createAfter(sg(d, n))), new $(B, T);
          }
          return null;
        }(o, e);
      }
      function sg(o, e) {
        let t = o, n = t;
        for (; e.isLimit(n) && n.parent; )
          t = n, n = n.parent;
        return t;
      }
      function ag(o, e) {
        return o && e.isSelectable(o);
      }
      class _C extends oe() {
        constructor(e, t) {
          super(), this.model = e, this.view = new YA(t), this.mapper = new Oh(), this.downcastDispatcher = new Nh({ mapper: this.mapper, schema: e.schema });
          const n = this.model.document, i = n.selection, r = this.model.markers;
          var s, a, l;
          this.listenTo(this.model, "_beforeChanges", () => {
            this.view._disableRendering(!0);
          }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
            this.view._disableRendering(!1);
          }, { priority: "lowest" }), this.listenTo(n, "change", () => {
            this.view.change((d) => {
              this.downcastDispatcher.convertChanges(n.differ, r, d), this.downcastDispatcher.convertSelection(i, r, d);
            });
          }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", /* @__PURE__ */ function(d, h) {
            return (m, f) => {
              const _ = f.newSelection, E = [];
              for (const T of _.getRanges())
                E.push(h.toModelRange(T));
              const B = d.createSelection(E, { backward: _.isBackward });
              B.isEqual(d.document.selection) || d.change((T) => {
                T.setSelection(B);
              });
            };
          }(this.model, this.mapper)), this.listenTo(this.view.document, "beforeinput", (s = this.mapper, a = this.model.schema, l = this.view, (d, h) => {
            if (!l.document.isComposing || b.isAndroid)
              for (let m = 0; m < h.targetRanges.length; m++) {
                const f = h.targetRanges[m], _ = s.toModelRange(f), E = rg(_, a);
                E && !E.isEqual(_) && (h.targetRanges[m] = s.toViewRange(E));
              }
          }), { priority: "high" }), this.downcastDispatcher.on("insert:$text", (d, h, m) => {
            if (!m.consumable.consume(h.item, d.name))
              return;
            const f = m.writer, _ = m.mapper.toViewPosition(h.range.start), E = f.createText(h.item.data);
            f.insert(_, E);
          }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (d, h, m) => {
            m.convertAttributes(h.item), h.reconversion || !h.item.is("element") || h.item.isEmpty || m.convertChildren(h.item);
          }, { priority: "lowest" }), this.downcastDispatcher.on("remove", (d, h, m) => {
            const f = m.mapper.toViewPosition(h.position), _ = h.position.getShiftedBy(h.length), E = m.mapper.toViewPosition(_, { isPhantom: !0 }), B = m.writer.createRange(f, E), T = m.writer.remove(B.getTrimmed());
            for (const O of m.writer.createRangeIn(T).getItems())
              m.mapper.unbindViewElement(O, { defer: !0 });
          }, { priority: "low" }), this.downcastDispatcher.on("selection", (d, h, m) => {
            const f = m.writer, _ = f.document.selection;
            for (const E of _.getRanges())
              E.isCollapsed && E.end.parent.isAttached() && m.writer.mergeAttributes(E.start);
            f.setSelection(null);
          }, { priority: "high" }), this.downcastDispatcher.on("selection", (d, h, m) => {
            const f = h.selection;
            if (f.isCollapsed || !m.consumable.consume(f, "selection"))
              return;
            const _ = [];
            for (const E of f.getRanges())
              _.push(m.mapper.toViewRange(E));
            m.writer.setSelection(_, { backward: f.isBackward });
          }, { priority: "low" }), this.downcastDispatcher.on("selection", (d, h, m) => {
            const f = h.selection;
            if (!f.isCollapsed || !m.consumable.consume(f, "selection"))
              return;
            const _ = m.writer, E = f.getFirstPosition(), B = m.mapper.toViewPosition(E), T = _.breakAttributes(B);
            _.setSelection(T);
          }, { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((d) => {
            if (d.rootName == "$graveyard")
              return null;
            const h = new Xu(this.view.document, d.name);
            return h.rootName = d.rootName, this.mapper.bindElements(d, h), h;
          });
        }
        destroy() {
          this.view.destroy(), this.stopListening();
        }
        reconvertMarker(e) {
          const t = typeof e == "string" ? e : e.name, n = this.model.markers.get(t);
          if (!n)
            throw new I("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: t });
          this.model.change(() => {
            this.model.markers._refresh(n);
          });
        }
        reconvertItem(e) {
          this.model.change(() => {
            this.model.document.differ._refreshItem(e);
          });
        }
      }
      class Mi {
        constructor() {
          this._consumables = /* @__PURE__ */ new Map();
        }
        add(e, t) {
          let n;
          e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : (this._consumables.has(e) ? n = this._consumables.get(e) : (n = new AC(e), this._consumables.set(e, n)), n.add(t));
        }
        test(e, t) {
          const n = this._consumables.get(e);
          return n === void 0 ? null : e.is("$text") || e.is("documentFragment") ? n : n.test(t);
        }
        consume(e, t) {
          return !!this.test(e, t) && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !1) : this._consumables.get(e).consume(t), !0);
        }
        revert(e, t) {
          const n = this._consumables.get(e);
          n !== void 0 && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : n.revert(t));
        }
        static consumablesFromElement(e) {
          const t = { element: e, name: !0, attributes: [], classes: [], styles: [] }, n = e.getAttributeKeys();
          for (const s of n)
            s != "style" && s != "class" && t.attributes.push(s);
          const i = e.getClassNames();
          for (const s of i)
            t.classes.push(s);
          const r = e.getStyleNames();
          for (const s of r)
            t.styles.push(s);
          return t;
        }
        static createFrom(e, t) {
          if (t || (t = new Mi()), e.is("$text"))
            return t.add(e), t;
          e.is("element") && t.add(e, Mi.consumablesFromElement(e)), e.is("documentFragment") && t.add(e);
          for (const n of e.getChildren())
            t = Mi.createFrom(n, t);
          return t;
        }
      }
      const qr = ["attributes", "classes", "styles"];
      class AC {
        constructor(e) {
          this.element = e, this._canConsumeName = null, this._consumables = { attributes: /* @__PURE__ */ new Map(), styles: /* @__PURE__ */ new Map(), classes: /* @__PURE__ */ new Map() };
        }
        add(e) {
          e.name && (this._canConsumeName = !0);
          for (const t of qr)
            t in e && this._add(t, e[t]);
        }
        test(e) {
          if (e.name && !this._canConsumeName)
            return this._canConsumeName;
          for (const t of qr)
            if (t in e) {
              const n = this._test(t, e[t]);
              if (n !== !0)
                return n;
            }
          return !0;
        }
        consume(e) {
          e.name && (this._canConsumeName = !1);
          for (const t of qr)
            t in e && this._consume(t, e[t]);
        }
        revert(e) {
          e.name && (this._canConsumeName = !0);
          for (const t of qr)
            t in e && this._revert(t, e[t]);
        }
        _add(e, t) {
          const n = _t(t) ? t : [t], i = this._consumables[e];
          for (const r of n) {
            if (e === "attributes" && (r === "class" || r === "style"))
              throw new I("viewconsumable-invalid-attribute", this);
            if (i.set(r, !0), e === "styles")
              for (const s of this.element.document.stylesProcessor.getRelatedStyles(r))
                i.set(s, !0);
          }
        }
        _test(e, t) {
          const n = _t(t) ? t : [t], i = this._consumables[e];
          for (const r of n)
            if (e !== "attributes" || r !== "class" && r !== "style") {
              const s = i.get(r);
              if (s === void 0)
                return null;
              if (!s)
                return !1;
            } else {
              const s = r == "class" ? "classes" : "styles", a = this._test(s, [...this._consumables[s].keys()]);
              if (a !== !0)
                return a;
            }
          return !0;
        }
        _consume(e, t) {
          const n = _t(t) ? t : [t], i = this._consumables[e];
          for (const r of n)
            if (e !== "attributes" || r !== "class" && r !== "style") {
              if (i.set(r, !1), e == "styles")
                for (const s of this.element.document.stylesProcessor.getRelatedStyles(r))
                  i.set(s, !1);
            } else {
              const s = r == "class" ? "classes" : "styles";
              this._consume(s, [...this._consumables[s].keys()]);
            }
        }
        _revert(e, t) {
          const n = _t(t) ? t : [t], i = this._consumables[e];
          for (const r of n)
            if (e !== "attributes" || r !== "class" && r !== "style")
              i.get(r) === !1 && i.set(r, !0);
            else {
              const s = r == "class" ? "classes" : "styles";
              this._revert(s, [...this._consumables[s].keys()]);
            }
        }
      }
      class CC extends oe() {
        constructor() {
          super(), this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (e, t) => {
            t[0] = new io(t[0]);
          }, { priority: "highest" }), this.on("checkChild", (e, t) => {
            t[0] = new io(t[0]), t[1] = this.getDefinition(t[1]);
          }, { priority: "highest" });
        }
        register(e, t) {
          if (this._sourceDefinitions[e])
            throw new I("schema-cannot-register-item-twice", this, { itemName: e });
          this._sourceDefinitions[e] = [Object.assign({}, t)], this._clearCache();
        }
        extend(e, t) {
          if (!this._sourceDefinitions[e])
            throw new I("schema-cannot-extend-missing-item", this, { itemName: e });
          this._sourceDefinitions[e].push(Object.assign({}, t)), this._clearCache();
        }
        getDefinitions() {
          return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
        }
        getDefinition(e) {
          let t;
          return t = typeof e == "string" ? e : "is" in e && (e.is("$text") || e.is("$textProxy")) ? "$text" : e.name, this.getDefinitions()[t];
        }
        isRegistered(e) {
          return !!this.getDefinition(e);
        }
        isBlock(e) {
          const t = this.getDefinition(e);
          return !(!t || !t.isBlock);
        }
        isLimit(e) {
          const t = this.getDefinition(e);
          return !!t && !(!t.isLimit && !t.isObject);
        }
        isObject(e) {
          const t = this.getDefinition(e);
          return !!t && !!(t.isObject || t.isLimit && t.isSelectable && t.isContent);
        }
        isInline(e) {
          const t = this.getDefinition(e);
          return !(!t || !t.isInline);
        }
        isSelectable(e) {
          const t = this.getDefinition(e);
          return !!t && !(!t.isSelectable && !t.isObject);
        }
        isContent(e) {
          const t = this.getDefinition(e);
          return !!t && !(!t.isContent && !t.isObject);
        }
        checkChild(e, t) {
          return !!t && this._checkContextMatch(t, e);
        }
        checkAttribute(e, t) {
          const n = this.getDefinition(e.last);
          return !!n && n.allowAttributes.includes(t);
        }
        checkMerge(e, t) {
          if (e instanceof W) {
            const n = e.nodeBefore, i = e.nodeAfter;
            if (!(n instanceof $e))
              throw new I("schema-check-merge-no-element-before", this);
            if (!(i instanceof $e))
              throw new I("schema-check-merge-no-element-after", this);
            return this.checkMerge(n, i);
          }
          for (const n of t.getChildren())
            if (!this.checkChild(e, n))
              return !1;
          return !0;
        }
        addChildCheck(e) {
          this.on("checkChild", (t, [n, i]) => {
            if (!i)
              return;
            const r = e(n, i);
            typeof r == "boolean" && (t.stop(), t.return = r);
          }, { priority: "high" });
        }
        addAttributeCheck(e) {
          this.on("checkAttribute", (t, [n, i]) => {
            const r = e(n, i);
            typeof r == "boolean" && (t.stop(), t.return = r);
          }, { priority: "high" });
        }
        setAttributeProperties(e, t) {
          this._attributeProperties[e] = Object.assign(this.getAttributeProperties(e), t);
        }
        getAttributeProperties(e) {
          return this._attributeProperties[e] || {};
        }
        getLimitElement(e) {
          let t;
          for (e instanceof W ? t = e.parent : t = (e instanceof $ ? [e] : Array.from(e.getRanges())).reduce((n, i) => {
            const r = i.getCommonAncestor();
            return n ? n.getCommonAncestor(r, { includeSelf: !0 }) : r;
          }, null); !this.isLimit(t) && t.parent; )
            t = t.parent;
          return t;
        }
        checkAttributeInSelection(e, t) {
          if (e.isCollapsed) {
            const n = [...e.getFirstPosition().getAncestors(), new Fe("", e.getAttributes())];
            return this.checkAttribute(n, t);
          }
          {
            const n = e.getRanges();
            for (const i of n)
              for (const r of i)
                if (this.checkAttribute(r.item, t))
                  return !0;
          }
          return !1;
        }
        *getValidRanges(e, t) {
          e = function* (n) {
            for (const i of n)
              yield* i.getMinimalFlatRanges();
          }(e);
          for (const n of e)
            yield* this._getValidRangesForRange(n, t);
        }
        getNearestSelectionRange(e, t = "both") {
          if (this.checkChild(e, "$text"))
            return new $(e);
          let n, i;
          const r = e.getAncestors().reverse().find((s) => this.isLimit(s)) || e.root;
          t != "both" && t != "backward" || (n = new rn({ boundaries: $._createIn(r), startPosition: e, direction: "backward" })), t != "both" && t != "forward" || (i = new rn({ boundaries: $._createIn(r), startPosition: e }));
          for (const s of function* (a, l) {
            let d = !1;
            for (; !d; ) {
              if (d = !0, a) {
                const h = a.next();
                h.done || (d = !1, yield { walker: a, value: h.value });
              }
              if (l) {
                const h = l.next();
                h.done || (d = !1, yield { walker: l, value: h.value });
              }
            }
          }(n, i)) {
            const a = s.walker == n ? "elementEnd" : "elementStart", l = s.value;
            if (l.type == a && this.isObject(l.item))
              return $._createOn(l.item);
            if (this.checkChild(l.nextPosition, "$text"))
              return new $(l.nextPosition);
          }
          return null;
        }
        findAllowedParent(e, t) {
          let n = e.parent;
          for (; n; ) {
            if (this.checkChild(n, t))
              return n;
            if (this.isLimit(n))
              return null;
            n = n.parent;
          }
          return null;
        }
        setAllowedAttributes(e, t, n) {
          const i = n.model;
          for (const [r, s] of Object.entries(t))
            i.schema.checkAttribute(e, r) && n.setAttribute(r, s, e);
        }
        removeDisallowedAttributes(e, t) {
          for (const n of e)
            if (n.is("$text"))
              lg(this, n, t);
            else {
              const i = $._createIn(n).getPositions();
              for (const r of i)
                lg(this, r.nodeBefore || r.parent, t);
            }
        }
        getAttributesWithProperty(e, t, n) {
          const i = {};
          for (const [r, s] of e.getAttributes()) {
            const a = this.getAttributeProperties(r);
            a[t] !== void 0 && (n !== void 0 && n !== a[t] || (i[r] = s));
          }
          return i;
        }
        createContext(e) {
          return new io(e);
        }
        _clearCache() {
          this._compiledDefinitions = null;
        }
        _compile() {
          const e = {}, t = this._sourceDefinitions, n = Object.keys(t);
          for (const i of n)
            e[i] = yC(t[i], i);
          for (const i of n)
            EC(e, i);
          for (const i of n)
            xC(e, i);
          for (const i of n)
            SC(e, i);
          for (const i of n)
            DC(e, i), BC(e, i);
          for (const i of n)
            TC(e, i), PC(e, i), IC(e, i);
          this._compiledDefinitions = e;
        }
        _checkContextMatch(e, t, n = t.length - 1) {
          const i = t.getItem(n);
          if (e.allowIn.includes(i.name)) {
            if (n == 0)
              return !0;
            {
              const r = this.getDefinition(i);
              return this._checkContextMatch(r, t, n - 1);
            }
          }
          return !1;
        }
        *_getValidRangesForRange(e, t) {
          let n = e.start, i = e.start;
          for (const r of e.getItems({ shallow: !0 }))
            r.is("element") && (yield* this._getValidRangesForRange($._createIn(r), t)), this.checkAttribute(r, t) || (n.isEqual(i) || (yield new $(n, i)), n = W._createAfter(r)), i = W._createAfter(r);
          n.isEqual(i) || (yield new $(n, i));
        }
      }
      class io {
        constructor(e) {
          if (e instanceof io)
            return e;
          let t;
          t = typeof e == "string" ? [e] : Array.isArray(e) ? e : e.getAncestors({ includeSelf: !0 }), this._items = t.map(RC);
        }
        get length() {
          return this._items.length;
        }
        get last() {
          return this._items[this._items.length - 1];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
        push(e) {
          const t = new io([e]);
          return t._items = [...this._items, ...t._items], t;
        }
        getItem(e) {
          return this._items[e];
        }
        *getNames() {
          yield* this._items.map((e) => e.name);
        }
        endsWith(e) {
          return Array.from(this.getNames()).join(" ").endsWith(e);
        }
        startsWith(e) {
          return Array.from(this.getNames()).join(" ").startsWith(e);
        }
      }
      function yC(o, e) {
        const t = { name: e, allowIn: [], allowContentOf: [], allowWhere: [], allowAttributes: [], allowAttributesOf: [], allowChildren: [], inheritTypesFrom: [] };
        return function(n, i) {
          for (const r of n) {
            const s = Object.keys(r).filter((a) => a.startsWith("is"));
            for (const a of s)
              i[a] = !!r[a];
          }
        }(o, t), ro(o, t, "allowIn"), ro(o, t, "allowContentOf"), ro(o, t, "allowWhere"), ro(o, t, "allowAttributes"), ro(o, t, "allowAttributesOf"), ro(o, t, "allowChildren"), ro(o, t, "inheritTypesFrom"), function(n, i) {
          for (const r of n) {
            const s = r.inheritAllFrom;
            s && (i.allowContentOf.push(s), i.allowWhere.push(s), i.allowAttributesOf.push(s), i.inheritTypesFrom.push(s));
          }
        }(o, t), t;
      }
      function EC(o, e) {
        const t = o[e];
        for (const n of t.allowChildren) {
          const i = o[n];
          i && i.allowIn.push(e);
        }
        t.allowChildren.length = 0;
      }
      function xC(o, e) {
        for (const t of o[e].allowContentOf)
          o[t] && OC(o, t).forEach((n) => {
            n.allowIn.push(e);
          });
        delete o[e].allowContentOf;
      }
      function SC(o, e) {
        for (const t of o[e].allowWhere) {
          const n = o[t];
          if (n) {
            const i = n.allowIn;
            o[e].allowIn.push(...i);
          }
        }
        delete o[e].allowWhere;
      }
      function DC(o, e) {
        for (const t of o[e].allowAttributesOf) {
          const n = o[t];
          if (n) {
            const i = n.allowAttributes;
            o[e].allowAttributes.push(...i);
          }
        }
        delete o[e].allowAttributesOf;
      }
      function BC(o, e) {
        const t = o[e];
        for (const n of t.inheritTypesFrom) {
          const i = o[n];
          if (i) {
            const r = Object.keys(i).filter((s) => s.startsWith("is"));
            for (const s of r)
              s in t || (t[s] = i[s]);
          }
        }
        delete t.inheritTypesFrom;
      }
      function TC(o, e) {
        const t = o[e], n = t.allowIn.filter((i) => o[i]);
        t.allowIn = Array.from(new Set(n));
      }
      function PC(o, e) {
        const t = o[e];
        for (const n of t.allowIn)
          o[n].allowChildren.push(e);
      }
      function IC(o, e) {
        const t = o[e];
        t.allowAttributes = Array.from(new Set(t.allowAttributes));
      }
      function ro(o, e, t) {
        for (const n of o) {
          const i = n[t];
          typeof i == "string" ? e[t].push(i) : Array.isArray(i) && e[t].push(...i);
        }
      }
      function OC(o, e) {
        const t = o[e];
        return (n = o, Object.keys(n).map((i) => n[i])).filter((i) => i.allowIn.includes(t.name));
        var n;
      }
      function RC(o) {
        return typeof o == "string" || o.is("documentFragment") ? { name: typeof o == "string" ? o : "$documentFragment", *getAttributeKeys() {
        }, getAttribute() {
        } } : { name: o.is("element") ? o.name : "$text", *getAttributeKeys() {
          yield* o.getAttributeKeys();
        }, getAttribute: (e) => o.getAttribute(e) };
      }
      function lg(o, e, t) {
        for (const n of e.getAttributeKeys())
          o.checkAttribute(e, n) || t.removeAttribute(n, e);
      }
      var zC = Object.defineProperty, MC = Object.defineProperties, NC = Object.getOwnPropertyDescriptors, cg = Object.getOwnPropertySymbols, FC = Object.prototype.hasOwnProperty, $C = Object.prototype.propertyIsEnumerable, dg = (o, e, t) => e in o ? zC(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class LC extends De() {
        constructor(e) {
          var t;
          super(), this._splitParts = /* @__PURE__ */ new Map(), this._cursorParents = /* @__PURE__ */ new Map(), this._modelCursor = null, this._emptyElementsToKeep = /* @__PURE__ */ new Set(), this.conversionApi = (t = ((n, i) => {
            for (var r in i || (i = {}))
              FC.call(i, r) && dg(n, r, i[r]);
            if (cg)
              for (var r of cg(i))
                $C.call(i, r) && dg(n, r, i[r]);
            return n;
          })({}, e), MC(t, NC({ consumable: null, writer: null, store: null, convertItem: (n, i) => this._convertItem(n, i), convertChildren: (n, i) => this._convertChildren(n, i), safeInsert: (n, i) => this._safeInsert(n, i), updateConversionResult: (n, i) => this._updateConversionResult(n, i), splitToAllowedParent: (n, i) => this._splitToAllowedParent(n, i), getSplitParts: (n) => this._getSplitParts(n), keepEmptyElement: (n) => this._keepEmptyElement(n) })));
        }
        convert(e, t, n = ["$root"]) {
          this.fire("viewCleanup", e), this._modelCursor = function(s, a) {
            let l;
            for (const d of new io(s)) {
              const h = {};
              for (const f of d.getAttributeKeys())
                h[f] = d.getAttribute(f);
              const m = a.createElement(d.name, h);
              l && a.insert(m, l), l = W._createAt(m, 0);
            }
            return l;
          }(n, t), this.conversionApi.writer = t, this.conversionApi.consumable = Mi.createFrom(e), this.conversionApi.store = {};
          const { modelRange: i } = this._convertItem(e, this._modelCursor), r = t.createDocumentFragment();
          if (i) {
            this._removeEmptyElements();
            for (const s of Array.from(this._modelCursor.parent.getChildren()))
              t.append(s, r);
            r.markers = function(s, a) {
              const l = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Map(), h = $._createIn(s).getItems();
              for (const m of h)
                m.is("element", "$marker") && l.add(m);
              for (const m of l) {
                const f = m.getAttribute("data-name"), _ = a.createPositionBefore(m);
                d.has(f) ? d.get(f).end = _.clone() : d.set(f, new $(_.clone())), a.remove(m);
              }
              return d;
            }(r, t);
          }
          return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, r;
        }
        _convertItem(e, t) {
          const n = { viewItem: e, modelCursor: t, modelRange: null };
          if (e.is("element") ? this.fire(`element:${e.name}`, n, this.conversionApi) : e.is("$text") ? this.fire("text", n, this.conversionApi) : this.fire("documentFragment", n, this.conversionApi), n.modelRange && !(n.modelRange instanceof $))
            throw new I("view-conversion-dispatcher-incorrect-result", this);
          return { modelRange: n.modelRange, modelCursor: n.modelCursor };
        }
        _convertChildren(e, t) {
          let n = t.is("position") ? t : W._createAt(t, 0);
          const i = new $(n);
          for (const r of Array.from(e.getChildren())) {
            const s = this._convertItem(r, n);
            s.modelRange instanceof $ && (i.end = s.modelRange.end, n = s.modelCursor);
          }
          return { modelRange: i, modelCursor: n };
        }
        _safeInsert(e, t) {
          const n = this._splitToAllowedParent(e, t);
          return !!n && (this.conversionApi.writer.insert(e, n.position), !0);
        }
        _updateConversionResult(e, t) {
          const n = this._getSplitParts(e), i = this.conversionApi.writer;
          t.modelRange || (t.modelRange = i.createRange(i.createPositionBefore(e), i.createPositionAfter(n[n.length - 1])));
          const r = this._cursorParents.get(e);
          t.modelCursor = r ? i.createPositionAt(r, 0) : t.modelRange.end;
        }
        _splitToAllowedParent(e, t) {
          const { schema: n, writer: i } = this.conversionApi;
          let r = n.findAllowedParent(t, e);
          if (r) {
            if (r === t.parent)
              return { position: t };
            this._modelCursor.parent.getAncestors().includes(r) && (r = null);
          }
          if (!r)
            return Yh(t, e, n) ? { position: Qh(t, i) } : null;
          const s = this.conversionApi.writer.split(t, r), a = [];
          for (const d of s.range.getWalker())
            if (d.type == "elementEnd")
              a.push(d.item);
            else {
              const h = a.pop(), m = d.item;
              this._registerSplitPair(h, m);
            }
          const l = s.range.end.parent;
          return this._cursorParents.set(e, l), { position: s.position, cursorParent: l };
        }
        _registerSplitPair(e, t) {
          this._splitParts.has(e) || this._splitParts.set(e, [e]);
          const n = this._splitParts.get(e);
          this._splitParts.set(t, n), n.push(t);
        }
        _getSplitParts(e) {
          let t;
          return t = this._splitParts.has(e) ? this._splitParts.get(e) : [e], t;
        }
        _keepEmptyElement(e) {
          this._emptyElementsToKeep.add(e);
        }
        _removeEmptyElements() {
          let e = !1;
          for (const t of this._splitParts.keys())
            t.isEmpty && !this._emptyElementsToKeep.has(t) && (this.conversionApi.writer.remove(t), this._splitParts.delete(t), e = !0);
          e && this._removeEmptyElements();
        }
      }
      class VC {
        getHtml(e) {
          const t = document.implementation.createHTMLDocument("").createElement("div");
          return t.appendChild(e), t.innerHTML;
        }
      }
      class jC {
        constructor(e) {
          this.skipComments = !0, this.domParser = new DOMParser(), this.domConverter = new ph(e, { renderingMode: "data" }), this.htmlWriter = new VC();
        }
        toData(e) {
          const t = this.domConverter.viewToDom(e);
          return this.htmlWriter.getHtml(t);
        }
        toView(e) {
          const t = this._toDom(e);
          return this.domConverter.domToView(t, { skipComments: this.skipComments });
        }
        registerRawContentMatcher(e) {
          this.domConverter.registerRawContentMatcher(e);
        }
        useFillerType(e) {
          this.domConverter.blockFillerMode = e == "marked" ? "markedNbsp" : "nbsp";
        }
        _toDom(e) {
          e.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (e = `<body>${e}</body>`);
          const t = this.domParser.parseFromString(e, "text/html"), n = t.createDocumentFragment(), i = t.body.childNodes;
          for (; i.length > 0; )
            n.appendChild(i[0]);
          return n;
        }
      }
      class HC extends De() {
        constructor(e, t) {
          super(), this.model = e, this.mapper = new Oh(), this.downcastDispatcher = new Nh({ mapper: this.mapper, schema: e.schema }), this.downcastDispatcher.on("insert:$text", (n, i, r) => {
            if (!r.consumable.consume(i.item, n.name))
              return;
            const s = r.writer, a = r.mapper.toViewPosition(i.range.start), l = s.createText(i.item.data);
            s.insert(a, l);
          }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (n, i, r) => {
            r.convertAttributes(i.item), i.reconversion || !i.item.is("element") || i.item.isEmpty || r.convertChildren(i.item);
          }, { priority: "lowest" }), this.upcastDispatcher = new LC({ schema: e.schema }), this.viewDocument = new th(t), this.stylesProcessor = t, this.htmlProcessor = new jC(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new nh(this.viewDocument), this.upcastDispatcher.on("text", (n, i, { schema: r, consumable: s, writer: a }) => {
            let l = i.modelCursor;
            if (!s.test(i.viewItem))
              return;
            if (!r.checkChild(l, "$text")) {
              if (!Yh(l, "$text", r) || i.viewItem.data.trim().length == 0)
                return;
              const h = l.nodeBefore;
              l = Qh(l, a), h && h.is("element", "$marker") && (a.move(a.createRangeOn(h), l), l = a.createPositionAfter(h));
            }
            s.consume(i.viewItem);
            const d = a.createText(i.viewItem.data);
            a.insert(d, l), i.modelRange = a.createRange(l, l.getShiftedBy(d.offsetSize)), i.modelCursor = i.modelRange.end;
          }, { priority: "lowest" }), this.upcastDispatcher.on("element", (n, i, r) => {
            if (!i.modelRange && r.consumable.consume(i.viewItem, { name: !0 })) {
              const { modelRange: s, modelCursor: a } = r.convertChildren(i.viewItem, i.modelCursor);
              i.modelRange = s, i.modelCursor = a;
            }
          }, { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", (n, i, r) => {
            if (!i.modelRange && r.consumable.consume(i.viewItem, { name: !0 })) {
              const { modelRange: s, modelCursor: a } = r.convertChildren(i.viewItem, i.modelCursor);
              i.modelRange = s, i.modelCursor = a;
            }
          }, { priority: "lowest" }), oe().prototype.decorate.call(this, "init"), oe().prototype.decorate.call(this, "set"), oe().prototype.decorate.call(this, "get"), oe().prototype.decorate.call(this, "toView"), oe().prototype.decorate.call(this, "toModel"), this.on("init", () => {
            this.fire("ready");
          }, { priority: "lowest" }), this.on("ready", () => {
            this.model.enqueueChange({ isUndoable: !1 }, Jh);
          }, { priority: "lowest" });
        }
        get(e = {}) {
          const { rootName: t = "main", trim: n = "empty" } = e;
          if (!this._checkIfRootsExists([t]))
            throw new I("datacontroller-get-non-existent-root", this);
          const i = this.model.document.getRoot(t);
          return i.isAttached() || ne("datacontroller-get-detached-root", this), n !== "empty" || this.model.hasContent(i, { ignoreWhitespaces: !0 }) ? this.stringify(i, e) : "";
        }
        stringify(e, t = {}) {
          const n = this.toView(e, t);
          return this.processor.toData(n);
        }
        toView(e, t = {}) {
          const n = this.viewDocument, i = this._viewWriter;
          this.mapper.clearBindings();
          const r = $._createIn(e), s = new to(n);
          this.mapper.bindElements(e, s);
          const a = e.is("documentFragment") ? e.markers : function(l) {
            const d = [], h = l.root.document;
            if (!h)
              return /* @__PURE__ */ new Map();
            const m = $._createIn(l);
            for (const f of h.model.markers) {
              const _ = f.getRange(), E = _.isCollapsed, B = _.start.isEqual(m.start) || _.end.isEqual(m.end);
              if (E && B)
                d.push([f.name, _]);
              else {
                const T = m.getIntersection(_);
                T && d.push([f.name, T]);
              }
            }
            return d.sort(([f, _], [E, B]) => {
              if (_.end.compareWith(B.start) !== "after")
                return 1;
              if (_.start.compareWith(B.end) !== "before")
                return -1;
              switch (_.start.compareWith(B.start)) {
                case "before":
                  return 1;
                case "after":
                  return -1;
                default:
                  switch (_.end.compareWith(B.end)) {
                    case "before":
                      return 1;
                    case "after":
                      return -1;
                    default:
                      return E.localeCompare(f);
                  }
              }
            }), new Map(d);
          }(e);
          return this.downcastDispatcher.convert(r, a, i, t), s;
        }
        init(e) {
          if (this.model.document.version)
            throw new I("datacontroller-init-document-not-empty", this);
          let t = {};
          if (typeof e == "string" ? t.main = e : t = e, !this._checkIfRootsExists(Object.keys(t)))
            throw new I("datacontroller-init-non-existent-root", this);
          return this.model.enqueueChange({ isUndoable: !1 }, (n) => {
            for (const i of Object.keys(t)) {
              const r = this.model.document.getRoot(i);
              n.insert(this.parse(t[i], r), r, 0);
            }
          }), Promise.resolve();
        }
        set(e, t = {}) {
          let n = {};
          if (typeof e == "string" ? n.main = e : n = e, !this._checkIfRootsExists(Object.keys(n)))
            throw new I("datacontroller-set-non-existent-root", this);
          this.model.enqueueChange(t.batchType || {}, (i) => {
            i.setSelection(null), i.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
            for (const r of Object.keys(n)) {
              const s = this.model.document.getRoot(r);
              i.remove(i.createRangeIn(s)), i.insert(this.parse(n[r], s), s, 0);
            }
          });
        }
        parse(e, t = "$root") {
          const n = this.processor.toView(e);
          return this.toModel(n, t);
        }
        toModel(e, t = "$root") {
          return this.model.change((n) => this.upcastDispatcher.convert(e, n, t));
        }
        addStyleProcessorRules(e) {
          e(this.stylesProcessor);
        }
        registerRawContentMatcher(e) {
          this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(e), this.htmlProcessor.registerRawContentMatcher(e);
        }
        destroy() {
          this.stopListening();
        }
        _checkIfRootsExists(e) {
          for (const t of e)
            if (!this.model.document.getRoot(t))
              return !1;
          return !0;
        }
      }
      class UC {
        constructor(e, t) {
          this._helpers = /* @__PURE__ */ new Map(), this._downcast = Xe(e), this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: !0 }), this._upcast = Xe(t), this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: !1 });
        }
        addAlias(e, t) {
          const n = this._downcast.includes(t);
          if (!this._upcast.includes(t) && !n)
            throw new I("conversion-add-alias-dispatcher-not-registered", this);
          this._createConversionHelpers({ name: e, dispatchers: [t], isDowncast: n });
        }
        for(e) {
          if (!this._helpers.has(e))
            throw new I("conversion-for-unknown-group", this);
          return this._helpers.get(e);
        }
        elementToElement(e) {
          this.for("downcast").elementToElement(e);
          for (const { model: t, view: n } of Za(e))
            this.for("upcast").elementToElement({ model: t, view: n, converterPriority: e.converterPriority });
        }
        attributeToElement(e) {
          this.for("downcast").attributeToElement(e);
          for (const { model: t, view: n } of Za(e))
            this.for("upcast").elementToAttribute({ view: n, model: t, converterPriority: e.converterPriority });
        }
        attributeToAttribute(e) {
          this.for("downcast").attributeToAttribute(e);
          for (const { model: t, view: n } of Za(e))
            this.for("upcast").attributeToAttribute({ view: n, model: t });
        }
        _createConversionHelpers({ name: e, dispatchers: t, isDowncast: n }) {
          if (this._helpers.has(e))
            throw new I("conversion-group-exists", this);
          const i = n ? new uC(t) : new wC(t);
          this._helpers.set(e, i);
        }
      }
      function* Za(o) {
        if (o.model.values)
          for (const e of o.model.values) {
            const t = { key: o.model.key, value: e }, n = o.view[e], i = o.upcastAlso ? o.upcastAlso[e] : void 0;
            yield* ug(t, n, i);
          }
        else
          yield* ug(o.model, o.view, o.upcastAlso);
      }
      function* ug(o, e, t) {
        if (yield { model: o, view: e }, t)
          for (const n of Xe(t))
            yield { model: o, view: n };
      }
      class Mt {
        constructor(e) {
          this.baseVersion = e, this.isDocumentOperation = this.baseVersion !== null, this.batch = null;
        }
        _validate() {
        }
        toJSON() {
          const e = Object.assign({}, this);
          return e.__className = this.constructor.className, delete e.batch, delete e.isDocumentOperation, e;
        }
        static get className() {
          return "Operation";
        }
        static fromJSON(e, t) {
          return new this(e.baseVersion);
        }
      }
      function Ja(o, e) {
        const t = gg(e), n = t.reduce((s, a) => s + a.offsetSize, 0), i = o.parent;
        $i(o);
        const r = o.index;
        return i._insertChild(r, t), Fi(i, r + t.length), Fi(i, r), new $(o, o.getShiftedBy(n));
      }
      function hg(o) {
        if (!o.isFlat)
          throw new I("operation-utils-remove-range-not-flat", this);
        const e = o.start.parent;
        $i(o.start), $i(o.end);
        const t = e._removeChildren(o.start.index, o.end.index - o.start.index);
        return Fi(e, o.start.index), t;
      }
      function Ni(o, e) {
        if (!o.isFlat)
          throw new I("operation-utils-move-range-not-flat", this);
        const t = hg(o);
        return Ja(e = e._getTransformedByDeletion(o.start, o.end.offset - o.start.offset), t);
      }
      function gg(o) {
        const e = [];
        (function t(n) {
          if (typeof n == "string")
            e.push(new Fe(n));
          else if (n instanceof Kt)
            e.push(new Fe(n.data, n.getAttributes()));
          else if (n instanceof no)
            e.push(n);
          else if (It(n))
            for (const i of n)
              t(i);
        })(o);
        for (let t = 1; t < e.length; t++) {
          const n = e[t], i = e[t - 1];
          n instanceof Fe && i instanceof Fe && mg(n, i) && (e.splice(t - 1, 2, new Fe(i.data + n.data, i.getAttributes())), t--);
        }
        return e;
      }
      function Fi(o, e) {
        const t = o.getChild(e - 1), n = o.getChild(e);
        if (t && n && t.is("$text") && n.is("$text") && mg(t, n)) {
          const i = new Fe(t.data + n.data, t.getAttributes());
          o._removeChildren(e - 1, 2), o._insertChild(e - 1, i);
        }
      }
      function $i(o) {
        const e = o.textNode, t = o.parent;
        if (e) {
          const n = o.offset - e.startOffset, i = e.index;
          t._removeChildren(i, 1);
          const r = new Fe(e.data.substr(0, n), e.getAttributes()), s = new Fe(e.data.substr(n), e.getAttributes());
          t._insertChild(i, [r, s]);
        }
      }
      function mg(o, e) {
        const t = o.getAttributes(), n = e.getAttributes();
        for (const i of t) {
          if (i[1] !== e.getAttribute(i[0]))
            return !1;
          n.next();
        }
        return n.next().done;
      }
      class Be extends Mt {
        constructor(e, t, n, i) {
          super(i), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNone";
        }
        get type() {
          return this.targetPosition.root.rootName == "$graveyard" ? "remove" : this.sourcePosition.root.rootName == "$graveyard" ? "reinsert" : "move";
        }
        get affectedSelectable() {
          return [$._createFromPositionAndShift(this.sourcePosition, this.howMany), $._createFromPositionAndShift(this.targetPosition, 0)];
        }
        clone() {
          return new Be(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
        }
        getReversed() {
          const e = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
          return new Be(this.getMovedRangeStart(), this.howMany, e, this.baseVersion + 1);
        }
        _validate() {
          const e = this.sourcePosition.parent, t = this.targetPosition.parent, n = this.sourcePosition.offset, i = this.targetPosition.offset;
          if (n + this.howMany > e.maxOffset)
            throw new I("move-operation-nodes-do-not-exist", this);
          if (e === t && n < i && i < n + this.howMany)
            throw new I("move-operation-range-into-itself", this);
          if (this.sourcePosition.root == this.targetPosition.root && vt(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
            const r = this.sourcePosition.path.length - 1;
            if (this.targetPosition.path[r] >= n && this.targetPosition.path[r] < n + this.howMany)
              throw new I("move-operation-node-into-itself", this);
          }
        }
        _execute() {
          Ni($._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
        }
        toJSON() {
          const e = super.toJSON();
          return e.sourcePosition = this.sourcePosition.toJSON(), e.targetPosition = this.targetPosition.toJSON(), e;
        }
        static get className() {
          return "MoveOperation";
        }
        static fromJSON(e, t) {
          const n = W.fromJSON(e.sourcePosition, t), i = W.fromJSON(e.targetPosition, t);
          return new this(n, e.howMany, i, e.baseVersion);
        }
      }
      class ht extends Mt {
        constructor(e, t, n) {
          super(n), this.position = e.clone(), this.position.stickiness = "toNone", this.nodes = new Oi(gg(t)), this.shouldReceiveAttributes = !1;
        }
        get type() {
          return "insert";
        }
        get howMany() {
          return this.nodes.maxOffset;
        }
        get affectedSelectable() {
          return this.position.clone();
        }
        clone() {
          const e = new Oi([...this.nodes].map((n) => n._clone(!0))), t = new ht(this.position, e, this.baseVersion);
          return t.shouldReceiveAttributes = this.shouldReceiveAttributes, t;
        }
        getReversed() {
          const e = this.position.root.document.graveyard, t = new W(e, [0]);
          return new Be(this.position, this.nodes.maxOffset, t, this.baseVersion + 1);
        }
        _validate() {
          const e = this.position.parent;
          if (!e || e.maxOffset < this.position.offset)
            throw new I("insert-operation-position-invalid", this);
        }
        _execute() {
          const e = this.nodes;
          this.nodes = new Oi([...e].map((t) => t._clone(!0))), Ja(this.position, e);
        }
        toJSON() {
          const e = super.toJSON();
          return e.position = this.position.toJSON(), e.nodes = this.nodes.toJSON(), e;
        }
        static get className() {
          return "InsertOperation";
        }
        static fromJSON(e, t) {
          const n = [];
          for (const r of e.nodes)
            r.name ? n.push($e.fromJSON(r)) : n.push(Fe.fromJSON(r));
          const i = new ht(W.fromJSON(e.position, t), n, e.baseVersion);
          return i.shouldReceiveAttributes = e.shouldReceiveAttributes, i;
        }
      }
      class Le extends Mt {
        constructor(e, t, n, i, r) {
          super(r), this.splitPosition = e.clone(), this.splitPosition.stickiness = "toNext", this.howMany = t, this.insertionPosition = n, this.graveyardPosition = i ? i.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
        }
        get type() {
          return "split";
        }
        get moveTargetPosition() {
          const e = this.insertionPosition.path.slice();
          return e.push(0), new W(this.insertionPosition.root, e);
        }
        get movedRange() {
          const e = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new $(this.splitPosition, e);
        }
        get affectedSelectable() {
          const e = [$._createFromPositionAndShift(this.splitPosition, 0), $._createFromPositionAndShift(this.insertionPosition, 0)];
          return this.graveyardPosition && e.push($._createFromPositionAndShift(this.graveyardPosition, 0)), e;
        }
        clone() {
          return new Le(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
        }
        getReversed() {
          const e = this.splitPosition.root.document.graveyard, t = new W(e, [0]);
          return new et(this.moveTargetPosition, this.howMany, this.splitPosition, t, this.baseVersion + 1);
        }
        _validate() {
          const e = this.splitPosition.parent, t = this.splitPosition.offset;
          if (!e || e.maxOffset < t)
            throw new I("split-operation-position-invalid", this);
          if (!e.parent)
            throw new I("split-operation-split-in-root", this);
          if (this.howMany != e.maxOffset - this.splitPosition.offset)
            throw new I("split-operation-how-many-invalid", this);
          if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
            throw new I("split-operation-graveyard-position-invalid", this);
        }
        _execute() {
          const e = this.splitPosition.parent;
          if (this.graveyardPosition)
            Ni($._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
          else {
            const t = e._clone();
            Ja(this.insertionPosition, t);
          }
          Ni(new $(W._createAt(e, this.splitPosition.offset), W._createAt(e, e.maxOffset)), this.moveTargetPosition);
        }
        toJSON() {
          const e = super.toJSON();
          return e.splitPosition = this.splitPosition.toJSON(), e.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (e.graveyardPosition = this.graveyardPosition.toJSON()), e;
        }
        static get className() {
          return "SplitOperation";
        }
        static getInsertionPosition(e) {
          const t = e.path.slice(0, -1);
          return t[t.length - 1]++, new W(e.root, t, "toPrevious");
        }
        static fromJSON(e, t) {
          const n = W.fromJSON(e.splitPosition, t), i = W.fromJSON(e.insertionPosition, t), r = e.graveyardPosition ? W.fromJSON(e.graveyardPosition, t) : null;
          return new this(n, e.howMany, i, r, e.baseVersion);
        }
      }
      class et extends Mt {
        constructor(e, t, n, i, r) {
          super(r), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = i.clone();
        }
        get type() {
          return "merge";
        }
        get deletionPosition() {
          return new W(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
        }
        get movedRange() {
          const e = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new $(this.sourcePosition, e);
        }
        get affectedSelectable() {
          const e = this.sourcePosition.parent;
          return [$._createOn(e), $._createFromPositionAndShift(this.targetPosition, 0), $._createFromPositionAndShift(this.graveyardPosition, 0)];
        }
        clone() {
          return new et(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
        }
        getReversed() {
          const e = this.targetPosition._getTransformedByMergeOperation(this), t = this.sourcePosition.path.slice(0, -1), n = new W(this.sourcePosition.root, t)._getTransformedByMergeOperation(this);
          return new Le(e, this.howMany, n, this.graveyardPosition, this.baseVersion + 1);
        }
        _validate() {
          const e = this.sourcePosition.parent, t = this.targetPosition.parent;
          if (!e.parent)
            throw new I("merge-operation-source-position-invalid", this);
          if (!t.parent)
            throw new I("merge-operation-target-position-invalid", this);
          if (this.howMany != e.maxOffset)
            throw new I("merge-operation-how-many-invalid", this);
        }
        _execute() {
          const e = this.sourcePosition.parent;
          Ni($._createIn(e), this.targetPosition), Ni($._createOn(e), this.graveyardPosition);
        }
        toJSON() {
          const e = super.toJSON();
          return e.sourcePosition = e.sourcePosition.toJSON(), e.targetPosition = e.targetPosition.toJSON(), e.graveyardPosition = e.graveyardPosition.toJSON(), e;
        }
        static get className() {
          return "MergeOperation";
        }
        static fromJSON(e, t) {
          const n = W.fromJSON(e.sourcePosition, t), i = W.fromJSON(e.targetPosition, t), r = W.fromJSON(e.graveyardPosition, t);
          return new this(n, e.howMany, i, r, e.baseVersion);
        }
      }
      class yt extends Mt {
        constructor(e, t, n, i, r, s) {
          super(s), this.name = e, this.oldRange = t ? t.clone() : null, this.newRange = n ? n.clone() : null, this.affectsData = r, this._markers = i;
        }
        get type() {
          return "marker";
        }
        get affectedSelectable() {
          const e = [];
          return this.oldRange && e.push(this.oldRange.clone()), this.newRange && (this.oldRange ? e.push(...this.newRange.getDifference(this.oldRange)) : e.push(this.newRange.clone())), e;
        }
        clone() {
          return new yt(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
        }
        getReversed() {
          return new yt(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
        }
        _execute() {
          this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name);
        }
        toJSON() {
          const e = super.toJSON();
          return this.oldRange && (e.oldRange = this.oldRange.toJSON()), this.newRange && (e.newRange = this.newRange.toJSON()), delete e._markers, e;
        }
        static get className() {
          return "MarkerOperation";
        }
        static fromJSON(e, t) {
          return new yt(e.name, e.oldRange ? $.fromJSON(e.oldRange, t) : null, e.newRange ? $.fromJSON(e.newRange, t) : null, t.model.markers, e.affectsData, e.baseVersion);
        }
      }
      const Wr = function(o, e) {
        return xh(o, e);
      };
      class rt extends Mt {
        constructor(e, t, n, i, r) {
          super(r), this.range = e.clone(), this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = i === void 0 ? null : i;
        }
        get type() {
          return this.oldValue === null ? "addAttribute" : this.newValue === null ? "removeAttribute" : "changeAttribute";
        }
        get affectedSelectable() {
          return this.range.clone();
        }
        clone() {
          return new rt(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new rt(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        toJSON() {
          const e = super.toJSON();
          return e.range = this.range.toJSON(), e;
        }
        _validate() {
          if (!this.range.isFlat)
            throw new I("attribute-operation-range-not-flat", this);
          for (const e of this.range.getItems({ shallow: !0 })) {
            if (this.oldValue !== null && !Wr(e.getAttribute(this.key), this.oldValue))
              throw new I("attribute-operation-wrong-old-value", this, { item: e, key: this.key, value: this.oldValue });
            if (this.oldValue === null && this.newValue !== null && e.hasAttribute(this.key))
              throw new I("attribute-operation-attribute-exists", this, { node: e, key: this.key });
          }
        }
        _execute() {
          Wr(this.oldValue, this.newValue) || function(e, t, n) {
            $i(e.start), $i(e.end);
            for (const i of e.getItems({ shallow: !0 })) {
              const r = i.is("$textProxy") ? i.textNode : i;
              n !== null ? r._setAttribute(t, n) : r._removeAttribute(t), Fi(r.parent, r.index);
            }
            Fi(e.end.parent, e.end.index);
          }(this.range, this.key, this.newValue);
        }
        static get className() {
          return "AttributeOperation";
        }
        static fromJSON(e, t) {
          return new rt($.fromJSON(e.range, t), e.key, e.oldValue, e.newValue, e.baseVersion);
        }
      }
      class ct extends Mt {
        get type() {
          return "noop";
        }
        get affectedSelectable() {
          return null;
        }
        clone() {
          return new ct(this.baseVersion);
        }
        getReversed() {
          return new ct(this.baseVersion + 1);
        }
        _execute() {
        }
        static get className() {
          return "NoOperation";
        }
      }
      class Et extends Mt {
        constructor(e, t, n, i) {
          super(i), this.position = e, this.position.stickiness = "toNext", this.oldName = t, this.newName = n;
        }
        get type() {
          return "rename";
        }
        get affectedSelectable() {
          return this.position.nodeAfter;
        }
        clone() {
          return new Et(this.position.clone(), this.oldName, this.newName, this.baseVersion);
        }
        getReversed() {
          return new Et(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
        }
        _validate() {
          const e = this.position.nodeAfter;
          if (!(e instanceof $e))
            throw new I("rename-operation-wrong-position", this);
          if (e.name !== this.oldName)
            throw new I("rename-operation-wrong-name", this);
        }
        _execute() {
          this.position.nodeAfter.name = this.newName;
        }
        toJSON() {
          const e = super.toJSON();
          return e.position = this.position.toJSON(), e;
        }
        static get className() {
          return "RenameOperation";
        }
        static fromJSON(e, t) {
          return new Et(W.fromJSON(e.position, t), e.oldName, e.newName, e.baseVersion);
        }
      }
      class mn extends Mt {
        constructor(e, t, n, i, r) {
          super(r), this.root = e, this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = i === void 0 ? null : i;
        }
        get type() {
          return this.oldValue === null ? "addRootAttribute" : this.newValue === null ? "removeRootAttribute" : "changeRootAttribute";
        }
        get affectedSelectable() {
          return this.root;
        }
        clone() {
          return new mn(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new mn(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        _validate() {
          if (this.root != this.root.root || this.root.is("documentFragment"))
            throw new I("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
          if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue)
            throw new I("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
          if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key))
            throw new I("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
        }
        _execute() {
          this.newValue !== null ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
        }
        toJSON() {
          const e = super.toJSON();
          return e.root = this.root.toJSON(), e;
        }
        static get className() {
          return "RootAttributeOperation";
        }
        static fromJSON(e, t) {
          if (!t.getRoot(e.root))
            throw new I("rootattribute-operation-fromjson-no-root", this, { rootName: e.root });
          return new mn(t.getRoot(e.root), e.key, e.oldValue, e.newValue, e.baseVersion);
        }
      }
      class sn extends Mt {
        constructor(e, t, n, i, r) {
          super(r), this.rootName = e, this.elementName = t, this.isAdd = n, this._document = i, !this._document.getRoot(this.rootName) && (this._document.createRoot(this.elementName, this.rootName)._isAttached = !1);
        }
        get type() {
          return this.isAdd ? "addRoot" : "detachRoot";
        }
        get affectedSelectable() {
          return this._document.getRoot(this.rootName);
        }
        clone() {
          return new sn(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
        }
        getReversed() {
          return new sn(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
        }
        _validate() {
          const e = this._document.getRoot(this.rootName);
          if (e.isAttached() && this.isAdd)
            throw new I("root-operation-root-attached", this);
          if (!e.isAttached() && !this.isAdd)
            throw new I("root-operation-root-detached", this);
        }
        _execute() {
          this._document.getRoot(this.rootName)._isAttached = this.isAdd;
        }
        toJSON() {
          const e = super.toJSON();
          return delete e._document, e;
        }
        static get className() {
          return "RootOperation";
        }
        static fromJSON(e, t) {
          return new sn(e.rootName, e.elementName, e.isAdd, t, e.baseVersion);
        }
      }
      const jt = {};
      jt[rt.className] = rt, jt[ht.className] = ht, jt[yt.className] = yt, jt[Be.className] = Be, jt[ct.className] = ct, jt[Mt.className] = Mt, jt[Et.className] = Et, jt[mn.className] = mn, jt[sn.className] = sn, jt[Le.className] = Le, jt[et.className] = et;
      class qC {
        static fromJSON(e, t) {
          return jt[e.__className].fromJSON(e, t);
        }
      }
      const Ya = /* @__PURE__ */ new Map();
      function Ce(o, e, t) {
        let n = Ya.get(o);
        n || (n = /* @__PURE__ */ new Map(), Ya.set(o, n)), n.set(e, t);
      }
      function WC(o) {
        return [o];
      }
      function pg(o, e, t = {}) {
        const n = function(i, r) {
          const s = Ya.get(i);
          return s && s.has(r) ? s.get(r) : WC;
        }(o.constructor, e.constructor);
        try {
          return n(o = o.clone(), e, t);
        } catch (i) {
          throw i;
        }
      }
      function GC(o, e, t) {
        o = o.slice(), e = e.slice();
        const n = new KC(t.document, t.useRelations, t.forceWeakRemove);
        n.setOriginalOperations(o), n.setOriginalOperations(e);
        const i = n.originalOperations;
        if (o.length == 0 || e.length == 0)
          return { operationsA: o, operationsB: e, originalOperations: i };
        const r = /* @__PURE__ */ new WeakMap();
        for (const l of o)
          r.set(l, 0);
        const s = { nextBaseVersionA: o[o.length - 1].baseVersion + 1, nextBaseVersionB: e[e.length - 1].baseVersion + 1, originalOperationsACount: o.length, originalOperationsBCount: e.length };
        let a = 0;
        for (; a < o.length; ) {
          const l = o[a], d = r.get(l);
          if (d == e.length) {
            a++;
            continue;
          }
          const h = e[d], m = pg(l, h, n.getContext(l, h, !0)), f = pg(h, l, n.getContext(h, l, !1));
          n.updateRelation(l, h), n.setOriginalOperations(m, l), n.setOriginalOperations(f, h);
          for (const _ of m)
            r.set(_, d + f.length);
          o.splice(a, 1, ...m), e.splice(d, 1, ...f);
        }
        if (t.padWithNoOps) {
          const l = o.length - s.originalOperationsACount, d = e.length - s.originalOperationsBCount;
          bg(o, d - l), bg(e, l - d);
        }
        return fg(o, s.nextBaseVersionB), fg(e, s.nextBaseVersionA), { operationsA: o, operationsB: e, originalOperations: i };
      }
      class KC {
        constructor(e, t, n = !1) {
          this.originalOperations = /* @__PURE__ */ new Map(), this._history = e.history, this._useRelations = t, this._forceWeakRemove = !!n, this._relations = /* @__PURE__ */ new Map();
        }
        setOriginalOperations(e, t = null) {
          const n = t ? this.originalOperations.get(t) : null;
          for (const i of e)
            this.originalOperations.set(i, n || i);
        }
        updateRelation(e, t) {
          if (e instanceof Be)
            t instanceof et ? e.targetPosition.isEqual(t.sourcePosition) || t.movedRange.containsPosition(e.targetPosition) ? this._setRelation(e, t, "insertAtSource") : e.targetPosition.isEqual(t.deletionPosition) ? this._setRelation(e, t, "insertBetween") : e.targetPosition.isAfter(t.sourcePosition) && this._setRelation(e, t, "moveTargetAfter") : t instanceof Be && (e.targetPosition.isEqual(t.sourcePosition) || e.targetPosition.isBefore(t.sourcePosition) ? this._setRelation(e, t, "insertBefore") : this._setRelation(e, t, "insertAfter"));
          else if (e instanceof Le) {
            if (t instanceof et)
              e.splitPosition.isBefore(t.sourcePosition) && this._setRelation(e, t, "splitBefore");
            else if (t instanceof Be)
              if (e.splitPosition.isEqual(t.sourcePosition) || e.splitPosition.isBefore(t.sourcePosition))
                this._setRelation(e, t, "splitBefore");
              else {
                const n = $._createFromPositionAndShift(t.sourcePosition, t.howMany);
                if (e.splitPosition.hasSameParentAs(t.sourcePosition) && n.containsPosition(e.splitPosition)) {
                  const i = n.end.offset - e.splitPosition.offset, r = e.splitPosition.offset - n.start.offset;
                  this._setRelation(e, t, { howMany: i, offset: r });
                }
              }
          } else if (e instanceof et)
            t instanceof et ? (e.targetPosition.isEqual(t.sourcePosition) || this._setRelation(e, t, "mergeTargetNotMoved"), e.sourcePosition.isEqual(t.targetPosition) && this._setRelation(e, t, "mergeSourceNotMoved"), e.sourcePosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeSameElement")) : t instanceof Le && e.sourcePosition.isEqual(t.splitPosition) && this._setRelation(e, t, "splitAtSource");
          else if (e instanceof yt) {
            const n = e.newRange;
            if (!n)
              return;
            if (t instanceof Be) {
              const i = $._createFromPositionAndShift(t.sourcePosition, t.howMany), r = i.containsPosition(n.start) || i.start.isEqual(n.start), s = i.containsPosition(n.end) || i.end.isEqual(n.end);
              !r && !s || i.containsRange(n) || this._setRelation(e, t, { side: r ? "left" : "right", path: r ? n.start.path.slice() : n.end.path.slice() });
            } else if (t instanceof et) {
              const i = n.start.isEqual(t.targetPosition), r = n.start.isEqual(t.deletionPosition), s = n.end.isEqual(t.deletionPosition), a = n.end.isEqual(t.sourcePosition);
              (i || r || s || a) && this._setRelation(e, t, { wasInLeftElement: i, wasStartBeforeMergedElement: r, wasEndBeforeMergedElement: s, wasInRightElement: a });
            }
          }
        }
        getContext(e, t, n) {
          return { aIsStrong: n, aWasUndone: this._wasUndone(e), bWasUndone: this._wasUndone(t), abRelation: this._useRelations ? this._getRelation(e, t) : null, baRelation: this._useRelations ? this._getRelation(t, e) : null, forceWeakRemove: this._forceWeakRemove };
        }
        _wasUndone(e) {
          const t = this.originalOperations.get(e);
          return t.wasUndone || this._history.isUndoneOperation(t);
        }
        _getRelation(e, t) {
          const n = this.originalOperations.get(t), i = this._history.getUndoneOperation(n);
          if (!i)
            return null;
          const r = this.originalOperations.get(e), s = this._relations.get(r);
          return s && s.get(i) || null;
        }
        _setRelation(e, t, n) {
          const i = this.originalOperations.get(e), r = this.originalOperations.get(t);
          let s = this._relations.get(i);
          s || (s = /* @__PURE__ */ new Map(), this._relations.set(i, s)), s.set(r, n);
        }
      }
      function fg(o, e) {
        for (const t of o)
          t.baseVersion = e++;
      }
      function bg(o, e) {
        for (let t = 0; t < e; t++)
          o.push(new ct(0));
      }
      function kg(o, e, t) {
        const n = o.nodes.getNode(0).getAttribute(e);
        if (n == t)
          return null;
        const i = new $(o.position, o.position.getShiftedBy(o.howMany));
        return new rt(i, e, n, t, 0);
      }
      function wg(o, e) {
        return o.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null;
      }
      function jo(o, e) {
        const t = [];
        for (let n = 0; n < o.length; n++) {
          const i = o[n], r = new Be(i.start, i.end.offset - i.start.offset, e, 0);
          t.push(r);
          for (let s = n + 1; s < o.length; s++)
            o[s] = o[s]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0];
          e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany);
        }
        return t;
      }
      Ce(rt, rt, (o, e, t) => {
        if (o.key === e.key && o.range.start.hasSameParentAs(e.range.start)) {
          const n = o.range.getDifference(e.range).map((r) => new rt(r, o.key, o.oldValue, o.newValue, 0)), i = o.range.getIntersection(e.range);
          return i && t.aIsStrong && n.push(new rt(i, e.key, e.newValue, o.newValue, 0)), n.length == 0 ? [new ct(0)] : n;
        }
        return [o];
      }), Ce(rt, ht, (o, e) => {
        if (o.range.start.hasSameParentAs(e.position) && o.range.containsPosition(e.position)) {
          const t = o.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes).map((n) => new rt(n, o.key, o.oldValue, o.newValue, o.baseVersion));
          if (e.shouldReceiveAttributes) {
            const n = kg(e, o.key, o.oldValue);
            n && t.unshift(n);
          }
          return t;
        }
        return o.range = o.range._getTransformedByInsertion(e.position, e.howMany, !1)[0], [o];
      }), Ce(rt, et, (o, e) => {
        const t = [];
        o.range.start.hasSameParentAs(e.deletionPosition) && (o.range.containsPosition(e.deletionPosition) || o.range.start.isEqual(e.deletionPosition)) && t.push($._createFromPositionAndShift(e.graveyardPosition, 1));
        const n = o.range._getTransformedByMergeOperation(e);
        return n.isCollapsed || t.push(n), t.map((i) => new rt(i, o.key, o.oldValue, o.newValue, o.baseVersion));
      }), Ce(rt, Be, (o, e) => function(n, i) {
        const r = $._createFromPositionAndShift(i.sourcePosition, i.howMany);
        let s = null, a = [];
        r.containsRange(n, !0) ? s = n : n.start.hasSameParentAs(r.start) ? (a = n.getDifference(r), s = n.getIntersection(r)) : a = [n];
        const l = [];
        for (let d of a) {
          d = d._getTransformedByDeletion(i.sourcePosition, i.howMany);
          const h = i.getMovedRangeStart(), m = d.start.hasSameParentAs(h), f = d._getTransformedByInsertion(h, i.howMany, m);
          l.push(...f);
        }
        return s && l.push(s._getTransformedByMove(i.sourcePosition, i.targetPosition, i.howMany, !1)[0]), l;
      }(o.range, e).map((n) => new rt(n, o.key, o.oldValue, o.newValue, o.baseVersion))), Ce(rt, Le, (o, e) => {
        if (o.range.end.isEqual(e.insertionPosition))
          return e.graveyardPosition || o.range.end.offset++, [o];
        if (o.range.start.hasSameParentAs(e.splitPosition) && o.range.containsPosition(e.splitPosition)) {
          const t = o.clone();
          return t.range = new $(e.moveTargetPosition.clone(), o.range.end._getCombined(e.splitPosition, e.moveTargetPosition)), o.range.end = e.splitPosition.clone(), o.range.end.stickiness = "toPrevious", [o, t];
        }
        return o.range = o.range._getTransformedBySplitOperation(e), [o];
      }), Ce(ht, rt, (o, e) => {
        const t = [o];
        if (o.shouldReceiveAttributes && o.position.hasSameParentAs(e.range.start) && e.range.containsPosition(o.position)) {
          const n = kg(o, e.key, e.newValue);
          n && t.push(n);
        }
        return t;
      }), Ce(ht, ht, (o, e, t) => (o.position.isEqual(e.position) && t.aIsStrong || (o.position = o.position._getTransformedByInsertOperation(e)), [o])), Ce(ht, Be, (o, e) => (o.position = o.position._getTransformedByMoveOperation(e), [o])), Ce(ht, Le, (o, e) => (o.position = o.position._getTransformedBySplitOperation(e), [o])), Ce(ht, et, (o, e) => (o.position = o.position._getTransformedByMergeOperation(e), [o])), Ce(yt, ht, (o, e) => (o.oldRange && (o.oldRange = o.oldRange._getTransformedByInsertOperation(e)[0]), o.newRange && (o.newRange = o.newRange._getTransformedByInsertOperation(e)[0]), [o])), Ce(yt, yt, (o, e, t) => {
        if (o.name == e.name) {
          if (!t.aIsStrong)
            return [new ct(0)];
          o.oldRange = e.newRange ? e.newRange.clone() : null;
        }
        return [o];
      }), Ce(yt, et, (o, e) => (o.oldRange && (o.oldRange = o.oldRange._getTransformedByMergeOperation(e)), o.newRange && (o.newRange = o.newRange._getTransformedByMergeOperation(e)), [o])), Ce(yt, Be, (o, e, t) => {
        if (o.oldRange && (o.oldRange = $._createFromRanges(o.oldRange._getTransformedByMoveOperation(e))), o.newRange) {
          if (t.abRelation) {
            const n = $._createFromRanges(o.newRange._getTransformedByMoveOperation(e));
            if (t.abRelation.side == "left" && e.targetPosition.isEqual(o.newRange.start))
              return o.newRange.end = n.end, o.newRange.start.path = t.abRelation.path, [o];
            if (t.abRelation.side == "right" && e.targetPosition.isEqual(o.newRange.end))
              return o.newRange.start = n.start, o.newRange.end.path = t.abRelation.path, [o];
          }
          o.newRange = $._createFromRanges(o.newRange._getTransformedByMoveOperation(e));
        }
        return [o];
      }), Ce(yt, Le, (o, e, t) => {
        if (o.oldRange && (o.oldRange = o.oldRange._getTransformedBySplitOperation(e)), o.newRange) {
          if (t.abRelation) {
            const n = o.newRange._getTransformedBySplitOperation(e);
            return o.newRange.start.isEqual(e.splitPosition) && t.abRelation.wasStartBeforeMergedElement ? o.newRange.start = W._createAt(e.insertionPosition) : o.newRange.start.isEqual(e.splitPosition) && !t.abRelation.wasInLeftElement && (o.newRange.start = W._createAt(e.moveTargetPosition)), o.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasInRightElement ? o.newRange.end = W._createAt(e.moveTargetPosition) : o.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasEndBeforeMergedElement ? o.newRange.end = W._createAt(e.insertionPosition) : o.newRange.end = n.end, [o];
          }
          o.newRange = o.newRange._getTransformedBySplitOperation(e);
        }
        return [o];
      }), Ce(et, ht, (o, e) => (o.sourcePosition.hasSameParentAs(e.position) && (o.howMany += e.howMany), o.sourcePosition = o.sourcePosition._getTransformedByInsertOperation(e), o.targetPosition = o.targetPosition._getTransformedByInsertOperation(e), [o])), Ce(et, et, (o, e, t) => {
        if (o.sourcePosition.isEqual(e.sourcePosition) && o.targetPosition.isEqual(e.targetPosition)) {
          if (t.bWasUndone) {
            const n = e.graveyardPosition.path.slice();
            return n.push(0), o.sourcePosition = new W(e.graveyardPosition.root, n), o.howMany = 0, [o];
          }
          return [new ct(0)];
        }
        if (o.sourcePosition.isEqual(e.sourcePosition) && !o.targetPosition.isEqual(e.targetPosition) && !t.bWasUndone && t.abRelation != "splitAtSource") {
          const n = o.targetPosition.root.rootName == "$graveyard", i = e.targetPosition.root.rootName == "$graveyard";
          if (i && !n || !(n && !i) && t.aIsStrong) {
            const r = e.targetPosition._getTransformedByMergeOperation(e), s = o.targetPosition._getTransformedByMergeOperation(e);
            return [new Be(r, o.howMany, s, 0)];
          }
          return [new ct(0)];
        }
        return o.sourcePosition.hasSameParentAs(e.targetPosition) && (o.howMany += e.howMany), o.sourcePosition = o.sourcePosition._getTransformedByMergeOperation(e), o.targetPosition = o.targetPosition._getTransformedByMergeOperation(e), o.graveyardPosition.isEqual(e.graveyardPosition) && t.aIsStrong || (o.graveyardPosition = o.graveyardPosition._getTransformedByMergeOperation(e)), [o];
      }), Ce(et, Be, (o, e, t) => {
        const n = $._createFromPositionAndShift(e.sourcePosition, e.howMany);
        return e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && o.deletionPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(o.sourcePosition) ? [new ct(0)] : (o.sourcePosition.hasSameParentAs(e.targetPosition) && (o.howMany += e.howMany), o.sourcePosition.hasSameParentAs(e.sourcePosition) && (o.howMany -= e.howMany), o.sourcePosition = o.sourcePosition._getTransformedByMoveOperation(e), o.targetPosition = o.targetPosition._getTransformedByMoveOperation(e), o.graveyardPosition.isEqual(e.targetPosition) || (o.graveyardPosition = o.graveyardPosition._getTransformedByMoveOperation(e)), [o]);
      }), Ce(et, Le, (o, e, t) => {
        if (e.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1), o.deletionPosition.isEqual(e.graveyardPosition) && (o.howMany = e.howMany)), o.targetPosition.isEqual(e.splitPosition)) {
          const n = e.howMany != 0, i = e.graveyardPosition && o.deletionPosition.isEqual(e.graveyardPosition);
          if (n || i || t.abRelation == "mergeTargetNotMoved")
            return o.sourcePosition = o.sourcePosition._getTransformedBySplitOperation(e), [o];
        }
        if (o.sourcePosition.isEqual(e.splitPosition)) {
          if (t.abRelation == "mergeSourceNotMoved")
            return o.howMany = 0, o.targetPosition = o.targetPosition._getTransformedBySplitOperation(e), [o];
          if (t.abRelation == "mergeSameElement" || o.sourcePosition.offset > 0)
            return o.sourcePosition = e.moveTargetPosition.clone(), o.targetPosition = o.targetPosition._getTransformedBySplitOperation(e), [o];
        }
        return o.sourcePosition.hasSameParentAs(e.splitPosition) && (o.howMany = e.splitPosition.offset), o.sourcePosition = o.sourcePosition._getTransformedBySplitOperation(e), o.targetPosition = o.targetPosition._getTransformedBySplitOperation(e), [o];
      }), Ce(Be, ht, (o, e) => {
        const t = $._createFromPositionAndShift(o.sourcePosition, o.howMany)._getTransformedByInsertOperation(e, !1)[0];
        return o.sourcePosition = t.start, o.howMany = t.end.offset - t.start.offset, o.targetPosition.isEqual(e.position) || (o.targetPosition = o.targetPosition._getTransformedByInsertOperation(e)), [o];
      }), Ce(Be, Be, (o, e, t) => {
        const n = $._createFromPositionAndShift(o.sourcePosition, o.howMany), i = $._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let r, s = t.aIsStrong, a = !t.aIsStrong;
        if (t.abRelation == "insertBefore" || t.baRelation == "insertAfter" ? a = !0 : t.abRelation != "insertAfter" && t.baRelation != "insertBefore" || (a = !1), r = o.targetPosition.isEqual(e.targetPosition) && a ? o.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) : o.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), wg(o, e) && wg(e, o))
          return [e.getReversed()];
        if (n.containsPosition(e.targetPosition) && n.containsRange(i, !0))
          return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), jo([n], r);
        if (i.containsPosition(o.targetPosition) && i.containsRange(n, !0))
          return n.start = n.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), n.end = n.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), jo([n], r);
        const l = vt(o.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
        if (l == "prefix" || l == "extension")
          return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), jo([n], r);
        o.type != "remove" || e.type == "remove" || t.aWasUndone || t.forceWeakRemove ? o.type == "remove" || e.type != "remove" || t.bWasUndone || t.forceWeakRemove || (s = !1) : s = !0;
        const d = [], h = n.getDifference(i);
        for (const f of h) {
          f.start = f.start._getTransformedByDeletion(e.sourcePosition, e.howMany), f.end = f.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
          const _ = vt(f.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same", E = f._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, _);
          d.push(...E);
        }
        const m = n.getIntersection(i);
        return m !== null && s && (m.start = m.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), m.end = m.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), d.length === 0 ? d.push(m) : d.length == 1 ? i.start.isBefore(n.start) || i.start.isEqual(n.start) ? d.unshift(m) : d.push(m) : d.splice(1, 0, m)), d.length === 0 ? [new ct(o.baseVersion)] : jo(d, r);
      }), Ce(Be, Le, (o, e, t) => {
        let n = o.targetPosition.clone();
        o.targetPosition.isEqual(e.insertionPosition) && e.graveyardPosition && t.abRelation != "moveTargetAfter" || (n = o.targetPosition._getTransformedBySplitOperation(e));
        const i = $._createFromPositionAndShift(o.sourcePosition, o.howMany);
        if (i.end.isEqual(e.insertionPosition))
          return e.graveyardPosition || o.howMany++, o.targetPosition = n, [o];
        if (i.start.hasSameParentAs(e.splitPosition) && i.containsPosition(e.splitPosition)) {
          let s = new $(e.splitPosition, i.end);
          return s = s._getTransformedBySplitOperation(e), jo([new $(i.start, e.splitPosition), s], n);
        }
        o.targetPosition.isEqual(e.splitPosition) && t.abRelation == "insertAtSource" && (n = e.moveTargetPosition), o.targetPosition.isEqual(e.insertionPosition) && t.abRelation == "insertBetween" && (n = o.targetPosition);
        const r = [i._getTransformedBySplitOperation(e)];
        if (e.graveyardPosition) {
          const s = i.start.isEqual(e.graveyardPosition) || i.containsPosition(e.graveyardPosition);
          o.howMany > 1 && s && !t.aWasUndone && r.push($._createFromPositionAndShift(e.insertionPosition, 1));
        }
        return jo(r, n);
      }), Ce(Be, et, (o, e, t) => {
        const n = $._createFromPositionAndShift(o.sourcePosition, o.howMany);
        if (e.deletionPosition.hasSameParentAs(o.sourcePosition) && n.containsPosition(e.sourcePosition)) {
          if (o.type != "remove" || t.forceWeakRemove) {
            if (o.howMany == 1)
              return t.bWasUndone ? (o.sourcePosition = e.graveyardPosition.clone(), o.targetPosition = o.targetPosition._getTransformedByMergeOperation(e), [o]) : [new ct(0)];
          } else if (!t.aWasUndone) {
            const r = [];
            let s = e.graveyardPosition.clone(), a = e.targetPosition._getTransformedByMergeOperation(e);
            o.howMany > 1 && (r.push(new Be(o.sourcePosition, o.howMany - 1, o.targetPosition, 0)), s = s._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany - 1), a = a._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany - 1));
            const l = e.deletionPosition._getCombined(o.sourcePosition, o.targetPosition), d = new Be(s, 1, l, 0), h = d.getMovedRangeStart().path.slice();
            h.push(0);
            const m = new W(d.targetPosition.root, h);
            a = a._getTransformedByMove(s, l, 1);
            const f = new Be(a, e.howMany, m, 0);
            return r.push(d), r.push(f), r;
          }
        }
        const i = $._createFromPositionAndShift(o.sourcePosition, o.howMany)._getTransformedByMergeOperation(e);
        return o.sourcePosition = i.start, o.howMany = i.end.offset - i.start.offset, o.targetPosition = o.targetPosition._getTransformedByMergeOperation(e), [o];
      }), Ce(Et, ht, (o, e) => (o.position = o.position._getTransformedByInsertOperation(e), [o])), Ce(Et, et, (o, e) => o.position.isEqual(e.deletionPosition) ? (o.position = e.graveyardPosition.clone(), o.position.stickiness = "toNext", [o]) : (o.position = o.position._getTransformedByMergeOperation(e), [o])), Ce(Et, Be, (o, e) => (o.position = o.position._getTransformedByMoveOperation(e), [o])), Ce(Et, Et, (o, e, t) => {
        if (o.position.isEqual(e.position)) {
          if (!t.aIsStrong)
            return [new ct(0)];
          o.oldName = e.newName;
        }
        return [o];
      }), Ce(Et, Le, (o, e) => {
        if (vt(o.position.path, e.splitPosition.getParentPath()) == "same" && !e.graveyardPosition) {
          const t = new Et(o.position.getShiftedBy(1), o.oldName, o.newName, 0);
          return [o, t];
        }
        return o.position = o.position._getTransformedBySplitOperation(e), [o];
      }), Ce(mn, mn, (o, e, t) => {
        if (o.root === e.root && o.key === e.key) {
          if (!t.aIsStrong || o.newValue === e.newValue)
            return [new ct(0)];
          o.oldValue = e.newValue;
        }
        return [o];
      }), Ce(sn, sn, (o, e, t) => o.rootName !== e.rootName || o.isAdd !== e.isAdd || t.bWasUndone ? [o] : [new ct(0)]), Ce(Le, ht, (o, e) => (o.splitPosition.hasSameParentAs(e.position) && o.splitPosition.offset < e.position.offset && (o.howMany += e.howMany), o.splitPosition = o.splitPosition._getTransformedByInsertOperation(e), o.insertionPosition = o.insertionPosition._getTransformedByInsertOperation(e), [o])), Ce(Le, et, (o, e, t) => {
        if (!o.graveyardPosition && !t.bWasUndone && o.splitPosition.hasSameParentAs(e.sourcePosition)) {
          const n = e.graveyardPosition.path.slice();
          n.push(0);
          const i = new W(e.graveyardPosition.root, n), r = Le.getInsertionPosition(new W(e.graveyardPosition.root, n)), s = new Le(i, 0, r, null, 0);
          return o.splitPosition = o.splitPosition._getTransformedByMergeOperation(e), o.insertionPosition = Le.getInsertionPosition(o.splitPosition), o.graveyardPosition = s.insertionPosition.clone(), o.graveyardPosition.stickiness = "toNext", [s, o];
        }
        return o.splitPosition.hasSameParentAs(e.deletionPosition) && !o.splitPosition.isAfter(e.deletionPosition) && o.howMany--, o.splitPosition.hasSameParentAs(e.targetPosition) && (o.howMany += e.howMany), o.splitPosition = o.splitPosition._getTransformedByMergeOperation(e), o.insertionPosition = Le.getInsertionPosition(o.splitPosition), o.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedByMergeOperation(e)), [o];
      }), Ce(Le, Be, (o, e, t) => {
        const n = $._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (o.graveyardPosition) {
          const r = n.start.isEqual(o.graveyardPosition) || n.containsPosition(o.graveyardPosition);
          if (!t.bWasUndone && r) {
            const s = o.splitPosition._getTransformedByMoveOperation(e), a = o.graveyardPosition._getTransformedByMoveOperation(e), l = a.path.slice();
            l.push(0);
            const d = new W(a.root, l);
            return [new Be(s, o.howMany, d, 0)];
          }
          o.graveyardPosition = o.graveyardPosition._getTransformedByMoveOperation(e);
        }
        const i = o.splitPosition.isEqual(e.targetPosition);
        if (i && (t.baRelation == "insertAtSource" || t.abRelation == "splitBefore"))
          return o.howMany += e.howMany, o.splitPosition = o.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany), o.insertionPosition = Le.getInsertionPosition(o.splitPosition), [o];
        if (i && t.abRelation && t.abRelation.howMany) {
          const { howMany: r, offset: s } = t.abRelation;
          return o.howMany += r, o.splitPosition = o.splitPosition.getShiftedBy(s), [o];
        }
        if (o.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(o.splitPosition)) {
          const r = e.howMany - (o.splitPosition.offset - e.sourcePosition.offset);
          return o.howMany -= r, o.splitPosition.hasSameParentAs(e.targetPosition) && o.splitPosition.offset < e.targetPosition.offset && (o.howMany += e.howMany), o.splitPosition = e.sourcePosition.clone(), o.insertionPosition = Le.getInsertionPosition(o.splitPosition), [o];
        }
        return e.sourcePosition.isEqual(e.targetPosition) || (o.splitPosition.hasSameParentAs(e.sourcePosition) && o.splitPosition.offset <= e.sourcePosition.offset && (o.howMany -= e.howMany), o.splitPosition.hasSameParentAs(e.targetPosition) && o.splitPosition.offset < e.targetPosition.offset && (o.howMany += e.howMany)), o.splitPosition.stickiness = "toNone", o.splitPosition = o.splitPosition._getTransformedByMoveOperation(e), o.splitPosition.stickiness = "toNext", o.graveyardPosition ? o.insertionPosition = o.insertionPosition._getTransformedByMoveOperation(e) : o.insertionPosition = Le.getInsertionPosition(o.splitPosition), [o];
      }), Ce(Le, Le, (o, e, t) => {
        if (o.splitPosition.isEqual(e.splitPosition)) {
          if (!o.graveyardPosition && !e.graveyardPosition)
            return [new ct(0)];
          if (o.graveyardPosition && e.graveyardPosition && o.graveyardPosition.isEqual(e.graveyardPosition))
            return [new ct(0)];
          if (t.abRelation == "splitBefore")
            return o.howMany = 0, o.graveyardPosition = o.graveyardPosition._getTransformedBySplitOperation(e), [o];
        }
        if (o.graveyardPosition && e.graveyardPosition && o.graveyardPosition.isEqual(e.graveyardPosition)) {
          const n = o.splitPosition.root.rootName == "$graveyard", i = e.splitPosition.root.rootName == "$graveyard";
          if (i && !n || !(n && !i) && t.aIsStrong) {
            const r = [];
            return e.howMany && r.push(new Be(e.moveTargetPosition, e.howMany, e.splitPosition, 0)), o.howMany && r.push(new Be(o.splitPosition, o.howMany, o.moveTargetPosition, 0)), r;
          }
          return [new ct(0)];
        }
        if (o.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedBySplitOperation(e)), o.splitPosition.isEqual(e.insertionPosition) && t.abRelation == "splitBefore")
          return o.howMany++, [o];
        if (e.splitPosition.isEqual(o.insertionPosition) && t.baRelation == "splitBefore") {
          const n = e.insertionPosition.path.slice();
          n.push(0);
          const i = new W(e.insertionPosition.root, n);
          return [o, new Be(o.insertionPosition, 1, i, 0)];
        }
        return o.splitPosition.hasSameParentAs(e.splitPosition) && o.splitPosition.offset < e.splitPosition.offset && (o.howMany -= e.howMany), o.splitPosition = o.splitPosition._getTransformedBySplitOperation(e), o.insertionPosition = Le.getInsertionPosition(o.splitPosition), [o];
      });
      class xt extends De(W) {
        constructor(e, t, n = "toNone") {
          if (super(e, t, n), !this.root.is("rootElement"))
            throw new I("model-liveposition-root-not-rootelement", e);
          ZC.call(this);
        }
        detach() {
          this.stopListening();
        }
        toPosition() {
          return new W(this.root, this.path.slice(), this.stickiness);
        }
        static fromPosition(e, t) {
          return new this(e.root, e.path.slice(), t || e.stickiness);
        }
      }
      function ZC() {
        this.listenTo(this.root.document.model, "applyOperation", (o, e) => {
          const t = e[0];
          t.isDocumentOperation && JC.call(this, t);
        }, { priority: "low" });
      }
      function JC(o) {
        const e = this.getTransformedByOperation(o);
        if (!this.isEqual(e)) {
          const t = this.toPosition();
          this.path = e.path, this.root = e.root, this.fire("change", t);
        }
      }
      xt.prototype.is = function(o) {
        return o === "livePosition" || o === "model:livePosition" || o == "position" || o === "model:position";
      };
      class Ho {
        constructor(e = {}) {
          typeof e == "string" && (e = e === "transparent" ? { isUndoable: !1 } : {}, ne("batch-constructor-deprecated-string-type"));
          const { isUndoable: t = !0, isLocal: n = !0, isUndo: i = !1, isTyping: r = !1 } = e;
          this.operations = [], this.isUndoable = t, this.isLocal = n, this.isUndo = i, this.isTyping = r;
        }
        get type() {
          return ne("batch-type-deprecated"), "default";
        }
        get baseVersion() {
          for (const e of this.operations)
            if (e.baseVersion !== null)
              return e.baseVersion;
          return null;
        }
        addOperation(e) {
          return e.batch = this, this.operations.push(e), e;
        }
      }
      var YC = Object.defineProperty, vg = Object.getOwnPropertySymbols, QC = Object.prototype.hasOwnProperty, XC = Object.prototype.propertyIsEnumerable, _g = (o, e, t) => e in o ? YC(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class e1 {
        constructor(e) {
          this._changesInElement = /* @__PURE__ */ new Map(), this._elementSnapshots = /* @__PURE__ */ new Map(), this._changedMarkers = /* @__PURE__ */ new Map(), this._changedRoots = /* @__PURE__ */ new Map(), this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = /* @__PURE__ */ new Set(), this._markerCollection = e;
        }
        get isEmpty() {
          return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
        }
        bufferOperation(e) {
          const t = e;
          switch (t.type) {
            case "insert":
              if (this._isInInsertedElement(t.position.parent))
                return;
              this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
              break;
            case "addAttribute":
            case "removeAttribute":
            case "changeAttribute":
              for (const n of t.range.getItems({ shallow: !0 }))
                this._isInInsertedElement(n.parent) || this._markAttribute(n);
              break;
            case "remove":
            case "move":
            case "reinsert": {
              if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition))
                return;
              const n = this._isInInsertedElement(t.sourcePosition.parent), i = this._isInInsertedElement(t.targetPosition.parent);
              n || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany), i || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
              break;
            }
            case "rename": {
              if (this._isInInsertedElement(t.position.parent))
                return;
              this._markRemove(t.position.parent, t.position.offset, 1), this._markInsert(t.position.parent, t.position.offset, 1);
              const n = $._createFromPositionAndShift(t.position, 1);
              for (const i of this._markerCollection.getMarkersIntersectingRange(n)) {
                const r = i.getData();
                this.bufferMarkerChange(i.name, r, r);
              }
              break;
            }
            case "split": {
              const n = t.splitPosition.parent;
              this._isInInsertedElement(n) || this._markRemove(n, t.splitPosition.offset, t.howMany), this._isInInsertedElement(t.insertionPosition.parent) || this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1), t.graveyardPosition && this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1);
              break;
            }
            case "merge": {
              const n = t.sourcePosition.parent;
              this._isInInsertedElement(n.parent) || this._markRemove(n.parent, n.startOffset, 1);
              const i = t.graveyardPosition.parent;
              this._markInsert(i, t.graveyardPosition.offset, 1);
              const r = t.targetPosition.parent;
              this._isInInsertedElement(r) || this._markInsert(r, t.targetPosition.offset, n.maxOffset);
              break;
            }
            case "detachRoot":
            case "addRoot":
              this._bufferRootStateChange(t.rootName, t.isAdd);
              break;
            case "addRootAttribute":
            case "removeRootAttribute":
            case "changeRootAttribute": {
              const n = t.root.rootName;
              this._bufferRootAttributeChange(n, t.key, t.oldValue, t.newValue);
              break;
            }
          }
          this._cachedChanges = null;
        }
        bufferMarkerChange(e, t, n) {
          const i = this._changedMarkers.get(e);
          i ? (i.newMarkerData = n, i.oldMarkerData.range == null && n.range == null && this._changedMarkers.delete(e)) : this._changedMarkers.set(e, { newMarkerData: n, oldMarkerData: t });
        }
        getMarkersToRemove() {
          const e = [];
          for (const [t, n] of this._changedMarkers)
            n.oldMarkerData.range != null && e.push({ name: t, range: n.oldMarkerData.range });
          return e;
        }
        getMarkersToAdd() {
          const e = [];
          for (const [t, n] of this._changedMarkers)
            n.newMarkerData.range != null && e.push({ name: t, range: n.newMarkerData.range });
          return e;
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map(([e, t]) => ({ name: e, data: { oldRange: t.oldMarkerData.range, newRange: t.newMarkerData.range } }));
        }
        hasDataChanges() {
          if (this._changesInElement.size > 0 || this._changedRoots.size > 0)
            return !0;
          for (const { newMarkerData: e, oldMarkerData: t } of this._changedMarkers.values()) {
            if (e.affectsData !== t.affectsData)
              return !0;
            if (e.affectsData) {
              const n = e.range && !t.range, i = !e.range && t.range, r = e.range && t.range && !e.range.isEqual(t.range);
              if (n || i || r)
                return !0;
            }
          }
          return !1;
        }
        getChanges(e = {}) {
          if (this._cachedChanges)
            return e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
          let t = [];
          for (const n of this._changesInElement.keys()) {
            const i = this._changesInElement.get(n).sort((h, m) => h.offset === m.offset ? h.type != m.type ? h.type == "remove" ? -1 : 1 : 0 : h.offset < m.offset ? -1 : 1), r = this._elementSnapshots.get(n), s = Ag(n.getChildren()), a = t1(r.length, i);
            let l = 0, d = 0;
            for (const h of a)
              if (h === "i")
                t.push(this._getInsertDiff(n, l, s[l])), l++;
              else if (h === "r")
                t.push(this._getRemoveDiff(n, l, r[d])), d++;
              else if (h === "a") {
                const m = s[l].attributes, f = r[d].attributes;
                let _;
                if (s[l].name == "$text")
                  _ = new $(W._createAt(n, l), W._createAt(n, l + 1));
                else {
                  const E = n.offsetToIndex(l);
                  _ = new $(W._createAt(n, l), W._createAt(n.getChild(E), 0));
                }
                t.push(...this._getAttributesDiff(_, f, m)), l++, d++;
              } else
                l++, d++;
          }
          t.sort((n, i) => n.position.root != i.position.root ? n.position.root.rootName < i.position.root.rootName ? -1 : 1 : n.position.isEqual(i.position) ? n.changeCount - i.changeCount : n.position.isBefore(i.position) ? -1 : 1);
          for (let n = 1, i = 0; n < t.length; n++) {
            const r = t[i], s = t[n], a = r.type == "remove" && s.type == "remove" && r.name == "$text" && s.name == "$text" && r.position.isEqual(s.position), l = r.type == "insert" && s.type == "insert" && r.name == "$text" && s.name == "$text" && r.position.parent == s.position.parent && r.position.offset + r.length == s.position.offset, d = r.type == "attribute" && s.type == "attribute" && r.position.parent == s.position.parent && r.range.isFlat && s.range.isFlat && r.position.offset + r.length == s.position.offset && r.attributeKey == s.attributeKey && r.attributeOldValue == s.attributeOldValue && r.attributeNewValue == s.attributeNewValue;
            a || l || d ? (r.length++, d && (r.range.end = r.range.end.getShiftedBy(1)), t[n] = null) : i = n;
          }
          t = t.filter((n) => n);
          for (const n of t)
            delete n.changeCount, n.type == "attribute" && (delete n.position, delete n.length);
          return this._changeCount = 0, this._cachedChangesWithGraveyard = t, this._cachedChanges = t.filter(n1), e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
        }
        getChangedRoots() {
          return Array.from(this._changedRoots.values()).map((e) => {
            const t = ((n, i) => {
              for (var r in i || (i = {}))
                QC.call(i, r) && _g(n, r, i[r]);
              if (vg)
                for (var r of vg(i))
                  XC.call(i, r) && _g(n, r, i[r]);
              return n;
            })({}, e);
            return t.state !== void 0 && delete t.attributes, t;
          });
        }
        getRefreshedItems() {
          return new Set(this._refreshedItems);
        }
        reset() {
          this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems = /* @__PURE__ */ new Set(), this._cachedChanges = null;
        }
        _bufferRootStateChange(e, t) {
          if (!this._changedRoots.has(e))
            return void this._changedRoots.set(e, { name: e, state: t ? "attached" : "detached" });
          const n = this._changedRoots.get(e);
          n.state !== void 0 ? (delete n.state, n.attributes === void 0 && this._changedRoots.delete(e)) : n.state = t ? "attached" : "detached";
        }
        _bufferRootAttributeChange(e, t, n, i) {
          const r = this._changedRoots.get(e) || { name: e }, s = r.attributes || {};
          if (s[t]) {
            const a = s[t];
            i === a.oldValue ? delete s[t] : a.newValue = i;
          } else
            s[t] = { oldValue: n, newValue: i };
          Object.entries(s).length === 0 ? (delete r.attributes, r.state === void 0 && this._changedRoots.delete(e)) : (r.attributes = s, this._changedRoots.set(e, r));
        }
        _refreshItem(e) {
          if (this._isInInsertedElement(e.parent))
            return;
          this._markRemove(e.parent, e.startOffset, e.offsetSize), this._markInsert(e.parent, e.startOffset, e.offsetSize), this._refreshedItems.add(e);
          const t = $._createOn(e);
          for (const n of this._markerCollection.getMarkersIntersectingRange(t)) {
            const i = n.getData();
            this.bufferMarkerChange(n.name, i, i);
          }
          this._cachedChanges = null;
        }
        _markInsert(e, t, n) {
          const i = { type: "insert", offset: t, howMany: n, count: this._changeCount++ };
          this._markChange(e, i);
        }
        _markRemove(e, t, n) {
          const i = { type: "remove", offset: t, howMany: n, count: this._changeCount++ };
          this._markChange(e, i), this._removeAllNestedChanges(e, t, n);
        }
        _markAttribute(e) {
          const t = { type: "attribute", offset: e.startOffset, howMany: e.offsetSize, count: this._changeCount++ };
          this._markChange(e.parent, t);
        }
        _markChange(e, t) {
          this._makeSnapshot(e);
          const n = this._getChangesForElement(e);
          this._handleChange(t, n), n.push(t);
          for (let i = 0; i < n.length; i++)
            n[i].howMany < 1 && (n.splice(i, 1), i--);
        }
        _getChangesForElement(e) {
          let t;
          return this._changesInElement.has(e) ? t = this._changesInElement.get(e) : (t = [], this._changesInElement.set(e, t)), t;
        }
        _makeSnapshot(e) {
          this._elementSnapshots.has(e) || this._elementSnapshots.set(e, Ag(e.getChildren()));
        }
        _handleChange(e, t) {
          e.nodesToHandle = e.howMany;
          for (const n of t) {
            const i = e.offset + e.howMany, r = n.offset + n.howMany;
            if (e.type == "insert" && (n.type == "insert" && (e.offset <= n.offset ? n.offset += e.howMany : e.offset < r && (n.howMany += e.nodesToHandle, e.nodesToHandle = 0)), n.type == "remove" && e.offset < n.offset && (n.offset += e.howMany), n.type == "attribute")) {
              if (e.offset <= n.offset)
                n.offset += e.howMany;
              else if (e.offset < r) {
                const s = n.howMany;
                n.howMany = e.offset - n.offset, t.unshift({ type: "attribute", offset: i, howMany: s - n.howMany, count: this._changeCount++ });
              }
            }
            if (e.type == "remove") {
              if (n.type == "insert") {
                if (i <= n.offset)
                  n.offset -= e.howMany;
                else if (i <= r)
                  if (e.offset < n.offset) {
                    const s = i - n.offset;
                    n.offset = e.offset, n.howMany -= s, e.nodesToHandle -= s;
                  } else
                    n.howMany -= e.nodesToHandle, e.nodesToHandle = 0;
                else if (e.offset <= n.offset)
                  e.nodesToHandle -= n.howMany, n.howMany = 0;
                else if (e.offset < r) {
                  const s = r - e.offset;
                  n.howMany -= s, e.nodesToHandle -= s;
                }
              }
              if (n.type == "remove" && (i <= n.offset ? n.offset -= e.howMany : e.offset < n.offset && (e.nodesToHandle += n.howMany, n.howMany = 0)), n.type == "attribute") {
                if (i <= n.offset)
                  n.offset -= e.howMany;
                else if (e.offset < n.offset) {
                  const s = i - n.offset;
                  n.offset = e.offset, n.howMany -= s;
                } else if (e.offset < r)
                  if (i <= r) {
                    const s = n.howMany;
                    n.howMany = e.offset - n.offset;
                    const a = s - n.howMany - e.nodesToHandle;
                    t.unshift({ type: "attribute", offset: e.offset, howMany: a, count: this._changeCount++ });
                  } else
                    n.howMany -= r - e.offset;
              }
            }
            if (e.type == "attribute") {
              if (n.type == "insert")
                if (e.offset < n.offset && i > n.offset) {
                  if (i > r) {
                    const s = { type: "attribute", offset: r, howMany: i - r, count: this._changeCount++ };
                    this._handleChange(s, t), t.push(s);
                  }
                  e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle;
                } else
                  e.offset >= n.offset && e.offset < r && (i > r ? (e.nodesToHandle = i - r, e.offset = r) : e.nodesToHandle = 0);
              if (n.type == "remove" && e.offset < n.offset && i > n.offset) {
                const s = { type: "attribute", offset: n.offset, howMany: i - n.offset, count: this._changeCount++ };
                this._handleChange(s, t), t.push(s), e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle;
              }
              n.type == "attribute" && (e.offset >= n.offset && i <= r ? (e.nodesToHandle = 0, e.howMany = 0, e.offset = 0) : e.offset <= n.offset && i >= r && (n.howMany = 0));
            }
          }
          e.howMany = e.nodesToHandle, delete e.nodesToHandle;
        }
        _getInsertDiff(e, t, n) {
          return { type: "insert", position: W._createAt(e, t), name: n.name, attributes: new Map(n.attributes), length: 1, changeCount: this._changeCount++ };
        }
        _getRemoveDiff(e, t, n) {
          return { type: "remove", position: W._createAt(e, t), name: n.name, attributes: new Map(n.attributes), length: 1, changeCount: this._changeCount++ };
        }
        _getAttributesDiff(e, t, n) {
          const i = [];
          n = new Map(n);
          for (const [r, s] of t) {
            const a = n.has(r) ? n.get(r) : null;
            a !== s && i.push({ type: "attribute", position: e.start, range: e.clone(), length: 1, attributeKey: r, attributeOldValue: s, attributeNewValue: a, changeCount: this._changeCount++ }), n.delete(r);
          }
          for (const [r, s] of n)
            i.push({ type: "attribute", position: e.start, range: e.clone(), length: 1, attributeKey: r, attributeOldValue: null, attributeNewValue: s, changeCount: this._changeCount++ });
          return i;
        }
        _isInInsertedElement(e) {
          const t = e.parent;
          if (!t)
            return !1;
          const n = this._changesInElement.get(t), i = e.startOffset;
          if (n) {
            for (const r of n)
              if (r.type == "insert" && i >= r.offset && i < r.offset + r.howMany)
                return !0;
          }
          return this._isInInsertedElement(t);
        }
        _removeAllNestedChanges(e, t, n) {
          const i = new $(W._createAt(e, t), W._createAt(e, t + n));
          for (const r of i.getItems({ shallow: !0 }))
            r.is("element") && (this._elementSnapshots.delete(r), this._changesInElement.delete(r), this._removeAllNestedChanges(r, 0, r.maxOffset));
        }
      }
      function Ag(o) {
        const e = [];
        for (const t of o)
          if (t.is("$text"))
            for (let n = 0; n < t.data.length; n++)
              e.push({ name: "$text", attributes: new Map(t.getAttributes()) });
          else
            e.push({ name: t.name, attributes: new Map(t.getAttributes()) });
        return e;
      }
      function t1(o, e) {
        const t = [];
        let n = 0, i = 0;
        for (const r of e) {
          if (r.offset > n) {
            for (let s = 0; s < r.offset - n; s++)
              t.push("e");
            i += r.offset - n;
          }
          if (r.type == "insert") {
            for (let s = 0; s < r.howMany; s++)
              t.push("i");
            n = r.offset + r.howMany;
          } else if (r.type == "remove") {
            for (let s = 0; s < r.howMany; s++)
              t.push("r");
            n = r.offset, i += r.howMany;
          } else
            t.push(..."a".repeat(r.howMany).split("")), n = r.offset + r.howMany, i += r.howMany;
        }
        if (i < o)
          for (let r = 0; r < o - i - n; r++)
            t.push("e");
        return t;
      }
      function n1(o) {
        const e = "position" in o && o.position.root.rootName == "$graveyard", t = "range" in o && o.range.root.rootName == "$graveyard";
        return !e && !t;
      }
      class o1 {
        constructor() {
          this._operations = [], this._undoPairs = /* @__PURE__ */ new Map(), this._undoneOperations = /* @__PURE__ */ new Set(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map(), this._version = 0, this._gaps = /* @__PURE__ */ new Map();
        }
        get version() {
          return this._version;
        }
        set version(e) {
          this._operations.length && e > this._version + 1 && this._gaps.set(this._version, e), this._version = e;
        }
        get lastOperation() {
          return this._operations[this._operations.length - 1];
        }
        addOperation(e) {
          if (e.baseVersion !== this.version)
            throw new I("model-document-history-addoperation-incorrect-version", this, { operation: e, historyVersion: this.version });
          this._operations.push(e), this._version++, this._baseVersionToOperationIndex.set(e.baseVersion, this._operations.length - 1);
        }
        getOperations(e, t = this.version) {
          if (!this._operations.length)
            return [];
          const n = this._operations[0];
          e === void 0 && (e = n.baseVersion);
          let i = t - 1;
          for (const [a, l] of this._gaps)
            e > a && e < l && (e = l), i > a && i < l && (i = a - 1);
          if (i < n.baseVersion || e > this.lastOperation.baseVersion)
            return [];
          let r = this._baseVersionToOperationIndex.get(e);
          r === void 0 && (r = 0);
          let s = this._baseVersionToOperationIndex.get(i);
          return s === void 0 && (s = this._operations.length - 1), this._operations.slice(r, s + 1);
        }
        getOperation(e) {
          const t = this._baseVersionToOperationIndex.get(e);
          if (t !== void 0)
            return this._operations[t];
        }
        setOperationAsUndone(e, t) {
          this._undoPairs.set(t, e), this._undoneOperations.add(e);
        }
        isUndoingOperation(e) {
          return this._undoPairs.has(e);
        }
        isUndoneOperation(e) {
          return this._undoneOperations.has(e);
        }
        getUndoneOperation(e) {
          return this._undoPairs.get(e);
        }
        reset() {
          this._version = 0, this._undoPairs = /* @__PURE__ */ new Map(), this._operations = [], this._undoneOperations = /* @__PURE__ */ new Set(), this._gaps = /* @__PURE__ */ new Map(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
        }
      }
      class Gr extends $e {
        constructor(e, t, n = "main") {
          super(t), this._isAttached = !0, this._document = e, this.rootName = n;
        }
        get document() {
          return this._document;
        }
        isAttached() {
          return this._isAttached;
        }
        toJSON() {
          return this.rootName;
        }
      }
      Gr.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "rootElement" || o === "model:rootElement" || o === "element" || o === "model:element") : o === "rootElement" || o === "model:rootElement" || o === "element" || o === "model:element" || o === "node" || o === "model:node";
      };
      var i1 = Object.defineProperty, r1 = Object.defineProperties, s1 = Object.getOwnPropertyDescriptors, Cg = Object.getOwnPropertySymbols, a1 = Object.prototype.hasOwnProperty, l1 = Object.prototype.propertyIsEnumerable, yg = (o, e, t) => e in o ? i1(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Eg = (o, e) => {
        for (var t in e || (e = {}))
          a1.call(e, t) && yg(o, t, e[t]);
        if (Cg)
          for (var t of Cg(e))
            l1.call(e, t) && yg(o, t, e[t]);
        return o;
      }, xg = (o, e) => r1(o, s1(e));
      const Qa = "$graveyard";
      class c1 extends De() {
        constructor(e) {
          super(), this.model = e, this.history = new o1(), this.selection = new Zt(this), this.roots = new Vt({ idProperty: "rootName" }), this.differ = new e1(e.markers), this.isReadOnly = !1, this._postFixers = /* @__PURE__ */ new Set(), this._hasSelectionChangedFromTheLastChangeBlock = !1, this.createRoot("$root", Qa), this.listenTo(e, "applyOperation", (t, n) => {
            const i = n[0];
            i.isDocumentOperation && this.differ.bufferOperation(i);
          }, { priority: "high" }), this.listenTo(e, "applyOperation", (t, n) => {
            const i = n[0];
            i.isDocumentOperation && this.history.addOperation(i);
          }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
            this._hasSelectionChangedFromTheLastChangeBlock = !0;
          }), this.listenTo(e.markers, "update", (t, n, i, r, s) => {
            const a = xg(Eg({}, n.getData()), { range: r });
            this.differ.bufferMarkerChange(n.name, s, a), i === null && n.on("change", (l, d) => {
              const h = n.getData();
              this.differ.bufferMarkerChange(n.name, xg(Eg({}, h), { range: d }), h);
            });
          }), this.registerPostFixer((t) => {
            let n = !1;
            for (const i of this.roots)
              i.isAttached() || i.isEmpty || (t.remove(t.createRangeIn(i)), n = !0);
            for (const i of this.model.markers)
              i.getRange().root.isAttached() || (t.removeMarker(i), n = !0);
            return n;
          });
        }
        get version() {
          return this.history.version;
        }
        set version(e) {
          this.history.version = e;
        }
        get graveyard() {
          return this.getRoot(Qa);
        }
        createRoot(e = "$root", t = "main") {
          if (this.roots.get(t))
            throw new I("model-document-createroot-name-exists", this, { name: t });
          const n = new Gr(this, e, t);
          return this.roots.add(n), n;
        }
        destroy() {
          this.selection.destroy(), this.stopListening();
        }
        getRoot(e = "main") {
          return this.roots.get(e);
        }
        getRootNames(e = !1) {
          return Array.from(this.roots).filter((t) => t.rootName != Qa && (e || t.isAttached())).map((t) => t.rootName);
        }
        registerPostFixer(e) {
          this._postFixers.add(e);
        }
        toJSON() {
          const e = $u(this);
          return e.selection = "[engine.model.DocumentSelection]", e.model = "[engine.model.Model]", e;
        }
        _handleChangeBlock(e) {
          this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(e), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", e.batch) : this.fire("change", e.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = !1;
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
        }
        _getDefaultRoot() {
          for (const e of this.roots)
            if (e !== this.graveyard)
              return e;
          return this.graveyard;
        }
        _getDefaultRange() {
          const e = this._getDefaultRoot(), t = this.model, n = t.schema, i = t.createPositionFromPath(e, [0]);
          return n.getNearestSelectionRange(i) || t.createRange(i);
        }
        _validateSelectionRange(e) {
          return Sg(e.start) && Sg(e.end);
        }
        _callPostFixers(e) {
          let t = !1;
          do
            for (const n of this._postFixers)
              if (this.selection.refresh(), t = n(e), t)
                break;
          while (t);
        }
      }
      function Sg(o) {
        const e = o.textNode;
        if (e) {
          const t = e.data, n = o.offset - e.startOffset;
          return !ha(t, n) && !ga(t, n);
        }
        return !0;
      }
      var d1 = Object.defineProperty, u1 = Object.defineProperties, h1 = Object.getOwnPropertyDescriptors, Dg = Object.getOwnPropertySymbols, g1 = Object.prototype.hasOwnProperty, m1 = Object.prototype.propertyIsEnumerable, Bg = (o, e, t) => e in o ? d1(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class p1 extends De() {
        constructor() {
          super(...arguments), this._markers = /* @__PURE__ */ new Map();
        }
        [Symbol.iterator]() {
          return this._markers.values();
        }
        has(e) {
          const t = e instanceof Uo ? e.name : e;
          return this._markers.has(t);
        }
        get(e) {
          return this._markers.get(e) || null;
        }
        _set(e, t, n = !1, i = !1) {
          const r = e instanceof Uo ? e.name : e;
          if (r.includes(","))
            throw new I("markercollection-incorrect-marker-name", this);
          const s = this._markers.get(r);
          if (s) {
            const h = s.getData(), m = s.getRange();
            let f = !1;
            return m.isEqual(t) || (s._attachLiveRange(gn.fromRange(t)), f = !0), n != s.managedUsingOperations && (s._managedUsingOperations = n, f = !0), typeof i == "boolean" && i != s.affectsData && (s._affectsData = i, f = !0), f && this.fire(`update:${r}`, s, m, t, h), s;
          }
          const a = gn.fromRange(t), l = new Uo(r, a, n, i);
          var d;
          return this._markers.set(r, l), this.fire(`update:${r}`, l, null, t, (d = ((h, m) => {
            for (var f in m || (m = {}))
              g1.call(m, f) && Bg(h, f, m[f]);
            if (Dg)
              for (var f of Dg(m))
                m1.call(m, f) && Bg(h, f, m[f]);
            return h;
          })({}, l.getData()), u1(d, h1({ range: null })))), l;
        }
        _remove(e) {
          const t = e instanceof Uo ? e.name : e, n = this._markers.get(t);
          return !!n && (this._markers.delete(t), this.fire(`update:${t}`, n, n.getRange(), null, n.getData()), this._destroyMarker(n), !0);
        }
        _refresh(e) {
          const t = e instanceof Uo ? e.name : e, n = this._markers.get(t);
          if (!n)
            throw new I("markercollection-refresh-marker-not-exists", this);
          const i = n.getRange();
          this.fire(`update:${t}`, n, i, i, n.getData());
        }
        *getMarkersAtPosition(e) {
          for (const t of this)
            t.getRange().containsPosition(e) && (yield t);
        }
        *getMarkersIntersectingRange(e) {
          for (const t of this)
            t.getRange().getIntersection(e) !== null && (yield t);
        }
        destroy() {
          for (const e of this._markers.values())
            this._destroyMarker(e);
          this._markers = null, this.stopListening();
        }
        *getMarkersGroup(e) {
          for (const t of this._markers.values())
            t.name.startsWith(e + ":") && (yield t);
        }
        _destroyMarker(e) {
          e.stopListening(), e._detachLiveRange();
        }
      }
      class Uo extends De(Pn) {
        constructor(e, t, n, i) {
          super(), this.name = e, this._liveRange = this._attachLiveRange(t), this._managedUsingOperations = n, this._affectsData = i;
        }
        get managedUsingOperations() {
          if (!this._liveRange)
            throw new I("marker-destroyed", this);
          return this._managedUsingOperations;
        }
        get affectsData() {
          if (!this._liveRange)
            throw new I("marker-destroyed", this);
          return this._affectsData;
        }
        getData() {
          return { range: this.getRange(), affectsData: this.affectsData, managedUsingOperations: this.managedUsingOperations };
        }
        getStart() {
          if (!this._liveRange)
            throw new I("marker-destroyed", this);
          return this._liveRange.start.clone();
        }
        getEnd() {
          if (!this._liveRange)
            throw new I("marker-destroyed", this);
          return this._liveRange.end.clone();
        }
        getRange() {
          if (!this._liveRange)
            throw new I("marker-destroyed", this);
          return this._liveRange.toRange();
        }
        _attachLiveRange(e) {
          return this._liveRange && this._detachLiveRange(), e.delegate("change:range").to(this), e.delegate("change:content").to(this), this._liveRange = e, e;
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
        }
      }
      Uo.prototype.is = function(o) {
        return o === "marker" || o === "model:marker";
      };
      class f1 extends Mt {
        constructor(e, t) {
          super(null), this.sourcePosition = e.clone(), this.howMany = t;
        }
        get type() {
          return "detach";
        }
        get affectedSelectable() {
          return null;
        }
        toJSON() {
          const e = super.toJSON();
          return e.sourcePosition = this.sourcePosition.toJSON(), e;
        }
        _validate() {
          if (this.sourcePosition.root.document)
            throw new I("detach-operation-on-document-node", this);
        }
        _execute() {
          hg($._createFromPositionAndShift(this.sourcePosition, this.howMany));
        }
        static get className() {
          return "DetachOperation";
        }
      }
      class pn extends Pn {
        constructor(e) {
          super(), this.markers = /* @__PURE__ */ new Map(), this._children = new Oi(), e && this._insertChild(0, e);
        }
        [Symbol.iterator]() {
          return this.getChildren();
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get nextSibling() {
          return null;
        }
        get previousSibling() {
          return null;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get document() {
          return null;
        }
        isAttached() {
          return !1;
        }
        getAncestors() {
          return [];
        }
        getChild(e) {
          return this._children.getNode(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(e) {
          return this._children.getNodeIndex(e);
        }
        getChildStartOffset(e) {
          return this._children.getNodeStartOffset(e);
        }
        getPath() {
          return [];
        }
        getNodeByPath(e) {
          let t = this;
          for (const n of e)
            t = t.getChild(t.offsetToIndex(n));
          return t;
        }
        offsetToIndex(e) {
          return this._children.offsetToIndex(e);
        }
        toJSON() {
          const e = [];
          for (const t of this._children)
            e.push(t.toJSON());
          return e;
        }
        static fromJSON(e) {
          const t = [];
          for (const n of e)
            n.name ? t.push($e.fromJSON(n)) : t.push(Fe.fromJSON(n));
          return new pn(t);
        }
        _appendChild(e) {
          this._insertChild(this.childCount, e);
        }
        _insertChild(e, t) {
          const n = function(i) {
            return typeof i == "string" ? [new Fe(i)] : (It(i) || (i = [i]), Array.from(i).map((r) => typeof r == "string" ? new Fe(r) : r instanceof Kt ? new Fe(r.data, r.getAttributes()) : r));
          }(t);
          for (const i of n)
            i.parent !== null && i._remove(), i.parent = this;
          this._children._insertNodes(e, n);
        }
        _removeChildren(e, t = 1) {
          const n = this._children._removeNodes(e, t);
          for (const i of n)
            i.parent = null;
          return n;
        }
      }
      pn.prototype.is = function(o) {
        return o === "documentFragment" || o === "model:documentFragment";
      };
      class b1 {
        constructor(e, t) {
          this.model = e, this.batch = t;
        }
        createText(e, t) {
          return new Fe(e, t);
        }
        createElement(e, t) {
          return new $e(e, t);
        }
        createDocumentFragment() {
          return new pn();
        }
        cloneElement(e, t = !0) {
          return e._clone(t);
        }
        insert(e, t, n = 0) {
          if (this._assertWriterUsedCorrectly(), e instanceof Fe && e.data == "")
            return;
          const i = W._createAt(t, n);
          if (e.parent) {
            if (Ig(e.root, i.root))
              return void this.move($._createOn(e), i);
            if (e.root.document)
              throw new I("model-writer-insert-forbidden-move", this);
            this.remove(e);
          }
          const r = i.root.document ? i.root.document.version : null, s = new ht(i, e, r);
          if (e instanceof Fe && (s.shouldReceiveAttributes = !0), this.batch.addOperation(s), this.model.applyOperation(s), e instanceof pn)
            for (const [a, l] of e.markers) {
              const d = W._createAt(l.root, 0), h = { range: new $(l.start._getCombined(d, i), l.end._getCombined(d, i)), usingOperation: !0, affectsData: !0 };
              this.model.markers.has(a) ? this.updateMarker(a, h) : this.addMarker(a, h);
            }
        }
        insertText(e, t, n, i) {
          t instanceof pn || t instanceof $e || t instanceof W ? this.insert(this.createText(e), t, n) : this.insert(this.createText(e, t), n, i);
        }
        insertElement(e, t, n, i) {
          t instanceof pn || t instanceof $e || t instanceof W ? this.insert(this.createElement(e), t, n) : this.insert(this.createElement(e, t), n, i);
        }
        append(e, t) {
          this.insert(e, t, "end");
        }
        appendText(e, t, n) {
          t instanceof pn || t instanceof $e ? this.insert(this.createText(e), t, "end") : this.insert(this.createText(e, t), n, "end");
        }
        appendElement(e, t, n) {
          t instanceof pn || t instanceof $e ? this.insert(this.createElement(e), t, "end") : this.insert(this.createElement(e, t), n, "end");
        }
        setAttribute(e, t, n) {
          if (this._assertWriterUsedCorrectly(), n instanceof $) {
            const i = n.getMinimalFlatRanges();
            for (const r of i)
              Tg(this, e, t, r);
          } else
            Pg(this, e, t, n);
        }
        setAttributes(e, t) {
          for (const [n, i] of hn(e))
            this.setAttribute(n, i, t);
        }
        removeAttribute(e, t) {
          if (this._assertWriterUsedCorrectly(), t instanceof $) {
            const n = t.getMinimalFlatRanges();
            for (const i of n)
              Tg(this, e, null, i);
          } else
            Pg(this, e, null, t);
        }
        clearAttributes(e) {
          this._assertWriterUsedCorrectly();
          const t = (n) => {
            for (const i of n.getAttributeKeys())
              this.removeAttribute(i, n);
          };
          if (e instanceof $)
            for (const n of e.getItems())
              t(n);
          else
            t(e);
        }
        move(e, t, n) {
          if (this._assertWriterUsedCorrectly(), !(e instanceof $))
            throw new I("writer-move-invalid-range", this);
          if (!e.isFlat)
            throw new I("writer-move-range-not-flat", this);
          const i = W._createAt(t, n);
          if (i.isEqual(e.start))
            return;
          if (this._addOperationForAffectedMarkers("move", e), !Ig(e.root, i.root))
            throw new I("writer-move-different-document", this);
          const r = e.root.document ? e.root.document.version : null, s = new Be(e.start, e.end.offset - e.start.offset, i, r);
          this.batch.addOperation(s), this.model.applyOperation(s);
        }
        remove(e) {
          this._assertWriterUsedCorrectly();
          const t = (e instanceof $ ? e : $._createOn(e)).getMinimalFlatRanges().reverse();
          for (const n of t)
            this._addOperationForAffectedMarkers("move", n), k1(n.start, n.end.offset - n.start.offset, this.batch, this.model);
        }
        merge(e) {
          this._assertWriterUsedCorrectly();
          const t = e.nodeBefore, n = e.nodeAfter;
          if (this._addOperationForAffectedMarkers("merge", e), !(t instanceof $e))
            throw new I("writer-merge-no-element-before", this);
          if (!(n instanceof $e))
            throw new I("writer-merge-no-element-after", this);
          e.root.document ? this._merge(e) : this._mergeDetached(e);
        }
        createPositionFromPath(e, t, n) {
          return this.model.createPositionFromPath(e, t, n);
        }
        createPositionAt(e, t) {
          return this.model.createPositionAt(e, t);
        }
        createPositionAfter(e) {
          return this.model.createPositionAfter(e);
        }
        createPositionBefore(e) {
          return this.model.createPositionBefore(e);
        }
        createRange(e, t) {
          return this.model.createRange(e, t);
        }
        createRangeIn(e) {
          return this.model.createRangeIn(e);
        }
        createRangeOn(e) {
          return this.model.createRangeOn(e);
        }
        createSelection(...e) {
          return this.model.createSelection(...e);
        }
        _mergeDetached(e) {
          const t = e.nodeBefore, n = e.nodeAfter;
          this.move($._createIn(n), W._createAt(t, "end")), this.remove(n);
        }
        _merge(e) {
          const t = W._createAt(e.nodeBefore, "end"), n = W._createAt(e.nodeAfter, 0), i = e.root.document.graveyard, r = new W(i, [0]), s = e.root.document.version, a = new et(n, e.nodeAfter.maxOffset, t, r, s);
          this.batch.addOperation(a), this.model.applyOperation(a);
        }
        rename(e, t) {
          if (this._assertWriterUsedCorrectly(), !(e instanceof $e))
            throw new I("writer-rename-not-element-instance", this);
          const n = e.root.document ? e.root.document.version : null, i = new Et(W._createBefore(e), e.name, t, n);
          this.batch.addOperation(i), this.model.applyOperation(i);
        }
        split(e, t) {
          this._assertWriterUsedCorrectly();
          let n, i, r = e.parent;
          if (!r.parent)
            throw new I("writer-split-element-no-parent", this);
          if (t || (t = r.parent), !e.parent.getAncestors({ includeSelf: !0 }).includes(t))
            throw new I("writer-split-invalid-limit-element", this);
          do {
            const s = r.root.document ? r.root.document.version : null, a = r.maxOffset - e.offset, l = Le.getInsertionPosition(e), d = new Le(e, a, l, null, s);
            this.batch.addOperation(d), this.model.applyOperation(d), n || i || (n = r, i = e.parent.nextSibling), r = (e = this.createPositionAfter(e.parent)).parent;
          } while (r !== t);
          return { position: e, range: new $(W._createAt(n, "end"), W._createAt(i, 0)) };
        }
        wrap(e, t) {
          if (this._assertWriterUsedCorrectly(), !e.isFlat)
            throw new I("writer-wrap-range-not-flat", this);
          const n = t instanceof $e ? t : new $e(t);
          if (n.childCount > 0)
            throw new I("writer-wrap-element-not-empty", this);
          if (n.parent !== null)
            throw new I("writer-wrap-element-attached", this);
          this.insert(n, e.start);
          const i = new $(e.start.getShiftedBy(1), e.end.getShiftedBy(1));
          this.move(i, W._createAt(n, 0));
        }
        unwrap(e) {
          if (this._assertWriterUsedCorrectly(), e.parent === null)
            throw new I("writer-unwrap-element-no-parent", this);
          this.move($._createIn(e), this.createPositionAfter(e)), this.remove(e);
        }
        addMarker(e, t) {
          if (this._assertWriterUsedCorrectly(), !t || typeof t.usingOperation != "boolean")
            throw new I("writer-addmarker-no-usingoperation", this);
          const n = t.usingOperation, i = t.range, r = t.affectsData !== void 0 && t.affectsData;
          if (this.model.markers.has(e))
            throw new I("writer-addmarker-marker-exists", this);
          if (!i)
            throw new I("writer-addmarker-no-range", this);
          return n ? (Li(this, e, null, i, r), this.model.markers.get(e)) : this.model.markers._set(e, i, n, r);
        }
        updateMarker(e, t) {
          this._assertWriterUsedCorrectly();
          const n = typeof e == "string" ? e : e.name, i = this.model.markers.get(n);
          if (!i)
            throw new I("writer-updatemarker-marker-not-exists", this);
          if (!t)
            return ne("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n }), void this.model.markers._refresh(i);
          const r = typeof t.usingOperation == "boolean", s = typeof t.affectsData == "boolean", a = s ? t.affectsData : i.affectsData;
          if (!r && !t.range && !s)
            throw new I("writer-updatemarker-wrong-options", this);
          const l = i.getRange(), d = t.range ? t.range : l;
          r && t.usingOperation !== i.managedUsingOperations ? t.usingOperation ? Li(this, n, null, d, a) : (Li(this, n, l, null, a), this.model.markers._set(n, d, void 0, a)) : i.managedUsingOperations ? Li(this, n, l, d, a) : this.model.markers._set(n, d, void 0, a);
        }
        removeMarker(e) {
          this._assertWriterUsedCorrectly();
          const t = typeof e == "string" ? e : e.name;
          if (!this.model.markers.has(t))
            throw new I("writer-removemarker-no-marker", this);
          const n = this.model.markers.get(t);
          if (!n.managedUsingOperations)
            return void this.model.markers._remove(t);
          Li(this, t, n.getRange(), null, n.affectsData);
        }
        addRoot(e, t = "$root") {
          this._assertWriterUsedCorrectly();
          const n = this.model.document.getRoot(e);
          if (n && n.isAttached())
            throw new I("writer-addroot-root-exists", this);
          const i = this.model.document, r = new sn(e, t, !0, i, i.version);
          return this.batch.addOperation(r), this.model.applyOperation(r), this.model.document.getRoot(e);
        }
        detachRoot(e) {
          this._assertWriterUsedCorrectly();
          const t = typeof e == "string" ? this.model.document.getRoot(e) : e;
          if (!t || !t.isAttached())
            throw new I("writer-detachroot-no-root", this);
          for (const r of this.model.markers)
            r.getRange().root === t && this.removeMarker(r);
          for (const r of t.getAttributeKeys())
            this.removeAttribute(r, t);
          this.remove(this.createRangeIn(t));
          const n = this.model.document, i = new sn(t.rootName, t.name, !1, n, n.version);
          this.batch.addOperation(i), this.model.applyOperation(i);
        }
        setSelection(...e) {
          this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...e);
        }
        setSelectionFocus(e, t) {
          this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(e, t);
        }
        setSelectionAttribute(e, t) {
          if (this._assertWriterUsedCorrectly(), typeof e == "string")
            this._setSelectionAttribute(e, t);
          else
            for (const [n, i] of hn(e))
              this._setSelectionAttribute(n, i);
        }
        removeSelectionAttribute(e) {
          if (this._assertWriterUsedCorrectly(), typeof e == "string")
            this._removeSelectionAttribute(e);
          else
            for (const t of e)
              this._removeSelectionAttribute(t);
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity();
        }
        restoreSelectionGravity(e) {
          this.model.document.selection._restoreGravity(e);
        }
        _setSelectionAttribute(e, t) {
          const n = this.model.document.selection;
          if (n.isCollapsed && n.anchor.parent.isEmpty) {
            const i = Zt._getStoreAttributeKey(e);
            this.setAttribute(i, t, n.anchor.parent);
          }
          n._setAttribute(e, t);
        }
        _removeSelectionAttribute(e) {
          const t = this.model.document.selection;
          if (t.isCollapsed && t.anchor.parent.isEmpty) {
            const n = Zt._getStoreAttributeKey(e);
            this.removeAttribute(n, t.anchor.parent);
          }
          t._removeAttribute(e);
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this)
            throw new I("writer-incorrect-use", this);
        }
        _addOperationForAffectedMarkers(e, t) {
          for (const n of this.model.markers) {
            if (!n.managedUsingOperations)
              continue;
            const i = n.getRange();
            let r = !1;
            if (e === "move") {
              const s = t;
              r = s.containsPosition(i.start) || s.start.isEqual(i.start) || s.containsPosition(i.end) || s.end.isEqual(i.end);
            } else {
              const s = t, a = s.nodeBefore, l = s.nodeAfter, d = i.start.parent == a && i.start.isAtEnd, h = i.end.parent == l && i.end.offset == 0, m = i.end.nodeAfter == l, f = i.start.nodeAfter == l;
              r = d || h || m || f;
            }
            r && this.updateMarker(n.name, { range: i });
          }
        }
      }
      function Tg(o, e, t, n) {
        const i = o.model, r = i.document;
        let s, a, l, d = n.start;
        for (const m of n.getWalker({ shallow: !0 }))
          l = m.item.getAttribute(e), s && a != l && (a != t && h(), d = s), s = m.nextPosition, a = l;
        function h() {
          const m = new $(d, s), f = m.root.document ? r.version : null, _ = new rt(m, e, a, t, f);
          o.batch.addOperation(_), i.applyOperation(_);
        }
        s instanceof W && s != d && a != t && h();
      }
      function Pg(o, e, t, n) {
        const i = o.model, r = i.document, s = n.getAttribute(e);
        let a, l;
        if (s != t) {
          if (n.root === n) {
            const d = n.document ? r.version : null;
            l = new mn(n, e, s, t, d);
          } else {
            a = new $(W._createBefore(n), o.createPositionAfter(n));
            const d = a.root.document ? r.version : null;
            l = new rt(a, e, s, t, d);
          }
          o.batch.addOperation(l), i.applyOperation(l);
        }
      }
      function Li(o, e, t, n, i) {
        const r = o.model, s = r.document, a = new yt(e, t, n, r.markers, !!i, s.version);
        o.batch.addOperation(a), r.applyOperation(a);
      }
      function k1(o, e, t, n) {
        let i;
        if (o.root.document) {
          const r = n.document, s = new W(r.graveyard, [0]);
          i = new Be(o, e, s, r.version);
        } else
          i = new f1(o, e);
        t.addOperation(i), n.applyOperation(i);
      }
      function Ig(o, e) {
        return o === e || o instanceof Gr && e instanceof Gr;
      }
      function w1(o, e, t = {}) {
        if (e.isCollapsed)
          return;
        const n = e.getFirstRange();
        if (n.root.rootName == "$graveyard")
          return;
        const i = o.schema;
        o.change((r) => {
          if (!t.doNotResetEntireContent && function(d, h) {
            const m = d.getLimitElement(h);
            if (!h.containsEntireContent(m))
              return !1;
            const f = h.getFirstRange();
            return f.start.parent == f.end.parent ? !1 : d.checkChild(m, "paragraph");
          }(i, e))
            return void function(d, h) {
              const m = d.model.schema.getLimitElement(h);
              d.remove(d.createRangeIn(m)), zg(d, d.createPositionAt(m, 0), h);
            }(r, e);
          const s = {};
          if (!t.doNotAutoparagraph) {
            const d = e.getSelectedElement();
            d && Object.assign(s, i.getAttributesWithProperty(d, "copyOnReplace", !0));
          }
          const [a, l] = function(d) {
            const h = d.root.document.model, m = d.start;
            let f = d.end;
            if (h.hasContent(d, { ignoreMarkers: !0 })) {
              const _ = function(E) {
                const B = E.parent, T = B.root.document.model.schema, O = B.getAncestors({ parentFirst: !0, includeSelf: !0 });
                for (const N of O) {
                  if (T.isLimit(N))
                    return null;
                  if (T.isBlock(N))
                    return N;
                }
              }(f);
              if (_ && f.isTouching(h.createPositionAt(_, 0))) {
                const E = h.createSelection(d);
                h.modifySelection(E, { direction: "backward" });
                const B = E.getLastPosition(), T = h.createRange(B, f);
                h.hasContent(T, { ignoreMarkers: !0 }) || (f = B);
              }
            }
            return [xt.fromPosition(m, "toPrevious"), xt.fromPosition(f, "toNext")];
          }(n);
          a.isTouching(l) || r.remove(r.createRange(a, l)), t.leaveUnmerged || (function(d, h, m) {
            const f = d.model;
            if (!Xa(d.model.schema, h, m))
              return;
            const [_, E] = function(B, T) {
              const O = B.getAncestors(), N = T.getAncestors();
              let H = 0;
              for (; O[H] && O[H] == N[H]; )
                H++;
              return [O[H], N[H]];
            }(h, m);
            !_ || !E || (!f.hasContent(_, { ignoreMarkers: !0 }) && f.hasContent(E, { ignoreMarkers: !0 }) ? Rg(d, h, m, _.parent) : Og(d, h, m, _.parent));
          }(r, a, l), i.removeDisallowedAttributes(a.parent.getChildren(), r)), Mg(r, e, a), !t.doNotAutoparagraph && function(d, h) {
            const m = d.checkChild(h, "$text"), f = d.checkChild(h, "paragraph");
            return !m && f;
          }(i, a) && zg(r, a, e, s), a.detach(), l.detach();
        });
      }
      function Og(o, e, t, n) {
        const i = e.parent, r = t.parent;
        if (i != n && r != n) {
          for (e = o.createPositionAfter(i), (t = o.createPositionBefore(r)).isEqual(e) || o.insert(r, e), o.merge(e); t.parent.isEmpty; ) {
            const s = t.parent;
            t = o.createPositionBefore(s), o.remove(s);
          }
          Xa(o.model.schema, e, t) && Og(o, e, t, n);
        }
      }
      function Rg(o, e, t, n) {
        const i = e.parent, r = t.parent;
        if (i != n && r != n) {
          for (e = o.createPositionAfter(i), (t = o.createPositionBefore(r)).isEqual(e) || o.insert(i, t); e.parent.isEmpty; ) {
            const s = e.parent;
            e = o.createPositionBefore(s), o.remove(s);
          }
          t = o.createPositionBefore(r), function(s, a) {
            const l = a.nodeBefore, d = a.nodeAfter;
            l.name != d.name && s.rename(l, d.name), s.clearAttributes(l), s.setAttributes(Object.fromEntries(d.getAttributes()), l), s.merge(a);
          }(o, t), Xa(o.model.schema, e, t) && Rg(o, e, t, n);
        }
      }
      function Xa(o, e, t) {
        const n = e.parent, i = t.parent;
        return n != i && !o.isLimit(n) && !o.isLimit(i) && function(r, s, a) {
          const l = new $(r, s);
          for (const d of l.getWalker())
            if (a.isLimit(d.item))
              return !1;
          return !0;
        }(e, t, o);
      }
      function zg(o, e, t, n = {}) {
        const i = o.createElement("paragraph");
        o.model.schema.setAllowedAttributes(i, n, o), o.insert(i, e), Mg(o, t, o.createPositionAt(i, 0));
      }
      function Mg(o, e, t) {
        e instanceof Zt ? o.setSelection(t) : e.setTo(t);
      }
      function Ng(o, e) {
        const t = [];
        Array.from(o.getItems({ direction: "backward" })).map((n) => e.createRangeOn(n)).filter((n) => (n.start.isAfter(o.start) || n.start.isEqual(o.start)) && (n.end.isBefore(o.end) || n.end.isEqual(o.end))).forEach((n) => {
          t.push(n.start.parent), e.remove(n);
        }), t.forEach((n) => {
          let i = n;
          for (; i.parent && i.isEmpty; ) {
            const r = e.createRangeOn(i);
            i = i.parent, e.remove(r);
          }
        });
      }
      class v1 {
        constructor(e, t, n) {
          this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null, this._nodeToSelect = null, this.model = e, this.writer = t, this.position = n, this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]), this.schema = e.schema, this._documentFragment = t.createDocumentFragment(), this._documentFragmentPosition = t.createPositionAt(this._documentFragment, 0);
        }
        handleNodes(e) {
          for (const t of Array.from(e))
            this._handleNode(t);
          this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
        }
        _updateLastNodeFromAutoParagraph(e) {
          const t = this.writer.createPositionAfter(this._lastNode), n = this.writer.createPositionAfter(e);
          if (n.isAfter(t)) {
            if (this._lastNode = e, this.position.parent != e || !this.position.isAtEnd)
              throw new I("insertcontent-invalid-insertion-position", this);
            this.position = n, this._setAffectedBoundaries(this.position);
          }
        }
        getSelectionRange() {
          return this._nodeToSelect ? $._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
        }
        getAffectedRange() {
          return this._affectedStart ? new $(this._affectedStart, this._affectedEnd) : null;
        }
        destroy() {
          this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
        }
        _handleNode(e) {
          if (this.schema.isObject(e))
            return void this._handleObject(e);
          let t = this._checkAndAutoParagraphToAllowedPosition(e);
          t || (t = this._checkAndSplitToAllowedPosition(e), t) ? (this._appendToFragment(e), this._firstNode || (this._firstNode = e), this._lastNode = e) : this._handleDisallowedNode(e);
        }
        _insertPartialFragment() {
          if (this._documentFragment.isEmpty)
            return;
          const e = xt.fromPosition(this.position, "toNext");
          this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = e.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = e.toPosition(), e.detach();
        }
        _handleObject(e) {
          this._checkAndSplitToAllowedPosition(e) ? this._appendToFragment(e) : this._tryAutoparagraphing(e);
        }
        _handleDisallowedNode(e) {
          e.is("element") ? this.handleNodes(e.getChildren()) : this._tryAutoparagraphing(e);
        }
        _appendToFragment(e) {
          if (!this.schema.checkChild(this.position, e))
            throw new I("insertcontent-wrong-position", this, { node: e, position: this.position });
          this.writer.insert(e, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(e.offsetSize), this.schema.isObject(e) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = e : this._nodeToSelect = null, this._filterAttributesOf.push(e);
        }
        _setAffectedBoundaries(e) {
          this._affectedStart || (this._affectedStart = xt.fromPosition(e, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(e) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = xt.fromPosition(e, "toNext"));
        }
        _mergeOnLeft() {
          const e = this._firstNode;
          if (!(e instanceof $e) || !this._canMergeLeft(e))
            return;
          const t = xt._createBefore(e);
          t.stickiness = "toNext";
          const n = xt.fromPosition(this.position, "toNext");
          this._affectedStart.isEqual(t) && (this._affectedStart.detach(), this._affectedStart = xt._createAt(t.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = xt._createAt(t.nodeBefore, "end", "toNext")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
        }
        _mergeOnRight() {
          const e = this._lastNode;
          if (!(e instanceof $e) || !this._canMergeRight(e))
            return;
          const t = xt._createAfter(e);
          if (t.stickiness = "toNext", !this.position.isEqual(t))
            throw new I("insertcontent-invalid-insertion-position", this);
          this.position = W._createAt(t.nodeBefore, "end");
          const n = xt.fromPosition(this.position, "toPrevious");
          this._affectedEnd.isEqual(t) && (this._affectedEnd.detach(), this._affectedEnd = xt._createAt(t.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = xt._createAt(t.nodeBefore, 0, "toPrevious")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
        }
        _canMergeLeft(e) {
          const t = e.previousSibling;
          return t instanceof $e && this.canMergeWith.has(t) && this.model.schema.checkMerge(t, e);
        }
        _canMergeRight(e) {
          const t = e.nextSibling;
          return t instanceof $e && this.canMergeWith.has(t) && this.model.schema.checkMerge(e, t);
        }
        _tryAutoparagraphing(e) {
          const t = this.writer.createElement("paragraph");
          this._getAllowedIn(this.position.parent, t) && this.schema.checkChild(t, e) && (t._appendChild(e), this._handleNode(t));
        }
        _checkAndAutoParagraphToAllowedPosition(e) {
          if (this.schema.checkChild(this.position.parent, e))
            return !0;
          if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", e))
            return !1;
          this._insertPartialFragment();
          const t = this.writer.createElement("paragraph");
          return this.writer.insert(t, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = t, this.position = this.writer.createPositionAt(t, 0), !0;
        }
        _checkAndSplitToAllowedPosition(e) {
          const t = this._getAllowedIn(this.position.parent, e);
          if (!t)
            return !1;
          for (t != this.position.parent && this._insertPartialFragment(); t != this.position.parent; )
            if (this.position.isAtStart) {
              const n = this.position.parent;
              this.position = this.writer.createPositionBefore(n), n.isEmpty && n.parent === t && this.writer.remove(n);
            } else if (this.position.isAtEnd)
              this.position = this.writer.createPositionAfter(this.position.parent);
            else {
              const n = this.writer.createPositionAfter(this.position.parent);
              this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = n, this.canMergeWith.add(this.position.nodeAfter);
            }
          return !0;
        }
        _getAllowedIn(e, t) {
          return this.schema.checkChild(e, t) ? e : this.schema.isLimit(e) ? null : this._getAllowedIn(e.parent, t);
        }
      }
      function Fg(o, e, t = "auto") {
        const n = o.getSelectedElement();
        if (n && e.schema.isObject(n) && !e.schema.isInline(n))
          return t == "before" || t == "after" ? e.createRange(e.createPositionAt(n, t)) : e.createRangeOn(n);
        const i = it(o.getSelectedBlocks());
        if (!i)
          return e.createRange(o.focus);
        if (i.isEmpty)
          return e.createRange(e.createPositionAt(i, 0));
        const r = e.createPositionAfter(i);
        return o.focus.isTouching(r) ? e.createRange(r) : e.createRange(e.createPositionBefore(i));
      }
      function _1(o, e, t, n = {}) {
        if (!o.schema.isObject(e))
          throw new I("insertobject-element-not-an-object", o, { object: e });
        const i = t || o.document.selection;
        let r = i;
        n.findOptimalPosition && o.schema.isBlock(e) && (r = o.createSelection(Fg(i, o, n.findOptimalPosition)));
        const s = it(i.getSelectedBlocks()), a = {};
        return s && Object.assign(a, o.schema.getAttributesWithProperty(s, "copyOnReplace", !0)), o.change((l) => {
          r.isCollapsed || o.deleteContent(r, { doNotAutoparagraph: !0 });
          let d = e;
          const h = r.anchor.parent;
          !o.schema.checkChild(h, e) && o.schema.checkChild(h, "paragraph") && o.schema.checkChild("paragraph", e) && (d = l.createElement("paragraph"), l.insert(e, d)), o.schema.setAllowedAttributes(d, a, l);
          const m = o.insertContent(d, r);
          return m.isCollapsed || n.setSelection && function(f, _, E, B) {
            const T = f.model;
            if (E == "on")
              return void f.setSelection(_, "on");
            if (E != "after")
              throw new I("insertobject-invalid-place-parameter-value", T);
            let O = _.nextSibling;
            if (T.schema.isInline(_))
              return void f.setSelection(_, "after");
            !(O && T.schema.checkChild(O, "$text")) && T.schema.checkChild(_.parent, "paragraph") && (O = f.createElement("paragraph"), T.schema.setAllowedAttributes(O, B, f), T.insertContent(O, f.createPositionAfter(_))), O && f.setSelection(O, 0);
          }(l, e, n.setSelection, a), m;
        });
      }
      const A1 = ' ,.?!:;"-()';
      function C1(o, e) {
        const { isForward: t, walker: n, unit: i, schema: r, treatEmojiAsSingleUnit: s } = o, { type: a, item: l, nextPosition: d } = e;
        if (a == "text")
          return o.unit === "word" ? function(h, m) {
            let f = h.position.textNode;
            for (f || (f = m ? h.position.nodeAfter : h.position.nodeBefore); f && f.is("$text"); ) {
              const _ = h.position.offset - f.startOffset;
              if (x1(f, _, m))
                f = m ? h.position.nodeAfter : h.position.nodeBefore;
              else {
                if (E1(f.data, _, m))
                  break;
                h.next();
              }
            }
            return h.position;
          }(n, t) : function(h, m, f) {
            const _ = h.position.textNode;
            if (_) {
              const E = _.data;
              let B = h.position.offset - _.startOffset;
              for (; ha(E, B) || m == "character" && ga(E, B) || f && ru(E, B); )
                h.next(), B = h.position.offset - _.startOffset;
            }
            return h.position;
          }(n, i, s);
        if (a == (t ? "elementStart" : "elementEnd")) {
          if (r.isSelectable(l))
            return W._createAt(l, t ? "after" : "before");
          if (r.checkChild(d, "$text"))
            return d;
        } else {
          if (r.isLimit(l))
            return void n.skip(() => !0);
          if (r.checkChild(d, "$text"))
            return d;
        }
      }
      function y1(o, e) {
        const t = o.root, n = W._createAt(t, e ? "end" : 0);
        return e ? new $(o, n) : new $(n, o);
      }
      function E1(o, e, t) {
        const n = e + (t ? 0 : -1);
        return A1.includes(o.charAt(n));
      }
      function x1(o, e, t) {
        return e === (t ? o.offsetSize : 0);
      }
      class S1 extends oe() {
        constructor() {
          super(), this.markers = new p1(), this.document = new c1(this), this.schema = new CC(), this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((e) => this.decorate(e)), this.on("applyOperation", (e, t) => {
            t[0]._validate();
          }, { priority: "highest" }), this.schema.register("$root", { isLimit: !0 }), this.schema.register("$container", { allowIn: ["$root", "$container"] }), this.schema.register("$block", { allowIn: ["$root", "$container"], isBlock: !0 }), this.schema.register("$blockObject", { allowWhere: "$block", isBlock: !0, isObject: !0 }), this.schema.register("$inlineObject", { allowWhere: "$text", allowAttributesOf: "$text", isInline: !0, isObject: !0 }), this.schema.register("$text", { allowIn: "$block", isInline: !0, isContent: !0 }), this.schema.register("$clipboardHolder", { allowContentOf: "$root", allowChildren: "$text", isLimit: !0 }), this.schema.register("$documentFragment", { allowContentOf: "$root", allowChildren: "$text", isLimit: !0 }), this.schema.register("$marker"), this.schema.addChildCheck((e, t) => {
            if (t.name === "$marker")
              return !0;
          }), vC(this), this.document.registerPostFixer(Jh), this.on("insertContent", (e, [t, n]) => {
            e.return = function(i, r, s) {
              return i.change((a) => {
                const l = s || i.document.selection;
                l.isCollapsed || i.deleteContent(l, { doNotAutoparagraph: !0 });
                const d = new v1(i, a, l.anchor), h = [];
                let m;
                if (r.is("documentFragment")) {
                  if (r.markers.size) {
                    const E = [];
                    for (const [B, T] of r.markers) {
                      const { start: O, end: N } = T, H = O.isEqual(N);
                      E.push({ position: O, name: B, isCollapsed: H }, { position: N, name: B, isCollapsed: H });
                    }
                    E.sort(({ position: B }, { position: T }) => B.isBefore(T) ? 1 : -1);
                    for (const { position: B, name: T, isCollapsed: O } of E) {
                      let N = null, H = null;
                      const X = B.parent === r && B.isAtStart, be = B.parent === r && B.isAtEnd;
                      X || be ? O && (H = X ? "start" : "end") : (N = a.createElement("$marker"), a.insert(N, B)), h.push({ name: T, element: N, collapsed: H });
                    }
                  }
                  m = r.getChildren();
                } else
                  m = [r];
                d.handleNodes(m);
                let f = d.getSelectionRange();
                if (r.is("documentFragment") && h.length) {
                  const E = f ? gn.fromRange(f) : null, B = {};
                  for (let T = h.length - 1; T >= 0; T--) {
                    const { name: O, element: N, collapsed: H } = h[T], X = !B[O];
                    if (X && (B[O] = []), N) {
                      const be = a.createPositionAt(N, "before");
                      B[O].push(be), a.remove(N);
                    } else {
                      const be = d.getAffectedRange();
                      if (!be) {
                        H && B[O].push(d.position);
                        continue;
                      }
                      H ? B[O].push(be[H]) : B[O].push(X ? be.start : be.end);
                    }
                  }
                  for (const [T, [O, N]] of Object.entries(B))
                    O && N && O.root === N.root && a.addMarker(T, { usingOperation: !0, affectsData: !0, range: new $(O, N) });
                  E && (f = E.toRange(), E.detach());
                }
                f && (l instanceof Zt ? a.setSelection(f) : l.setTo(f));
                const _ = d.getAffectedRange() || i.createRange(l.anchor);
                return d.destroy(), _;
              });
            }(this, t, n);
          }), this.on("insertObject", (e, [t, n, i]) => {
            e.return = _1(this, t, n, i);
          }), this.on("canEditAt", (e) => {
            const t = !this.document.isReadOnly;
            e.return = t, t || e.stop();
          });
        }
        change(e) {
          try {
            return this._pendingChanges.length === 0 ? (this._pendingChanges.push({ batch: new Ho(), callback: e }), this._runPendingChanges()[0]) : e(this._currentWriter);
          } catch (t) {
            I.rethrowUnexpectedError(t, this);
          }
        }
        enqueueChange(e, t) {
          try {
            e ? typeof e == "function" ? (t = e, e = new Ho()) : e instanceof Ho || (e = new Ho(e)) : e = new Ho(), this._pendingChanges.push({ batch: e, callback: t }), this._pendingChanges.length == 1 && this._runPendingChanges();
          } catch (n) {
            I.rethrowUnexpectedError(n, this);
          }
        }
        applyOperation(e) {
          e._execute();
        }
        insertContent(e, t, n, ...i) {
          const r = el(t, n);
          return this.fire("insertContent", [e, r, n, ...i]);
        }
        insertObject(e, t, n, i, ...r) {
          const s = el(t, n);
          return this.fire("insertObject", [e, s, i, i, ...r]);
        }
        deleteContent(e, t) {
          w1(this, e, t);
        }
        modifySelection(e, t) {
          (function(n, i, r = {}) {
            const s = n.schema, a = r.direction != "backward", l = r.unit ? r.unit : "character", d = !!r.treatEmojiAsSingleUnit, h = i.focus, m = new rn({ boundaries: y1(h, a), singleCharacters: !0, direction: a ? "forward" : "backward" }), f = { walker: m, schema: s, isForward: a, unit: l, treatEmojiAsSingleUnit: d };
            let _;
            for (; _ = m.next(); ) {
              if (_.done)
                return;
              const E = C1(f, _.value);
              if (E)
                return void (i instanceof Zt ? n.change((B) => {
                  B.setSelectionFocus(E);
                }) : i.setFocus(E));
            }
          })(this, e, t);
        }
        getSelectedContent(e) {
          return function(t, n) {
            return t.change((i) => {
              const r = i.createDocumentFragment(), s = n.getFirstRange();
              if (!s || s.isCollapsed)
                return r;
              const a = s.start.root, l = s.start.getCommonPath(s.end), d = a.getNodeByPath(l);
              let h;
              h = s.start.parent == s.end.parent ? s : i.createRange(i.createPositionAt(d, s.start.path[l.length]), i.createPositionAt(d, s.end.path[l.length] + 1));
              const m = h.end.offset - h.start.offset;
              for (const f of h.getItems({ shallow: !0 }))
                f.is("$textProxy") ? i.appendText(f.data, f.getAttributes(), r) : i.append(i.cloneElement(f, !0), r);
              if (h != s) {
                const f = s._getTransformedByMove(h.start, i.createPositionAt(r, 0), m)[0], _ = i.createRange(i.createPositionAt(r, 0), f.start);
                Ng(i.createRange(f.end, i.createPositionAt(r, "end")), i), Ng(_, i);
              }
              return r;
            });
          }(this, e);
        }
        hasContent(e, t = {}) {
          const n = e instanceof $ ? e : $._createIn(e);
          if (n.isCollapsed)
            return !1;
          const { ignoreWhitespaces: i = !1, ignoreMarkers: r = !1 } = t;
          if (!r) {
            for (const s of this.markers.getMarkersIntersectingRange(n))
              if (s.affectsData)
                return !0;
          }
          for (const s of n.getItems())
            if (this.schema.isContent(s) && (!s.is("$textProxy") || !i || s.data.search(/\S/) !== -1))
              return !0;
          return !1;
        }
        canEditAt(e) {
          const t = el(e);
          return this.fire("canEditAt", [t]);
        }
        createPositionFromPath(e, t, n) {
          return new W(e, t, n);
        }
        createPositionAt(e, t) {
          return W._createAt(e, t);
        }
        createPositionAfter(e) {
          return W._createAfter(e);
        }
        createPositionBefore(e) {
          return W._createBefore(e);
        }
        createRange(e, t) {
          return new $(e, t);
        }
        createRangeIn(e) {
          return $._createIn(e);
        }
        createRangeOn(e) {
          return $._createOn(e);
        }
        createSelection(...e) {
          return new zt(...e);
        }
        createBatch(e) {
          return new Ho(e);
        }
        createOperationFromJSON(e) {
          return qC.fromJSON(e, this.document);
        }
        destroy() {
          this.document.destroy(), this.stopListening();
        }
        _runPendingChanges() {
          const e = [];
          this.fire("_beforeChanges");
          try {
            for (; this._pendingChanges.length; ) {
              const t = this._pendingChanges[0].batch;
              this._currentWriter = new b1(this, t);
              const n = this._pendingChanges[0].callback(this._currentWriter);
              e.push(n), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
            }
          } finally {
            this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges");
          }
          return e;
        }
      }
      function el(o, e) {
        if (o)
          return o instanceof zt || o instanceof Zt ? o : o instanceof no ? e || e === 0 ? new zt(o, e) : o.is("rootElement") ? new zt(o, "in") : new zt(o, "on") : new zt(o);
      }
      class D1 extends Tn {
        constructor() {
          super(...arguments), this.domEventType = "click";
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
      }
      class tl extends Tn {
        constructor() {
          super(...arguments), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
      }
      class Kr {
        constructor(e) {
          this.document = e;
        }
        createDocumentFragment(e) {
          return new to(this.document, e);
        }
        createElement(e, t, n) {
          return new Ot(this.document, e, t, n);
        }
        createText(e) {
          return new Ne(this.document, e);
        }
        clone(e, t = !1) {
          return e._clone(t);
        }
        appendChild(e, t) {
          return t._appendChild(e);
        }
        insertChild(e, t, n) {
          return n._insertChild(e, t);
        }
        removeChildren(e, t, n) {
          return n._removeChildren(e, t);
        }
        remove(e) {
          const t = e.parent;
          return t ? this.removeChildren(t.getChildIndex(e), 1, t) : [];
        }
        replace(e, t) {
          const n = e.parent;
          if (n) {
            const i = n.getChildIndex(e);
            return this.removeChildren(i, 1, n), this.insertChild(i, t, n), !0;
          }
          return !1;
        }
        unwrapElement(e) {
          const t = e.parent;
          if (t) {
            const n = t.getChildIndex(e);
            this.remove(e), this.insertChild(n, e.getChildren(), t);
          }
        }
        rename(e, t) {
          const n = new Ot(this.document, e, t.getAttributes(), t.getChildren());
          return this.replace(t, n) ? n : null;
        }
        setAttribute(e, t, n) {
          n._setAttribute(e, t);
        }
        removeAttribute(e, t) {
          t._removeAttribute(e);
        }
        addClass(e, t) {
          t._addClass(e);
        }
        removeClass(e, t) {
          t._removeClass(e);
        }
        setStyle(e, t, n) {
          Ct(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t);
        }
        removeStyle(e, t) {
          t._removeStyle(e);
        }
        setCustomProperty(e, t, n) {
          n._setCustomProperty(e, t);
        }
        removeCustomProperty(e, t) {
          return t._removeCustomProperty(e);
        }
        createPositionAt(e, t) {
          return Z._createAt(e, t);
        }
        createPositionAfter(e) {
          return Z._createAfter(e);
        }
        createPositionBefore(e) {
          return Z._createBefore(e);
        }
        createRange(e, t) {
          return new re(e, t);
        }
        createRangeOn(e) {
          return re._createOn(e);
        }
        createRangeIn(e) {
          return re._createIn(e);
        }
        createSelection(...e) {
          return new tn(...e);
        }
      }
      function B1(o = "") {
        if (o === "")
          return { top: void 0, right: void 0, bottom: void 0, left: void 0 };
        const e = o.replace(/, /g, ",").split(" ").map((r) => r.replace(/,/g, ", ")), t = e[0], n = e[2] || t, i = e[1] || t;
        return { top: t, bottom: n, right: i, left: e[3] || i };
      }
      function T1({ top: o, right: e, bottom: t, left: n }) {
        const i = [];
        return n !== e ? i.push(o, e, t, n) : t !== o ? i.push(o, e, t) : e !== o ? i.push(o, e) : i.push(o), i.join(" ");
      }
      function P1(o) {
        var e, t;
        o.setNormalizer("margin", (e = "margin", (n) => ({ path: e, value: B1(n) }))), o.setNormalizer("margin-top", (n) => ({ path: "margin.top", value: n })), o.setNormalizer("margin-right", (n) => ({ path: "margin.right", value: n })), o.setNormalizer("margin-bottom", (n) => ({ path: "margin.bottom", value: n })), o.setNormalizer("margin-left", (n) => ({ path: "margin.left", value: n })), o.setReducer("margin", (t = "margin", (n) => {
          const { top: i, right: r, bottom: s, left: a } = n, l = [];
          return [i, r, a, s].every((d) => !!d) ? l.push([t, T1(n)]) : (i && l.push([t + "-top", i]), r && l.push([t + "-right", r]), s && l.push([t + "-bottom", s]), a && l.push([t + "-left", a])), l;
        })), o.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"]);
      }
      class I1 {
        constructor() {
          this._commands = /* @__PURE__ */ new Map();
        }
        add(e, t) {
          this._commands.set(e, t);
        }
        get(e) {
          return this._commands.get(e);
        }
        execute(e, ...t) {
          const n = this.get(e);
          if (!n)
            throw new I("commandcollection-command-not-found", this, { commandName: e });
          return n.execute(...t);
        }
        *names() {
          yield* this._commands.keys();
        }
        *commands() {
          yield* this._commands.values();
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]();
        }
        destroy() {
          for (const e of this.commands())
            e.destroy();
        }
      }
      class O1 extends oe() {
        constructor(e = {}) {
          super();
          const t = this.constructor, n = e.language || t.defaultConfig && t.defaultConfig.language;
          this._context = e.context || new Mu({ language: n }), this._context._addEditor(this, !e.context);
          const i = Array.from(t.builtinPlugins || []);
          this.config = new Nd(e, t.defaultConfig), this.config.define("plugins", i), this.config.define(this._context._getEditorConfig()), this.plugins = new zu(this, i, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = /* @__PURE__ */ new Set(), this.commands = new I1(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.model = new S1(), this.on("change:isReadOnly", () => {
            this.model.document.isReadOnly = this.isReadOnly;
          });
          const r = new iA();
          this.data = new HC(this.model, r), this.editing = new _C(this.model, r), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new UC([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new x_(this), this.keystrokes.listenTo(this.editing.view.document);
        }
        get isReadOnly() {
          return this._readOnlyLocks.size > 0;
        }
        set isReadOnly(e) {
          throw new I("editor-isreadonly-has-no-setter");
        }
        enableReadOnlyMode(e) {
          if (typeof e != "string" && typeof e != "symbol")
            throw new I("editor-read-only-lock-id-invalid", null, { lockId: e });
          this._readOnlyLocks.has(e) || (this._readOnlyLocks.add(e), this._readOnlyLocks.size === 1 && this.fire("change:isReadOnly", "isReadOnly", !0, !1));
        }
        disableReadOnlyMode(e) {
          if (typeof e != "string" && typeof e != "symbol")
            throw new I("editor-read-only-lock-id-invalid", null, { lockId: e });
          this._readOnlyLocks.has(e) && (this._readOnlyLocks.delete(e), this._readOnlyLocks.size === 0 && this.fire("change:isReadOnly", "isReadOnly", !1, !0));
        }
        initPlugins() {
          const e = this.config, t = e.get("plugins"), n = e.get("removePlugins") || [], i = e.get("extraPlugins") || [], r = e.get("substitutePlugins") || [];
          return this.plugins.init(t.concat(i), n, r);
        }
        destroy() {
          let e = Promise.resolve();
          return this.state == "initializing" && (e = new Promise((t) => this.once("ready", t))), e.then(() => {
            this.fire("destroy"), this.stopListening(), this.commands.destroy();
          }).then(() => this.plugins.destroy()).then(() => {
            this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
          }).then(() => this._context._removeEditor(this));
        }
        execute(e, ...t) {
          try {
            return this.commands.execute(e, ...t);
          } catch (n) {
            I.rethrowUnexpectedError(n, this);
          }
        }
        focus() {
          this.editing.view.focus();
        }
        static create(...e) {
          throw new Error("This is an abstract method.");
        }
      }
      function Zr(o) {
        return class extends o {
          setData(e) {
            this.data.set(e);
          }
          getData(e) {
            return this.data.get(e);
          }
        };
      }
      {
        const o = Zr(Object);
        Zr.setData = o.prototype.setData, Zr.getData = o.prototype.getData;
      }
      function nl(o) {
        return class extends o {
          updateSourceElement(e = this.data.get()) {
            if (!this.sourceElement)
              throw new I("editor-missing-sourceelement", this);
            const t = this.config.get("updateSourceElementOnDestroy"), n = this.sourceElement instanceof HTMLTextAreaElement;
            Jv(this.sourceElement, t || n ? e : "");
          }
        };
      }
      nl.updateSourceElement = nl(Object).prototype.updateSourceElement;
      class Jr extends Pr {
        static get pluginName() {
          return "PendingActions";
        }
        init() {
          this.set("hasAny", !1), this._actions = new Vt({ idProperty: "_id" }), this._actions.delegate("add", "remove").to(this);
        }
        add(e) {
          if (typeof e != "string")
            throw new I("pendingactions-add-invalid-message", this);
          const t = new (oe())();
          return t.set("message", e), this._actions.add(t), this.hasAny = !0, t;
        }
        remove(e) {
          this._actions.remove(e), this.hasAny = !!this._actions.length;
        }
        get first() {
          return this._actions.get(0);
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]();
        }
      }
      const qe = { bold: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', cancel: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>', caption: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>', check: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>', eraser: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>', image: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>', lowVision: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>', importExport: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path clip-rule="evenodd" d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>', paragraph: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>', plus: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>', text: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path clip-rule="evenodd" d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>', alignBottom: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>', alignMiddle: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>', alignTop: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>', alignLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', alignCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>', alignRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>', alignJustify: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', objectLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>', objectRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectFullWidth: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>', objectInline: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectSizeFull: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>', objectSizeLarge: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>', objectSizeSmall: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>', objectSizeMedium: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>', pencil: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>', pilcrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>', quote: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', threeVerticalDots: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>' };
      var $g = k(5542), R1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()($g.Z, R1), $g.Z.locals;
      const { threeVerticalDots: Lg } = qe, z1 = { alignLeft: qe.alignLeft, bold: qe.bold, importExport: qe.importExport, paragraph: qe.paragraph, plus: qe.plus, text: qe.text, threeVerticalDots: qe.threeVerticalDots };
      class ol extends we {
        constructor(e, t) {
          super(e);
          const n = this.bindTemplate, i = this.t;
          this.options = t || {}, this.set("ariaLabel", i("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new Gt(), this.keystrokes = new un(), this.set("class", void 0), this.set("isCompact", !1), this.itemsView = new M1(e), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
          const r = e.uiLanguageDirection === "rtl";
          this._focusCycler = new Si({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: [r ? "arrowright" : "arrowleft", "arrowup"], focusNext: [r ? "arrowleft" : "arrowright", "arrowdown"] } });
          const s = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")];
          var a;
          this.options.shouldGroupWhenFull && this.options.isFloating && s.push("ck-toolbar_floating"), this.setTemplate({ tag: "div", attributes: { class: s, role: "toolbar", "aria-label": n.to("ariaLabel"), style: { maxWidth: n.to("maxWidth") }, tabindex: -1 }, children: this.children, on: { mousedown: (a = this, a.bindTemplate.to((l) => {
            l.target === a.element && l.preventDefault();
          })) } }), this._behavior = this.options.shouldGroupWhenFull ? new F1(this) : new N1(this);
        }
        render() {
          super.render(), this.focusTracker.add(this.element);
          for (const e of this.items)
            this.focusTracker.add(e.element);
          this.items.on("add", (e, t) => {
            this.focusTracker.add(t.element);
          }), this.items.on("remove", (e, t) => {
            this.focusTracker.remove(t.element);
          }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
        }
        destroy() {
          return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        fillFromConfig(e, t, n) {
          this.items.addMany(this._buildItemsFromConfig(e, t, n));
        }
        _buildItemsFromConfig(e, t, n) {
          const i = Pu(e), r = n || i.removeItems;
          return this._cleanItemsConfiguration(i.items, t, r).map((s) => K(s) ? this._createNestedToolbarDropdown(s, t, r) : s === "|" ? new Tu() : s === "-" ? new E_() : t.create(s)).filter((s) => !!s);
        }
        _cleanItemsConfiguration(e, t, n) {
          const i = e.filter((r, s, a) => r === "|" || n.indexOf(r) === -1 && (r === "-" ? !this.options.shouldGroupWhenFull || (ne("toolbarview-line-break-ignored-when-grouping-items", a), !1) : !(!K(r) && !t.has(r)) || (ne("toolbarview-item-unavailable", { item: r }), !1)));
          return this._cleanSeparatorsAndLineBreaks(i);
        }
        _cleanSeparatorsAndLineBreaks(e) {
          const t = (s) => s !== "-" && s !== "|", n = e.length, i = e.findIndex(t);
          if (i === -1)
            return [];
          const r = n - e.slice().reverse().findIndex(t);
          return e.slice(i, r).filter((s, a, l) => t(s) ? !0 : !(a > 0 && l[a - 1] === s));
        }
        _createNestedToolbarDropdown(e, t, n) {
          let { label: i, icon: r, items: s, tooltip: a = !0, withText: l = !1 } = e;
          if (s = this._cleanItemsConfiguration(s, t, n), !s.length)
            return null;
          const d = fn(this.locale);
          return i || ne("toolbarview-nested-toolbar-dropdown-missing-label", e), d.class = "ck-toolbar__nested-toolbar-dropdown", d.buttonView.set({ label: i, tooltip: a, withText: !!l }), r !== !1 ? d.buttonView.icon = z1[r] || r || Lg : d.buttonView.withText = !0, Yr(d, () => d.toolbarView._buildItemsFromConfig(s, t, n)), d;
        }
      }
      class M1 extends we {
        constructor(e) {
          super(e), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar__items"] }, children: this.children });
        }
      }
      class N1 {
        constructor(e) {
          const t = e.bindTemplate;
          e.set("isVertical", !1), e.itemsView.children.bindTo(e.items).using((n) => n), e.focusables.bindTo(e.items).using((n) => n), e.extendTemplate({ attributes: { class: [t.if("isVertical", "ck-toolbar_vertical")] } });
        }
        render() {
        }
        destroy() {
        }
      }
      class F1 {
        constructor(e) {
          this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = !1, this.view = e, this.viewChildren = e.children, this.viewFocusables = e.focusables, this.viewItemsView = e.itemsView, this.viewFocusTracker = e.focusTracker, this.viewLocale = e.locale, this.ungroupedItems = e.createCollection(), this.groupedItems = e.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), e.itemsView.children.bindTo(this.ungroupedItems).using((t) => t), this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this)), e.children.on("change", this._updateFocusCycleableItems.bind(this)), e.items.on("change", (t, n) => {
            const i = n.index, r = Array.from(n.added);
            for (const s of n.removed)
              i >= this.ungroupedItems.length ? this.groupedItems.remove(s) : this.ungroupedItems.remove(s);
            for (let s = i; s < i + r.length; s++) {
              const a = r[s - i];
              s > this.ungroupedItems.length ? this.groupedItems.add(a, s - this.ungroupedItems.length) : this.ungroupedItems.add(a, s);
            }
            this._updateGrouping();
          }), e.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
        }
        render(e) {
          this.viewElement = e.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(e);
        }
        destroy() {
          this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
        }
        _updateGrouping() {
          if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
            return;
          if (!Kn(this.viewElement))
            return void (this.shouldUpdateGroupingOnNextResize = !0);
          const e = this.groupedItems.length;
          let t;
          for (; this._areItemsOverflowing; )
            this._groupLastItem(), t = !0;
          if (!t && this.groupedItems.length) {
            for (; this.groupedItems.length && !this._areItemsOverflowing; )
              this._ungroupFirstItem();
            this._areItemsOverflowing && this._groupLastItem();
          }
          this.groupedItems.length !== e && this.view.fire("groupedItemsUpdate");
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length)
            return !1;
          const e = this.viewElement, t = this.viewLocale.uiLanguageDirection, n = new Ze(e.lastChild), i = new Ze(e);
          if (!this.cachedPadding) {
            const r = fe.window.getComputedStyle(e), s = t === "ltr" ? "paddingRight" : "paddingLeft";
            this.cachedPadding = Number.parseInt(r[s]);
          }
          return t === "ltr" ? n.right > i.right - this.cachedPadding : n.left < i.left + this.cachedPadding;
        }
        _enableGroupingOnResize() {
          let e;
          this.resizeObserver = new Er(this.viewElement, (t) => {
            e && e === t.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = !1, this._updateGrouping(), e = t.contentRect.width);
          }), this._updateGrouping();
        }
        _enableGroupingOnMaxWidthChange(e) {
          e.on("change:maxWidth", () => {
            this._updateGrouping();
          });
        }
        _groupLastItem() {
          this.groupedItems.length || (this.viewChildren.add(new Tu()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
        }
        _createGroupedItemsDropdown() {
          const e = this.viewLocale, t = e.t, n = fn(e);
          return n.class = "ck-toolbar__grouped-dropdown", n.panelPosition = e.uiLanguageDirection === "ltr" ? "sw" : "se", Yr(n, this.groupedItems), n.buttonView.set({ label: t("Show more items"), tooltip: !0, tooltipPosition: e.uiLanguageDirection === "rtl" ? "se" : "sw", icon: Lg }), n;
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear(), this.ungroupedItems.map((e) => {
            this.viewFocusables.add(e);
          }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
        }
      }
      var Vg = k(1046), $1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Vg.Z, $1), Vg.Z.locals;
      class L1 extends we {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.items = this.createCollection(), this.focusTracker = new Gt(), this.keystrokes = new un(), this._focusCycler = new Si({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowup", focusNext: "arrowdown" } }), this.set("ariaLabel", void 0), this.set("role", void 0), this.setTemplate({ tag: "ul", attributes: { class: ["ck", "ck-reset", "ck-list"], role: t.to("role"), "aria-label": t.to("ariaLabel") }, children: this.items });
        }
        render() {
          super.render();
          for (const e of this.items)
            this.focusTracker.add(e.element);
          this.items.on("add", (e, t) => {
            this.focusTracker.add(t.element);
          }), this.items.on("remove", (e, t) => {
            this.focusTracker.remove(t.element);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
      }
      class jg extends we {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("isVisible", !0), this.children = this.createCollection(), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__item", t.if("isVisible", "ck-hidden", (n) => !n)], role: "presentation" }, children: this.children });
        }
        focus() {
          this.children.first.focus();
        }
      }
      class V1 extends we {
        constructor(e) {
          super(e), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } });
        }
      }
      var Hg = k(7686), j1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Hg.Z, j1), Hg.Z.locals;
      class il extends we {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isToggleable", !1), this.set("isVisible", !0), this.set("keystroke", void 0), this.set("withKeystroke", !1), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.children = this.createCollection(), this.actionView = this._createActionView(), this.arrowView = this._createArrowView(), this.keystrokes = new un(), this.focusTracker = new Gt(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-splitbutton", t.to("class"), t.if("isVisible", "ck-hidden", (n) => !n), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")] }, children: this.children });
        }
        render() {
          super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (e, t) => {
            this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), t());
          }), this.keystrokes.set("arrowleft", (e, t) => {
            this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), t());
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this.actionView.focus();
        }
        _createActionView() {
          const e = new je();
          return e.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), e.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }), e.delegate("execute").to(this), e;
        }
        _createArrowView() {
          const e = new je(), t = e.bindTemplate;
          return e.icon = Du, e.extendTemplate({ attributes: { class: ["ck-splitbutton__arrow"], "data-cke-tooltip-disabled": t.to("isOn"), "aria-haspopup": !0, "aria-expanded": t.to("isOn", (n) => String(n)) } }), e.bind("isEnabled").to(this), e.bind("label").to(this), e.bind("tooltip").to(this), e.delegate("execute").to(this, "open"), e;
        }
      }
      var Ug = k(7339), H1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Ug.Z, H1), Ug.Z.locals;
      var qg = k(3949), U1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(qg.Z, U1), qg.Z.locals;
      function fn(o, e = Bu) {
        const t = new e(o), n = new C_(o), i = new ba(o, t, n);
        return t.bind("isEnabled").to(i), t instanceof il ? t.arrowView.bind("isOn").to(i, "isOpen") : t.bind("isOn").to(i, "isOpen"), function(r) {
          (function(s) {
            s.on("render", () => {
              v({ emitter: s, activator: () => s.isOpen, callback: () => {
                s.isOpen = !1;
              }, contextElements: [s.element] });
            });
          })(r), function(s) {
            s.on("execute", (a) => {
              a.source instanceof Tr || (s.isOpen = !1);
            });
          }(r), function(s) {
            s.focusTracker.on("change:isFocused", (a, l, d) => {
              s.isOpen && !d && (s.isOpen = !1);
            });
          }(r), function(s) {
            s.keystrokes.set("arrowdown", (a, l) => {
              s.isOpen && (s.panelView.focus(), l());
            }), s.keystrokes.set("arrowup", (a, l) => {
              s.isOpen && (s.panelView.focusLast(), l());
            });
          }(r), function(s) {
            s.on("change:isOpen", (a, l, d) => {
              if (d)
                return;
              const h = s.panelView.element;
              h && h.contains(fe.document.activeElement) && s.buttonView.focus();
            });
          }(r), function(s) {
            s.on("change:isOpen", (a, l, d) => {
              d && s.panelView.focus();
            }, { priority: "low" });
          }(r);
        }(i), i;
      }
      function Yr(o, e, t = {}) {
        o.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }), o.isOpen ? Wg(o, e, t) : o.once("change:isOpen", () => Wg(o, e, t), { priority: "highest" }), t.enableActiveItemFocusOnDropdownOpen && Kg(o, () => o.toolbarView.items.find((n) => n.isOn));
      }
      function Wg(o, e, t) {
        const n = o.locale, i = n.t, r = o.toolbarView = new ol(n), s = typeof e == "function" ? e() : e;
        r.ariaLabel = t.ariaLabel || i("Dropdown toolbar"), t.maxWidth && (r.maxWidth = t.maxWidth), t.class && (r.class = t.class), t.isCompact && (r.isCompact = t.isCompact), t.isVertical && (r.isVertical = !0), s instanceof Zn ? r.items.bindTo(s).using((a) => a) : r.items.addMany(s), o.panelView.children.add(r), r.items.delegate("execute").to(o);
      }
      function rl(o, e, t = {}) {
        o.isOpen ? Gg(o, e, t) : o.once("change:isOpen", () => Gg(o, e, t), { priority: "highest" }), Kg(o, () => o.listView.items.find((n) => n instanceof jg && n.children.first.isOn));
      }
      function Gg(o, e, t) {
        const n = o.locale, i = o.listView = new L1(n), r = typeof e == "function" ? e() : e;
        i.ariaLabel = t.ariaLabel, i.role = t.role, i.items.bindTo(r).using((s) => {
          if (s.type === "separator")
            return new V1(n);
          if (s.type === "button" || s.type === "switchbutton") {
            const a = new jg(n);
            let l;
            return l = s.type === "button" ? new je(n) : new Tr(n), l.bind(...Object.keys(s.model)).to(s.model), l.delegate("execute").to(a), a.children.add(l), a;
          }
          return null;
        }), o.panelView.children.add(i), i.items.delegate("execute").to(o);
      }
      function Kg(o, e) {
        o.on("change:isOpen", () => {
          if (!o.isOpen)
            return;
          const t = e();
          t && (typeof t.focus == "function" ? t.focus() : ne("ui-dropdown-focus-child-on-open-child-missing-focus", { view: t }));
        }, { priority: ce.low - 10 });
      }
      function Zg(o, e, t) {
        const n = new A_(o.locale);
        return n.set({ id: e, ariaDescribedById: t }), n.bind("isReadOnly").to(o, "isEnabled", (i) => !i), n.bind("hasError").to(o, "errorText", (i) => !!i), n.on("input", () => {
          o.errorText = null;
        }), o.bind("isEmpty", "isFocused", "placeholder").to(n), n;
      }
      const Vi = (o, e = 0, t = 1) => o > t ? t : o < e ? e : o, ft = (o, e = 0, t = Math.pow(10, e)) => Math.round(t * o) / t, sl = (o) => (o[0] === "#" && (o = o.substring(1)), o.length < 6 ? { r: parseInt(o[0] + o[0], 16), g: parseInt(o[1] + o[1], 16), b: parseInt(o[2] + o[2], 16), a: o.length === 4 ? ft(parseInt(o[3] + o[3], 16) / 255, 2) : 1 } : { r: parseInt(o.substring(0, 2), 16), g: parseInt(o.substring(2, 4), 16), b: parseInt(o.substring(4, 6), 16), a: o.length === 8 ? ft(parseInt(o.substring(6, 8), 16) / 255, 2) : 1 }), q1 = ({ h: o, s: e, v: t, a: n }) => {
        const i = (200 - e) * t / 100;
        return { h: ft(o), s: ft(i > 0 && i < 200 ? e * t / 100 / (i <= 100 ? i : 200 - i) * 100 : 0), l: ft(i / 2), a: ft(n, 2) };
      }, al = (o) => {
        const { h: e, s: t, l: n } = q1(o);
        return `hsl(${e}, ${t}%, ${n}%)`;
      }, W1 = ({ h: o, s: e, v: t, a: n }) => {
        o = o / 360 * 6, e /= 100, t /= 100;
        const i = Math.floor(o), r = t * (1 - e), s = t * (1 - (o - i) * e), a = t * (1 - (1 - o + i) * e), l = i % 6;
        return { r: ft(255 * [t, s, r, r, a, t][l]), g: ft(255 * [a, t, t, s, r, r][l]), b: ft(255 * [r, r, a, t, t, s][l]), a: ft(n, 2) };
      }, Qr = (o) => {
        const e = o.toString(16);
        return e.length < 2 ? "0" + e : e;
      }, G1 = ({ r: o, g: e, b: t, a: n }) => {
        const i = n < 1 ? Qr(ft(255 * n)) : "";
        return "#" + Qr(o) + Qr(e) + Qr(t) + i;
      }, K1 = ({ r: o, g: e, b: t, a: n }) => {
        const i = Math.max(o, e, t), r = i - Math.min(o, e, t), s = r ? i === o ? (e - t) / r : i === e ? 2 + (t - o) / r : 4 + (o - e) / r : 0;
        return { h: ft(60 * (s < 0 ? s + 6 : s)), s: ft(i ? r / i * 100 : 0), v: ft(i / 255 * 100), a: n };
      }, Jg = (o, e) => {
        if (o === e)
          return !0;
        for (const t in o)
          if (o[t] !== e[t])
            return !1;
        return !0;
      }, Yg = {}, Qg = (o) => {
        let e = Yg[o];
        return e || (e = document.createElement("template"), e.innerHTML = o, Yg[o] = e), e;
      }, ll = (o, e, t) => {
        o.dispatchEvent(new CustomEvent(e, { bubbles: !0, detail: t }));
      };
      let qo = !1;
      const cl = (o) => "touches" in o, Xg = (o, e) => {
        const t = cl(e) ? e.touches[0] : e, n = o.el.getBoundingClientRect();
        ll(o.el, "move", o.getMove({ x: Vi((t.pageX - (n.left + window.pageXOffset)) / n.width), y: Vi((t.pageY - (n.top + window.pageYOffset)) / n.height) }));
      };
      class em {
        constructor(e, t, n, i) {
          const r = Qg(`<div role="slider" tabindex="0" part="${t}" ${n}><div part="${t}-pointer"></div></div>`);
          e.appendChild(r.content.cloneNode(!0));
          const s = e.querySelector(`[part=${t}]`);
          s.addEventListener("mousedown", this), s.addEventListener("touchstart", this), s.addEventListener("keydown", this), this.el = s, this.xy = i, this.nodes = [s.firstChild, s];
        }
        set dragging(e) {
          const t = e ? document.addEventListener : document.removeEventListener;
          t(qo ? "touchmove" : "mousemove", this), t(qo ? "touchend" : "mouseup", this);
        }
        handleEvent(e) {
          switch (e.type) {
            case "mousedown":
            case "touchstart":
              if (e.preventDefault(), !((t) => !(qo && !cl(t) || (qo || (qo = cl(t)), 0)))(e) || !qo && e.button != 0)
                return;
              this.el.focus(), Xg(this, e), this.dragging = !0;
              break;
            case "mousemove":
            case "touchmove":
              e.preventDefault(), Xg(this, e);
              break;
            case "mouseup":
            case "touchend":
              this.dragging = !1;
              break;
            case "keydown":
              ((t, n) => {
                const i = n.keyCode;
                i > 40 || t.xy && i < 37 || i < 33 || (n.preventDefault(), ll(t.el, "move", t.getMove({ x: i === 39 ? 0.01 : i === 37 ? -0.01 : i === 34 ? 0.05 : i === 33 ? -0.05 : i === 35 ? 1 : i === 36 ? -1 : 0, y: i === 40 ? 0.01 : i === 38 ? -0.01 : 0 }, !0)));
              })(this, e);
          }
        }
        style(e) {
          e.forEach((t, n) => {
            for (const i in t)
              this.nodes[n].style.setProperty(i, t[i]);
          });
        }
      }
      class Z1 extends em {
        constructor(e) {
          super(e, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', !1);
        }
        update({ h: e }) {
          this.h = e, this.style([{ left: e / 360 * 100 + "%", color: al({ h: e, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuenow", `${ft(e)}`);
        }
        getMove(e, t) {
          return { h: t ? Vi(this.h + 360 * e.x, 0, 360) : 360 * e.x };
        }
      }
      class J1 extends em {
        constructor(e) {
          super(e, "saturation", 'aria-label="Color"', !0);
        }
        update(e) {
          this.hsva = e, this.style([{ top: 100 - e.v + "%", left: `${e.s}%`, color: al(e) }, { "background-color": al({ h: e.h, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuetext", `Saturation ${ft(e.s)}%, Brightness ${ft(e.v)}%`);
        }
        getMove(e, t) {
          return { s: t ? Vi(this.hsva.s + 100 * e.x, 0, 100) : 100 * e.x, v: t ? Vi(this.hsva.v - 100 * e.y, 0, 100) : Math.round(100 - 100 * e.y) };
        }
      }
      const Xr = Symbol("same"), dl = Symbol("color"), tm = Symbol("hsva"), ul = Symbol("update"), nm = Symbol("parts"), om = Symbol("css"), im = Symbol("sliders");
      class Y1 extends HTMLElement {
        static get observedAttributes() {
          return ["color"];
        }
        get [om]() {
          return [':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}', "[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}", "[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}"];
        }
        get [im]() {
          return [J1, Z1];
        }
        get color() {
          return this[dl];
        }
        set color(e) {
          if (!this[Xr](e)) {
            const t = this.colorModel.toHsva(e);
            this[ul](t), this[dl] = e;
          }
        }
        constructor() {
          super();
          const e = Qg(`<style>${this[om].join("")}</style>`), t = this.attachShadow({ mode: "open" });
          t.appendChild(e.content.cloneNode(!0)), t.addEventListener("move", this), this[nm] = this[im].map((n) => new n(t));
        }
        connectedCallback() {
          if (this.hasOwnProperty("color")) {
            const e = this.color;
            delete this.color, this.color = e;
          } else
            this.color || (this.color = this.colorModel.defaultColor);
        }
        attributeChangedCallback(e, t, n) {
          const i = this.colorModel.fromAttr(n);
          this[Xr](i) || (this.color = i);
        }
        handleEvent(e) {
          const t = this[tm], n = { ...t, ...e.detail };
          let i;
          this[ul](n), Jg(n, t) || this[Xr](i = this.colorModel.fromHsva(n)) || (this[dl] = i, ll(this, "color-changed", { value: i }));
        }
        [Xr](e) {
          return this.color && this.colorModel.equal(e, this.color);
        }
        [ul](e) {
          this[tm] = e, this[nm].forEach((t) => t.update(e));
        }
      }
      const Q1 = { defaultColor: "#000", toHsva: (o) => K1(sl(o)), fromHsva: ({ h: o, s: e, v: t }) => G1(W1({ h: o, s: e, v: t, a: 1 })), equal: (o, e) => o.toLowerCase() === e.toLowerCase() || Jg(sl(o), sl(e)), fromAttr: (o) => o };
      class X1 extends Y1 {
        get colorModel() {
          return Q1;
        }
      }
      customElements.define("hex-color-picker", class extends X1 {
      });
      var rm = k(3398), ey = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(rm.Z, ey), rm.Z.locals;
      class ty {
        constructor(e) {
          this._components = /* @__PURE__ */ new Map(), this.editor = e;
        }
        *names() {
          for (const e of this._components.values())
            yield e.originalName;
        }
        add(e, t) {
          this._components.set(hl(e), { callback: t, originalName: e });
        }
        create(e) {
          if (!this.has(e))
            throw new I("componentfactory-item-missing", this, { name: e });
          return this._components.get(hl(e)).callback(this.editor.locale);
        }
        has(e) {
          return this._components.has(hl(e));
        }
      }
      function hl(o) {
        return String(o).toLowerCase();
      }
      var sm = k(8793), ny = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(sm.Z, ny), sm.Z.locals;
      var oy = Object.defineProperty, am = Object.getOwnPropertySymbols, iy = Object.prototype.hasOwnProperty, ry = Object.prototype.propertyIsEnumerable, lm = (o, e, t) => e in o ? oy(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, xe = (o, e) => {
        for (var t in e || (e = {}))
          iy.call(e, t) && lm(o, t, e[t]);
        if (am)
          for (var t of am(e))
            ry.call(e, t) && lm(o, t, e[t]);
        return o;
      };
      const cm = aa("px"), dm = fe.document.body, gl = class extends we {
        constructor(o) {
          super(o);
          const e = this.bindTemplate;
          this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", !1), this.set("withArrow", !0), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-panel", e.to("position", (t) => `ck-balloon-panel_${t}`), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")], style: { top: e.to("top", cm), left: e.to("left", cm) } }, children: this.content });
        }
        show() {
          this.isVisible = !0;
        }
        hide() {
          this.isVisible = !1;
        }
        attachTo(o) {
          this.show();
          const e = gl.defaultPositions, t = Object.assign({}, { element: this.element, positions: [e.southArrowNorth, e.southArrowNorthMiddleWest, e.southArrowNorthMiddleEast, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthMiddleWest, e.northArrowSouthMiddleEast, e.northArrowSouthWest, e.northArrowSouthEast, e.viewportStickyNorth], limiter: dm, fitInViewport: !0 }, o), n = gl._getOptimalPosition(t), i = parseInt(n.left), r = parseInt(n.top), s = n.name, a = n.config || {}, { withArrow: l = !0 } = a;
          this.top = r, this.left = i, this.position = s, this.withArrow = l;
        }
        pin(o) {
          this.unpin(), this._pinWhenIsVisibleCallback = () => {
            this.isVisible ? this._startPinning(o) : this._stopPinning();
          }, this._startPinning(o), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
        }
        unpin() {
          this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
        }
        _startPinning(o) {
          this.attachTo(o);
          const e = ml(o.target), t = o.limiter ? ml(o.limiter) : dm;
          this.listenTo(fe.document, "scroll", (n, i) => {
            const r = i.target, s = e && r.contains(e), a = t && r.contains(t);
            !s && !a && e && t || this.attachTo(o);
          }, { useCapture: !0 }), this.listenTo(fe.window, "resize", () => {
            this.attachTo(o);
          });
        }
        _stopPinning() {
          this.stopListening(fe.document, "scroll"), this.stopListening(fe.window, "resize");
        }
      };
      let St = gl;
      function ml(o) {
        return Ro(o) ? o : Cr(o) ? o.commonAncestorContainer : typeof o == "function" ? ml(o()) : null;
      }
      function um(o = {}) {
        const { sideOffset: e = St.arrowSideOffset, heightOffset: t = St.arrowHeightOffset, stickyVerticalOffset: n = St.stickyVerticalOffset, config: i } = o;
        return { northWestArrowSouthWest: (a, l) => xe({ top: r(a, l), left: a.left - e, name: "arrow_sw" }, i && { config: i }), northWestArrowSouthMiddleWest: (a, l) => xe({ top: r(a, l), left: a.left - 0.25 * l.width - e, name: "arrow_smw" }, i && { config: i }), northWestArrowSouth: (a, l) => xe({ top: r(a, l), left: a.left - l.width / 2, name: "arrow_s" }, i && { config: i }), northWestArrowSouthMiddleEast: (a, l) => xe({ top: r(a, l), left: a.left - 0.75 * l.width + e, name: "arrow_sme" }, i && { config: i }), northWestArrowSouthEast: (a, l) => xe({ top: r(a, l), left: a.left - l.width + e, name: "arrow_se" }, i && { config: i }), northArrowSouthWest: (a, l) => xe({ top: r(a, l), left: a.left + a.width / 2 - e, name: "arrow_sw" }, i && { config: i }), northArrowSouthMiddleWest: (a, l) => xe({ top: r(a, l), left: a.left + a.width / 2 - 0.25 * l.width - e, name: "arrow_smw" }, i && { config: i }), northArrowSouth: (a, l) => xe({ top: r(a, l), left: a.left + a.width / 2 - l.width / 2, name: "arrow_s" }, i && { config: i }), northArrowSouthMiddleEast: (a, l) => xe({ top: r(a, l), left: a.left + a.width / 2 - 0.75 * l.width + e, name: "arrow_sme" }, i && { config: i }), northArrowSouthEast: (a, l) => xe({ top: r(a, l), left: a.left + a.width / 2 - l.width + e, name: "arrow_se" }, i && { config: i }), northEastArrowSouthWest: (a, l) => xe({ top: r(a, l), left: a.right - e, name: "arrow_sw" }, i && { config: i }), northEastArrowSouthMiddleWest: (a, l) => xe({ top: r(a, l), left: a.right - 0.25 * l.width - e, name: "arrow_smw" }, i && { config: i }), northEastArrowSouth: (a, l) => xe({ top: r(a, l), left: a.right - l.width / 2, name: "arrow_s" }, i && { config: i }), northEastArrowSouthMiddleEast: (a, l) => xe({ top: r(a, l), left: a.right - 0.75 * l.width + e, name: "arrow_sme" }, i && { config: i }), northEastArrowSouthEast: (a, l) => xe({ top: r(a, l), left: a.right - l.width + e, name: "arrow_se" }, i && { config: i }), southWestArrowNorthWest: (a) => xe({ top: s(a), left: a.left - e, name: "arrow_nw" }, i && { config: i }), southWestArrowNorthMiddleWest: (a, l) => xe({ top: s(a), left: a.left - 0.25 * l.width - e, name: "arrow_nmw" }, i && { config: i }), southWestArrowNorth: (a, l) => xe({ top: s(a), left: a.left - l.width / 2, name: "arrow_n" }, i && { config: i }), southWestArrowNorthMiddleEast: (a, l) => xe({ top: s(a), left: a.left - 0.75 * l.width + e, name: "arrow_nme" }, i && { config: i }), southWestArrowNorthEast: (a, l) => xe({ top: s(a), left: a.left - l.width + e, name: "arrow_ne" }, i && { config: i }), southArrowNorthWest: (a) => xe({ top: s(a), left: a.left + a.width / 2 - e, name: "arrow_nw" }, i && { config: i }), southArrowNorthMiddleWest: (a, l) => xe({ top: s(a), left: a.left + a.width / 2 - 0.25 * l.width - e, name: "arrow_nmw" }, i && { config: i }), southArrowNorth: (a, l) => xe({ top: s(a), left: a.left + a.width / 2 - l.width / 2, name: "arrow_n" }, i && { config: i }), southArrowNorthMiddleEast: (a, l) => xe({ top: s(a), left: a.left + a.width / 2 - 0.75 * l.width + e, name: "arrow_nme" }, i && { config: i }), southArrowNorthEast: (a, l) => xe({ top: s(a), left: a.left + a.width / 2 - l.width + e, name: "arrow_ne" }, i && { config: i }), southEastArrowNorthWest: (a) => xe({ top: s(a), left: a.right - e, name: "arrow_nw" }, i && { config: i }), southEastArrowNorthMiddleWest: (a, l) => xe({ top: s(a), left: a.right - 0.25 * l.width - e, name: "arrow_nmw" }, i && { config: i }), southEastArrowNorth: (a, l) => xe({ top: s(a), left: a.right - l.width / 2, name: "arrow_n" }, i && { config: i }), southEastArrowNorthMiddleEast: (a, l) => xe({ top: s(a), left: a.right - 0.75 * l.width + e, name: "arrow_nme" }, i && { config: i }), southEastArrowNorthEast: (a, l) => xe({ top: s(a), left: a.right - l.width + e, name: "arrow_ne" }, i && { config: i }), westArrowEast: (a, l) => xe({ top: a.top + a.height / 2 - l.height / 2, left: a.left - l.width - t, name: "arrow_e" }, i && { config: i }), eastArrowWest: (a, l) => xe({ top: a.top + a.height / 2 - l.height / 2, left: a.right + t, name: "arrow_w" }, i && { config: i }), viewportStickyNorth: (a, l, d) => a.getIntersection(d) ? { top: d.top + n, left: a.left + a.width / 2 - l.width / 2, name: "arrowless", config: xe({ withArrow: !1 }, i) } : null };
        function r(a, l) {
          return a.top - l.height - t;
        }
        function s(a) {
          return a.bottom + t;
        }
      }
      St.arrowSideOffset = 25, St.arrowHeightOffset = 10, St.stickyVerticalOffset = 20, St._getOptimalPosition = Zd, St.defaultPositions = um();
      var hm = k(3332), sy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(hm.Z, sy), hm.Z.locals;
      const gm = "ck-tooltip", Dt = class extends Bn() {
        constructor(o) {
          if (super(), this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver = null, Dt._editors.add(o), Dt._instance)
            return Dt._instance;
          Dt._instance = this, this.tooltipTextView = new we(o.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-tooltip__text"] }, children: [{ text: this.tooltipTextView.bindTemplate.to("text") }] }), this.balloonPanelView = new St(o.locale), this.balloonPanelView.class = gm, this.balloonPanelView.content.add(this.tooltipTextView), this._pinTooltipDebounced = Ii(this._pinTooltip, 600), this.listenTo(fe.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(fe.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(fe.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(fe.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(fe.document, "scroll", this._onScroll.bind(this), { useCapture: !0 }), this._watchdogExcluded = !0;
        }
        destroy(o) {
          const e = o.ui.view && o.ui.view.body;
          Dt._editors.delete(o), this.stopListening(o.ui), e && e.has(this.balloonPanelView) && e.remove(this.balloonPanelView), Dt._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), Dt._instance = null);
        }
        static getPositioningFunctions(o) {
          const e = Dt.defaultBalloonPositions;
          return { s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest], n: [e.northArrowSouth], e: [e.eastArrowWest], w: [e.westArrowEast], sw: [e.southArrowNorthEast], se: [e.southArrowNorthWest] }[o];
        }
        _onEnterOrFocus(o, { target: e }) {
          const t = pl(e);
          var n;
          t && t !== this._currentElementWithTooltip && (this._unpinTooltip(), this._pinTooltipDebounced(t, { text: (n = t).dataset.ckeTooltipText, position: n.dataset.ckeTooltipPosition || "s", cssClass: n.dataset.ckeTooltipClass || "" }));
        }
        _onLeaveOrBlur(o, { target: e, relatedTarget: t }) {
          if (o.name === "mouseleave") {
            if (!Ro(e) || this._currentElementWithTooltip && e !== this._currentElementWithTooltip)
              return;
            const n = pl(e), i = pl(t);
            n && n !== i && this._unpinTooltip();
          } else {
            if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip)
              return;
            this._unpinTooltip();
          }
        }
        _onScroll(o, { target: e }) {
          this._currentElementWithTooltip && (e.contains(this.balloonPanelView.element) && e.contains(this._currentElementWithTooltip) || this._unpinTooltip());
        }
        _pinTooltip(o, { text: e, position: t, cssClass: n }) {
          const i = it(Dt._editors.values()).ui.view.body;
          i.has(this.balloonPanelView) || i.add(this.balloonPanelView), this.tooltipTextView.text = e, this.balloonPanelView.pin({ target: o, positions: Dt.getPositioningFunctions(t) }), this._resizeObserver = new Er(o, () => {
            Kn(o) || this._unpinTooltip();
          }), this.balloonPanelView.class = [gm, n].filter((r) => r).join(" ");
          for (const r of Dt._editors)
            this.listenTo(r.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
          this._currentElementWithTooltip = o, this._currentTooltipPosition = t;
        }
        _unpinTooltip() {
          this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
          for (const o of Dt._editors)
            this.stopListening(o.ui, "update");
          this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver && this._resizeObserver.destroy();
        }
        _updateTooltipPosition() {
          Kn(this._currentElementWithTooltip) ? this.balloonPanelView.pin({ target: this._currentElementWithTooltip, positions: Dt.getPositioningFunctions(this._currentTooltipPosition) }) : this._unpinTooltip();
        }
      };
      let es = Dt;
      function pl(o) {
        return Ro(o) ? o.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null;
      }
      es.defaultBalloonPositions = um({ heightOffset: 5, sideOffset: 13 }), es._editors = /* @__PURE__ */ new Set(), es._instance = null;
      const fl = function(o, e, t) {
        var n = !0, i = !0;
        if (typeof o != "function")
          throw new TypeError("Expected a function");
        return K(t) && (n = "leading" in t ? !!t.leading : n, i = "trailing" in t ? !!t.trailing : i), Ii(o, e, { leading: n, maxWait: e, trailing: i });
      };
      var ay = Object.defineProperty, mm = Object.getOwnPropertySymbols, ly = Object.prototype.hasOwnProperty, cy = Object.prototype.propertyIsEnumerable, pm = (o, e, t) => e in o ? ay(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, dy = (o, e) => {
        for (var t in e || (e = {}))
          ly.call(e, t) && pm(o, t, e[t]);
        if (mm)
          for (var t of mm(e))
            cy.call(e, t) && pm(o, t, e[t]);
        return o;
      };
      const uy = 50, hy = 350, gy = "Powered by", ts = { top: -99999, left: -99999, name: "invalid", config: { withArrow: !1 } };
      class my extends Bn() {
        constructor(e) {
          super(), this.editor = e, this._balloonView = null, this._lastFocusedEditableElement = null, this._showBalloonThrottled = fl(this._showBalloon.bind(this), 50, { leading: !0 }), e.on("ready", this._handleEditorReady.bind(this));
        }
        destroy() {
          const e = this._balloonView;
          e && (e.unpin(), this._balloonView = null), this._showBalloonThrottled.cancel(), this.stopListening();
        }
        _handleEditorReady() {
          const e = this.editor;
          (function(t) {
            function n(_) {
              return _.match(/^[a-zA-Z0-9+/=$]+$/g) && _.length >= 40 && _.length <= 255 ? "VALID" : "INVALID";
            }
            let i = "", r = "";
            if (!t)
              return "INVALID";
            try {
              i = atob(t);
            } catch {
              return "INVALID";
            }
            const s = i.split("-"), a = s[0], l = s[1];
            if (!l)
              return n(t);
            try {
              atob(l);
            } catch {
              try {
                if (atob(a), !atob(a).length)
                  return n(t);
              } catch {
                return n(t);
              }
            }
            if (a.length < 40 || a.length > 255)
              return "INVALID";
            try {
              atob(a);
            } catch {
              return "INVALID";
            }
            try {
              r = atob(l);
            } catch {
              return "INVALID";
            }
            if (r.length !== 8)
              return "INVALID";
            const d = Number(r.substring(0, 4)), h = Number(r.substring(4, 6)) - 1, m = Number(r.substring(6, 8)), f = new Date(d, h, m);
            return f < Yt || isNaN(Number(f)) ? "INVALID" : "VALID";
          })(e.config.get("licenseKey")) !== "VALID" && e.ui.view && (e.ui.focusTracker.on("change:isFocused", (t, n, i) => {
            this._updateLastFocusedEditableElement(), i ? this._showBalloon() : this._hideBalloon();
          }), e.ui.focusTracker.on("change:focusedElement", (t, n, i) => {
            this._updateLastFocusedEditableElement(), i && this._showBalloon();
          }), e.ui.on("update", () => {
            this._showBalloonThrottled();
          }));
        }
        _createBalloonView() {
          const e = this.editor, t = this._balloonView = new St(), n = bm(e), i = new py(e.locale, n.label);
          t.content.add(i), t.set({ class: "ck-powered-by-balloon" }), e.ui.view.body.add(t), e.ui.focusTracker.add(t.element), this._balloonView = t;
        }
        _showBalloon() {
          if (!this._lastFocusedEditableElement)
            return;
          const e = function(t, n) {
            const i = bm(t), r = i.side === "right" ? function(s, a) {
              return fm(s, a, (l, d) => l.left + l.width - d.width - a.horizontalOffset);
            }(n, i) : function(s, a) {
              return fm(s, a, (l) => l.left + a.horizontalOffset);
            }(n, i);
            return { target: n, positions: [r] };
          }(this.editor, this._lastFocusedEditableElement);
          e && (this._balloonView || this._createBalloonView(), this._balloonView.pin(e));
        }
        _hideBalloon() {
          this._balloonView && this._balloonView.unpin();
        }
        _updateLastFocusedEditableElement() {
          const e = this.editor, t = e.ui.focusTracker.isFocused, n = e.ui.focusTracker.focusedElement;
          if (!t || !n)
            return void (this._lastFocusedEditableElement = null);
          const i = Array.from(e.ui.getEditableElementsNames()).map((r) => e.ui.getEditableElement(r));
          i.includes(n) ? this._lastFocusedEditableElement = n : this._lastFocusedEditableElement = i[0];
        }
      }
      class py extends we {
        constructor(e, t) {
          super(e);
          const n = new xi(), i = this.bindTemplate;
          n.set({ content: `<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><g clip-path="url(#a)"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h52.4v10H0z"/></clipPath></defs></svg>
`, isColorInherited: !1 }), n.extendTemplate({ attributes: { style: { width: "53px", height: "10px" } } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-powered-by"], "aria-hidden": !0 }, children: [{ tag: "a", attributes: { href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo", target: "_blank", tabindex: "-1" }, children: [...t ? [{ tag: "span", attributes: { class: ["ck", "ck-powered-by__label"] }, children: [t] }] : [], n], on: { dragstart: i.to((r) => r.preventDefault()) } }] });
        }
      }
      function fm(o, e, t) {
        return (n, i) => {
          const r = n.getVisible();
          if (!r || n.width < hy || n.height < uy)
            return ts;
          let s;
          s = e.position === "inside" ? n.bottom - i.height : n.bottom - i.height / 2, s -= e.verticalOffset;
          const a = t(n, i);
          if (e.position === "inside") {
            const l = i.clone().moveTo(a, s);
            if (l.getIntersectionArea(r) < l.getArea())
              return ts;
          } else {
            const l = function(d) {
              let h = d.parentElement;
              if (!h)
                return null;
              for (; h.tagName != "BODY"; ) {
                const m = h.style.overflowY || fe.window.getComputedStyle(h).overflowY;
                if (m === "auto" || m === "scroll")
                  break;
                if (h = h.parentElement, !h)
                  return null;
              }
              return h;
            }(o);
            if (l) {
              const d = new Ze(l);
              if (r.bottom + i.height / 2 > d.bottom)
                return ts;
            }
          }
          return { top: s, left: a, name: `position_${e.position}-side_${e.side}`, config: { withArrow: !1 } };
        };
      }
      function bm(o) {
        const e = o.config.get("ui.poweredBy"), t = e && e.position || "border";
        return dy({ position: t, label: gy, verticalOffset: t === "inside" ? 5 : 0, horizontalOffset: 5, side: o.locale.contentLanguageDirection === "ltr" ? "right" : "left" }, e);
      }
      class fy extends oe() {
        constructor(e) {
          super(), this.isReady = !1, this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [], this.editor = e, this.componentFactory = new ty(e), this.focusTracker = new Gt(), this.tooltipManager = new es(e), this.poweredBy = new my(e), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.once("ready", () => {
            this.isReady = !0;
          }), this.listenTo(e.editing.view.document, "layoutChanged", () => this.update()), this._initFocusTracking();
        }
        get element() {
          return null;
        }
        update() {
          this.fire("update");
        }
        destroy() {
          this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor), this.poweredBy.destroy();
          for (const e of this._editableElementsMap.values())
            e.ckeditorInstance = null, this.editor.keystrokes.stopListening(e);
          this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
        }
        setEditableElement(e, t) {
          this._editableElementsMap.set(e, t), t.ckeditorInstance || (t.ckeditorInstance = this.editor), this.focusTracker.add(t);
          const n = () => {
            this.editor.editing.view.getDomRoot(e) || this.editor.keystrokes.listenTo(t);
          };
          this.isReady ? n() : this.once("ready", n);
        }
        removeEditableElement(e) {
          const t = this._editableElementsMap.get(e);
          t && (this._editableElementsMap.delete(e), this.editor.keystrokes.stopListening(t), this.focusTracker.remove(t), t.ckeditorInstance = null);
        }
        getEditableElement(e = "main") {
          return this._editableElementsMap.get(e);
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys();
        }
        addToolbar(e, t = {}) {
          e.isRendered ? (this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element)) : e.once("render", () => {
            this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element);
          }), this._focusableToolbarDefinitions.push({ toolbarView: e, options: t });
        }
        get _editableElements() {
          return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
        }
        _readViewportOffsetFromConfig() {
          const e = this.editor, t = e.config.get("ui.viewportOffset");
          if (t)
            return t;
          const n = e.config.get("toolbar.viewportTopOffset");
          return n ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), { top: n }) : { top: 0 };
        }
        _initFocusTracking() {
          const e = this.editor, t = e.editing.view;
          let n, i;
          e.keystrokes.set("Alt+F10", (r, s) => {
            const a = this.focusTracker.focusedElement;
            Array.from(this._editableElementsMap.values()).includes(a) && !Array.from(t.domRoots.values()).includes(a) && (n = a);
            const l = this._getCurrentFocusedToolbarDefinition();
            l && i || (i = this._getFocusableCandidateToolbarDefinitions());
            for (let d = 0; d < i.length; d++) {
              const h = i.shift();
              if (i.push(h), h !== l && this._focusFocusableCandidateToolbar(h)) {
                l && l.options.afterBlur && l.options.afterBlur();
                break;
              }
            }
            s();
          }), e.keystrokes.set("Esc", (r, s) => {
            const a = this._getCurrentFocusedToolbarDefinition();
            a && (n ? (n.focus(), n = null) : e.editing.view.focus(), a.options.afterBlur && a.options.afterBlur(), s());
          });
        }
        _getFocusableCandidateToolbarDefinitions() {
          const e = [];
          for (const t of this._focusableToolbarDefinitions) {
            const { toolbarView: n, options: i } = t;
            (Kn(n.element) || i.beforeFocus) && e.push(t);
          }
          return e.sort((t, n) => km(t) - km(n)), e;
        }
        _getCurrentFocusedToolbarDefinition() {
          for (const e of this._focusableToolbarDefinitions)
            if (e.toolbarView.element && e.toolbarView.element.contains(this.focusTracker.focusedElement))
              return e;
          return null;
        }
        _focusFocusableCandidateToolbar(e) {
          const { toolbarView: t, options: { beforeFocus: n } } = e;
          return n && n(), !!Kn(t.element) && (t.focus(), !0);
        }
      }
      function km(o) {
        const { toolbarView: e, options: t } = o;
        let n = 10;
        return Kn(e.element) && n--, t.isContextual && n--, n;
      }
      var wm = k(9688), by = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(wm.Z, by), wm.Z.locals;
      class ky extends we {
        constructor(e) {
          super(e), this.body = new g_(e);
        }
        render() {
          super.render(), this.body.attachToDom();
        }
        destroy() {
          return this.body.detachFromDom(), super.destroy();
        }
      }
      class wy extends ky {
        constructor(e) {
          super(e), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"], role: "application", dir: e.uiLanguageDirection, lang: e.uiLanguage, "aria-labelledby": this._voiceLabelView.id }, children: [this._voiceLabelView, { tag: "div", attributes: { class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation" }, children: this.top }, { tag: "div", attributes: { class: ["ck", "ck-editor__main"], role: "presentation" }, children: this.main }] });
        }
        _createVoiceLabel() {
          const e = this.t, t = new Cu();
          return t.text = e("Rich Text Editor"), t.extendTemplate({ attributes: { class: "ck-voice-label" } }), t;
        }
      }
      class vy extends we {
        constructor(e, t, n) {
          super(e), this.name = null, this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"], lang: e.contentLanguage, dir: e.contentLanguageDirection } }), this.set("isFocused", !1), this._editableElement = n, this._hasExternalElement = !!this._editableElement, this._editingView = t;
        }
        render() {
          super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
        }
        destroy() {
          this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
        }
        get hasExternalElement() {
          return this._hasExternalElement;
        }
        _updateIsFocusedClasses() {
          const e = this._editingView;
          function t(n) {
            e.change((i) => {
              const r = e.document.getRoot(n.name);
              i.addClass(n.isFocused ? "ck-focused" : "ck-blurred", r), i.removeClass(n.isFocused ? "ck-blurred" : "ck-focused", r);
            });
          }
          e.isRenderingInProgress ? function n(i) {
            e.once("change:isRenderingInProgress", (r, s, a) => {
              a ? n(i) : t(i);
            });
          }(this) : t(this);
        }
      }
      class _y extends vy {
        constructor(e, t, n, i = {}) {
          super(e, t, n);
          const r = e.t;
          this.extendTemplate({ attributes: { role: "textbox", class: "ck-editor__editable_inline" } }), this._generateLabel = i.label || (() => r("Editor editing area: %0", this.name));
        }
        render() {
          super.render();
          const e = this._editingView;
          e.change((t) => {
            const n = e.document.getRoot(this.name);
            t.setAttribute("aria-label", this._generateLabel(this), n);
          });
        }
      }
      var vm = k(8847), Ay = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(vm.Z, Ay), vm.Z.locals;
      class _m extends Pr {
        static get pluginName() {
          return "Notification";
        }
        init() {
          this.on("show:warning", (e, t) => {
            window.alert(t.message);
          }, { priority: "lowest" });
        }
        showSuccess(e, t = {}) {
          this._showNotification({ message: e, type: "success", namespace: t.namespace, title: t.title });
        }
        showInfo(e, t = {}) {
          this._showNotification({ message: e, type: "info", namespace: t.namespace, title: t.title });
        }
        showWarning(e, t = {}) {
          this._showNotification({ message: e, type: "warning", namespace: t.namespace, title: t.title });
        }
        _showNotification(e) {
          const t = e.namespace ? `show:${e.type}:${e.namespace}` : `show:${e.type}`;
          this.fire(t, { message: e.message, type: e.type, title: e.title || "" });
        }
      }
      class bl extends oe() {
        constructor(e, t) {
          super(), t && wh(this, t), e && this.set(e);
        }
      }
      var Am = k(4650), Cy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Am.Z, Cy), Am.Z.locals;
      var Cm = k(7676), yy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Cm.Z, yy), Cm.Z.locals;
      const ns = aa("px");
      class os extends G {
        constructor(e) {
          super(e), this._viewToStack = /* @__PURE__ */ new Map(), this._idToStack = /* @__PURE__ */ new Map(), this._view = null, this._rotatorView = null, this._fakePanelsView = null, this.positionLimiter = () => {
            const t = this.editor.editing.view, n = t.document.selection.editableElement;
            return n ? t.domConverter.mapViewToDom(n.root) : null;
          }, this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", !1);
        }
        static get pluginName() {
          return "ContextualBalloon";
        }
        destroy() {
          super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy();
        }
        get view() {
          return this._view || this._createPanelView(), this._view;
        }
        hasView(e) {
          return Array.from(this._viewToStack.keys()).includes(e);
        }
        add(e) {
          if (this._view || this._createPanelView(), this.hasView(e.view))
            throw new I("contextualballoon-add-view-exist", [this, e]);
          const t = e.stackId || "main";
          if (!this._idToStack.has(t))
            return this._idToStack.set(t, /* @__PURE__ */ new Map([[e.view, e]])), this._viewToStack.set(e.view, this._idToStack.get(t)), this._numberOfStacks = this._idToStack.size, void (this._visibleStack && !e.singleViewMode || this.showStack(t));
          const n = this._idToStack.get(t);
          e.singleViewMode && this.showStack(t), n.set(e.view, e), this._viewToStack.set(e.view, n), n === this._visibleStack && this._showView(e);
        }
        remove(e) {
          if (!this.hasView(e))
            throw new I("contextualballoon-remove-view-not-exist", [this, e]);
          const t = this._viewToStack.get(e);
          this._singleViewMode && this.visibleView === e && (this._singleViewMode = !1), this.visibleView === e && (t.size === 1 ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(t.values())[t.size - 2])), t.size === 1 ? (this._idToStack.delete(this._getStackId(t)), this._numberOfStacks = this._idToStack.size) : t.delete(e), this._viewToStack.delete(e);
        }
        updatePosition(e) {
          e && (this._visibleStack.get(this.visibleView).position = e), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition();
        }
        showStack(e) {
          this.visibleStack = e;
          const t = this._idToStack.get(e);
          if (!t)
            throw new I("contextualballoon-showstack-stack-not-exist", this);
          this._visibleStack !== t && this._showView(Array.from(t.values()).pop());
        }
        _createPanelView() {
          this._view = new St(this.editor.locale), this.editor.ui.view.body.add(this._view), this.editor.ui.focusTracker.add(this._view.element), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView);
        }
        _getStackId(e) {
          return Array.from(this._idToStack.entries()).find((t) => t[1] === e)[0];
        }
        _showNextStack() {
          const e = Array.from(this._idToStack.values());
          let t = e.indexOf(this._visibleStack) + 1;
          e[t] || (t = 0), this.showStack(this._getStackId(e[t]));
        }
        _showPrevStack() {
          const e = Array.from(this._idToStack.values());
          let t = e.indexOf(this._visibleStack) - 1;
          e[t] || (t = e.length - 1), this.showStack(this._getStackId(e[t]));
        }
        _createRotatorView() {
          const e = new Ey(this.editor.locale), t = this.editor.locale.t;
          return this.view.content.add(e), e.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (n, i) => !i && n > 1), e.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), e.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (n, i) => {
            if (i < 2)
              return "";
            const r = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
            return t("%0 of %1", [r, i]);
          }), e.buttonNextView.on("execute", () => {
            e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
          }), e.buttonPrevView.on("execute", () => {
            e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
          }), e;
        }
        _createFakePanelsView() {
          const e = new xy(this.editor.locale, this.view);
          return e.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, n) => !n && t >= 2 ? Math.min(t - 1, 2) : 0), e.listenTo(this.view, "change:top", () => e.updatePosition()), e.listenTo(this.view, "change:left", () => e.updatePosition()), this.editor.ui.view.body.add(e), e;
        }
        _showView({ view: e, balloonClassName: t = "", withArrow: n = !0, singleViewMode: i = !1 }) {
          this.view.class = t, this.view.withArrow = n, this._rotatorView.showView(e), this.visibleView = e, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), i && (this._singleViewMode = !0);
        }
        _getBalloonPosition() {
          let e = Array.from(this._visibleStack.values()).pop().position;
          return e && (e.limiter || (e = Object.assign({}, e, { limiter: this.positionLimiter })), e = Object.assign({}, e, { viewportOffsetConfig: this.editor.ui.viewportOffset })), e;
        }
      }
      class Ey extends we {
        constructor(e) {
          super(e);
          const t = e.t, n = this.bindTemplate;
          this.set("isNavigationVisible", !0), this.focusTracker = new Gt(), this.buttonPrevView = this._createButtonView(t("Previous"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'), this.buttonNextView = this._createButtonView(t("Next"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" }, children: [{ tag: "div", attributes: { class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", (i) => i ? "" : "ck-hidden")] }, children: [this.buttonPrevView, { tag: "span", attributes: { class: ["ck-balloon-rotator__counter"] }, children: [{ text: n.to("counter") }] }, this.buttonNextView] }, { tag: "div", attributes: { class: "ck-balloon-rotator__content" }, children: this.content }] });
        }
        render() {
          super.render(), this.focusTracker.add(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy();
        }
        showView(e) {
          this.hideView(), this.content.add(e);
        }
        hideView() {
          this.content.clear();
        }
        _createButtonView(e, t) {
          const n = new je(this.locale);
          return n.set({ label: e, icon: t, tooltip: !0 }), n;
        }
      }
      class xy extends we {
        constructor(e, t) {
          super(e);
          const n = this.bindTemplate;
          this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = t, this.setTemplate({ tag: "div", attributes: { class: ["ck-fake-panel", n.to("numberOfPanels", (i) => i ? "" : "ck-hidden")], style: { top: n.to("top", ns), left: n.to("left", ns), width: n.to("width", ns), height: n.to("height", ns) } }, children: this.content }), this.on("change:numberOfPanels", (i, r, s, a) => {
            s > a ? this._addPanels(s - a) : this._removePanels(a - s), this.updatePosition();
          });
        }
        _addPanels(e) {
          for (; e--; ) {
            const t = new we();
            t.setTemplate({ tag: "div" }), this.content.add(t), this.registerChild(t);
          }
        }
        _removePanels(e) {
          for (; e--; ) {
            const t = this.content.last;
            this.content.remove(t), this.deregisterChild(t), t.destroy();
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: e, left: t } = this._balloonPanelView, { width: n, height: i } = new Ze(this._balloonPanelView.element);
            Object.assign(this, { top: e, left: t, width: n, height: i });
          }
        }
      }
      var ym = k(5868), Sy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(ym.Z, Sy), ym.Z.locals;
      const ji = aa("px");
      class Dy extends we {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("isActive", !1), this.set("isSticky", !1), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheLimiter", !1), this.set("_hasViewportTopOffset", !1), this.content = this.createCollection(), this._contentPanelPlaceholder = new Xt({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__placeholder"], style: { display: t.to("isSticky", (n) => n ? "block" : "none"), height: t.to("isSticky", (n) => n ? ji(this._panelRect.height) : null) } } }).render(), this._contentPanel = new Xt({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__content", t.if("isSticky", "ck-sticky-panel__content_sticky"), t.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")], style: { width: t.to("isSticky", (n) => n ? ji(this._contentPanelPlaceholder.getBoundingClientRect().width) : null), top: t.to("_hasViewportTopOffset", (n) => n ? ji(this.viewportTopOffset) : null), bottom: t.to("_isStickyToTheLimiter", (n) => n ? ji(this.limiterBottomOffset) : null), marginLeft: t.to("_marginLeft") } }, children: this.content }).render(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel"] }, children: [this._contentPanelPlaceholder, this._contentPanel] });
        }
        render() {
          super.render(), this._checkIfShouldBeSticky(), this.listenTo(fe.window, "scroll", () => {
            this._checkIfShouldBeSticky();
          }), this.listenTo(this, "change:isActive", () => {
            this._checkIfShouldBeSticky();
          });
        }
        _checkIfShouldBeSticky() {
          const e = this._panelRect = this._contentPanel.getBoundingClientRect();
          let t;
          this.limiterElement ? (t = this._limiterRect = this.limiterElement.getBoundingClientRect(), this.isSticky = this.isActive && t.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < t.height) : this.isSticky = !1, this.isSticky ? (this._isStickyToTheLimiter = t.bottom < e.height + this.limiterBottomOffset + this.viewportTopOffset, this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset, this._marginLeft = this._isStickyToTheLimiter ? null : ji(-fe.window.scrollX)) : (this._isStickyToTheLimiter = !1, this._hasViewportTopOffset = !1, this._marginLeft = null);
        }
      }
      var Em = k(9695), By = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Em.Z, By), Em.Z.locals;
      class Ty extends fy {
        constructor(e, t) {
          super(e), this.view = t, this._toolbarConfig = Pu(e.config.get("toolbar")), this._elementReplacer = new Kc();
        }
        get element() {
          return this.view.element;
        }
        init(e) {
          const t = this.editor, n = this.view, i = t.editing.view, r = n.editable, s = i.document.getRoot();
          r.name = s.rootName, n.render();
          const a = r.element;
          this.setEditableElement(r.name, a), n.editable.bind("isFocused").to(this.focusTracker), i.attachDomRoot(a), e && this._elementReplacer.replace(e, this.element), this._initPlaceholder(), this._initToolbar(), this.fire("ready");
        }
        destroy() {
          super.destroy();
          const e = this.view, t = this.editor.editing.view;
          this._elementReplacer.restore(), t.detachDomRoot(e.editable.name), e.destroy();
        }
        _initToolbar() {
          const e = this.view;
          e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), e.stickyPanel.limiterElement = e.element, e.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: t }) => t || 0), e.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(e.toolbar);
        }
        _initPlaceholder() {
          const e = this.editor, t = e.editing.view, n = t.document.getRoot(), i = e.sourceElement;
          let r;
          const s = e.config.get("placeholder");
          s && (r = typeof s == "string" ? s : s[this.view.editable.name]), !r && i && i.tagName.toLowerCase() === "textarea" && (r = i.getAttribute("placeholder")), r && function({ view: a, element: l, text: d, isDirectHost: h = !0, keepOnFocus: m = !1 }) {
            const f = a.document;
            Ir.has(f) || (Ir.set(f, /* @__PURE__ */ new Map()), f.registerPostFixer((_) => wa(f, _)), f.on("change:isComposing", () => {
              a.change((_) => wa(f, _));
            }, { priority: "high" })), Ir.get(f).set(l, { text: d, isDirectHost: h, keepOnFocus: m, hostElement: h ? l : null }), a.change((_) => wa(f, _));
          }({ view: t, element: n, text: r, isDirectHost: !1, keepOnFocus: !0 });
        }
      }
      var xm = k(3143), Py = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(xm.Z, Py), xm.Z.locals;
      class Iy extends wy {
        constructor(e, t, n = {}) {
          super(e), this.stickyPanel = new Dy(e), this.toolbar = new ol(e, { shouldGroupWhenFull: n.shouldToolbarGroupWhenFull }), this.editable = new _y(e, t);
        }
        render() {
          super.render(), this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable);
        }
      }
      class Sm {
        constructor(e) {
          if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = typeof e.crashNumberLimit == "number" ? e.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = typeof e.minimumNonErrorTimePeriod == "number" ? e.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (t) => {
            const n = "error" in t ? t.error : t.reason;
            n instanceof Error && this._handleError(n, t);
          }, this._listeners = {}, !this._restart)
            throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
        }
        destroy() {
          this._stopErrorHandling(), this._listeners = {};
        }
        on(e, t) {
          this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t);
        }
        off(e, t) {
          this._listeners[e] = this._listeners[e].filter((n) => n !== t);
        }
        _fire(e, ...t) {
          const n = this._listeners[e] || [];
          for (const i of n)
            i.apply(this, [null, ...t]);
        }
        _startErrorHandling() {
          window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _stopErrorHandling() {
          window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _handleError(e, t) {
          if (this._shouldReactToError(e)) {
            this.crashes.push({ message: e.message, stack: e.stack, filename: t instanceof ErrorEvent ? t.filename : void 0, lineno: t instanceof ErrorEvent ? t.lineno : void 0, colno: t instanceof ErrorEvent ? t.colno : void 0, date: this._now() });
            const n = this._shouldRestart();
            this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: e, causesRestart: n }), n ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
          }
        }
        _shouldReactToError(e) {
          return e.is && e.is("CKEditorError") && e.context !== void 0 && e.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(e);
        }
        _shouldRestart() {
          return this.crashes.length <= this._crashNumberLimit ? !0 : (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
        }
      }
      function kl(o, e = /* @__PURE__ */ new Set()) {
        const t = [o], n = /* @__PURE__ */ new Set();
        let i = 0;
        for (; t.length > i; ) {
          const r = t[i++];
          if (!n.has(r) && Oy(r) && !e.has(r))
            if (n.add(r), Symbol.iterator in r)
              try {
                for (const s of r)
                  t.push(s);
              } catch {
              }
            else
              for (const s in r)
                s !== "defaultValue" && t.push(r[s]);
        }
        return n;
      }
      function Oy(o) {
        const e = Object.prototype.toString.call(o), t = typeof o;
        return !(t === "number" || t === "boolean" || t === "string" || t === "symbol" || t === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || o == null || o._watchdogExcluded || o instanceof EventTarget || o instanceof Event);
      }
      function Dm(o, e, t = /* @__PURE__ */ new Set()) {
        if (o === e && typeof (n = o) == "object" && n !== null)
          return !0;
        var n;
        const i = kl(o, t), r = kl(e, t);
        for (const s of i)
          if (r.has(s))
            return !0;
        return !1;
      }
      class Bm extends Sm {
        constructor(e, t = {}) {
          super(t), this._editor = null, this._throttledSave = fl(this._save.bind(this), typeof t.saveInterval == "number" ? t.saveInterval : 5e3), e && (this._creator = (n, i) => e.create(n, i)), this._destructor = (n) => n.destroy();
        }
        get editor() {
          return this._editor;
        }
        get _item() {
          return this._editor;
        }
        setCreator(e) {
          this._creator = e;
        }
        setDestructor(e) {
          this._destructor = e;
        }
        _restart() {
          return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((e) => {
            console.error("An error happened during the editor destroying.", e);
          }).then(() => {
            if (typeof this._elementOrData == "string")
              return this.create(this._data, this._config, this._config.context);
            {
              const e = Object.assign({}, this._config, { initialData: this._data });
              return this.create(this._elementOrData, e, e.context);
            }
          }).then(() => {
            this._fire("restart");
          });
        }
        create(e = this._elementOrData, t = this._config, n) {
          return Promise.resolve().then(() => (super._startErrorHandling(), this._elementOrData = e, this._config = this._cloneEditorConfiguration(t) || {}, this._config.context = n, this._creator(e, this._config))).then((i) => {
            this._editor = i, i.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = i.model.document.version, this._data = this._getData(), this.state = "ready", this._fire("stateChange");
          });
        }
        destroy() {
          return Promise.resolve().then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling(), this._throttledSave.flush();
            const e = this._editor;
            return this._editor = null, e.model.document.off("change:data", this._throttledSave), this._destructor(e);
          });
        }
        _save() {
          const e = this._editor.model.document.version;
          try {
            this._data = this._getData(), this._lastDocumentVersion = e;
          } catch (t) {
            console.error(t, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
          }
        }
        _setExcludedProperties(e) {
          this._excludedProps = e;
        }
        _getData() {
          const e = {};
          for (const t of this._editor.model.document.getRootNames())
            e[t] = this._editor.data.get({ rootName: t });
          return e;
        }
        _isErrorComingFromThisItem(e) {
          return Dm(this._editor, e.context, this._excludedProps);
        }
        _cloneEditorConfiguration(e) {
          return ra(e, (t, n) => Ro(t) || n === "context" ? t : void 0);
        }
      }
      const Hi = Symbol("MainQueueId");
      class Ry {
        constructor() {
          this._onEmptyCallbacks = [], this._queues = /* @__PURE__ */ new Map(), this._activeActions = 0;
        }
        onEmpty(e) {
          this._onEmptyCallbacks.push(e);
        }
        enqueue(e, t) {
          const n = e === Hi;
          this._activeActions++, this._queues.get(e) || this._queues.set(e, Promise.resolve());
          const i = (n ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Hi), this._queues.get(e)])).then(t), r = i.catch(() => {
          });
          return this._queues.set(e, r), i.finally(() => {
            this._activeActions--, this._queues.get(e) === r && this._activeActions === 0 && this._onEmptyCallbacks.forEach((s) => s());
          });
        }
      }
      function Tm(o) {
        return Array.isArray(o) ? o : [o];
      }
      class is extends Zr(nl(O1)) {
        constructor(e, t = {}) {
          if (!rs(e) && t.initialData !== void 0)
            throw new I("editor-create-initial-data", null);
          super(t), this.config.get("initialData") === void 0 && this.config.set("initialData", function(r) {
            return rs(r) ? (s = r, s instanceof HTMLTextAreaElement ? s.value : s.innerHTML) : r;
            var s;
          }(e)), rs(e) && (this.sourceElement = e), this.model.document.createRoot();
          const n = !this.config.get("toolbar.shouldNotGroupWhenFull"), i = new Iy(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: n });
          this.ui = new Ty(this, i), function(r) {
            if (!Un(r.updateSourceElement))
              throw new I("attachtoform-missing-elementapi-interface", r);
            const s = r.sourceElement;
            if (function(a) {
              return !!a && a.tagName.toLowerCase() === "textarea";
            }(s) && s.form) {
              let a;
              const l = s.form, d = () => r.updateSourceElement();
              Un(l.submit) && (a = l.submit, l.submit = () => {
                d(), a.apply(l);
              }), l.addEventListener("submit", d), r.on("destroy", () => {
                l.removeEventListener("submit", d), a && (l.submit = a);
              });
            }
          }(this);
        }
        destroy() {
          return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy();
        }
        static create(e, t = {}) {
          return new Promise((n) => {
            const i = new this(e, t);
            n(i.initPlugins().then(() => i.ui.init(rs(e) ? e : null)).then(() => i.data.init(i.config.get("initialData"))).then(() => i.fire("ready")).then(() => i));
          });
        }
      }
      function rs(o) {
        return Ro(o);
      }
      is.Context = Mu, is.EditorWatchdog = Bm, is.ContextWatchdog = class extends Sm {
        constructor(o, e = {}) {
          super(e), this._watchdogs = /* @__PURE__ */ new Map(), this._context = null, this._contextProps = /* @__PURE__ */ new Set(), this._actionQueues = new Ry(), this._watchdogConfig = e, this._creator = (t) => o.create(t), this._destructor = (t) => t.destroy(), this._actionQueues.onEmpty(() => {
            this.state === "initializing" && (this.state = "ready", this._fire("stateChange"));
          });
        }
        setCreator(o) {
          this._creator = o;
        }
        setDestructor(o) {
          this._destructor = o;
        }
        get context() {
          return this._context;
        }
        create(o = {}) {
          return this._actionQueues.enqueue(Hi, () => (this._contextConfig = o, this._create()));
        }
        getItem(o) {
          return this._getWatchdog(o)._item;
        }
        getItemState(o) {
          return this._getWatchdog(o).state;
        }
        add(o) {
          const e = Tm(o);
          return Promise.all(e.map((t) => this._actionQueues.enqueue(t.id, () => {
            if (this.state === "destroyed")
              throw new Error("Cannot add items to destroyed watchdog.");
            if (!this._context)
              throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
            let n;
            if (this._watchdogs.has(t.id))
              throw new Error(`Item with the given id is already added: '${t.id}'.`);
            if (t.type === "editor")
              return n = new Bm(null, this._watchdogConfig), n.setCreator(t.creator), n._setExcludedProperties(this._contextProps), t.destructor && n.setDestructor(t.destructor), this._watchdogs.set(t.id, n), n.on("error", (i, { error: r, causesRestart: s }) => {
                this._fire("itemError", { itemId: t.id, error: r }), s && this._actionQueues.enqueue(t.id, () => new Promise((a) => {
                  const l = () => {
                    n.off("restart", l), this._fire("itemRestart", { itemId: t.id }), a();
                  };
                  n.on("restart", l);
                }));
              }), n.create(t.sourceElementOrData, t.config, this._context);
            throw new Error(`Not supported item type: '${t.type}'.`);
          })));
        }
        remove(o) {
          const e = Tm(o);
          return Promise.all(e.map((t) => this._actionQueues.enqueue(t, () => {
            const n = this._getWatchdog(t);
            return this._watchdogs.delete(t), n.destroy();
          })));
        }
        destroy() {
          return this._actionQueues.enqueue(Hi, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _restart() {
          return this._actionQueues.enqueue(Hi, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((o) => {
            console.error("An error happened during destroying the context or items.", o);
          }).then(() => this._create()).then(() => this._fire("restart"))));
        }
        _create() {
          return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((o) => (this._context = o, this._contextProps = kl(this._context), Promise.all(Array.from(this._watchdogs.values()).map((e) => (e._setExcludedProperties(this._contextProps), e.create(void 0, void 0, this._context))))));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling();
            const o = this._context;
            return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((e) => e.destroy())).then(() => this._destructor(o));
          });
        }
        _getWatchdog(o) {
          const e = this._watchdogs.get(o);
          if (!e)
            throw new Error(`Item with the given id was not registered: ${o}.`);
          return e;
        }
        _isErrorComingFromThisItem(o) {
          for (const e of this._watchdogs.values())
            if (e._isErrorComingFromThisItem(o))
              return !1;
          return Dm(this._context, o.context);
        }
      };
      class wl extends Tn {
        constructor(e) {
          super(e), this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"];
          const t = this.document;
          function n(i) {
            return (r, s) => {
              s.preventDefault();
              const a = s.dropRange ? [s.dropRange] : null, l = new U(t, i);
              t.fire(l, { dataTransfer: s.dataTransfer, method: r.name, targetRanges: a, target: s.target, domEvent: s.domEvent }), l.stop.called && s.stopPropagation();
            };
          }
          this.listenTo(t, "paste", n("clipboardInput"), { priority: "low" }), this.listenTo(t, "drop", n("clipboardInput"), { priority: "low" }), this.listenTo(t, "dragover", n("dragging"), { priority: "low" });
        }
        onDomEvent(e) {
          const t = "clipboardData" in e ? e.clipboardData : e.dataTransfer, n = e.type == "drop" || e.type == "paste", i = { dataTransfer: new Dh(t, { cacheFiles: n }) };
          e.type != "drop" && e.type != "dragover" || (i.dropRange = function(r, s) {
            const a = s.target.ownerDocument, l = s.clientX, d = s.clientY;
            let h;
            return a.caretRangeFromPoint && a.caretRangeFromPoint(l, d) ? h = a.caretRangeFromPoint(l, d) : s.rangeParent && (h = a.createRange(), h.setStart(s.rangeParent, s.rangeOffset), h.collapse(!0)), h ? r.domConverter.domRangeToView(h) : null;
          }(this.view, e)), this.fire(e.type, e, i);
        }
      }
      const Pm = ["figcaption", "li"];
      function Im(o) {
        let e = "";
        if (o.is("$text") || o.is("$textProxy"))
          e = o.data;
        else if (o.is("element", "img") && o.hasAttribute("alt"))
          e = o.getAttribute("alt");
        else if (o.is("element", "br"))
          e = `
`;
        else {
          let t = null;
          for (const n of o.getChildren()) {
            const i = Im(n);
            t && (t.is("containerElement") || n.is("containerElement")) && (Pm.includes(t.name) || Pm.includes(n.name) ? e += `
` : e += `

`), e += i, t = n;
          }
        }
        return e;
      }
      class bn extends G {
        static get pluginName() {
          return "ClipboardPipeline";
        }
        init() {
          this.editor.editing.view.addObserver(wl), this._setupPasteDrop(), this._setupCopyCut();
        }
        _setupPasteDrop() {
          const e = this.editor, t = e.model, n = e.editing.view, i = n.document;
          this.listenTo(i, "clipboardInput", (r, s) => {
            s.method != "paste" || e.model.canEditAt(e.model.document.selection) || r.stop();
          }, { priority: "highest" }), this.listenTo(i, "clipboardInput", (r, s) => {
            const a = s.dataTransfer;
            let l;
            if (s.content)
              l = s.content;
            else {
              let m = "";
              a.getData("text/html") ? m = function(f) {
                return f.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (_, E) => E.length == 1 ? " " : E).replace(/<!--[\s\S]*?-->/g, "");
              }(a.getData("text/html")) : a.getData("text/plain") && (((d = (d = a.getData("text/plain")).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || d.includes("<br>")) && (d = `<p>${d}</p>`), m = d), l = this.editor.data.htmlProcessor.toView(m);
            }
            var d;
            const h = new U(this, "inputTransformation");
            this.fire(h, { content: l, dataTransfer: a, targetRanges: s.targetRanges, method: s.method }), h.stop.called && r.stop(), n.scrollToTheSelection();
          }, { priority: "low" }), this.listenTo(this, "inputTransformation", (r, s) => {
            if (s.content.isEmpty)
              return;
            const a = this.editor.data.toModel(s.content, "$clipboardHolder");
            a.childCount != 0 && (r.stop(), t.change(() => {
              this.fire("contentInsertion", { content: a, method: s.method, dataTransfer: s.dataTransfer, targetRanges: s.targetRanges });
            }));
          }, { priority: "low" }), this.listenTo(this, "contentInsertion", (r, s) => {
            s.resultRange = t.insertContent(s.content);
          }, { priority: "low" });
        }
        _setupCopyCut() {
          const e = this.editor, t = e.model.document, n = e.editing.view.document, i = (r, s) => {
            const a = s.dataTransfer;
            s.preventDefault();
            const l = e.data.toView(e.model.getSelectedContent(t.selection));
            n.fire("clipboardOutput", { dataTransfer: a, content: l, method: r.name });
          };
          this.listenTo(n, "copy", i, { priority: "low" }), this.listenTo(n, "cut", (r, s) => {
            e.model.canEditAt(e.model.document.selection) ? i(r, s) : s.preventDefault();
          }, { priority: "low" }), this.listenTo(n, "clipboardOutput", (r, s) => {
            s.content.isEmpty || (s.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(s.content)), s.dataTransfer.setData("text/plain", Im(s.content))), s.method == "cut" && e.model.deleteContent(t.selection);
          }, { priority: "low" });
        }
      }
      class Om {
        constructor(e, t = 20) {
          this._batch = null, this.model = e, this._size = 0, this.limit = t, this._isLocked = !1, this._changeCallback = (n, i) => {
            i.isLocal && i.isUndoable && i !== this._batch && this._reset(!0);
          }, this._selectionChangeCallback = () => {
            this._reset();
          }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
        }
        get batch() {
          return this._batch || (this._batch = this.model.createBatch({ isTyping: !0 })), this._batch;
        }
        get size() {
          return this._size;
        }
        input(e) {
          this._size += e, this._size >= this.limit && this._reset(!0);
        }
        get isLocked() {
          return this._isLocked;
        }
        lock() {
          this._isLocked = !0;
        }
        unlock() {
          this._isLocked = !1;
        }
        destroy() {
          this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
        }
        _reset(e = !1) {
          this.isLocked && !e || (this._batch = null, this._size = 0);
        }
      }
      class zy extends pe {
        constructor(e, t) {
          super(e), this._buffer = new Om(e.model, t), this._isEnabledBasedOnSelection = !1;
        }
        get buffer() {
          return this._buffer;
        }
        destroy() {
          super.destroy(), this._buffer.destroy();
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document, i = e.text || "", r = i.length;
          let s = n.selection;
          if (e.selection ? s = e.selection : e.range && (s = t.createSelection(e.range)), !t.canEditAt(s))
            return;
          const a = e.resultRange;
          t.enqueueChange(this._buffer.batch, (l) => {
            this._buffer.lock(), t.deleteContent(s), i && t.insertContent(l.createText(i, n.selection.getAttributes()), s), a ? l.setSelection(a) : s.is("documentSelection") || l.setSelection(s), this._buffer.unlock(), this._buffer.input(r);
          });
        }
      }
      const Rm = ["insertText", "insertReplacementText"];
      class My extends on {
        constructor(e) {
          super(e), b.isAndroid && Rm.push("insertCompositionText");
          const t = e.document;
          t.on("beforeinput", (n, i) => {
            if (!this.isEnabled)
              return;
            const { data: r, targetRanges: s, inputType: a, domEvent: l } = i;
            if (!Rm.includes(a))
              return;
            const d = new U(t, "insertText");
            t.fire(d, new Vo(e, l, { text: r, selection: e.createSelection(s) })), d.stop.called && n.stop();
          }), t.on("compositionend", (n, { data: i, domEvent: r }) => {
            this.isEnabled && !b.isAndroid && i && t.fire("insertText", new Vo(e, r, { text: i, selection: t.selection }));
          }, { priority: "lowest" });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class zm extends G {
        static get pluginName() {
          return "Input";
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view, i = t.document.selection;
          n.addObserver(My);
          const r = new zy(e, e.config.get("typing.undoStep") || 20);
          e.commands.add("insertText", r), e.commands.add("input", r), this.listenTo(n.document, "insertText", (s, a) => {
            n.document.isComposing || a.preventDefault();
            const { text: l, selection: d, resultRange: h } = a, m = Array.from(d.getRanges()).map((E) => e.editing.mapper.toModelRange(E));
            let f = l;
            if (b.isAndroid) {
              const E = Array.from(m[0].getItems()).reduce((B, T) => B + (T.is("$textProxy") ? T.data : ""), "");
              E && (E.length <= f.length ? f.startsWith(E) && (f = f.substring(E.length), m[0].start = m[0].start.getShiftedBy(E.length)) : E.startsWith(f) && (m[0].start = m[0].start.getShiftedBy(f.length), f = ""));
            }
            const _ = { text: f, selection: t.createSelection(m) };
            h && (_.resultRange = e.editing.mapper.toModelRange(h)), e.execute("insertText", _);
          }), b.isAndroid ? this.listenTo(n.document, "keydown", (s, a) => {
            !i.isCollapsed && a.keyCode == 229 && n.document.isComposing && Mm(t, r);
          }) : this.listenTo(n.document, "compositionstart", () => {
            i.isCollapsed || Mm(t, r);
          });
        }
      }
      function Mm(o, e) {
        if (!e.isEnabled)
          return;
        const t = e.buffer;
        t.lock(), o.enqueueChange(t.batch, () => {
          o.deleteContent(o.document.selection);
        }), t.unlock();
      }
      class Nm extends pe {
        constructor(e, t) {
          super(e), this.direction = t, this._buffer = new Om(e.model, e.config.get("typing.undoStep")), this._isEnabledBasedOnSelection = !1;
        }
        get buffer() {
          return this._buffer;
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document;
          t.enqueueChange(this._buffer.batch, (i) => {
            this._buffer.lock();
            const r = i.createSelection(e.selection || n.selection);
            if (!t.canEditAt(r))
              return;
            const s = e.sequence || 1, a = r.isCollapsed;
            if (r.isCollapsed && t.modifySelection(r, { direction: this.direction, unit: e.unit, treatEmojiAsSingleUnit: !0 }), this._shouldEntireContentBeReplacedWithParagraph(s))
              return void this._replaceEntireContentWithParagraph(i);
            if (this._shouldReplaceFirstBlockWithParagraph(r, s))
              return void this.editor.execute("paragraph", { selection: r });
            if (r.isCollapsed)
              return;
            let l = 0;
            r.getFirstRange().getMinimalFlatRanges().forEach((d) => {
              l += Fs(d.getWalker({ singleCharacters: !0, ignoreElementEnd: !0, shallow: !0 }));
            }), t.deleteContent(r, { doNotResetEntireContent: a, direction: this.direction }), this._buffer.input(l), i.setSelection(r), this._buffer.unlock();
          });
        }
        _shouldEntireContentBeReplacedWithParagraph(e) {
          if (e > 1)
            return !1;
          const t = this.editor.model, n = t.document.selection, i = t.schema.getLimitElement(n);
          if (!(n.isCollapsed && n.containsEntireContent(i)) || !t.schema.checkChild(i, "paragraph"))
            return !1;
          const r = i.getChild(0);
          return !r || !r.is("element", "paragraph");
        }
        _replaceEntireContentWithParagraph(e) {
          const t = this.editor.model, n = t.document.selection, i = t.schema.getLimitElement(n), r = e.createElement("paragraph");
          e.remove(e.createRangeIn(i)), e.insert(r, i), e.setSelection(r, 0);
        }
        _shouldReplaceFirstBlockWithParagraph(e, t) {
          const n = this.editor.model;
          if (t > 1 || this.direction != "backward" || !e.isCollapsed)
            return !1;
          const i = e.getFirstPosition(), r = n.schema.getLimitElement(i), s = r.getChild(0);
          return i.parent == s && !!e.containsEntireContent(s) && !!n.schema.checkChild(r, "paragraph") && s.name != "paragraph";
        }
      }
      const Fm = "word", On = "selection", Wo = "backward", Ui = "forward", $m = { deleteContent: { unit: On, direction: Wo }, deleteContentBackward: { unit: "codePoint", direction: Wo }, deleteWordBackward: { unit: Fm, direction: Wo }, deleteHardLineBackward: { unit: On, direction: Wo }, deleteSoftLineBackward: { unit: On, direction: Wo }, deleteContentForward: { unit: "character", direction: Ui }, deleteWordForward: { unit: Fm, direction: Ui }, deleteHardLineForward: { unit: On, direction: Ui }, deleteSoftLineForward: { unit: On, direction: Ui } };
      class Ny extends on {
        constructor(e) {
          super(e);
          const t = e.document;
          let n = 0;
          t.on("keydown", () => {
            n++;
          }), t.on("keyup", () => {
            n = 0;
          }), t.on("beforeinput", (i, r) => {
            if (!this.isEnabled)
              return;
            const { targetRanges: s, domEvent: a, inputType: l } = r, d = $m[l];
            if (!d)
              return;
            const h = { direction: d.direction, unit: d.unit, sequence: n };
            h.unit == On && (h.selectionToRemove = e.createSelection(s[0])), l === "deleteContentBackward" && (b.isAndroid && (h.sequence = 1), function(f) {
              if (f.length != 1 || f[0].isCollapsed)
                return !1;
              const _ = f[0].getWalker({ direction: "backward", singleCharacters: !0, ignoreElementEnd: !0 });
              let E = 0;
              for (const { nextPosition: B } of _) {
                if (B.parent.is("$text")) {
                  const T = B.parent.data, O = B.offset;
                  if (ha(T, O) || ga(T, O) || ru(T, O))
                    continue;
                  E++;
                } else
                  E++;
                if (E > 1)
                  return !0;
              }
              return !1;
            }(s) && (h.unit = On, h.selectionToRemove = e.createSelection(s)));
            const m = new $o(t, "delete", s[0]);
            t.fire(m, new Vo(e, a, h)), m.stop.called && i.stop();
          }), b.isBlink && function(i) {
            const r = i.view, s = r.document;
            let a = null, l = !1;
            function d(m) {
              return m == Ae.backspace || m == Ae.delete;
            }
            function h(m) {
              return m == Ae.backspace ? Wo : Ui;
            }
            s.on("keydown", (m, { keyCode: f }) => {
              a = f, l = !1;
            }), s.on("keyup", (m, { keyCode: f, domEvent: _ }) => {
              const E = s.selection, B = i.isEnabled && f == a && d(f) && !E.isCollapsed && !l;
              if (a = null, B) {
                const T = E.getFirstRange(), O = new $o(s, "delete", T), N = { unit: On, direction: h(f), selectionToRemove: E };
                s.fire(O, new Vo(r, _, N));
              }
            }), s.on("beforeinput", (m, { inputType: f }) => {
              const _ = $m[f];
              d(a) && _ && _.direction == h(a) && (l = !0);
            }, { priority: "high" }), s.on("beforeinput", (m, { inputType: f, data: _ }) => {
              a == Ae.delete && f == "insertText" && _ == "" && m.stop();
            }, { priority: "high" });
          }(this);
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class Go extends G {
        static get pluginName() {
          return "Delete";
        }
        init() {
          const e = this.editor, t = e.editing.view, n = t.document, i = e.model.document;
          t.addObserver(Ny), this._undoOnBackspace = !1;
          const r = new Nm(e, "forward");
          e.commands.add("deleteForward", r), e.commands.add("forwardDelete", r), e.commands.add("delete", new Nm(e, "backward")), this.listenTo(n, "delete", (s, a) => {
            n.isComposing || a.preventDefault();
            const { direction: l, sequence: d, selectionToRemove: h, unit: m } = a, f = l === "forward" ? "deleteForward" : "delete", _ = { sequence: d };
            if (m == "selection") {
              const E = Array.from(h.getRanges()).map((B) => e.editing.mapper.toModelRange(B));
              _.selection = e.model.createSelection(E);
            } else
              _.unit = m;
            e.execute(f, _), t.scrollToTheSelection();
          }, { priority: "low" }), this.editor.plugins.has("UndoEditing") && (this.listenTo(n, "delete", (s, a) => {
            this._undoOnBackspace && a.direction == "backward" && a.sequence == 1 && a.unit == "codePoint" && (this._undoOnBackspace = !1, e.execute("undo"), a.preventDefault(), s.stop());
          }, { context: "$capture" }), this.listenTo(i, "change", () => {
            this._undoOnBackspace = !1;
          }));
        }
        requestUndoOnBackspace() {
          this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0);
        }
      }
      class Fy extends G {
        static get requires() {
          return [zm, Go];
        }
        static get pluginName() {
          return "Typing";
        }
      }
      function Lm(o, e) {
        let t = o.start;
        return { text: Array.from(o.getItems()).reduce((n, i) => i.is("$text") || i.is("$textProxy") ? n + i.data : (t = e.createPositionAfter(i), ""), ""), range: e.createRange(t, o.end) };
      }
      class Vm extends oe() {
        constructor(e, t) {
          super(), this.model = e, this.testCallback = t, this._hasMatch = !1, this.set("isEnabled", !0), this.on("change:isEnabled", () => {
            this.isEnabled ? this._startListening() : (this.stopListening(e.document.selection), this.stopListening(e.document));
          }), this._startListening();
        }
        get hasMatch() {
          return this._hasMatch;
        }
        _startListening() {
          const e = this.model.document;
          this.listenTo(e.selection, "change:range", (t, { directChange: n }) => {
            n && (e.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this._hasMatch = !1));
          }), this.listenTo(e, "change:data", (t, n) => {
            !n.isUndo && n.isLocal && this._evaluateTextBeforeSelection("data", { batch: n });
          });
        }
        _evaluateTextBeforeSelection(e, t = {}) {
          const n = this.model, i = n.document.selection, r = n.createRange(n.createPositionAt(i.focus.parent, 0), i.focus), { text: s, range: a } = Lm(r, n), l = this.testCallback(s);
          if (!l && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!l, l) {
            const d = Object.assign(t, { text: s, range: a });
            typeof l == "object" && Object.assign(d, l), this.fire(`matched:${e}`, d);
          }
        }
      }
      class jm extends G {
        constructor(e) {
          super(e), this.attributes = /* @__PURE__ */ new Set(), this._overrideUid = null;
        }
        static get pluginName() {
          return "TwoStepCaretMovement";
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view, i = e.locale, r = t.document.selection;
          this.listenTo(n.document, "arrowKey", (s, a) => {
            if (!r.isCollapsed || a.shiftKey || a.altKey || a.ctrlKey)
              return;
            const l = a.keyCode == Ae.arrowright, d = a.keyCode == Ae.arrowleft;
            if (!l && !d)
              return;
            const h = i.contentLanguageDirection;
            let m = !1;
            m = h === "ltr" && l || h === "rtl" && d ? this._handleForwardMovement(a) : this._handleBackwardMovement(a), m === !0 && s.stop();
          }, { context: "$text", priority: "highest" }), this._isNextGravityRestorationSkipped = !1, this.listenTo(r, "change:range", (s, a) => {
            this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = !1 : this._isGravityOverridden && (!a.directChange && as(r.getFirstPosition(), this.attributes) || this._restoreGravity());
          });
        }
        registerAttribute(e) {
          this.attributes.add(e);
        }
        _handleForwardMovement(e) {
          const t = this.attributes, n = this.editor.model.document.selection, i = n.getFirstPosition();
          return !this._isGravityOverridden && (!i.isAtStart || !vl(n, t)) && !!as(i, t) && (ss(e), this._overrideGravity(), !0);
        }
        _handleBackwardMovement(e) {
          const t = this.attributes, n = this.editor.model, i = n.document.selection, r = i.getFirstPosition();
          return this._isGravityOverridden ? (ss(e), this._restoreGravity(), _l(n, t, r), !0) : r.isAtStart ? !!vl(i, t) && (ss(e), _l(n, t, r), !0) : !!function(s, a) {
            const l = s.getShiftedBy(-1);
            return as(l, a);
          }(r, t) && (r.isAtEnd && !vl(i, t) && as(r, t) ? (ss(e), _l(n, t, r), !0) : (this._isNextGravityRestorationSkipped = !0, this._overrideGravity(), !1));
        }
        get _isGravityOverridden() {
          return !!this._overrideUid;
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change((e) => e.overrideSelectionGravity());
        }
        _restoreGravity() {
          this.editor.model.change((e) => {
            e.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
          });
        }
      }
      function vl(o, e) {
        for (const t of e)
          if (o.hasAttribute(t))
            return !0;
        return !1;
      }
      function _l(o, e, t) {
        const n = t.nodeBefore;
        o.change((i) => {
          n ? i.setSelectionAttribute(n.getAttributes()) : i.removeSelectionAttribute(e);
        });
      }
      function ss(o) {
        o.preventDefault();
      }
      function as(o, e) {
        const { nodeBefore: t, nodeAfter: n } = o;
        for (const i of e) {
          const r = t ? t.getAttribute(i) : void 0;
          if ((n ? n.getAttribute(i) : void 0) !== r)
            return !0;
        }
        return !1;
      }
      var Hm = /[\\^$.*+?()[\]{}|]/g, $y = RegExp(Hm.source);
      const Ly = function(o) {
        return (o = Aa(o)) && $y.test(o) ? o.replace(Hm, "\\$&") : o;
      }, Um = { copyright: { from: "(c)", to: "©" }, registeredTrademark: { from: "(r)", to: "®" }, trademark: { from: "(tm)", to: "™" }, oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null] }, oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null] }, twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null] }, oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null] }, threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null] }, lessThanOrEqual: { from: "<=", to: "≤" }, greaterThanOrEqual: { from: ">=", to: "≥" }, notEqual: { from: "!=", to: "≠" }, arrowLeft: { from: "<-", to: "←" }, arrowRight: { from: "->", to: "→" }, horizontalEllipsis: { from: "...", to: "…" }, enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] }, emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] }, quotesPrimary: { from: Ko('"'), to: [null, "“", null, "”"] }, quotesSecondary: { from: Ko("'"), to: [null, "‘", null, "’"] }, quotesPrimaryEnGb: { from: Ko("'"), to: [null, "‘", null, "’"] }, quotesSecondaryEnGb: { from: Ko('"'), to: [null, "“", null, "”"] }, quotesPrimaryPl: { from: Ko('"'), to: [null, "„", null, "”"] }, quotesSecondaryPl: { from: Ko("'"), to: [null, "‚", null, "’"] } }, qm = { symbols: ["copyright", "registeredTrademark", "trademark"], mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"], typography: ["horizontalEllipsis", "enDash", "emDash"], quotes: ["quotesPrimary", "quotesSecondary"] }, Vy = ["symbols", "mathematical", "typography", "quotes"];
      function jy(o) {
        return typeof o == "string" ? new RegExp(`(${Ly(o)})$`) : o;
      }
      function Hy(o) {
        return typeof o == "string" ? () => [o] : o instanceof Array ? () => o : o;
      }
      function Uy(o) {
        return (o.textNode ? o.textNode : o.nodeAfter).getAttributes();
      }
      function Ko(o) {
        return new RegExp(`(^|\\s)(${o})([^${o}]*)(${o})$`);
      }
      function Zo(o, e, t, n) {
        return n.createRange(Wm(o, e, t, !0, n), Wm(o, e, t, !1, n));
      }
      function Wm(o, e, t, n, i) {
        let r = o.textNode || (n ? o.nodeBefore : o.nodeAfter), s = null;
        for (; r && r.getAttribute(e) == t; )
          s = r, r = n ? r.previousSibling : r.nextSibling;
        return s ? i.createPositionAt(s, n ? "before" : "after") : o;
      }
      function* Gm(o, e) {
        for (const t of e)
          t && o.getAttributeProperties(t[0]).copyOnEnter && (yield t);
      }
      class qy extends pe {
        execute() {
          this.editor.model.change((e) => {
            this.enterBlock(e), this.fire("afterExecute", { writer: e });
          });
        }
        enterBlock(e) {
          const t = this.editor.model, n = t.document.selection, i = t.schema, r = n.isCollapsed, s = n.getFirstRange(), a = s.start.parent, l = s.end.parent;
          if (i.isLimit(a) || i.isLimit(l))
            return r || a != l || t.deleteContent(n), !1;
          if (r) {
            const d = Gm(e.model.schema, n.getAttributes());
            return Km(e, s.start), e.setSelectionAttribute(d), !0;
          }
          {
            const d = !(s.start.isAtStart && s.end.isAtEnd), h = a == l;
            if (t.deleteContent(n, { leaveUnmerged: d }), d) {
              if (h)
                return Km(e, n.focus), !0;
              e.setSelection(l, 0);
            }
          }
          return !1;
        }
      }
      function Km(o, e) {
        o.split(e), o.setSelection(e.parent.nextSibling, 0);
      }
      const Wy = { insertParagraph: { isSoft: !1 }, insertLineBreak: { isSoft: !0 } };
      class Zm extends on {
        constructor(e) {
          super(e);
          const t = this.document;
          let n = !1;
          t.on("keydown", (i, r) => {
            n = r.shiftKey;
          }), t.on("beforeinput", (i, r) => {
            if (!this.isEnabled)
              return;
            let s = r.inputType;
            b.isSafari && n && s == "insertParagraph" && (s = "insertLineBreak");
            const a = r.domEvent, l = Wy[s];
            if (!l)
              return;
            const d = new $o(t, "enter", r.targetRanges[0]);
            t.fire(d, new Vo(e, a, { isSoft: l.isSoft })), d.stop.called && i.stop();
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class qi extends G {
        static get pluginName() {
          return "Enter";
        }
        init() {
          const e = this.editor, t = e.editing.view, n = t.document;
          t.addObserver(Zm), e.commands.add("enter", new qy(e)), this.listenTo(n, "enter", (i, r) => {
            n.isComposing || r.preventDefault(), r.isSoft || (e.execute("enter"), t.scrollToTheSelection());
          }, { priority: "low" });
        }
      }
      class Gy extends pe {
        execute() {
          const e = this.editor.model, t = e.document;
          e.change((n) => {
            (function(i, r, s) {
              const a = s.isCollapsed, l = s.getFirstRange(), d = l.start.parent, h = l.end.parent, m = d == h;
              if (a) {
                const f = Gm(i.schema, s.getAttributes());
                Jm(i, r, l.end), r.removeSelectionAttribute(s.getAttributeKeys()), r.setSelectionAttribute(f);
              } else {
                const f = !(l.start.isAtStart && l.end.isAtEnd);
                i.deleteContent(s, { leaveUnmerged: f }), m ? Jm(i, r, s.focus) : f && r.setSelection(h, 0);
              }
            })(e, n, t.selection), this.fire("afterExecute", { writer: n });
          });
        }
        refresh() {
          const e = this.editor.model, t = e.document;
          this.isEnabled = function(n, i) {
            if (i.rangeCount > 1)
              return !1;
            const r = i.anchor;
            if (!r || !n.checkChild(r, "softBreak"))
              return !1;
            const s = i.getFirstRange(), a = s.start.parent, l = s.end.parent;
            return !((Al(a, n) || Al(l, n)) && a !== l);
          }(e.schema, t.selection);
        }
      }
      function Jm(o, e, t) {
        const n = e.createElement("softBreak");
        o.insertContent(n, t), e.setSelection(n, "after");
      }
      function Al(o, e) {
        return !o.is("rootElement") && (e.isLimit(o) || Al(o.parent, e));
      }
      class Ky extends G {
        static get pluginName() {
          return "ShiftEnter";
        }
        init() {
          const e = this.editor, t = e.model.schema, n = e.conversion, i = e.editing.view, r = i.document;
          t.register("softBreak", { allowWhere: "$text", isInline: !0 }), n.for("upcast").elementToElement({ model: "softBreak", view: "br" }), n.for("downcast").elementToElement({ model: "softBreak", view: (s, { writer: a }) => a.createEmptyElement("br") }), i.addObserver(Zm), e.commands.add("shiftEnter", new Gy(e)), this.listenTo(r, "enter", (s, a) => {
            r.isComposing || a.preventDefault(), a.isSoft && (e.execute("shiftEnter"), i.scrollToTheSelection());
          }, { priority: "low" });
        }
      }
      class Zy extends De() {
        constructor() {
          super(...arguments), this._stack = [];
        }
        add(e, t) {
          const n = this._stack, i = n[0];
          this._insertDescriptor(e);
          const r = n[0];
          i === r || Cl(i, r) || this.fire("change:top", { oldDescriptor: i, newDescriptor: r, writer: t });
        }
        remove(e, t) {
          const n = this._stack, i = n[0];
          this._removeDescriptor(e);
          const r = n[0];
          i === r || Cl(i, r) || this.fire("change:top", { oldDescriptor: i, newDescriptor: r, writer: t });
        }
        _insertDescriptor(e) {
          const t = this._stack, n = t.findIndex((r) => r.id === e.id);
          if (Cl(e, t[n]))
            return;
          n > -1 && t.splice(n, 1);
          let i = 0;
          for (; t[i] && Jy(t[i], e); )
            i++;
          t.splice(i, 0, e);
        }
        _removeDescriptor(e) {
          const t = this._stack, n = t.findIndex((i) => i.id === e);
          n > -1 && t.splice(n, 1);
        }
      }
      function Cl(o, e) {
        return o && e && o.priority == e.priority && ls(o.classes) == ls(e.classes);
      }
      function Jy(o, e) {
        return o.priority > e.priority || !(o.priority < e.priority) && ls(o.classes) > ls(e.classes);
      }
      function ls(o) {
        return Array.isArray(o) ? o.sort().join(",") : o;
      }
      const Yy = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>', Qy = "ck-widget", Ym = "ck-widget_selected";
      function Je(o) {
        return !!o.is("element") && !!o.getCustomProperty("widget");
      }
      function yl(o, e, t = {}) {
        if (!o.is("containerElement"))
          throw new I("widget-to-widget-wrong-element-type", null, { element: o });
        return e.setAttribute("contenteditable", "false", o), e.addClass(Qy, o), e.setCustomProperty("widget", !0, o), o.getFillerOffset = n2, e.setCustomProperty("widgetLabel", [], o), t.label && function(n, i) {
          n.getCustomProperty("widgetLabel").push(i);
        }(o, t.label), t.hasSelectionHandle && function(n, i) {
          const r = i.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(s) {
            const a = this.toDomElement(s), l = new xi();
            return l.set("content", Yy), l.render(), a.appendChild(l.element), a;
          });
          i.insert(i.createPositionAt(n, 0), r), i.addClass(["ck-widget_with-selection-handle"], n);
        }(o, e), Qm(o, e), o;
      }
      function Xy(o, e, t) {
        if (e.classes && t.addClass(Xe(e.classes), o), e.attributes)
          for (const n in e.attributes)
            t.setAttribute(n, e.attributes[n], o);
      }
      function e2(o, e, t) {
        if (e.classes && t.removeClass(Xe(e.classes), o), e.attributes)
          for (const n in e.attributes)
            t.removeAttribute(n, o);
      }
      function Qm(o, e, t = Xy, n = e2) {
        const i = new Zy();
        i.on("change:top", (r, s) => {
          s.oldDescriptor && n(o, s.oldDescriptor, s.writer), s.newDescriptor && t(o, s.newDescriptor, s.writer);
        }), e.setCustomProperty("addHighlight", (r, s, a) => i.add(s, a), o), e.setCustomProperty("removeHighlight", (r, s, a) => i.remove(s, a), o);
      }
      function t2(o, e, t = {}) {
        return e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], o), e.setAttribute("role", "textbox", o), t.label && e.setAttribute("aria-label", t.label, o), e.setAttribute("contenteditable", o.isReadOnly ? "false" : "true", o), o.on("change:isReadOnly", (n, i, r) => {
          e.setAttribute("contenteditable", r ? "false" : "true", o);
        }), o.on("change:isFocused", (n, i, r) => {
          r ? e.addClass("ck-editor__nested-editable_focused", o) : e.removeClass("ck-editor__nested-editable_focused", o);
        }), Qm(o, e), o;
      }
      function n2() {
        return null;
      }
      const kn = "widget-type-around";
      function so(o, e, t) {
        return !!o && Je(o) && !t.isInline(e);
      }
      function Rn(o) {
        return o.getAttribute(kn);
      }
      var Xm = k(4921), o2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Xm.Z, o2), Xm.Z.locals;
      const ep = ["before", "after"], i2 = new DOMParser().parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', "image/svg+xml").firstChild, tp = "ck-widget__type-around_disabled";
      class r2 extends G {
        constructor() {
          super(...arguments), this._currentFakeCaretModelElement = null;
        }
        static get pluginName() {
          return "WidgetTypeAround";
        }
        static get requires() {
          return [qi, Go];
        }
        init() {
          const e = this.editor, t = e.editing.view;
          this.on("change:isEnabled", (n, i, r) => {
            t.change((s) => {
              for (const a of t.document.roots)
                r ? s.removeClass(tp, a) : s.addClass(tp, a);
            }), r || e.model.change((s) => {
              s.removeSelectionAttribute(kn);
            });
          }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration();
        }
        destroy() {
          super.destroy(), this._currentFakeCaretModelElement = null;
        }
        _insertParagraph(e, t) {
          const n = this.editor, i = n.editing.view, r = n.model.schema.getAttributesWithProperty(e, "copyOnReplace", !0);
          n.execute("insertParagraph", { position: n.model.createPositionAt(e, t), attributes: r }), i.focus(), i.scrollToTheSelection();
        }
        _listenToIfEnabled(e, t, n, i) {
          this.listenTo(e, t, (...r) => {
            this.isEnabled && n(...r);
          }, i);
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const e = this.editor.model.document.selection, t = Rn(e);
          if (!t)
            return !1;
          const n = e.getSelectedElement();
          return this._insertParagraph(n, t), !0;
        }
        _enableTypeAroundUIInjection() {
          const e = this.editor, t = e.model.schema, n = e.locale.t, i = { before: n("Insert paragraph before block"), after: n("Insert paragraph after block") };
          e.editing.downcastDispatcher.on("insert", (r, s, a) => {
            const l = a.mapper.toViewElement(s.item);
            l && so(l, s.item, t) && (function(d, h, m) {
              const f = d.createUIElement("div", { class: "ck ck-reset_all ck-widget__type-around" }, function(_) {
                const E = this.toDomElement(_);
                return function(B, T) {
                  for (const O of ep) {
                    const N = new Xt({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${O}`], title: T[O], "aria-hidden": "true" }, children: [B.ownerDocument.importNode(i2, !0)] });
                    B.appendChild(N.render());
                  }
                }(E, h), function(B) {
                  const T = new Xt({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] } });
                  B.appendChild(T.render());
                }(E), E;
              });
              d.insert(d.createPositionAt(m, "end"), f);
            }(a.writer, i, l), l.getCustomProperty("widgetLabel").push(() => this.isEnabled ? n("Press Enter to type after or press Shift + Enter to type before the widget") : ""));
          }, { priority: "low" });
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const e = this.editor, t = e.model, n = t.document.selection, i = t.schema, r = e.editing.view;
          function s(a) {
            return `ck-widget_type-around_show-fake-caret_${a}`;
          }
          this._listenToIfEnabled(r.document, "arrowKey", (a, l) => {
            this._handleArrowKeyPress(a, l);
          }, { context: [Je, "$text"], priority: "high" }), this._listenToIfEnabled(n, "change:range", (a, l) => {
            l.directChange && e.model.change((d) => {
              d.removeSelectionAttribute(kn);
            });
          }), this._listenToIfEnabled(t.document, "change:data", () => {
            const a = n.getSelectedElement();
            a && so(e.editing.mapper.toViewElement(a), a, i) || e.model.change((l) => {
              l.removeSelectionAttribute(kn);
            });
          }), this._listenToIfEnabled(e.editing.downcastDispatcher, "selection", (a, l, d) => {
            const h = d.writer;
            if (this._currentFakeCaretModelElement) {
              const E = d.mapper.toViewElement(this._currentFakeCaretModelElement);
              E && (h.removeClass(ep.map(s), E), this._currentFakeCaretModelElement = null);
            }
            const m = l.selection.getSelectedElement();
            if (!m)
              return;
            const f = d.mapper.toViewElement(m);
            if (!so(f, m, i))
              return;
            const _ = Rn(l.selection);
            _ && (h.addClass(s(_), f), this._currentFakeCaretModelElement = m);
          }), this._listenToIfEnabled(e.ui.focusTracker, "change:isFocused", (a, l, d) => {
            d || e.model.change((h) => {
              h.removeSelectionAttribute(kn);
            });
          });
        }
        _handleArrowKeyPress(e, t) {
          const n = this.editor, i = n.model, r = i.document.selection, s = i.schema, a = n.editing.view, l = function(m, f) {
            const _ = da(m, f);
            return _ === "down" || _ === "right";
          }(t.keyCode, n.locale.contentLanguageDirection), d = a.document.selection.getSelectedElement();
          let h;
          so(d, n.editing.mapper.toModelElement(d), s) ? h = this._handleArrowKeyPressOnSelectedWidget(l) : r.isCollapsed ? h = this._handleArrowKeyPressWhenSelectionNextToAWidget(l) : t.shiftKey || (h = this._handleArrowKeyPressWhenNonCollapsedSelection(l)), h && (t.preventDefault(), e.stop());
        }
        _handleArrowKeyPressOnSelectedWidget(e) {
          const t = this.editor.model, n = Rn(t.document.selection);
          return t.change((i) => n ? n !== (e ? "after" : "before") ? (i.removeSelectionAttribute(kn), !0) : !1 : (i.setSelectionAttribute(kn, e ? "after" : "before"), !0));
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(e) {
          const t = this.editor, n = t.model, i = n.schema, r = t.plugins.get("Widget"), s = r._getObjectElementNextToSelection(e);
          return !!so(t.editing.mapper.toViewElement(s), s, i) && (n.change((a) => {
            r._setSelectionOverElement(s), a.setSelectionAttribute(kn, e ? "before" : "after");
          }), !0);
        }
        _handleArrowKeyPressWhenNonCollapsedSelection(e) {
          const t = this.editor, n = t.model, i = n.schema, r = t.editing.mapper, s = n.document.selection, a = e ? s.getLastPosition().nodeBefore : s.getFirstPosition().nodeAfter;
          return !!so(r.toViewElement(a), a, i) && (n.change((l) => {
            l.setSelection(a, "on"), l.setSelectionAttribute(kn, e ? "after" : "before");
          }), !0);
        }
        _enableInsertingParagraphsOnButtonClick() {
          const e = this.editor, t = e.editing.view;
          this._listenToIfEnabled(t.document, "mousedown", (n, i) => {
            const r = i.domTarget.closest(".ck-widget__type-around__button");
            if (!r)
              return;
            const s = function(d) {
              return d.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
            }(r), a = function(d, h) {
              const m = d.closest(".ck-widget");
              return h.mapDomToView(m);
            }(r, t.domConverter), l = e.editing.mapper.toModelElement(a);
            this._insertParagraph(l, s), i.preventDefault(), n.stop();
          });
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const e = this.editor, t = e.model.document.selection, n = e.editing.view;
          this._listenToIfEnabled(n.document, "enter", (i, r) => {
            if (i.eventPhase != "atTarget")
              return;
            const s = t.getSelectedElement(), a = e.editing.mapper.toViewElement(s), l = e.model.schema;
            let d;
            this._insertParagraphAccordingToFakeCaretPosition() ? d = !0 : so(a, s, l) && (this._insertParagraph(s, r.isSoft ? "before" : "after"), d = !0), d && (r.preventDefault(), i.stop());
          }, { context: Je });
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const e = this.editor.editing.view.document;
          this._listenToIfEnabled(e, "insertText", (t, n) => {
            this._insertParagraphAccordingToFakeCaretPosition() && (n.selection = e.selection);
          }, { priority: "high" }), b.isAndroid ? this._listenToIfEnabled(e, "keydown", (t, n) => {
            n.keyCode == 229 && this._insertParagraphAccordingToFakeCaretPosition();
          }) : this._listenToIfEnabled(e, "compositionstart", () => {
            this._insertParagraphAccordingToFakeCaretPosition();
          }, { priority: "high" });
        }
        _enableDeleteIntegration() {
          const e = this.editor, t = e.editing.view, n = e.model, i = n.schema;
          this._listenToIfEnabled(t.document, "delete", (r, s) => {
            if (r.eventPhase != "atTarget")
              return;
            const a = Rn(n.document.selection);
            if (!a)
              return;
            const l = s.direction, d = n.document.selection.getSelectedElement(), h = l == "forward";
            if (a === "before" === h)
              e.execute("delete", { selection: n.createSelection(d, "on") });
            else {
              const m = i.getNearestSelectionRange(n.createPositionAt(d, a), l);
              if (m)
                if (m.isCollapsed) {
                  const f = n.createSelection(m.start);
                  if (n.modifySelection(f, { direction: l }), f.focus.isEqual(m.start)) {
                    const _ = function(E, B) {
                      let T = B;
                      for (const O of B.getAncestors({ parentFirst: !0 })) {
                        if (O.childCount > 1 || E.isLimit(O))
                          break;
                        T = O;
                      }
                      return T;
                    }(i, m.start.parent);
                    n.deleteContent(n.createSelection(_, "on"), { doNotAutoparagraph: !0 });
                  } else
                    n.change((_) => {
                      _.setSelection(m), e.execute(h ? "deleteForward" : "delete");
                    });
                } else
                  n.change((f) => {
                    f.setSelection(m), e.execute(h ? "deleteForward" : "delete");
                  });
            }
            s.preventDefault(), r.stop();
          }, { context: Je });
        }
        _enableInsertContentIntegration() {
          const e = this.editor, t = this.editor.model, n = t.document.selection;
          this._listenToIfEnabled(e.model, "insertContent", (i, [r, s]) => {
            if (s && !s.is("documentSelection"))
              return;
            const a = Rn(n);
            return a ? (i.stop(), t.change((l) => {
              const d = n.getSelectedElement(), h = t.createPositionAt(d, a), m = l.createSelection(h), f = t.insertContent(r, m);
              return l.setSelection(m), f;
            })) : void 0;
          }, { priority: "high" });
        }
        _enableInsertObjectIntegration() {
          const e = this.editor, t = this.editor.model.document.selection;
          this._listenToIfEnabled(e.model, "insertObject", (n, i) => {
            const [, r, s = {}] = i;
            if (r && !r.is("documentSelection"))
              return;
            const a = Rn(t);
            a && (s.findOptimalPosition = a, i[3] = s);
          }, { priority: "high" });
        }
        _enableDeleteContentIntegration() {
          const e = this.editor, t = this.editor.model.document.selection;
          this._listenToIfEnabled(e.model, "deleteContent", (n, [i]) => {
            i && !i.is("documentSelection") || Rn(t) && n.stop();
          }, { priority: "high" });
        }
      }
      function s2(o) {
        const e = o.model;
        return (t, n) => {
          const i = n.keyCode == Ae.arrowup, r = n.keyCode == Ae.arrowdown, s = n.shiftKey, a = e.document.selection;
          if (!i && !r)
            return;
          const l = r;
          if (s && function(h, m) {
            return !h.isCollapsed && h.isBackward == m;
          }(a, l))
            return;
          const d = function(h, m, f) {
            const _ = h.model;
            if (f) {
              const E = m.isCollapsed ? m.focus : m.getLastPosition(), B = np(_, E, "forward");
              if (!B)
                return null;
              const T = _.createRange(E, B), O = op(_.schema, T, "backward");
              return O ? _.createRange(E, O) : null;
            }
            {
              const E = m.isCollapsed ? m.focus : m.getFirstPosition(), B = np(_, E, "backward");
              if (!B)
                return null;
              const T = _.createRange(B, E), O = op(_.schema, T, "forward");
              return O ? _.createRange(O, E) : null;
            }
          }(o, a, l);
          if (d) {
            if (d.isCollapsed && (a.isCollapsed || s))
              return;
            (d.isCollapsed || function(h, m, f) {
              const _ = h.model, E = h.view.domConverter;
              if (f) {
                const H = _.createSelection(m.start);
                _.modifySelection(H), H.focus.isAtEnd || m.start.isEqual(H.focus) || (m = _.createRange(H.focus, m.end));
              }
              const B = h.mapper.toViewRange(m), T = E.viewRangeToDom(B), O = Ze.getDomRangeRects(T);
              let N;
              for (const H of O)
                if (N !== void 0) {
                  if (Math.round(H.top) >= N)
                    return !1;
                  N = Math.max(N, Math.round(H.bottom));
                } else
                  N = Math.round(H.bottom);
              return !0;
            }(o, d, l)) && (e.change((h) => {
              const m = l ? d.end : d.start;
              if (s) {
                const f = e.createSelection(a.anchor);
                f.setFocus(m), h.setSelection(f);
              } else
                h.setSelection(m);
            }), t.stop(), n.preventDefault(), n.stopPropagation());
          }
        };
      }
      function np(o, e, t) {
        const n = o.schema, i = o.createRangeIn(e.root), r = t == "forward" ? "elementStart" : "elementEnd";
        for (const { previousPosition: s, item: a, type: l } of i.getWalker({ startPosition: e, direction: t })) {
          if (n.isLimit(a) && !n.isInline(a))
            return s;
          if (l == r && n.isBlock(a))
            return null;
        }
        return null;
      }
      function op(o, e, t) {
        const n = t == "backward" ? e.end : e.start;
        if (o.checkChild(n, "$text"))
          return n;
        for (const { nextPosition: i } of e.getWalker({ direction: t }))
          if (o.checkChild(i, "$text"))
            return i;
        return null;
      }
      var ip = k(3488), a2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(ip.Z, a2), ip.Z.locals;
      class Wi extends G {
        constructor() {
          super(...arguments), this._previouslySelected = /* @__PURE__ */ new Set();
        }
        static get pluginName() {
          return "Widget";
        }
        static get requires() {
          return [r2, Go];
        }
        init() {
          const e = this.editor, t = e.editing.view, n = t.document;
          this.editor.editing.downcastDispatcher.on("selection", (i, r, s) => {
            const a = s.writer, l = r.selection;
            if (l.isCollapsed)
              return;
            const d = l.getSelectedElement();
            if (!d)
              return;
            const h = e.editing.mapper.toViewElement(d);
            var m;
            Je(h) && s.consumable.consume(l, "selection") && a.setSelection(a.createRangeOn(h), { fake: !0, label: (m = h, m.getCustomProperty("widgetLabel").reduce((f, _) => typeof _ == "function" ? f ? f + ". " + _() : _() : f ? f + ". " + _ : _, "")) });
          }), this.editor.editing.downcastDispatcher.on("selection", (i, r, s) => {
            this._clearPreviouslySelectedWidgets(s.writer);
            const a = s.writer, l = a.document.selection;
            let d = null;
            for (const h of l.getRanges())
              for (const m of h) {
                const f = m.item;
                Je(f) && !l2(f, d) && (a.addClass(Ym, f), this._previouslySelected.add(f), d = f);
              }
          }, { priority: "low" }), t.addObserver(tl), this.listenTo(n, "mousedown", (...i) => this._onMousedown(...i)), this.listenTo(n, "arrowKey", (...i) => {
            this._handleSelectionChangeOnArrowKeyPress(...i);
          }, { context: [Je, "$text"] }), this.listenTo(n, "arrowKey", (...i) => {
            this._preventDefaultOnArrowKeyPress(...i);
          }, { context: "$root" }), this.listenTo(n, "arrowKey", s2(this.editor.editing), { context: "$text" }), this.listenTo(n, "delete", (i, r) => {
            this._handleDelete(r.direction == "forward") && (r.preventDefault(), i.stop());
          }, { context: "$root" });
        }
        _onMousedown(e, t) {
          const n = this.editor, i = n.editing.view, r = i.document;
          let s = t.target;
          if (function(l) {
            let d = l;
            for (; d; ) {
              if (d.is("editableElement") && !d.is("rootElement"))
                return !0;
              if (Je(d))
                return !1;
              d = d.parent;
            }
            return !1;
          }(s)) {
            if ((b.isSafari || b.isGecko) && t.domEvent.detail >= 3) {
              const l = n.editing.mapper, d = s.is("attributeElement") ? s.findAncestor((m) => !m.is("attributeElement")) : s, h = l.toModelElement(d);
              t.preventDefault(), this.editor.model.change((m) => {
                m.setSelection(h, "in");
              });
            }
            return;
          }
          if (!Je(s) && (s = s.findAncestor(Je), !s))
            return;
          b.isAndroid && t.preventDefault(), r.isFocused || i.focus();
          const a = n.editing.mapper.toModelElement(s);
          this._setSelectionOverElement(a);
        }
        _handleSelectionChangeOnArrowKeyPress(e, t) {
          const n = t.keyCode, i = this.editor.model, r = i.schema, s = i.document.selection, a = s.getSelectedElement(), l = da(n, this.editor.locale.contentLanguageDirection), d = l == "down" || l == "right", h = l == "up" || l == "down";
          if (a && r.isObject(a)) {
            const f = d ? s.getLastPosition() : s.getFirstPosition(), _ = r.getNearestSelectionRange(f, d ? "forward" : "backward");
            return void (_ && (i.change((E) => {
              E.setSelection(_);
            }), t.preventDefault(), e.stop()));
          }
          if (!s.isCollapsed && !t.shiftKey) {
            const f = s.getFirstPosition(), _ = s.getLastPosition(), E = f.nodeAfter, B = _.nodeBefore;
            return void ((E && r.isObject(E) || B && r.isObject(B)) && (i.change((T) => {
              T.setSelection(d ? _ : f);
            }), t.preventDefault(), e.stop()));
          }
          if (!s.isCollapsed)
            return;
          const m = this._getObjectElementNextToSelection(d);
          if (m && r.isObject(m)) {
            if (r.isInline(m) && h)
              return;
            this._setSelectionOverElement(m), t.preventDefault(), e.stop();
          }
        }
        _preventDefaultOnArrowKeyPress(e, t) {
          const n = this.editor.model, i = n.schema, r = n.document.selection.getSelectedElement();
          r && i.isObject(r) && (t.preventDefault(), e.stop());
        }
        _handleDelete(e) {
          const t = this.editor.model.document.selection;
          if (!this.editor.model.canEditAt(t) || !t.isCollapsed)
            return;
          const n = this._getObjectElementNextToSelection(e);
          return n ? (this.editor.model.change((i) => {
            let r = t.anchor.parent;
            for (; r.isEmpty; ) {
              const s = r;
              r = s.parent, i.remove(s);
            }
            this._setSelectionOverElement(n);
          }), !0) : void 0;
        }
        _setSelectionOverElement(e) {
          this.editor.model.change((t) => {
            t.setSelection(t.createRangeOn(e));
          });
        }
        _getObjectElementNextToSelection(e) {
          const t = this.editor.model, n = t.schema, i = t.document.selection, r = t.createSelection(i);
          if (t.modifySelection(r, { direction: e ? "forward" : "backward" }), r.isEqual(i))
            return null;
          const s = e ? r.focus.nodeBefore : r.focus.nodeAfter;
          return s && n.isObject(s) ? s : null;
        }
        _clearPreviouslySelectedWidgets(e) {
          for (const t of this._previouslySelected)
            e.removeClass(Ym, t);
          this._previouslySelected.clear();
        }
      }
      function l2(o, e) {
        return !!e && Array.from(o.getAncestors()).includes(e);
      }
      class cs extends G {
        constructor() {
          super(...arguments), this._toolbarDefinitions = /* @__PURE__ */ new Map();
        }
        static get requires() {
          return [os];
        }
        static get pluginName() {
          return "WidgetToolbarRepository";
        }
        init() {
          const e = this.editor;
          if (e.plugins.has("BalloonToolbar")) {
            const t = e.plugins.get("BalloonToolbar");
            this.listenTo(t, "show", (n) => {
              (function(i) {
                const r = i.getSelectedElement();
                return !(!r || !Je(r));
              })(e.editing.view.document.selection) && n.stop();
            }, { priority: "high" });
          }
          this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
            this._updateToolbarsVisibility();
          }), this.listenTo(e.ui, "update", () => {
            this._updateToolbarsVisibility();
          }), this.listenTo(e.ui.focusTracker, "change:isFocused", () => {
            this._updateToolbarsVisibility();
          }, { priority: "low" });
        }
        destroy() {
          super.destroy();
          for (const e of this._toolbarDefinitions.values())
            e.view.destroy();
        }
        register(e, { ariaLabel: t, items: n, getRelatedElement: i, balloonClassName: r = "ck-toolbar-container" }) {
          if (!n.length)
            return void ne("widget-toolbar-no-items", { toolbarId: e });
          const s = this.editor, a = s.t, l = new ol(s.locale);
          if (l.ariaLabel = t || a("Widget toolbar"), this._toolbarDefinitions.has(e))
            throw new I("widget-toolbar-duplicated", this, { toolbarId: e });
          const d = { view: l, getRelatedElement: i, balloonClassName: r, itemsConfig: n, initialized: !1 };
          s.ui.addToolbar(l, { isContextual: !0, beforeFocus: () => {
            const h = i(s.editing.view.document.selection);
            h && this._showToolbar(d, h);
          }, afterBlur: () => {
            this._hideToolbar(d);
          } }), this._toolbarDefinitions.set(e, d);
        }
        _updateToolbarsVisibility() {
          let e = 0, t = null, n = null;
          for (const i of this._toolbarDefinitions.values()) {
            const r = i.getRelatedElement(this.editor.editing.view.document.selection);
            if (this.isEnabled && r)
              if (this.editor.ui.focusTracker.isFocused) {
                const s = r.getAncestors().length;
                s > e && (e = s, t = r, n = i);
              } else
                this._isToolbarVisible(i) && this._hideToolbar(i);
            else
              this._isToolbarInBalloon(i) && this._hideToolbar(i);
          }
          n && this._showToolbar(n, t);
        }
        _hideToolbar(e) {
          this._balloon.remove(e.view), this.stopListening(this._balloon, "change:visibleView");
        }
        _showToolbar(e, t) {
          this._isToolbarVisible(e) ? rp(this.editor, t) : this._isToolbarInBalloon(e) || (e.initialized || (e.initialized = !0, e.view.fillFromConfig(e.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({ view: e.view, position: sp(this.editor, t), balloonClassName: e.balloonClassName }), this.listenTo(this._balloon, "change:visibleView", () => {
            for (const n of this._toolbarDefinitions.values())
              if (this._isToolbarVisible(n)) {
                const i = n.getRelatedElement(this.editor.editing.view.document.selection);
                rp(this.editor, i);
              }
          }));
        }
        _isToolbarVisible(e) {
          return this._balloon.visibleView === e.view;
        }
        _isToolbarInBalloon(e) {
          return this._balloon.hasView(e.view);
        }
      }
      function rp(o, e) {
        const t = o.plugins.get("ContextualBalloon"), n = sp(o, e);
        t.updatePosition(n);
      }
      function sp(o, e) {
        const t = o.editing.view, n = St.defaultPositions;
        return { target: t.domConverter.mapViewToDom(e), positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast, n.viewportStickyNorth] };
      }
      var ap = k(8506), c2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(ap.Z, c2), ap.Z.locals;
      var lp = k(903), d2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(lp.Z, d2), lp.Z.locals;
      class u2 extends G {
        static get pluginName() {
          return "DragDrop";
        }
        static get requires() {
          return [bn, Wi];
        }
        init() {
          const e = this.editor, t = e.editing.view;
          this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, this._updateDropMarkerThrottled = fl((n) => this._updateDropMarker(n), 40), this._removeDropMarkerDelayed = ua(() => this._removeDropMarker(), 40), this._clearDraggableAttributesDelayed = ua(() => this._clearDraggableAttributes(), 40), e.plugins.has("DragDropExperimental") ? this.forceDisabled("DragDropExperimental") : (t.addObserver(wl), t.addObserver(tl), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDropMarker(), this._setupDraggableAttributeHandling(), this.listenTo(e, "change:isReadOnly", (n, i, r) => {
            r ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
          }), this.on("change:isEnabled", (n, i, r) => {
            r || this._finalizeDragging(!1);
          }), b.isAndroid && this.forceDisabled("noAndroidSupport"));
        }
        destroy() {
          return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._updateDropMarkerThrottled.cancel(), this._removeDropMarkerDelayed.cancel(), this._clearDraggableAttributesDelayed.cancel(), super.destroy();
        }
        _setupDragging() {
          const e = this.editor, t = e.model, n = t.document, i = e.editing.view, r = i.document;
          this.listenTo(r, "dragstart", (s, a) => {
            const l = n.selection;
            if (a.target && a.target.is("editableElement"))
              return void a.preventDefault();
            const d = a.target ? up(a.target) : null;
            if (d) {
              const _ = e.editing.mapper.toModelElement(d);
              this._draggedRange = gn.fromRange(t.createRangeOn(_)), e.plugins.has("WidgetToolbarRepository") && e.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
            } else if (!r.selection.isCollapsed) {
              const _ = r.selection.getSelectedElement();
              _ && Je(_) || (this._draggedRange = gn.fromRange(l.getFirstRange()));
            }
            if (!this._draggedRange)
              return void a.preventDefault();
            this._draggingUid = ie();
            const h = this.isEnabled && e.model.canEditAt(this._draggedRange);
            a.dataTransfer.effectAllowed = h ? "copyMove" : "copy", a.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
            const m = t.createSelection(this._draggedRange.toRange()), f = e.data.toView(t.getSelectedContent(m));
            r.fire("clipboardOutput", { dataTransfer: a.dataTransfer, content: f, method: "dragstart" }), h || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
          }, { priority: "low" }), this.listenTo(r, "dragend", (s, a) => {
            this._finalizeDragging(!a.dataTransfer.isCanceled && a.dataTransfer.dropEffect == "move");
          }, { priority: "low" }), this.listenTo(r, "dragenter", () => {
            this.isEnabled && i.focus();
          }), this.listenTo(r, "dragleave", () => {
            this._removeDropMarkerDelayed();
          }), this.listenTo(r, "dragging", (s, a) => {
            if (!this.isEnabled)
              return void (a.dataTransfer.dropEffect = "none");
            this._removeDropMarkerDelayed.cancel();
            const l = cp(e, a.targetRanges, a.target);
            e.model.canEditAt(l) ? (this._draggedRange || (a.dataTransfer.dropEffect = "copy"), b.isGecko || (a.dataTransfer.effectAllowed == "copy" ? a.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(a.dataTransfer.effectAllowed) && (a.dataTransfer.dropEffect = "move")), l && this._updateDropMarkerThrottled(l)) : a.dataTransfer.dropEffect = "none";
          }, { priority: "low" });
        }
        _setupClipboardInputIntegration() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "clipboardInput", (n, i) => {
            if (i.method != "drop")
              return;
            const r = cp(e, i.targetRanges, i.target);
            if (this._removeDropMarker(), !r || !e.model.canEditAt(r))
              return this._finalizeDragging(!1), void n.stop();
            if (this._draggedRange && this._draggingUid != i.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = ""), dp(i.dataTransfer) == "move" && this._draggedRange && this._draggedRange.containsRange(r, !0))
              return this._finalizeDragging(!1), void n.stop();
            i.targetRanges = [e.editing.mapper.toViewRange(r)];
          }, { priority: "high" });
        }
        _setupContentInsertionIntegration() {
          const e = this.editor.plugins.get(bn);
          e.on("contentInsertion", (t, n) => {
            if (!this.isEnabled || n.method !== "drop")
              return;
            const i = n.targetRanges.map((r) => this.editor.editing.mapper.toModelRange(r));
            this.editor.model.change((r) => r.setSelection(i));
          }, { priority: "high" }), e.on("contentInsertion", (t, n) => {
            if (!this.isEnabled || n.method !== "drop")
              return;
            const i = dp(n.dataTransfer) == "move", r = !n.resultRange || !n.resultRange.isCollapsed;
            this._finalizeDragging(r && i);
          }, { priority: "lowest" });
        }
        _setupDraggableAttributeHandling() {
          const e = this.editor, t = e.editing.view, n = t.document;
          this.listenTo(n, "mousedown", (i, r) => {
            if (b.isAndroid || !r)
              return;
            this._clearDraggableAttributesDelayed.cancel();
            let s = up(r.target);
            if (b.isBlink && !s && !n.selection.isCollapsed) {
              const a = n.selection.getSelectedElement();
              if (!a || !Je(a)) {
                const l = n.selection.editableElement;
                l && !l.isReadOnly && (s = l);
              }
            }
            s && (t.change((a) => {
              a.setAttribute("draggable", "true", s);
            }), this._draggableElement = e.editing.mapper.toModelElement(s));
          }), this.listenTo(n, "mouseup", () => {
            b.isAndroid || this._clearDraggableAttributesDelayed();
          });
        }
        _clearDraggableAttributes() {
          const e = this.editor.editing;
          e.view.change((t) => {
            this._draggableElement && this._draggableElement.root.rootName != "$graveyard" && t.removeAttribute("draggable", e.mapper.toViewElement(this._draggableElement)), this._draggableElement = null;
          });
        }
        _setupDropMarker() {
          const e = this.editor;
          e.conversion.for("editingDowncast").markerToHighlight({ model: "drop-target", view: { classes: ["ck-clipboard-drop-target-range"] } }), e.conversion.for("editingDowncast").markerToElement({ model: "drop-target", view: (t, { writer: n }) => {
            if (e.model.schema.checkChild(t.markerRange.start, "$text"))
              return n.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(i) {
                const r = this.toDomElement(i);
                return r.append("⁠", i.createElement("span"), "⁠"), r;
              });
          } });
        }
        _updateDropMarker(e) {
          const t = this.editor, n = t.model.markers;
          t.model.change((i) => {
            n.has("drop-target") ? n.get("drop-target").getRange().isEqual(e) || i.updateMarker("drop-target", { range: e }) : i.addMarker("drop-target", { range: e, usingOperation: !1, affectsData: !1 });
          });
        }
        _removeDropMarker() {
          const e = this.editor.model;
          this._removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), e.markers.has("drop-target") && e.change((t) => {
            t.removeMarker("drop-target");
          });
        }
        _finalizeDragging(e) {
          const t = this.editor, n = t.model;
          this._removeDropMarker(), this._clearDraggableAttributes(), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._draggedRange && (e && this.isEnabled && n.deleteContent(n.createSelection(this._draggedRange), { doNotAutoparagraph: !0 }), this._draggedRange.detach(), this._draggedRange = null);
        }
      }
      function cp(o, e, t) {
        const n = o.model, i = o.editing.mapper;
        let r = null;
        const s = e ? e[0].start : null;
        if (t.is("uiElement") && (t = t.parent), r = function(d, h) {
          const m = d.model, f = d.editing.mapper;
          if (Je(h))
            return m.createRangeOn(f.toModelElement(h));
          if (!h.is("editableElement")) {
            const _ = h.findAncestor((E) => Je(E) || E.is("editableElement"));
            if (Je(_))
              return m.createRangeOn(f.toModelElement(_));
          }
          return null;
        }(o, t), r)
          return r;
        const a = function(d, h) {
          const m = d.editing.mapper, f = d.editing.view, _ = m.toModelElement(h);
          if (_)
            return _;
          const E = f.createPositionBefore(h), B = m.findMappedViewAncestor(E);
          return m.toModelElement(B);
        }(o, t), l = s ? i.toModelPosition(s) : null;
        return l ? (r = function(d, h, m) {
          const f = d.model;
          if (!f.schema.checkChild(m, "$block"))
            return null;
          const _ = f.createPositionAt(m, 0), E = h.path.slice(0, _.path.length), B = f.createPositionFromPath(h.root, E), T = B.nodeAfter;
          return T && f.schema.isObject(T) ? f.createRangeOn(T) : null;
        }(o, l, a), r || (r = n.schema.getNearestSelectionRange(l, b.isGecko ? "forward" : "backward"), r || function(d, h) {
          const m = d.model;
          let f = h;
          for (; f; ) {
            if (m.schema.isObject(f))
              return m.createRangeOn(f);
            f = f.parent;
          }
          return null;
        }(o, l.parent))) : function(d, h) {
          const m = d.model, f = m.schema, _ = m.createPositionAt(h, 0);
          return f.getNearestSelectionRange(_, "forward");
        }(o, a);
      }
      function dp(o) {
        return b.isGecko ? o.dropEffect : ["all", "copyMove"].includes(o.effectAllowed) ? "move" : "copy";
      }
      function up(o) {
        if (o.is("editableElement"))
          return null;
        if (o.hasClass("ck-widget__selection-handle"))
          return o.findAncestor(Je);
        if (Je(o))
          return o;
        const e = o.findAncestor((t) => Je(t) || t.is("editableElement"));
        return Je(e) ? e : null;
      }
      class h2 extends G {
        static get pluginName() {
          return "PastePlainText";
        }
        static get requires() {
          return [bn];
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view, i = n.document, r = t.document.selection;
          let s = !1;
          n.addObserver(wl), this.listenTo(i, "keydown", (a, l) => {
            s = l.shiftKey;
          }), e.plugins.get(bn).on("contentInsertion", (a, l) => {
            (s || function(d, h) {
              if (d.childCount > 1)
                return !1;
              const m = d.getChild(0);
              return h.isObject(m) ? !1 : Array.from(m.getAttributeKeys()).length == 0;
            }(l.content, t.schema)) && t.change((d) => {
              const h = Array.from(r.getAttributes()).filter(([f]) => t.schema.getAttributeProperties(f).isFormatting);
              r.isCollapsed || t.deleteContent(r, { doNotAutoparagraph: !0 }), h.push(...r.getAttributes());
              const m = d.createRangeIn(l.content);
              for (const f of m.getItems())
                f.is("$textProxy") && d.setAttributes(h, f);
            });
          });
        }
      }
      class g2 extends G {
        static get pluginName() {
          return "Clipboard";
        }
        static get requires() {
          return [bn, u2, h2];
        }
      }
      class m2 extends pe {
        constructor(e) {
          super(e), this.affectsData = !1;
        }
        execute() {
          const e = this.editor.model, t = e.document.selection;
          let n = e.schema.getLimitElement(t);
          if (t.containsEntireContent(n) || !hp(e.schema, n))
            do
              if (n = n.parent, !n)
                return;
            while (!hp(e.schema, n));
          e.change((i) => {
            i.setSelection(n, "in");
          });
        }
      }
      function hp(o, e) {
        return o.isLimit(e) && (o.checkChild(e, "$text") || o.checkChild(e, "paragraph"));
      }
      const p2 = Sr("Ctrl+A");
      class f2 extends G {
        static get pluginName() {
          return "SelectAllEditing";
        }
        init() {
          const e = this.editor, t = e.editing.view.document;
          e.commands.add("selectAll", new m2(e)), this.listenTo(t, "keydown", (n, i) => {
            Mo(i) === p2 && (e.execute("selectAll"), i.preventDefault());
          });
        }
      }
      class b2 extends G {
        static get pluginName() {
          return "SelectAllUI";
        }
        init() {
          const e = this.editor;
          e.ui.componentFactory.add("selectAll", (t) => {
            const n = e.commands.get("selectAll"), i = new je(t), r = t.t;
            return i.set({ label: r("Select all"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>', keystroke: "Ctrl+A", tooltip: !0 }), i.bind("isEnabled").to(n, "isEnabled"), this.listenTo(i, "execute", () => {
              e.execute("selectAll"), e.editing.view.focus();
            }), i;
          });
        }
      }
      class k2 extends G {
        static get requires() {
          return [f2, b2];
        }
        static get pluginName() {
          return "SelectAll";
        }
      }
      var w2 = Object.defineProperty, gp = Object.getOwnPropertySymbols, v2 = Object.prototype.hasOwnProperty, _2 = Object.prototype.propertyIsEnumerable, mp = (o, e, t) => e in o ? w2(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class pp extends pe {
        constructor(e) {
          super(e), this._stack = [], this._createdBatches = /* @__PURE__ */ new WeakSet(), this.refresh(), this._isEnabledBasedOnSelection = !1, this.listenTo(e.data, "set", (t, n) => {
            n[1] = ((r, s) => {
              for (var a in s || (s = {}))
                v2.call(s, a) && mp(r, a, s[a]);
              if (gp)
                for (var a of gp(s))
                  _2.call(s, a) && mp(r, a, s[a]);
              return r;
            })({}, n[1]);
            const i = n[1];
            i.batchType || (i.batchType = { isUndoable: !1 });
          }, { priority: "high" }), this.listenTo(e.data, "set", (t, n) => {
            n[1].batchType.isUndoable || this.clearStack();
          });
        }
        refresh() {
          this.isEnabled = this._stack.length > 0;
        }
        get createdBatches() {
          return this._createdBatches;
        }
        addBatch(e) {
          const t = this.editor.model.document.selection, n = { ranges: t.hasOwnRange ? Array.from(t.getRanges()) : [], isBackward: t.isBackward };
          this._stack.push({ batch: e, selection: n }), this.refresh();
        }
        clearStack() {
          this._stack = [], this.refresh();
        }
        _restoreSelection(e, t, n) {
          const i = this.editor.model, r = i.document, s = [], a = e.map((d) => d.getTransformedByOperations(n)), l = a.flat();
          for (const d of a) {
            const h = d.filter((m) => m.root != r.graveyard).filter((m) => !C2(m, l));
            h.length && (A2(h), s.push(h[0]));
          }
          s.length && i.change((d) => {
            d.setSelection(s, { backward: t });
          });
        }
        _undo(e, t) {
          const n = this.editor.model, i = n.document;
          this._createdBatches.add(t);
          const r = e.operations.slice().filter((s) => s.isDocumentOperation);
          r.reverse();
          for (const s of r) {
            const a = s.baseVersion + 1, l = Array.from(i.history.getOperations(a)), d = GC([s.getReversed()], l, { useRelations: !0, document: this.editor.model.document, padWithNoOps: !1, forceWeakRemove: !0 }).operationsA;
            for (let h of d) {
              const m = h.affectedSelectable;
              m && !n.canEditAt(m) && (h = new ct(h.baseVersion)), t.addOperation(h), n.applyOperation(h), i.history.setOperationAsUndone(s, h);
            }
          }
        }
      }
      function A2(o) {
        o.sort((e, t) => e.start.isBefore(t.start) ? -1 : 1);
        for (let e = 1; e < o.length; e++) {
          const t = o[e - 1].getJoined(o[e], !0);
          t && (e--, o.splice(e, 2, t));
        }
      }
      function C2(o, e) {
        return e.some((t) => t !== o && t.containsRange(o, !0));
      }
      class y2 extends pp {
        execute(e = null) {
          const t = e ? this._stack.findIndex((r) => r.batch == e) : this._stack.length - 1, n = this._stack.splice(t, 1)[0], i = this.editor.model.createBatch({ isUndo: !0 });
          this.editor.model.enqueueChange(i, () => {
            this._undo(n.batch, i);
            const r = this.editor.model.document.history.getOperations(n.batch.baseVersion);
            this._restoreSelection(n.selection.ranges, n.selection.isBackward, r), this.fire("revert", n.batch, i);
          }), this.refresh();
        }
      }
      class E2 extends pp {
        execute() {
          const e = this._stack.pop(), t = this.editor.model.createBatch({ isUndo: !0 });
          this.editor.model.enqueueChange(t, () => {
            const n = e.batch.operations[e.batch.operations.length - 1].baseVersion + 1, i = this.editor.model.document.history.getOperations(n);
            this._restoreSelection(e.selection.ranges, e.selection.isBackward, i), this._undo(e.batch, t);
          }), this.refresh();
        }
      }
      class x2 extends G {
        constructor() {
          super(...arguments), this._batchRegistry = /* @__PURE__ */ new WeakSet();
        }
        static get pluginName() {
          return "UndoEditing";
        }
        init() {
          const e = this.editor;
          this._undoCommand = new y2(e), this._redoCommand = new E2(e), e.commands.add("undo", this._undoCommand), e.commands.add("redo", this._redoCommand), this.listenTo(e.model, "applyOperation", (t, n) => {
            const i = n[0];
            if (!i.isDocumentOperation)
              return;
            const r = i.batch, s = this._redoCommand.createdBatches.has(r), a = this._undoCommand.createdBatches.has(r);
            this._batchRegistry.has(r) || (this._batchRegistry.add(r), r.isUndoable && (s ? this._undoCommand.addBatch(r) : a || (this._undoCommand.addBatch(r), this._redoCommand.clearStack())));
          }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (t, n, i) => {
            this._redoCommand.addBatch(i);
          }), e.keystrokes.set("CTRL+Z", "undo"), e.keystrokes.set("CTRL+Y", "redo"), e.keystrokes.set("CTRL+SHIFT+Z", "redo");
        }
      }
      const fp = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', bp = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
      class S2 extends G {
        static get pluginName() {
          return "UndoUI";
        }
        init() {
          const e = this.editor, t = e.locale, n = e.t, i = t.uiLanguageDirection == "ltr" ? fp : bp, r = t.uiLanguageDirection == "ltr" ? bp : fp;
          this._addButton("undo", n("Undo"), "CTRL+Z", i), this._addButton("redo", n("Redo"), "CTRL+Y", r);
        }
        _addButton(e, t, n, i) {
          const r = this.editor;
          r.ui.componentFactory.add(e, (s) => {
            const a = r.commands.get(e), l = new je(s);
            return l.set({ label: t, icon: i, keystroke: n, tooltip: !0 }), l.bind("isEnabled").to(a, "isEnabled"), this.listenTo(l, "execute", () => {
              r.execute(e), r.editing.view.focus();
            }), l;
          });
        }
      }
      class D2 extends G {
        static get requires() {
          return [x2, S2];
        }
        static get pluginName() {
          return "Undo";
        }
      }
      class B2 extends oe() {
        constructor() {
          super();
          const e = new window.FileReader();
          this._reader = e, this._data = void 0, this.set("loaded", 0), e.onprogress = (t) => {
            this.loaded = t.loaded;
          };
        }
        get error() {
          return this._reader.error;
        }
        get data() {
          return this._data;
        }
        read(e) {
          const t = this._reader;
          return this.total = e.size, new Promise((n, i) => {
            t.onload = () => {
              const r = t.result;
              this._data = r, n(r);
            }, t.onerror = () => {
              i("error");
            }, t.onabort = () => {
              i("aborted");
            }, this._reader.readAsDataURL(e);
          });
        }
        abort() {
          this._reader.abort();
        }
      }
      class wn extends G {
        constructor() {
          super(...arguments), this.loaders = new Vt(), this._loadersMap = /* @__PURE__ */ new Map(), this._pendingAction = null;
        }
        static get pluginName() {
          return "FileRepository";
        }
        static get requires() {
          return [Jr];
        }
        init() {
          this.loaders.on("change", () => this._updatePendingAction()), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (e, t) => t ? e / t * 100 : 0);
        }
        getLoader(e) {
          return this._loadersMap.get(e) || null;
        }
        createLoader(e) {
          if (!this.createUploadAdapter)
            return ne("filerepository-no-upload-adapter"), null;
          const t = new kp(Promise.resolve(e), this.createUploadAdapter);
          return this.loaders.add(t), this._loadersMap.set(e, t), e instanceof Promise && t.file.then((n) => {
            this._loadersMap.set(n, t);
          }).catch(() => {
          }), t.on("change:uploaded", () => {
            let n = 0;
            for (const i of this.loaders)
              n += i.uploaded;
            this.uploaded = n;
          }), t.on("change:uploadTotal", () => {
            let n = 0;
            for (const i of this.loaders)
              i.uploadTotal && (n += i.uploadTotal);
            this.uploadTotal = n;
          }), t;
        }
        destroyLoader(e) {
          const t = e instanceof kp ? e : this.getLoader(e);
          t._destroy(), this.loaders.remove(t), this._loadersMap.forEach((n, i) => {
            n === t && this._loadersMap.delete(i);
          });
        }
        _updatePendingAction() {
          const e = this.editor.plugins.get(Jr);
          if (this.loaders.length) {
            if (!this._pendingAction) {
              const t = this.editor.t, n = (i) => `${t("Upload in progress")} ${parseInt(i)}%.`;
              this._pendingAction = e.add(n(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", n);
            }
          } else
            e.remove(this._pendingAction), this._pendingAction = null;
        }
      }
      class kp extends oe() {
        constructor(e, t) {
          super(), this.id = ie(), this._filePromiseWrapper = this._createFilePromiseWrapper(e), this._adapter = t(this), this._reader = new B2(), this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (n, i) => i ? n / i * 100 : 0), this.set("uploadResponse", null);
        }
        get file() {
          return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((e) => this._filePromiseWrapper ? e : null) : Promise.resolve(null);
        }
        get data() {
          return this._reader.data;
        }
        read() {
          if (this.status != "idle")
            throw new I("filerepository-read-wrong-status", this);
          return this.status = "reading", this.file.then((e) => this._reader.read(e)).then((e) => {
            if (this.status !== "reading")
              throw this.status;
            return this.status = "idle", e;
          }).catch((e) => {
            throw e === "aborted" ? (this.status = "aborted", "aborted") : (this.status = "error", this._reader.error ? this._reader.error : e);
          });
        }
        upload() {
          if (this.status != "idle")
            throw new I("filerepository-upload-wrong-status", this);
          return this.status = "uploading", this.file.then(() => this._adapter.upload()).then((e) => (this.uploadResponse = e, this.status = "idle", e)).catch((e) => {
            throw this.status === "aborted" ? "aborted" : (this.status = "error", e);
          });
        }
        abort() {
          const e = this.status;
          this.status = "aborted", this._filePromiseWrapper.isFulfilled ? e == "reading" ? this._reader.abort() : e == "uploading" && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
          }), this._filePromiseWrapper.rejecter("aborted")), this._destroy();
        }
        _destroy() {
          this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0;
        }
        _createFilePromiseWrapper(e) {
          const t = {};
          return t.promise = new Promise((n, i) => {
            t.rejecter = i, t.isFulfilled = !1, e.then((r) => {
              t.isFulfilled = !0, n(r);
            }).catch((r) => {
              t.isFulfilled = !0, i(r);
            });
          }), t;
        }
      }
      class T2 extends we {
        constructor(e) {
          super(e), this.buttonView = new je(e), this._fileInputView = new P2(e), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.setTemplate({ tag: "span", attributes: { class: "ck-file-dialog-button" }, children: [this.buttonView, this._fileInputView] }), this.buttonView.on("execute", () => {
            this._fileInputView.open();
          });
        }
        focus() {
          this.buttonView.focus();
        }
      }
      class P2 extends we {
        constructor(e) {
          super(e), this.set("acceptedType", void 0), this.set("allowMultipleFiles", !1);
          const t = this.bindTemplate;
          this.setTemplate({ tag: "input", attributes: { class: ["ck-hidden"], type: "file", tabindex: "-1", accept: t.to("acceptedType"), multiple: t.to("allowMultipleFiles") }, on: { change: t.to(() => {
            this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = "";
          }) } });
        }
        open() {
          this.element.click();
        }
      }
      const wp = "ckCsrfToken", vp = "abcdefghijklmnopqrstuvwxyz0123456789";
      function I2() {
        let o = function(n) {
          n = n.toLowerCase();
          const i = document.cookie.split(";");
          for (const r of i) {
            const s = r.split("=");
            if (decodeURIComponent(s[0].trim().toLowerCase()) === n)
              return decodeURIComponent(s[1]);
          }
          return null;
        }(wp);
        var e, t;
        return o && o.length == 40 || (o = function(n) {
          let i = "";
          const r = new Uint8Array(n);
          window.crypto.getRandomValues(r);
          for (let s = 0; s < r.length; s++) {
            const a = vp.charAt(r[s] % vp.length);
            i += Math.random() > 0.5 ? a.toUpperCase() : a;
          }
          return i;
        }(40), e = wp, t = o, document.cookie = encodeURIComponent(e) + "=" + encodeURIComponent(t) + ";path=/"), o;
      }
      class O2 {
        constructor(e, t, n) {
          this.loader = e, this.url = t, this.t = n;
        }
        upload() {
          return this.loader.file.then((e) => new Promise((t, n) => {
            this._initRequest(), this._initListeners(t, n, e), this._sendRequest(e);
          }));
        }
        abort() {
          this.xhr && this.xhr.abort();
        }
        _initRequest() {
          const e = this.xhr = new XMLHttpRequest();
          e.open("POST", this.url, !0), e.responseType = "json";
        }
        _initListeners(e, t, n) {
          const i = this.xhr, r = this.loader, s = (0, this.t)("Cannot upload file:") + ` ${n.name}.`;
          i.addEventListener("error", () => t(s)), i.addEventListener("abort", () => t()), i.addEventListener("load", () => {
            const a = i.response;
            if (!a || !a.uploaded)
              return t(a && a.error && a.error.message ? a.error.message : s);
            e({ default: a.url });
          }), i.upload && i.upload.addEventListener("progress", (a) => {
            a.lengthComputable && (r.uploadTotal = a.total, r.uploaded = a.loaded);
          });
        }
        _sendRequest(e) {
          const t = new FormData();
          t.append("upload", e), t.append("ckCsrfToken", I2()), this.xhr.send(t);
        }
      }
      class El extends pe {
        constructor(e, t) {
          super(e), this.attributeKey = t;
        }
        refresh() {
          const e = this.editor.model, t = e.document;
          this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey);
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document.selection, i = e.forceValue === void 0 ? !this.value : e.forceValue;
          t.change((r) => {
            if (n.isCollapsed)
              i ? r.setSelectionAttribute(this.attributeKey, !0) : r.removeSelectionAttribute(this.attributeKey);
            else {
              const s = t.schema.getValidRanges(n.getRanges(), this.attributeKey);
              for (const a of s)
                i ? r.setAttribute(this.attributeKey, i, a) : r.removeAttribute(this.attributeKey, a);
            }
          });
        }
        _getValueFromFirstAllowedNode() {
          const e = this.editor.model, t = e.schema, n = e.document.selection;
          if (n.isCollapsed)
            return n.hasAttribute(this.attributeKey);
          for (const i of n.getRanges())
            for (const r of i.getItems())
              if (t.checkAttribute(r, this.attributeKey))
                return r.hasAttribute(this.attributeKey);
          return !1;
        }
      }
      const Jo = "bold";
      class R2 extends G {
        static get pluginName() {
          return "BoldEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: Jo }), e.model.schema.setAttributeProperties(Jo, { isFormatting: !0, copyOnEnter: !0 }), e.conversion.attributeToElement({ model: Jo, view: "strong", upcastAlso: ["b", (t) => {
            const n = t.getStyle("font-weight");
            return n && (n == "bold" || Number(n) >= 600) ? { name: !0, styles: ["font-weight"] } : null;
          }] }), e.commands.add(Jo, new El(e, Jo)), e.keystrokes.set("CTRL+B", Jo);
        }
      }
      const xl = "bold";
      class z2 extends G {
        static get pluginName() {
          return "BoldUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(xl, (n) => {
            const i = e.commands.get(xl), r = new je(n);
            return r.set({ label: t("Bold"), icon: qe.bold, keystroke: "CTRL+B", tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(xl), e.editing.view.focus();
            }), r;
          });
        }
      }
      var _p = k(8603), M2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(_p.Z, M2), _p.Z.locals;
      const Yo = "italic";
      class N2 extends G {
        static get pluginName() {
          return "ItalicEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: Yo }), e.model.schema.setAttributeProperties(Yo, { isFormatting: !0, copyOnEnter: !0 }), e.conversion.attributeToElement({ model: Yo, view: "i", upcastAlso: ["em", { styles: { "font-style": "italic" } }] }), e.commands.add(Yo, new El(e, Yo)), e.keystrokes.set("CTRL+I", Yo);
        }
      }
      const Sl = "italic";
      class F2 extends G {
        static get pluginName() {
          return "ItalicUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(Sl, (n) => {
            const i = e.commands.get(Sl), r = new je(n);
            return r.set({ label: t("Italic"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>', keystroke: "CTRL+I", tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(Sl), e.editing.view.focus();
            }), r;
          });
        }
      }
      const Gi = "underline";
      class $2 extends G {
        static get pluginName() {
          return "UnderlineEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: Gi }), e.model.schema.setAttributeProperties(Gi, { isFormatting: !0, copyOnEnter: !0 }), e.conversion.attributeToElement({ model: Gi, view: "u", upcastAlso: { styles: { "text-decoration": "underline" } } }), e.commands.add(Gi, new El(e, Gi)), e.keystrokes.set("CTRL+U", "underline");
        }
      }
      const Dl = "underline";
      class L2 extends G {
        static get pluginName() {
          return "UnderlineUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(Dl, (n) => {
            const i = e.commands.get(Dl), r = new je(n);
            return r.set({ label: t("Underline"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>', keystroke: "CTRL+U", tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(Dl), e.editing.view.focus();
            }), r;
          });
        }
      }
      class V2 extends pe {
        refresh() {
          this.value = this._getValue(), this.isEnabled = this._checkEnabled();
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.schema, i = t.document.selection, r = Array.from(i.getSelectedBlocks()), s = e.forceValue === void 0 ? !this.value : e.forceValue;
          t.change((a) => {
            if (s) {
              const l = r.filter((d) => ds(d) || Cp(n, d));
              this._applyQuote(a, l);
            } else
              this._removeQuote(a, r.filter(ds));
          });
        }
        _getValue() {
          const e = it(this.editor.model.document.selection.getSelectedBlocks());
          return !(!e || !ds(e));
        }
        _checkEnabled() {
          if (this.value)
            return !0;
          const e = this.editor.model.document.selection, t = this.editor.model.schema, n = it(e.getSelectedBlocks());
          return !!n && Cp(t, n);
        }
        _removeQuote(e, t) {
          Ap(e, t).reverse().forEach((n) => {
            if (n.start.isAtStart && n.end.isAtEnd)
              return void e.unwrap(n.start.parent);
            if (n.start.isAtStart) {
              const r = e.createPositionBefore(n.start.parent);
              return void e.move(n, r);
            }
            n.end.isAtEnd || e.split(n.end);
            const i = e.createPositionAfter(n.end.parent);
            e.move(n, i);
          });
        }
        _applyQuote(e, t) {
          const n = [];
          Ap(e, t).reverse().forEach((i) => {
            let r = ds(i.start);
            r || (r = e.createElement("blockQuote"), e.wrap(i, r)), n.push(r);
          }), n.reverse().reduce((i, r) => i.nextSibling == r ? (e.merge(e.createPositionAfter(i)), i) : r);
        }
      }
      function ds(o) {
        return o.parent.name == "blockQuote" ? o.parent : null;
      }
      function Ap(o, e) {
        let t, n = 0;
        const i = [];
        for (; n < e.length; ) {
          const r = e[n], s = e[n + 1];
          t || (t = o.createPositionBefore(r)), s && r.nextSibling == s || (i.push(o.createRange(t, o.createPositionAfter(r))), t = null), n++;
        }
        return i;
      }
      function Cp(o, e) {
        const t = o.checkChild(e.parent, "blockQuote"), n = o.checkChild(["$root", "blockQuote"], e);
        return t && n;
      }
      class j2 extends G {
        static get pluginName() {
          return "BlockQuoteEditing";
        }
        static get requires() {
          return [qi, Go];
        }
        init() {
          const e = this.editor, t = e.model.schema;
          e.commands.add("blockQuote", new V2(e)), t.register("blockQuote", { inheritAllFrom: "$container" }), e.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }), e.model.document.registerPostFixer((s) => {
            const a = e.model.document.differ.getChanges();
            for (const l of a)
              if (l.type == "insert") {
                const d = l.position.nodeAfter;
                if (!d)
                  continue;
                if (d.is("element", "blockQuote") && d.isEmpty)
                  return s.remove(d), !0;
                if (d.is("element", "blockQuote") && !t.checkChild(l.position, d))
                  return s.unwrap(d), !0;
                if (d.is("element")) {
                  const h = s.createRangeIn(d);
                  for (const m of h.getItems())
                    if (m.is("element", "blockQuote") && !t.checkChild(s.createPositionBefore(m), m))
                      return s.unwrap(m), !0;
                }
              } else if (l.type == "remove") {
                const d = l.position.parent;
                if (d.is("element", "blockQuote") && d.isEmpty)
                  return s.remove(d), !0;
              }
            return !1;
          });
          const n = this.editor.editing.view.document, i = e.model.document.selection, r = e.commands.get("blockQuote");
          this.listenTo(n, "enter", (s, a) => {
            !i.isCollapsed || !r.value || i.getLastPosition().parent.isEmpty && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), s.stop());
          }, { context: "blockquote" }), this.listenTo(n, "delete", (s, a) => {
            if (a.direction != "backward" || !i.isCollapsed || !r.value)
              return;
            const l = i.getLastPosition().parent;
            l.isEmpty && !l.previousSibling && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), s.stop());
          }, { context: "blockquote" });
        }
      }
      var yp = k(3062), H2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(yp.Z, H2), yp.Z.locals;
      class U2 extends G {
        static get pluginName() {
          return "BlockQuoteUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add("blockQuote", (n) => {
            const i = e.commands.get("blockQuote"), r = new je(n);
            return r.set({ label: t("Block quote"), icon: qe.quote, tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute("blockQuote"), e.editing.view.focus();
            }), r;
          });
        }
      }
      class q2 extends G {
        static get pluginName() {
          return "CloudServicesUploadAdapter";
        }
        static get requires() {
          return ["CloudServices", wn];
        }
        init() {
          const e = this.editor, t = e.plugins.get("CloudServices"), n = t.token, i = t.uploadUrl;
          if (!n)
            return;
          const r = e.plugins.get("CloudServicesCore");
          this._uploadGateway = r.createUploadGateway(n, i), e.plugins.get(wn).createUploadAdapter = (s) => new W2(this._uploadGateway, s);
        }
      }
      class W2 {
        constructor(e, t) {
          this.uploadGateway = e, this.loader = t;
        }
        upload() {
          return this.loader.file.then((e) => (this.fileUploader = this.uploadGateway.upload(e), this.fileUploader.on("progress", (t, n) => {
            this.loader.uploadTotal = n.total, this.loader.uploaded = n.uploaded;
          }), this.fileUploader.send()));
        }
        abort() {
          this.fileUploader.abort();
        }
      }
      class G2 extends pe {
        constructor(e) {
          super(e), this._isEnabledBasedOnSelection = !1;
        }
        refresh() {
          const e = this.editor.model, t = it(e.document.selection.getSelectedBlocks());
          this.value = !!t && t.is("element", "paragraph"), this.isEnabled = !!t && Ep(t, e.schema);
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document, i = e.selection || n.selection;
          t.canEditAt(i) && t.change((r) => {
            const s = i.getSelectedBlocks();
            for (const a of s)
              !a.is("element", "paragraph") && Ep(a, t.schema) && r.rename(a, "paragraph");
          });
        }
      }
      function Ep(o, e) {
        return e.checkChild(o.parent, "paragraph") && !e.isObject(o);
      }
      class K2 extends pe {
        constructor(e) {
          super(e), this._isEnabledBasedOnSelection = !1;
        }
        execute(e) {
          const t = this.editor.model, n = e.attributes;
          let i = e.position;
          t.canEditAt(i) && t.change((r) => {
            const s = r.createElement("paragraph");
            if (n && t.schema.setAllowedAttributes(s, n, r), !t.schema.checkChild(i.parent, s)) {
              const a = t.schema.findAllowedParent(i, s);
              if (!a)
                return;
              i = r.split(i, a).position;
            }
            t.insertContent(s, i), r.setSelection(s, "in");
          });
        }
      }
      const xp = class extends G {
        static get pluginName() {
          return "Paragraph";
        }
        init() {
          const o = this.editor, e = o.model;
          o.commands.add("paragraph", new G2(o)), o.commands.add("insertParagraph", new K2(o)), e.schema.register("paragraph", { inheritAllFrom: "$block" }), o.conversion.elementToElement({ model: "paragraph", view: "p" }), o.conversion.for("upcast").elementToElement({ model: (t, { writer: n }) => xp.paragraphLikeElements.has(t.name) ? t.isEmpty ? null : n.createElement("paragraph") : null, view: /.+/, converterPriority: "low" });
        }
      };
      let Bl = xp;
      Bl.paragraphLikeElements = /* @__PURE__ */ new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);
      class Z2 extends pe {
        constructor(e, t) {
          super(e), this.modelElements = t;
        }
        refresh() {
          const e = it(this.editor.model.document.selection.getSelectedBlocks());
          this.value = !!e && this.modelElements.includes(e.name) && e.name, this.isEnabled = !!e && this.modelElements.some((t) => Sp(e, t, this.editor.model.schema));
        }
        execute(e) {
          const t = this.editor.model, n = t.document, i = e.value;
          t.change((r) => {
            const s = Array.from(n.selection.getSelectedBlocks()).filter((a) => Sp(a, i, t.schema));
            for (const a of s)
              a.is("element", i) || r.rename(a, i);
          });
        }
      }
      function Sp(o, e, t) {
        return t.checkChild(o.parent, e) && !t.isObject(o);
      }
      const Dp = "paragraph";
      class J2 extends G {
        static get pluginName() {
          return "HeadingEditing";
        }
        constructor(e) {
          super(e), e.config.define("heading", { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }] });
        }
        static get requires() {
          return [Bl];
        }
        init() {
          const e = this.editor, t = e.config.get("heading.options"), n = [];
          for (const i of t)
            i.model !== "paragraph" && (e.model.schema.register(i.model, { inheritAllFrom: "$block" }), e.conversion.elementToElement(i), n.push(i.model));
          this._addDefaultH1Conversion(e), e.commands.add("heading", new Z2(e, n));
        }
        afterInit() {
          const e = this.editor, t = e.commands.get("enter"), n = e.config.get("heading.options");
          t && this.listenTo(t, "afterExecute", (i, r) => {
            const s = e.model.document.selection.getFirstPosition().parent;
            n.some((a) => s.is("element", a.model)) && !s.is("element", Dp) && s.childCount === 0 && r.writer.rename(s, Dp);
          });
        }
        _addDefaultH1Conversion(e) {
          e.conversion.for("upcast").elementToElement({ model: "heading1", view: "h1", converterPriority: ce.get("low") + 1 });
        }
      }
      var Bp = k(8733), Y2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Bp.Z, Y2), Bp.Z.locals;
      class Q2 extends G {
        static get pluginName() {
          return "HeadingUI";
        }
        init() {
          const e = this.editor, t = e.t, n = function(s) {
            const a = s.t, l = { Paragraph: a("Paragraph"), "Heading 1": a("Heading 1"), "Heading 2": a("Heading 2"), "Heading 3": a("Heading 3"), "Heading 4": a("Heading 4"), "Heading 5": a("Heading 5"), "Heading 6": a("Heading 6") };
            return s.config.get("heading.options").map((d) => {
              const h = l[d.title];
              return h && h != d.title && (d.title = h), d;
            });
          }(e), i = t("Choose heading"), r = t("Heading");
          e.ui.componentFactory.add("heading", (s) => {
            const a = {}, l = new Vt(), d = e.commands.get("heading"), h = e.commands.get("paragraph"), m = [d];
            for (const _ of n) {
              const E = { type: "button", model: new bl({ label: _.title, class: _.class, role: "menuitemradio", withText: !0 }) };
              _.model === "paragraph" ? (E.model.bind("isOn").to(h, "value"), E.model.set("commandName", "paragraph"), m.push(h)) : (E.model.bind("isOn").to(d, "value", (B) => B === _.model), E.model.set({ commandName: "heading", commandValue: _.model })), l.add(E), a[_.model] = _.title;
            }
            const f = fn(s);
            return rl(f, l, { ariaLabel: r, role: "menu" }), f.buttonView.set({ ariaLabel: r, ariaLabelledBy: void 0, isOn: !1, withText: !0, tooltip: r }), f.extendTemplate({ attributes: { class: ["ck-heading-dropdown"] } }), f.bind("isEnabled").toMany(m, "isEnabled", (..._) => _.some((E) => E)), f.buttonView.bind("label").to(d, "value", h, "value", (_, E) => {
              const B = _ || E && "paragraph";
              return typeof B == "boolean" ? i : a[B] ? a[B] : i;
            }), this.listenTo(f, "execute", (_) => {
              const { commandName: E, commandValue: B } = _.source;
              e.execute(E, B ? { value: B } : void 0), e.editing.view.focus();
            }), f;
          });
        }
      }
      function Tp(o) {
        return o.createContainerElement("figure", { class: "image" }, [o.createEmptyElement("img"), o.createSlot("children")]);
      }
      function Pp(o, e) {
        const t = o.plugins.get("ImageUtils"), n = o.plugins.has("ImageInlineEditing") && o.plugins.has("ImageBlockEditing");
        return (r) => t.isInlineImageView(r) ? n && (r.getStyle("display") == "block" || r.findAncestor(t.isBlockImageView) ? "imageBlock" : "imageInline") !== e ? null : i(r) : null;
        function i(r) {
          const s = { name: !0 };
          return r.hasAttribute("src") && (s.attributes = ["src"]), s;
        }
      }
      function Tl(o, e) {
        const t = it(e.getSelectedBlocks());
        return !t || o.isObject(t) || t.isEmpty && t.name != "listItem" ? "imageBlock" : "imageInline";
      }
      var X2 = Object.defineProperty, Ip = Object.getOwnPropertySymbols, eE = Object.prototype.hasOwnProperty, tE = Object.prototype.propertyIsEnumerable, Op = (o, e, t) => e in o ? X2(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Rp = (o, e) => {
        for (var t in e || (e = {}))
          eE.call(e, t) && Op(o, t, e[t]);
        if (Ip)
          for (var t of Ip(e))
            tE.call(e, t) && Op(o, t, e[t]);
        return o;
      };
      class vn extends G {
        static get pluginName() {
          return "ImageUtils";
        }
        isImage(e) {
          return this.isInlineImage(e) || this.isBlockImage(e);
        }
        isInlineImageView(e) {
          return !!e && e.is("element", "img");
        }
        isBlockImageView(e) {
          return !!e && e.is("element", "figure") && e.hasClass("image");
        }
        insertImage(e = {}, t = null, n = null) {
          const i = this.editor, r = i.model, s = r.document.selection;
          n = zp(i, t || s, n), e = Rp(Rp({}, Object.fromEntries(s.getAttributes())), e);
          for (const a in e)
            r.schema.checkAttribute(n, a) || delete e[a];
          return r.change((a) => {
            const l = a.createElement(n, e);
            return r.insertObject(l, t, null, { setSelection: "on", findOptimalPosition: t || n == "imageInline" ? void 0 : "auto" }), l.parent ? l : null;
          });
        }
        getClosestSelectedImageWidget(e) {
          const t = e.getFirstPosition();
          if (!t)
            return null;
          const n = e.getSelectedElement();
          if (n && this.isImageWidget(n))
            return n;
          let i = t.parent;
          for (; i; ) {
            if (i.is("element") && this.isImageWidget(i))
              return i;
            i = i.parent;
          }
          return null;
        }
        getClosestSelectedImageElement(e) {
          const t = e.getSelectedElement();
          return this.isImage(t) ? t : e.getFirstPosition().findAncestor("imageBlock");
        }
        isImageAllowed() {
          const e = this.editor.model.document.selection;
          return function(t, n) {
            if (zp(t, n, null) == "imageBlock") {
              const r = function(s, a) {
                const l = function(h, m) {
                  const f = h.getSelectedElement();
                  if (f) {
                    const _ = Rn(h);
                    if (_)
                      return m.createRange(m.createPositionAt(f, _));
                  }
                  return Fg(h, m);
                }(s, a), d = l.start.parent;
                return d.isEmpty && !d.is("element", "$root") ? d.parent : d;
              }(n, t.model);
              if (t.model.schema.checkChild(r, "imageBlock"))
                return !0;
            } else if (t.model.schema.checkChild(n.focus, "imageInline"))
              return !0;
            return !1;
          }(this.editor, e) && function(t) {
            return [...t.focus.getAncestors()].every((n) => !n.is("element", "imageBlock"));
          }(e);
        }
        toImageWidget(e, t, n) {
          return t.setCustomProperty("image", !0, e), yl(e, t, { label: () => {
            const i = this.findViewImgElement(e).getAttribute("alt");
            return i ? `${i} ${n}` : n;
          } });
        }
        isImageWidget(e) {
          return !!e.getCustomProperty("image") && Je(e);
        }
        isBlockImage(e) {
          return !!e && e.is("element", "imageBlock");
        }
        isInlineImage(e) {
          return !!e && e.is("element", "imageInline");
        }
        findViewImgElement(e) {
          if (this.isInlineImageView(e))
            return e;
          const t = this.editor.editing.view;
          for (const { item: n } of t.createRangeIn(e))
            if (this.isInlineImageView(n))
              return n;
        }
      }
      function zp(o, e, t) {
        const n = o.model.schema, i = o.config.get("image.insert.type");
        return o.plugins.has("ImageBlockEditing") ? o.plugins.has("ImageInlineEditing") ? t || (i === "inline" ? "imageInline" : i === "block" ? "imageBlock" : e.is("selection") ? Tl(n, e) : n.checkChild(e, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline";
      }
      class nE extends pe {
        refresh() {
          const e = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
          this.isEnabled = !!e, this.isEnabled && e.hasAttribute("alt") ? this.value = e.getAttribute("alt") : this.value = !1;
        }
        execute(e) {
          const t = this.editor, n = t.plugins.get("ImageUtils"), i = t.model, r = n.getClosestSelectedImageElement(i.document.selection);
          i.change((s) => {
            s.setAttribute("alt", e.newValue, r);
          });
        }
      }
      class oE extends G {
        static get requires() {
          return [vn];
        }
        static get pluginName() {
          return "ImageTextAlternativeEditing";
        }
        init() {
          this.editor.commands.add("imageTextAlternative", new nE(this.editor));
        }
      }
      var Mp = k(1905), iE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Mp.Z, iE), Mp.Z.locals;
      var Np = k(6764), rE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Np.Z, rE), Np.Z.locals;
      class sE extends we {
        constructor(e) {
          super(e);
          const t = this.locale.t;
          this.focusTracker = new Gt(), this.keystrokes = new un(), this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(t("Save"), qe.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(t("Cancel"), qe.cancel, "ck-button-cancel", "cancel"), this._focusables = new Zn(), this._focusCycler = new Si({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.labeledInput, this.saveButtonView, this.cancelButtonView] });
        }
        render() {
          super.render(), this.keystrokes.listenTo(this.element), p({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((e) => {
            this._focusables.add(e), this.focusTracker.add(e.element);
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        _createButton(e, t, n, i) {
          const r = new je(this.locale);
          return r.set({ label: e, icon: t, tooltip: !0 }), r.extendTemplate({ attributes: { class: n } }), i && r.delegate("execute").to(this, i), r;
        }
        _createLabeledInputView() {
          const e = this.locale.t, t = new Eu(this.locale, Zg);
          return t.label = e("Text alternative"), t;
        }
      }
      function Fp(o) {
        const e = o.editing.view, t = St.defaultPositions, n = o.plugins.get("ImageUtils");
        return { target: e.domConverter.mapViewToDom(n.getClosestSelectedImageWidget(e.document.selection)), positions: [t.northArrowSouth, t.northArrowSouthWest, t.northArrowSouthEast, t.southArrowNorth, t.southArrowNorthWest, t.southArrowNorthEast, t.viewportStickyNorth] };
      }
      class aE extends G {
        static get requires() {
          return [os];
        }
        static get pluginName() {
          return "ImageTextAlternativeUI";
        }
        init() {
          this._createButton();
        }
        destroy() {
          super.destroy(), this._form && this._form.destroy();
        }
        _createButton() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add("imageTextAlternative", (n) => {
            const i = e.commands.get("imageTextAlternative"), r = new je(n);
            return r.set({ label: t("Change image text alternative"), icon: qe.lowVision, tooltip: !0 }), r.bind("isEnabled").to(i, "isEnabled"), r.bind("isOn").to(i, "value", (s) => !!s), this.listenTo(r, "execute", () => {
              this._showForm();
            }), r;
          });
        }
        _createForm() {
          const e = this.editor, t = e.editing.view.document, n = e.plugins.get("ImageUtils");
          this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (x(sE))(e.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
            e.execute("imageTextAlternative", { newValue: this._form.labeledInput.fieldView.element.value }), this._hideForm(!0);
          }), this.listenTo(this._form, "cancel", () => {
            this._hideForm(!0);
          }), this._form.keystrokes.set("Esc", (i, r) => {
            this._hideForm(!0), r();
          }), this.listenTo(e.ui, "update", () => {
            n.getClosestSelectedImageWidget(t.selection) ? this._isVisible && function(i) {
              const r = i.plugins.get("ContextualBalloon");
              if (i.plugins.get("ImageUtils").getClosestSelectedImageWidget(i.editing.view.document.selection)) {
                const s = Fp(i);
                r.updatePosition(s);
              }
            }(e) : this._hideForm(!0);
          }), v({ emitter: this._form, activator: () => this._isVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideForm() });
        }
        _showForm() {
          if (this._isVisible)
            return;
          this._form || this._createForm();
          const e = this.editor, t = e.commands.get("imageTextAlternative"), n = this._form.labeledInput;
          this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({ view: this._form, position: Fp(e) }), n.fieldView.value = n.fieldView.element.value = t.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
        }
        _hideForm(e = !1) {
          this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), e && this.editor.editing.view.focus());
        }
        get _isVisible() {
          return !!this._balloon && this._balloon.visibleView === this._form;
        }
        get _isInBalloon() {
          return !!this._balloon && this._balloon.hasView(this._form);
        }
      }
      class $p extends G {
        static get requires() {
          return [oE, aE];
        }
        static get pluginName() {
          return "ImageTextAlternative";
        }
      }
      function Lp(o, e) {
        const t = (n, i, r) => {
          if (!r.consumable.consume(i.item, n.name))
            return;
          const s = r.writer, a = r.mapper.toViewElement(i.item), l = o.findViewImgElement(a);
          if (i.attributeNewValue === null) {
            const d = i.attributeOldValue;
            d && d.data && (s.removeAttribute("srcset", l), s.removeAttribute("sizes", l), d.width && s.removeAttribute("width", l));
          } else {
            const d = i.attributeNewValue;
            d && d.data && (s.setAttribute("srcset", d.data, l), s.setAttribute("sizes", "100vw", l), d.width && s.setAttribute("width", d.width, l));
          }
        };
        return (n) => {
          n.on(`attribute:srcset:${e}`, t);
        };
      }
      function us(o, e, t) {
        const n = (i, r, s) => {
          if (!s.consumable.consume(r.item, i.name))
            return;
          const a = s.writer, l = s.mapper.toViewElement(r.item), d = o.findViewImgElement(l);
          a.setAttribute(r.attributeKey, r.attributeNewValue || "", d);
        };
        return (i) => {
          i.on(`attribute:${t}:${e}`, n);
        };
      }
      class lE extends on {
        observe(e) {
          this.listenTo(e, "load", (t, n) => {
            const i = n.target;
            this.checkShouldIgnoreEventFromTarget(i) || i.tagName == "IMG" && this._fireEvents(n);
          }, { useCapture: !0 });
        }
        stopObserving(e) {
          this.stopListening(e);
        }
        _fireEvents(e) {
          this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", e));
        }
      }
      var cE = Object.defineProperty, Vp = Object.getOwnPropertySymbols, dE = Object.prototype.hasOwnProperty, uE = Object.prototype.propertyIsEnumerable, jp = (o, e, t) => e in o ? cE(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, hs = (o, e) => {
        for (var t in e || (e = {}))
          dE.call(e, t) && jp(o, t, e[t]);
        if (Vp)
          for (var t of Vp(e))
            uE.call(e, t) && jp(o, t, e[t]);
        return o;
      };
      class hE extends pe {
        constructor(e) {
          super(e);
          const t = e.config.get("image.insert.type");
          e.plugins.has("ImageBlockEditing") || t === "block" && ne("image-block-plugin-required"), e.plugins.has("ImageInlineEditing") || t === "inline" && ne("image-inline-plugin-required");
        }
        refresh() {
          const e = this.editor.plugins.get("ImageUtils");
          this.isEnabled = e.isImageAllowed();
        }
        execute(e) {
          const t = Xe(e.source), n = this.editor.model.document.selection, i = this.editor.plugins.get("ImageUtils"), r = Object.fromEntries(n.getAttributes());
          t.forEach((s, a) => {
            const l = n.getSelectedElement();
            if (typeof s == "string" && (s = { src: s }), a && l && i.isImage(l)) {
              const d = this.editor.model.createPositionAfter(l);
              i.insertImage(hs(hs({}, s), r), d);
            } else
              i.insertImage(hs(hs({}, s), r));
          });
        }
      }
      class gE extends pe {
        refresh() {
          const e = this.editor.plugins.get("ImageUtils"), t = this.editor.model.document.selection.getSelectedElement();
          this.isEnabled = e.isImage(t), this.value = this.isEnabled ? t.getAttribute("src") : null;
        }
        execute(e) {
          const t = this.editor.model.document.selection.getSelectedElement();
          this.editor.model.change((n) => {
            n.setAttribute("src", e.source, t), n.removeAttribute("srcset", t), n.removeAttribute("sizes", t);
          });
        }
      }
      class Hp extends G {
        static get requires() {
          return [vn];
        }
        static get pluginName() {
          return "ImageEditing";
        }
        init() {
          const e = this.editor, t = e.conversion;
          e.editing.view.addObserver(lE), t.for("upcast").attributeToAttribute({ view: { name: "img", key: "alt" }, model: "alt" }).attributeToAttribute({ view: { name: "img", key: "srcset" }, model: { key: "srcset", value: (r) => {
            const s = { data: r.getAttribute("srcset") };
            return r.hasAttribute("width") && (s.width = r.getAttribute("width")), s;
          } } });
          const n = new hE(e), i = new gE(e);
          e.commands.add("insertImage", n), e.commands.add("replaceImageSource", i), e.commands.add("imageInsert", n);
        }
      }
      class Up extends pe {
        constructor(e, t) {
          super(e), this._modelElementName = t;
        }
        refresh() {
          const e = this.editor.plugins.get("ImageUtils"), t = e.getClosestSelectedImageElement(this.editor.model.document.selection);
          this._modelElementName === "imageBlock" ? this.isEnabled = e.isInlineImage(t) : this.isEnabled = e.isBlockImage(t);
        }
        execute() {
          const e = this.editor, t = this.editor.model, n = e.plugins.get("ImageUtils"), i = n.getClosestSelectedImageElement(t.document.selection), r = Object.fromEntries(i.getAttributes());
          return r.src || r.uploadId ? t.change((s) => {
            const a = Array.from(t.markers).filter((h) => h.getRange().containsItem(i)), l = n.insertImage(r, t.createSelection(i, "on"), this._modelElementName);
            if (!l)
              return null;
            const d = s.createRangeOn(l);
            for (const h of a) {
              const m = h.getRange(), f = m.root.rootName != "$graveyard" ? m.getJoined(d, !0) : d;
              s.updateMarker(h, { range: f });
            }
            return { oldElement: i, newElement: l };
          }) : null;
        }
      }
      class mE extends G {
        static get requires() {
          return [Hp, vn, bn];
        }
        static get pluginName() {
          return "ImageBlockEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.register("imageBlock", { inheritAllFrom: "$blockObject", allowAttributes: ["alt", "src", "srcset"] }), this._setupConversion(), e.plugins.has("ImageInlineEditing") && (e.commands.add("imageTypeBlock", new Up(this.editor, "imageBlock")), this._setupClipboardIntegration());
        }
        _setupConversion() {
          const e = this.editor, t = e.t, n = e.conversion, i = e.plugins.get("ImageUtils");
          n.for("dataDowncast").elementToStructure({ model: "imageBlock", view: (r, { writer: s }) => Tp(s) }), n.for("editingDowncast").elementToStructure({ model: "imageBlock", view: (r, { writer: s }) => i.toImageWidget(Tp(s), s, t("image widget")) }), n.for("downcast").add(us(i, "imageBlock", "src")).add(us(i, "imageBlock", "alt")).add(Lp(i, "imageBlock")), n.for("upcast").elementToElement({ view: Pp(e, "imageBlock"), model: (r, { writer: s }) => s.createElement("imageBlock", r.hasAttribute("src") ? { src: r.getAttribute("src") } : void 0) }).add(/* @__PURE__ */ function(r) {
            const s = (a, l, d) => {
              if (!d.consumable.test(l.viewItem, { name: !0, classes: "image" }))
                return;
              const h = r.findViewImgElement(l.viewItem);
              if (!h || !d.consumable.test(h, { name: !0 }))
                return;
              d.consumable.consume(l.viewItem, { name: !0, classes: "image" });
              const m = it(d.convertItem(h, l.modelCursor).modelRange.getItems());
              m ? (d.convertChildren(l.viewItem, m), d.updateConversionResult(m, l)) : d.consumable.revert(l.viewItem, { name: !0, classes: "image" });
            };
            return (a) => {
              a.on("element:figure", s);
            };
          }(i));
        }
        _setupClipboardIntegration() {
          const e = this.editor, t = e.model, n = e.editing.view, i = e.plugins.get("ImageUtils"), r = e.plugins.get("ClipboardPipeline");
          this.listenTo(r, "inputTransformation", (s, a) => {
            const l = Array.from(a.content.getChildren());
            let d;
            if (!l.every(i.isInlineImageView))
              return;
            d = a.targetRanges ? e.editing.mapper.toModelRange(a.targetRanges[0]) : t.document.selection.getFirstRange();
            const h = t.createSelection(d);
            if (Tl(t.schema, h) === "imageBlock") {
              const m = new Kr(n.document), f = l.map((_) => m.createElement("figure", { class: "image" }, _));
              a.content = m.createDocumentFragment(f);
            }
          });
        }
      }
      var qp = k(3508), pE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(qp.Z, pE), qp.Z.locals;
      class fE extends G {
        static get requires() {
          return [mE, Wi, $p];
        }
        static get pluginName() {
          return "ImageBlock";
        }
      }
      class bE extends G {
        static get requires() {
          return [Hp, vn, bn];
        }
        static get pluginName() {
          return "ImageInlineEditing";
        }
        init() {
          const e = this.editor, t = e.model.schema;
          t.register("imageInline", { inheritAllFrom: "$inlineObject", allowAttributes: ["alt", "src", "srcset"] }), t.addChildCheck((n, i) => {
            if (n.endsWith("caption") && i.name === "imageInline")
              return !1;
          }), this._setupConversion(), e.plugins.has("ImageBlockEditing") && (e.commands.add("imageTypeInline", new Up(this.editor, "imageInline")), this._setupClipboardIntegration());
        }
        _setupConversion() {
          const e = this.editor, t = e.t, n = e.conversion, i = e.plugins.get("ImageUtils");
          n.for("dataDowncast").elementToElement({ model: "imageInline", view: (r, { writer: s }) => s.createEmptyElement("img") }), n.for("editingDowncast").elementToStructure({ model: "imageInline", view: (r, { writer: s }) => i.toImageWidget(function(a) {
            return a.createContainerElement("span", { class: "image-inline" }, a.createEmptyElement("img"));
          }(s), s, t("image widget")) }), n.for("downcast").add(us(i, "imageInline", "src")).add(us(i, "imageInline", "alt")).add(Lp(i, "imageInline")), n.for("upcast").elementToElement({ view: Pp(e, "imageInline"), model: (r, { writer: s }) => s.createElement("imageInline", r.hasAttribute("src") ? { src: r.getAttribute("src") } : void 0) });
        }
        _setupClipboardIntegration() {
          const e = this.editor, t = e.model, n = e.editing.view, i = e.plugins.get("ImageUtils"), r = e.plugins.get("ClipboardPipeline");
          this.listenTo(r, "inputTransformation", (s, a) => {
            const l = Array.from(a.content.getChildren());
            let d;
            if (!l.every(i.isBlockImageView))
              return;
            d = a.targetRanges ? e.editing.mapper.toModelRange(a.targetRanges[0]) : t.document.selection.getFirstRange();
            const h = t.createSelection(d);
            if (Tl(t.schema, h) === "imageInline") {
              const m = new Kr(n.document), f = l.map((_) => _.childCount === 1 ? (Array.from(_.getAttributes()).forEach((E) => m.setAttribute(...E, i.findViewImgElement(_))), _.getChild(0)) : _);
              a.content = m.createDocumentFragment(f);
            }
          });
        }
      }
      class kE extends G {
        static get requires() {
          return [bE, Wi, $p];
        }
        static get pluginName() {
          return "ImageInline";
        }
      }
      var Wp = k(2640), wE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Wp.Z, wE), Wp.Z.locals;
      function Gp(o) {
        const e = o.map((t) => t.replace("+", "\\+"));
        return new RegExp(`^image\\/(${e.join("|")})$`);
      }
      function vE(o) {
        return new Promise((e, t) => {
          const n = o.getAttribute("src");
          fetch(n).then((i) => i.blob()).then((i) => {
            const r = Kp(i, n), s = r.replace("image/", ""), a = new File([i], `image.${s}`, { type: r });
            e(a);
          }).catch((i) => i && i.name === "TypeError" ? function(r) {
            return function(s) {
              return new Promise((a, l) => {
                const d = fe.document.createElement("img");
                d.addEventListener("load", () => {
                  const h = fe.document.createElement("canvas");
                  h.width = d.width, h.height = d.height, h.getContext("2d").drawImage(d, 0, 0), h.toBlob((m) => m ? a(m) : l());
                }), d.addEventListener("error", () => l()), d.src = s;
              });
            }(r).then((s) => {
              const a = Kp(s, r), l = a.replace("image/", "");
              return new File([s], `image.${l}`, { type: a });
            });
          }(n).then(e).catch(t) : t(i));
        });
      }
      function Kp(o, e) {
        return o.type ? o.type : e.match(/data:(image\/\w+);base64/) ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg";
      }
      class _E extends G {
        static get pluginName() {
          return "ImageUploadUI";
        }
        init() {
          const e = this.editor, t = e.t, n = (i) => {
            const r = new T2(i), s = e.commands.get("uploadImage"), a = e.config.get("image.upload.types"), l = Gp(a);
            return r.set({ acceptedType: a.map((d) => `image/${d}`).join(","), allowMultipleFiles: !0 }), r.buttonView.set({ label: t("Insert image"), icon: qe.image, tooltip: !0 }), r.buttonView.bind("isEnabled").to(s), r.on("done", (d, h) => {
              const m = Array.from(h).filter((f) => l.test(f.type));
              m.length && (e.execute("uploadImage", { file: m }), e.editing.view.focus());
            }), r;
          };
          e.ui.componentFactory.add("uploadImage", n), e.ui.componentFactory.add("imageUpload", n);
        }
      }
      var Zp = k(3689), AE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Zp.Z, AE), Zp.Z.locals;
      var Jp = k(4036), CE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Jp.Z, CE), Jp.Z.locals;
      var Yp = k(3773), yE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Yp.Z, yE), Yp.Z.locals;
      class EE extends G {
        constructor(e) {
          super(e), this.uploadStatusChange = (t, n, i) => {
            const r = this.editor, s = n.item, a = s.getAttribute("uploadId");
            if (!i.consumable.consume(n.item, t.name))
              return;
            const l = r.plugins.get("ImageUtils"), d = r.plugins.get(wn), h = a ? n.attributeNewValue : null, m = this.placeholder, f = r.editing.mapper.toViewElement(s), _ = i.writer;
            if (h == "reading")
              return Qp(f, _), void Xp(l, m, f, _);
            if (h == "uploading") {
              const E = d.loaders.get(a);
              return Qp(f, _), void (E ? (ef(f, _), function(B, T, O, N) {
                const H = function(X) {
                  const be = X.createUIElement("div", { class: "ck-progress-bar" });
                  return X.setCustomProperty("progressBar", !0, be), be;
                }(T);
                T.insert(T.createPositionAt(B, "end"), H), O.on("change:uploadedPercent", (X, be, Ge) => {
                  N.change((Pe) => {
                    Pe.setStyle("width", Ge + "%", H);
                  });
                });
              }(f, _, E, r.editing.view), function(B, T, O, N) {
                if (N.data) {
                  const H = B.findViewImgElement(T);
                  O.setAttribute("src", N.data, H);
                }
              }(l, f, _, E)) : Xp(l, m, f, _));
            }
            h == "complete" && d.loaders.get(a) && function(E, B, T) {
              const O = B.createUIElement("div", { class: "ck-image-upload-complete-icon" });
              B.insert(B.createPositionAt(E, "end"), O), setTimeout(() => {
                T.change((N) => N.remove(N.createRangeOn(O)));
              }, 3e3);
            }(f, _, r.editing.view), function(E, B) {
              nf(E, B, "progressBar");
            }(f, _), ef(f, _), function(E, B) {
              B.removeClass("ck-appear", E);
            }(f, _);
          }, this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        }
        static get pluginName() {
          return "ImageUploadProgress";
        }
        init() {
          const e = this.editor;
          e.plugins.has("ImageBlockEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange), e.plugins.has("ImageInlineEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange);
        }
      }
      function Qp(o, e) {
        o.hasClass("ck-appear") || e.addClass("ck-appear", o);
      }
      function Xp(o, e, t, n) {
        t.hasClass("ck-image-upload-placeholder") || n.addClass("ck-image-upload-placeholder", t);
        const i = o.findViewImgElement(t);
        i.getAttribute("src") !== e && n.setAttribute("src", e, i), tf(t, "placeholder") || n.insert(n.createPositionAfter(i), function(r) {
          const s = r.createUIElement("div", { class: "ck-upload-placeholder-loader" });
          return r.setCustomProperty("placeholder", !0, s), s;
        }(n));
      }
      function ef(o, e) {
        o.hasClass("ck-image-upload-placeholder") && e.removeClass("ck-image-upload-placeholder", o), nf(o, e, "placeholder");
      }
      function tf(o, e) {
        for (const t of o.getChildren())
          if (t.getCustomProperty(e))
            return t;
      }
      function nf(o, e, t) {
        const n = tf(o, t);
        n && e.remove(e.createRangeOn(n));
      }
      var xE = Object.defineProperty, SE = Object.defineProperties, DE = Object.getOwnPropertyDescriptors, of = Object.getOwnPropertySymbols, BE = Object.prototype.hasOwnProperty, TE = Object.prototype.propertyIsEnumerable, rf = (o, e, t) => e in o ? xE(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class PE extends pe {
        refresh() {
          const e = this.editor, t = e.plugins.get("ImageUtils"), n = e.model.document.selection.getSelectedElement();
          this.isEnabled = t.isImageAllowed() || t.isImage(n);
        }
        execute(e) {
          const t = Xe(e.file), n = this.editor.model.document.selection, i = this.editor.plugins.get("ImageUtils"), r = Object.fromEntries(n.getAttributes());
          t.forEach((s, a) => {
            const l = n.getSelectedElement();
            if (a && l && i.isImage(l)) {
              const d = this.editor.model.createPositionAfter(l);
              this._uploadImage(s, r, d);
            } else
              this._uploadImage(s, r);
          });
        }
        _uploadImage(e, t, n) {
          const i = this.editor, r = i.plugins.get(wn).createLoader(e), s = i.plugins.get("ImageUtils");
          var a, l;
          r && s.insertImage((a = ((d, h) => {
            for (var m in h || (h = {}))
              BE.call(h, m) && rf(d, m, h[m]);
            if (of)
              for (var m of of(h))
                TE.call(h, m) && rf(d, m, h[m]);
            return d;
          })({}, t), l = { uploadId: r.id }, SE(a, DE(l))), n);
        }
      }
      class IE extends G {
        constructor(e) {
          super(e), e.config.define("image", { upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] } }), this._uploadImageElements = /* @__PURE__ */ new Map();
        }
        static get requires() {
          return [wn, _m, bn, vn];
        }
        static get pluginName() {
          return "ImageUploadEditing";
        }
        init() {
          const e = this.editor, t = e.model.document, n = e.conversion, i = e.plugins.get(wn), r = e.plugins.get("ImageUtils"), s = e.plugins.get("ClipboardPipeline"), a = Gp(e.config.get("image.upload.types")), l = new PE(e);
          e.commands.add("uploadImage", l), e.commands.add("imageUpload", l), n.for("upcast").attributeToAttribute({ view: { name: "img", key: "uploadId" }, model: "uploadId" }), this.listenTo(e.editing.view.document, "clipboardInput", (d, h) => {
            if (m = h.dataTransfer, Array.from(m.types).includes("text/html") && m.getData("text/html") !== "")
              return;
            var m;
            const f = Array.from(h.dataTransfer.files).filter((_) => !!_ && a.test(_.type));
            f.length && (d.stop(), e.model.change((_) => {
              h.targetRanges && _.setSelection(h.targetRanges.map((E) => e.editing.mapper.toModelRange(E))), e.model.enqueueChange(() => {
                e.execute("uploadImage", { file: f });
              });
            }));
          }), this.listenTo(s, "inputTransformation", (d, h) => {
            const m = Array.from(e.editing.view.createRangeIn(h.content)).map((_) => _.item).filter((_) => function(E, B) {
              return !(!E.isInlineImageView(B) || !B.getAttribute("src") || !B.getAttribute("src").match(/^data:image\/\w+;base64,/g) && !B.getAttribute("src").match(/^blob:/g));
            }(r, _) && !_.getAttribute("uploadProcessed")).map((_) => ({ promise: vE(_), imageElement: _ }));
            if (!m.length)
              return;
            const f = new Kr(e.editing.view.document);
            for (const _ of m) {
              f.setAttribute("uploadProcessed", !0, _.imageElement);
              const E = i.createLoader(_.promise);
              E && (f.setAttribute("src", "", _.imageElement), f.setAttribute("uploadId", E.id, _.imageElement));
            }
          }), e.editing.view.document.on("dragover", (d, h) => {
            h.preventDefault();
          }), t.on("change", () => {
            const d = t.differ.getChanges({ includeChangesInGraveyard: !0 }).reverse(), h = /* @__PURE__ */ new Set();
            for (const m of d)
              if (m.type == "insert" && m.name != "$text") {
                const f = m.position.nodeAfter, _ = m.position.root.rootName == "$graveyard";
                for (const E of OE(e, f)) {
                  const B = E.getAttribute("uploadId");
                  if (!B)
                    continue;
                  const T = i.loaders.get(B);
                  T && (_ ? h.has(B) || T.abort() : (h.add(B), this._uploadImageElements.set(B, E), T.status == "idle" && this._readAndUpload(T)));
                }
              }
          }), this.on("uploadComplete", (d, { imageElement: h, data: m }) => {
            const f = m.urls ? m.urls : m;
            this.editor.model.change((_) => {
              _.setAttribute("src", f.default, h), this._parseAndSetSrcsetAttributeOnImage(f, h, _);
            });
          }, { priority: "low" });
        }
        afterInit() {
          const e = this.editor.model.schema;
          this.editor.plugins.has("ImageBlockEditing") && e.extend("imageBlock", { allowAttributes: ["uploadId", "uploadStatus"] }), this.editor.plugins.has("ImageInlineEditing") && e.extend("imageInline", { allowAttributes: ["uploadId", "uploadStatus"] });
        }
        _readAndUpload(e) {
          const t = this.editor, n = t.model, i = t.locale.t, r = t.plugins.get(wn), s = t.plugins.get(_m), a = t.plugins.get("ImageUtils"), l = this._uploadImageElements;
          return n.enqueueChange({ isUndoable: !1 }, (h) => {
            h.setAttribute("uploadStatus", "reading", l.get(e.id));
          }), e.read().then(() => {
            const h = e.upload(), m = l.get(e.id);
            if (b.isSafari) {
              const f = t.editing.mapper.toViewElement(m), _ = a.findViewImgElement(f);
              t.editing.view.once("render", () => {
                if (!_.parent)
                  return;
                const E = t.editing.view.domConverter.mapViewToDom(_.parent);
                if (!E)
                  return;
                const B = E.style.display;
                E.style.display = "none", E._ckHack = E.offsetHeight, E.style.display = B;
              });
            }
            return n.enqueueChange({ isUndoable: !1 }, (f) => {
              f.setAttribute("uploadStatus", "uploading", m);
            }), h;
          }).then((h) => {
            n.enqueueChange({ isUndoable: !1 }, (m) => {
              const f = l.get(e.id);
              m.setAttribute("uploadStatus", "complete", f), this.fire("uploadComplete", { data: h, imageElement: f });
            }), d();
          }).catch((h) => {
            if (e.status !== "error" && e.status !== "aborted")
              throw h;
            e.status == "error" && h && s.showWarning(h, { title: i("Upload failed"), namespace: "upload" }), n.enqueueChange({ isUndoable: !1 }, (m) => {
              m.remove(l.get(e.id));
            }), d();
          });
          function d() {
            n.enqueueChange({ isUndoable: !1 }, (h) => {
              const m = l.get(e.id);
              h.removeAttribute("uploadId", m), h.removeAttribute("uploadStatus", m), l.delete(e.id);
            }), r.destroyLoader(e);
          }
        }
        _parseAndSetSrcsetAttributeOnImage(e, t, n) {
          let i = 0;
          const r = Object.keys(e).filter((s) => {
            const a = parseInt(s, 10);
            if (!isNaN(a))
              return i = Math.max(i, a), !0;
          }).map((s) => `${e[s]} ${s}w`).join(", ");
          r != "" && n.setAttribute("srcset", { data: r, width: i }, t);
        }
      }
      function OE(o, e) {
        const t = o.plugins.get("ImageUtils");
        return Array.from(o.model.createRangeOn(e)).filter((n) => t.isImage(n.item)).map((n) => n.item);
      }
      var sf = k(1568), RE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(sf.Z, RE), sf.Z.locals;
      var af = k(3535), zE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(af.Z, zE), af.Z.locals;
      class ME extends pe {
        refresh() {
          const e = this.editor, t = e.plugins.get("ImageUtils").getClosestSelectedImageElement(e.model.document.selection);
          this.isEnabled = !!t, t && t.hasAttribute("width") ? this.value = { width: t.getAttribute("width"), height: null } : this.value = null;
        }
        execute(e) {
          const t = this.editor, n = t.model, i = t.plugins.get("ImageUtils").getClosestSelectedImageElement(n.document.selection);
          this.value = { width: e.width, height: null }, i && n.change((r) => {
            r.setAttribute("width", e.width, i);
          });
        }
      }
      class NE extends G {
        static get requires() {
          return [vn];
        }
        static get pluginName() {
          return "ImageResizeEditing";
        }
        constructor(e) {
          super(e), e.config.define("image", { resizeUnit: "%", resizeOptions: [{ name: "resizeImage:original", value: null, icon: "original" }, { name: "resizeImage:25", value: "25", icon: "small" }, { name: "resizeImage:50", value: "50", icon: "medium" }, { name: "resizeImage:75", value: "75", icon: "large" }] });
        }
        init() {
          const e = this.editor, t = new ME(e);
          this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline"), e.commands.add("resizeImage", t), e.commands.add("imageResize", t);
        }
        _registerSchema() {
          this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: "width" }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: "width" });
        }
        _registerConverters(e) {
          const t = this.editor;
          t.conversion.for("downcast").add((n) => n.on(`attribute:width:${e}`, (i, r, s) => {
            if (!s.consumable.consume(r.item, i.name))
              return;
            const a = s.writer, l = s.mapper.toViewElement(r.item);
            r.attributeNewValue !== null ? (a.setStyle("width", r.attributeNewValue, l), a.addClass("image_resized", l)) : (a.removeStyle("width", l), a.removeClass("image_resized", l));
          })), t.conversion.for("upcast").attributeToAttribute({ view: { name: e === "imageBlock" ? "figure" : "img", styles: { width: /.+/ } }, model: { key: "width", value: (n) => n.getStyle("width") } });
        }
      }
      const Pl = { small: qe.objectSizeSmall, medium: qe.objectSizeMedium, large: qe.objectSizeLarge, original: qe.objectSizeFull };
      function lf(o) {
        return (e) => o === null && e === o || e !== null && e.width === o;
      }
      var cf = k(6270), FE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(cf.Z, FE), cf.Z.locals;
      class $E extends pe {
        constructor(e, t) {
          super(e), this._defaultStyles = { imageBlock: !1, imageInline: !1 }, this._styles = new Map(t.map((n) => {
            if (n.isDefault)
              for (const i of n.modelElements)
                this._defaultStyles[i] = n.name;
            return [n.name, n];
          }));
        }
        refresh() {
          const e = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
          this.isEnabled = !!e, this.isEnabled ? e.hasAttribute("imageStyle") ? this.value = e.getAttribute("imageStyle") : this.value = this._defaultStyles[e.name] : this.value = !1;
        }
        execute(e = {}) {
          const t = this.editor, n = t.model, i = t.plugins.get("ImageUtils");
          n.change((r) => {
            const s = e.value;
            let a = i.getClosestSelectedImageElement(n.document.selection);
            s && this.shouldConvertImageType(s, a) && (this.editor.execute(i.isBlockImage(a) ? "imageTypeInline" : "imageTypeBlock"), a = i.getClosestSelectedImageElement(n.document.selection)), !s || this._styles.get(s).isDefault ? r.removeAttribute("imageStyle", a) : r.setAttribute("imageStyle", s, a);
          });
        }
        shouldConvertImageType(e, t) {
          return !this._styles.get(e).modelElements.includes(t.name);
        }
      }
      var LE = Object.defineProperty, df = Object.getOwnPropertySymbols, VE = Object.prototype.hasOwnProperty, jE = Object.prototype.propertyIsEnumerable, uf = (o, e, t) => e in o ? LE(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, hf = (o, e) => {
        for (var t in e || (e = {}))
          VE.call(e, t) && uf(o, t, e[t]);
        if (df)
          for (var t of df(e))
            jE.call(e, t) && uf(o, t, e[t]);
        return o;
      };
      const { objectFullWidth: HE, objectInline: gf, objectLeft: mf, objectRight: Il, objectCenter: Ol, objectBlockLeft: pf, objectBlockRight: ff } = qe, gs = { get inline() {
        return { name: "inline", title: "In line", icon: gf, modelElements: ["imageInline"], isDefault: !0 };
      }, get alignLeft() {
        return { name: "alignLeft", title: "Left aligned image", icon: mf, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-left" };
      }, get alignBlockLeft() {
        return { name: "alignBlockLeft", title: "Left aligned image", icon: pf, modelElements: ["imageBlock"], className: "image-style-block-align-left" };
      }, get alignCenter() {
        return { name: "alignCenter", title: "Centered image", icon: Ol, modelElements: ["imageBlock"], className: "image-style-align-center" };
      }, get alignRight() {
        return { name: "alignRight", title: "Right aligned image", icon: Il, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-right" };
      }, get alignBlockRight() {
        return { name: "alignBlockRight", title: "Right aligned image", icon: ff, modelElements: ["imageBlock"], className: "image-style-block-align-right" };
      }, get block() {
        return { name: "block", title: "Centered image", icon: Ol, modelElements: ["imageBlock"], isDefault: !0 };
      }, get side() {
        return { name: "side", title: "Side image", icon: Il, modelElements: ["imageBlock"], className: "image-style-side" };
      } }, bf = { full: HE, left: pf, right: ff, center: Ol, inlineLeft: mf, inlineRight: Il, inline: gf }, kf = [{ name: "imageStyle:wrapText", title: "Wrap text", defaultItem: "imageStyle:alignLeft", items: ["imageStyle:alignLeft", "imageStyle:alignRight"] }, { name: "imageStyle:breakText", title: "Break text", defaultItem: "imageStyle:block", items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"] }];
      function wf(o) {
        ne("image-style-configuration-definition-invalid", o);
      }
      const Rl = { normalizeStyles: function(o) {
        return (o.configuredStyles.options || []).map((e) => function(t) {
          return t = typeof t == "string" ? gs[t] ? hf({}, gs[t]) : { name: t } : function(n, i) {
            const r = hf({}, i);
            for (const s in n)
              Object.prototype.hasOwnProperty.call(i, s) || (r[s] = n[s]);
            return r;
          }(gs[t.name], t), typeof t.icon == "string" && (t.icon = bf[t.icon] || t.icon), t;
        }(e)).filter((e) => function(t, { isBlockPluginLoaded: n, isInlinePluginLoaded: i }) {
          const { modelElements: r, name: s } = t;
          if (!(r && r.length && s))
            return wf({ style: t }), !1;
          {
            const a = [n ? "imageBlock" : null, i ? "imageInline" : null];
            if (!r.some((l) => a.includes(l)))
              return ne("image-style-missing-dependency", { style: t, missingPlugins: r.map((l) => l === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing") }), !1;
          }
          return !0;
        }(e, o));
      }, getDefaultStylesConfiguration: function(o, e) {
        return o && e ? { options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"] } : o ? { options: ["block", "side"] } : e ? { options: ["inline", "alignLeft", "alignRight"] } : {};
      }, getDefaultDropdownDefinitions: function(o) {
        return o.has("ImageBlockEditing") && o.has("ImageInlineEditing") ? [...kf] : [];
      }, warnInvalidStyle: wf, DEFAULT_OPTIONS: gs, DEFAULT_ICONS: bf, DEFAULT_DROPDOWN_DEFINITIONS: kf };
      function vf(o, e) {
        for (const t of e)
          if (t.name === o)
            return t;
      }
      class _f extends G {
        static get pluginName() {
          return "ImageStyleEditing";
        }
        static get requires() {
          return [vn];
        }
        init() {
          const { normalizeStyles: e, getDefaultStylesConfiguration: t } = Rl, n = this.editor, i = n.plugins.has("ImageBlockEditing"), r = n.plugins.has("ImageInlineEditing");
          n.config.define("image.styles", t(i, r)), this.normalizedStyles = e({ configuredStyles: n.config.get("image.styles"), isBlockPluginLoaded: i, isInlinePluginLoaded: r }), this._setupConversion(i, r), this._setupPostFixer(), n.commands.add("imageStyle", new $E(n, this.normalizedStyles));
        }
        _setupConversion(e, t) {
          const n = this.editor, i = n.model.schema, r = (s = this.normalizedStyles, (l, d, h) => {
            if (!h.consumable.consume(d.item, l.name))
              return;
            const m = vf(d.attributeNewValue, s), f = vf(d.attributeOldValue, s), _ = h.mapper.toViewElement(d.item), E = h.writer;
            f && E.removeClass(f.className, _), m && E.addClass(m.className, _);
          });
          var s;
          const a = function(l) {
            const d = { imageInline: l.filter((h) => !h.isDefault && h.modelElements.includes("imageInline")), imageBlock: l.filter((h) => !h.isDefault && h.modelElements.includes("imageBlock")) };
            return (h, m, f) => {
              if (!m.modelRange)
                return;
              const _ = m.viewItem, E = it(m.modelRange.getItems());
              if (E && f.schema.checkAttribute(E, "imageStyle"))
                for (const B of d[E.name])
                  f.consumable.consume(_, { classes: B.className }) && f.writer.setAttribute("imageStyle", B.name, E);
            };
          }(this.normalizedStyles);
          n.editing.downcastDispatcher.on("attribute:imageStyle", r), n.data.downcastDispatcher.on("attribute:imageStyle", r), e && (i.extend("imageBlock", { allowAttributes: "imageStyle" }), n.data.upcastDispatcher.on("element:figure", a, { priority: "low" })), t && (i.extend("imageInline", { allowAttributes: "imageStyle" }), n.data.upcastDispatcher.on("element:img", a, { priority: "low" }));
        }
        _setupPostFixer() {
          const e = this.editor, t = e.model.document, n = e.plugins.get(vn), i = new Map(this.normalizedStyles.map((r) => [r.name, r]));
          t.registerPostFixer((r) => {
            let s = !1;
            for (const a of t.differ.getChanges())
              if (a.type == "insert" || a.type == "attribute" && a.attributeKey == "imageStyle") {
                let l = a.type == "insert" ? a.position.nodeAfter : a.range.start.nodeAfter;
                if (l && l.is("element", "paragraph") && l.childCount > 0 && (l = l.getChild(0)), !n.isImage(l))
                  continue;
                const d = l.getAttribute("imageStyle");
                if (!d)
                  continue;
                const h = i.get(d);
                h && h.modelElements.includes(l.name) || (r.removeAttribute("imageStyle", l), s = !0);
              }
            return s;
          });
        }
      }
      var Af = k(5083), UE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Af.Z, UE), Af.Z.locals;
      class qE extends G {
        static get requires() {
          return [_f];
        }
        static get pluginName() {
          return "ImageStyleUI";
        }
        get localizedDefaultStylesTitles() {
          const e = this.editor.t;
          return { "Wrap text": e("Wrap text"), "Break text": e("Break text"), "In line": e("In line"), "Full size image": e("Full size image"), "Side image": e("Side image"), "Left aligned image": e("Left aligned image"), "Centered image": e("Centered image"), "Right aligned image": e("Right aligned image") };
        }
        init() {
          const e = this.editor.plugins, t = this.editor.config.get("image.toolbar") || [], n = Cf(e.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
          for (const r of n)
            this._createButton(r);
          const i = Cf([...t.filter(K), ...Rl.getDefaultDropdownDefinitions(e)], this.localizedDefaultStylesTitles);
          for (const r of i)
            this._createDropdown(r, n);
        }
        _createDropdown(e, t) {
          const n = this.editor.ui.componentFactory;
          n.add(e.name, (i) => {
            let r;
            const { defaultItem: s, items: a, title: l } = e, d = a.filter((_) => t.find(({ name: E }) => yf(E) === _)).map((_) => {
              const E = n.create(_);
              return _ === s && (r = E), E;
            });
            a.length !== d.length && Rl.warnInvalidStyle({ dropdown: e });
            const h = fn(i, il), m = h.buttonView, f = m.arrowView;
            return Yr(h, d, { enableActiveItemFocusOnDropdownOpen: !0 }), m.set({ label: Ef(l, r.label), class: null, tooltip: !0 }), f.unbind("label"), f.set({ label: l }), m.bind("icon").toMany(d, "isOn", (..._) => {
              const E = _.findIndex(Qn);
              return E < 0 ? r.icon : d[E].icon;
            }), m.bind("label").toMany(d, "isOn", (..._) => {
              const E = _.findIndex(Qn);
              return Ef(l, E < 0 ? r.label : d[E].label);
            }), m.bind("isOn").toMany(d, "isOn", (..._) => _.some(Qn)), m.bind("class").toMany(d, "isOn", (..._) => _.some(Qn) ? "ck-splitbutton_flatten" : void 0), m.on("execute", () => {
              d.some(({ isOn: _ }) => _) ? h.isOpen = !h.isOpen : r.fire("execute");
            }), h.bind("isEnabled").toMany(d, "isEnabled", (..._) => _.some(Qn)), this.listenTo(h, "execute", () => {
              this.editor.editing.view.focus();
            }), h;
          });
        }
        _createButton(e) {
          const t = e.name;
          this.editor.ui.componentFactory.add(yf(t), (n) => {
            const i = this.editor.commands.get("imageStyle"), r = new je(n);
            return r.set({ label: e.title, icon: e.icon, tooltip: !0, isToggleable: !0 }), r.bind("isEnabled").to(i, "isEnabled"), r.bind("isOn").to(i, "value", (s) => s === t), r.on("execute", this._executeCommand.bind(this, t)), r;
          });
        }
        _executeCommand(e) {
          this.editor.execute("imageStyle", { value: e }), this.editor.editing.view.focus();
        }
      }
      function Cf(o, e) {
        for (const t of o)
          e[t.title] && (t.title = e[t.title]);
        return o;
      }
      function yf(o) {
        return `imageStyle:${o}`;
      }
      function Ef(o, e) {
        return (o ? o + ": " : "") + e;
      }
      class WE extends G {
        static get pluginName() {
          return "IndentEditing";
        }
        init() {
          const e = this.editor;
          e.commands.add("indent", new Ru(e)), e.commands.add("outdent", new Ru(e));
        }
      }
      const xf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>', Sf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
      class GE extends G {
        static get pluginName() {
          return "IndentUI";
        }
        init() {
          const e = this.editor, t = e.locale, n = e.t, i = t.uiLanguageDirection == "ltr" ? xf : Sf, r = t.uiLanguageDirection == "ltr" ? Sf : xf;
          this._defineButton("indent", n("Increase indent"), i), this._defineButton("outdent", n("Decrease indent"), r);
        }
        _defineButton(e, t, n) {
          const i = this.editor;
          i.ui.componentFactory.add(e, (r) => {
            const s = i.commands.get(e), a = new je(r);
            return a.set({ label: t, icon: n, tooltip: !0 }), a.bind("isEnabled").to(s, "isEnabled"), this.listenTo(a, "execute", () => {
              i.execute(e), i.editing.view.focus();
            }), a;
          });
        }
      }
      class ms extends pe {
        constructor(e, t) {
          super(e), this._indentBehavior = t;
        }
        refresh() {
          const e = this.editor.model, t = it(e.document.selection.getSelectedBlocks());
          t && e.schema.checkAttribute(t, "blockIndent") ? this.isEnabled = this._indentBehavior.checkEnabled(t.getAttribute("blockIndent")) : this.isEnabled = !1;
        }
        execute() {
          const e = this.editor.model, t = function(n) {
            const i = n.document.selection, r = n.schema;
            return Array.from(i.getSelectedBlocks()).filter((s) => r.checkAttribute(s, "blockIndent"));
          }(e);
          e.change((n) => {
            for (const i of t) {
              const r = i.getAttribute("blockIndent"), s = this._indentBehavior.getNextIndent(r);
              s ? n.setAttribute("blockIndent", s, i) : n.removeAttribute("blockIndent", i);
            }
          });
        }
      }
      class Df {
        constructor(e) {
          this.isForward = e.direction === "forward", this.offset = e.offset, this.unit = e.unit;
        }
        checkEnabled(e) {
          const t = parseFloat(e || "0");
          return this.isForward || t > 0;
        }
        getNextIndent(e) {
          const t = parseFloat(e || "0");
          if (!(!e || e.endsWith(this.unit)))
            return this.isForward ? this.offset + this.unit : void 0;
          const n = t + (this.isForward ? this.offset : -this.offset);
          return n > 0 ? n + this.unit : void 0;
        }
      }
      class Bf {
        constructor(e) {
          this.isForward = e.direction === "forward", this.classes = e.classes;
        }
        checkEnabled(e) {
          const t = this.classes.indexOf(e);
          return this.isForward ? t < this.classes.length - 1 : t >= 0;
        }
        getNextIndent(e) {
          const t = this.classes.indexOf(e), n = this.isForward ? 1 : -1;
          return this.classes[t + n];
        }
      }
      const KE = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"];
      class ZE {
        constructor() {
          this._definitions = /* @__PURE__ */ new Set();
        }
        get length() {
          return this._definitions.size;
        }
        add(e) {
          Array.isArray(e) ? e.forEach((t) => this._definitions.add(t)) : this._definitions.add(e);
        }
        getDispatcher() {
          return (e) => {
            e.on("attribute:linkHref", (t, n, i) => {
              if (!i.consumable.test(n.item, "attribute:linkHref") || !n.item.is("selection") && !i.schema.isInline(n.item))
                return;
              const r = i.writer, s = r.document.selection;
              for (const a of this._definitions) {
                const l = r.createAttributeElement("a", a.attributes, { priority: 5 });
                a.classes && r.addClass(a.classes, l);
                for (const d in a.styles)
                  r.setStyle(d, a.styles[d], l);
                r.setCustomProperty("link", !0, l), a.callback(n.attributeNewValue) ? n.item.is("selection") ? r.wrap(s.getFirstRange(), l) : r.wrap(i.mapper.toViewRange(n.range), l) : r.unwrap(i.mapper.toViewRange(n.range), l);
              }
            }, { priority: "high" });
          };
        }
        getDispatcherForLinkedImage() {
          return (e) => {
            e.on("attribute:linkHref:imageBlock", (t, n, { writer: i, mapper: r }) => {
              const s = r.toViewElement(n.item), a = Array.from(s.getChildren()).find((l) => l.is("element", "a"));
              for (const l of this._definitions) {
                const d = hn(l.attributes);
                if (l.callback(n.attributeNewValue)) {
                  for (const [h, m] of d)
                    h === "class" ? i.addClass(m, a) : i.setAttribute(h, m, a);
                  l.classes && i.addClass(l.classes, a);
                  for (const h in l.styles)
                    i.setStyle(h, l.styles[h], a);
                } else {
                  for (const [h, m] of d)
                    h === "class" ? i.removeClass(m, a) : i.removeAttribute(h, a);
                  l.classes && i.removeClass(l.classes, a);
                  for (const h in l.styles)
                    i.removeStyle(h, a);
                }
              }
            });
          };
        }
      }
      const JE = function(o, e, t) {
        var n = o.length;
        return t = t === void 0 ? n : t, !e && t >= n ? o : qu(o, e, t);
      };
      var YE = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
      const Tf = function(o) {
        return YE.test(o);
      }, QE = function(o) {
        return o.split("");
      };
      var Pf = "\\ud800-\\udfff", XE = "[" + Pf + "]", zl = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", Ml = "\\ud83c[\\udffb-\\udfff]", If = "[^" + Pf + "]", Of = "(?:\\ud83c[\\udde6-\\uddff]){2}", Rf = "[\\ud800-\\udbff][\\udc00-\\udfff]", zf = "(?:" + zl + "|" + Ml + ")?", Mf = "[\\ufe0e\\ufe0f]?", ex = Mf + zf + ("(?:\\u200d(?:" + [If, Of, Rf].join("|") + ")" + Mf + zf + ")*"), tx = "(?:" + [If + zl + "?", zl, Of, Rf, XE].join("|") + ")", nx = RegExp(Ml + "(?=" + Ml + ")|" + tx + ex, "g");
      const ox = function(o) {
        return o.match(nx) || [];
      }, ix = function(o) {
        return Tf(o) ? ox(o) : QE(o);
      }, rx = /* @__PURE__ */ function(o) {
        return function(e) {
          e = Aa(e);
          var t = Tf(e) ? ix(e) : void 0, n = t ? t[0] : e.charAt(0), i = t ? JE(t, 1).join("") : e.slice(1);
          return n[o]() + i;
        };
      }("toUpperCase"), sx = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, ax = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i, lx = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i, cx = /^((\w+:(\/{2,})?)|(\W))/i, Nl = "Ctrl+K";
      function Nf(o, { writer: e }) {
        const t = e.createAttributeElement("a", { href: o }, { priority: 5 });
        return e.setCustomProperty("link", !0, t), t;
      }
      function Ff(o) {
        const e = String(o);
        return function(t) {
          return !!t.replace(sx, "").match(ax);
        }(e) ? e : "#";
      }
      function Fl(o, e) {
        return !!o && e.checkAttribute(o.name, "linkHref");
      }
      function $l(o, e) {
        const t = (n = o, lx.test(n) ? "mailto:" : e);
        var n;
        const i = !!t && !$f(o);
        return o && i ? t + o : o;
      }
      function $f(o) {
        return cx.test(o);
      }
      function Lf(o) {
        window.open(o, "_blank", "noopener");
      }
      class dx extends pe {
        constructor() {
          super(...arguments), this.manualDecorators = new Vt(), this.automaticDecorators = new ZE();
        }
        restoreManualDecoratorStates() {
          for (const e of this.manualDecorators)
            e.value = this._getDecoratorStateFromModel(e.id);
        }
        refresh() {
          const e = this.editor.model, t = e.document.selection, n = t.getSelectedElement() || it(t.getSelectedBlocks());
          Fl(n, e.schema) ? (this.value = n.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttribute(n, "linkHref")) : (this.value = t.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref"));
          for (const i of this.manualDecorators)
            i.value = this._getDecoratorStateFromModel(i.id);
        }
        execute(e, t = {}) {
          const n = this.editor.model, i = n.document.selection, r = [], s = [];
          for (const a in t)
            t[a] ? r.push(a) : s.push(a);
          n.change((a) => {
            if (i.isCollapsed) {
              const l = i.getFirstPosition();
              if (i.hasAttribute("linkHref")) {
                const d = Vf(i);
                let h = Zo(l, "linkHref", i.getAttribute("linkHref"), n);
                i.getAttribute("linkHref") === d && (h = this._updateLinkContent(n, a, h, e)), a.setAttribute("linkHref", e, h), r.forEach((m) => {
                  a.setAttribute(m, !0, h);
                }), s.forEach((m) => {
                  a.removeAttribute(m, h);
                }), a.setSelection(a.createPositionAfter(h.end.nodeBefore));
              } else if (e !== "") {
                const d = hn(i.getAttributes());
                d.set("linkHref", e), r.forEach((m) => {
                  d.set(m, !0);
                });
                const { end: h } = n.insertContent(a.createText(e, d), l);
                a.setSelection(h);
              }
              ["linkHref", ...r, ...s].forEach((d) => {
                a.removeSelectionAttribute(d);
              });
            } else {
              const l = n.schema.getValidRanges(i.getRanges(), "linkHref"), d = [];
              for (const m of i.getSelectedBlocks())
                n.schema.checkAttribute(m, "linkHref") && d.push(a.createRangeOn(m));
              const h = d.slice();
              for (const m of l)
                this._isRangeToUpdate(m, d) && h.push(m);
              for (const m of h) {
                let f = m;
                if (h.length === 1) {
                  const _ = Vf(i);
                  i.getAttribute("linkHref") === _ && (f = this._updateLinkContent(n, a, m, e), a.setSelection(a.createSelection(f)));
                }
                a.setAttribute("linkHref", e, f), r.forEach((_) => {
                  a.setAttribute(_, !0, f);
                }), s.forEach((_) => {
                  a.removeAttribute(_, f);
                });
              }
            }
          });
        }
        _getDecoratorStateFromModel(e) {
          const t = this.editor.model, n = t.document.selection, i = n.getSelectedElement();
          return Fl(i, t.schema) ? i.getAttribute(e) : n.getAttribute(e);
        }
        _isRangeToUpdate(e, t) {
          for (const n of t)
            if (n.containsRange(e))
              return !1;
          return !0;
        }
        _updateLinkContent(e, t, n, i) {
          const r = t.createText(i, { linkHref: i });
          return e.insertContent(r, n);
        }
      }
      function Vf(o) {
        if (o.isCollapsed) {
          const e = o.getFirstPosition();
          return e.textNode && e.textNode.data;
        }
        {
          const e = Array.from(o.getFirstRange().getItems());
          if (e.length > 1)
            return null;
          const t = e[0];
          return t.is("$text") || t.is("$textProxy") ? t.data : null;
        }
      }
      class ux extends pe {
        refresh() {
          const e = this.editor.model, t = e.document.selection, n = t.getSelectedElement();
          Fl(n, e.schema) ? this.isEnabled = e.schema.checkAttribute(n, "linkHref") : this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref");
        }
        execute() {
          const e = this.editor, t = this.editor.model, n = t.document.selection, i = e.commands.get("link");
          t.change((r) => {
            const s = n.isCollapsed ? [Zo(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), t)] : t.schema.getValidRanges(n.getRanges(), "linkHref");
            for (const a of s)
              if (r.removeAttribute("linkHref", a), i)
                for (const l of i.manualDecorators)
                  r.removeAttribute(l.id, a);
          });
        }
      }
      class hx extends oe() {
        constructor({ id: e, label: t, attributes: n, classes: i, styles: r, defaultValue: s }) {
          super(), this.id = e, this.set("value", void 0), this.defaultValue = s, this.label = t, this.attributes = n, this.classes = i, this.styles = r;
        }
        _createPattern() {
          return { attributes: this.attributes, classes: this.classes, styles: this.styles };
        }
      }
      var jf = k(9773), gx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(jf.Z, gx), jf.Z.locals;
      var mx = Object.defineProperty, Hf = Object.getOwnPropertySymbols, px = Object.prototype.hasOwnProperty, fx = Object.prototype.propertyIsEnumerable, Uf = (o, e, t) => e in o ? mx(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, bx = (o, e) => {
        for (var t in e || (e = {}))
          px.call(e, t) && Uf(o, t, e[t]);
        if (Hf)
          for (var t of Hf(e))
            fx.call(e, t) && Uf(o, t, e[t]);
        return o;
      };
      const qf = "automatic", kx = /^(https?:)?\/\//;
      class wx extends G {
        static get pluginName() {
          return "LinkEditing";
        }
        static get requires() {
          return [jm, zm, bn];
        }
        constructor(e) {
          super(e), e.config.define("link", { addTargetToExternalLinks: !1 });
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: "linkHref" }), e.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: Nf }), e.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (n, i) => Nf(Ff(n), i) }), e.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: { href: !0 } }, model: { key: "linkHref", value: (n) => n.getAttribute("href") } }), e.commands.add("link", new dx(e)), e.commands.add("unlink", new ux(e));
          const t = function(n, i) {
            const r = { "Open in a new tab": n("Open in a new tab"), Downloadable: n("Downloadable") };
            return i.forEach((s) => ("label" in s && r[s.label] && (s.label = r[s.label]), s)), i;
          }(e.t, function(n) {
            const i = [];
            if (n)
              for (const [r, s] of Object.entries(n)) {
                const a = Object.assign({}, s, { id: `link${rx(r)}` });
                i.push(a);
              }
            return i;
          }(e.config.get("link.decorators")));
          this._enableAutomaticDecorators(t.filter((n) => n.mode === qf)), this._enableManualDecorators(t.filter((n) => n.mode === "manual")), e.plugins.get(jm).registerAttribute("linkHref"), function(n, i, r, s) {
            const a = n.editing.view, l = /* @__PURE__ */ new Set();
            a.document.registerPostFixer((d) => {
              const h = n.model.document.selection;
              let m = !1;
              if (h.hasAttribute(i)) {
                const f = Zo(h.getFirstPosition(), i, h.getAttribute(i), n.model), _ = n.editing.mapper.toViewRange(f);
                for (const E of _.getItems())
                  E.is("element", r) && !E.hasClass(s) && (d.addClass(s, E), l.add(E), m = !0);
              }
              return m;
            }), n.conversion.for("editingDowncast").add((d) => {
              function h() {
                a.change((m) => {
                  for (const f of l.values())
                    m.removeClass(s, f), l.delete(f);
                });
              }
              d.on("insert", h, { priority: "highest" }), d.on("remove", h, { priority: "highest" }), d.on("attribute", h, { priority: "highest" }), d.on("selection", h, { priority: "highest" });
            });
          }(e, "linkHref", "a", "ck-link_selected"), this._enableLinkOpen(), this._enableInsertContentSelectionAttributesFixer(), this._enableClickingAfterLink(), this._enableTypingOverLink(), this._handleDeleteContentAfterLink(), this._enableClipboardIntegration();
        }
        _enableAutomaticDecorators(e) {
          const t = this.editor, n = t.commands.get("link").automaticDecorators;
          t.config.get("link.addTargetToExternalLinks") && n.add({ id: "linkIsExternal", mode: qf, callback: (i) => !!i && kx.test(i), attributes: { target: "_blank", rel: "noopener noreferrer" } }), n.add(e), n.length && t.conversion.for("downcast").add(n.getDispatcher());
        }
        _enableManualDecorators(e) {
          if (!e.length)
            return;
          const t = this.editor, n = t.commands.get("link").manualDecorators;
          e.forEach((i) => {
            t.model.schema.extend("$text", { allowAttributes: i.id });
            const r = new hx(i);
            n.add(r), t.conversion.for("downcast").attributeToElement({ model: r.id, view: (s, { writer: a, schema: l }, { item: d }) => {
              if ((d.is("selection") || l.isInline(d)) && s) {
                const h = a.createAttributeElement("a", r.attributes, { priority: 5 });
                r.classes && a.addClass(r.classes, h);
                for (const m in r.styles)
                  a.setStyle(m, r.styles[m], h);
                return a.setCustomProperty("link", !0, h), h;
              }
            } }), t.conversion.for("upcast").elementToAttribute({ view: bx({ name: "a" }, r._createPattern()), model: { key: r.id } });
          });
        }
        _enableLinkOpen() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "click", (n, i) => {
            if (!(b.isMac ? i.domEvent.metaKey : i.domEvent.ctrlKey))
              return;
            let r = i.domTarget;
            if (r.tagName.toLowerCase() != "a" && (r = r.closest("a")), !r)
              return;
            const s = r.getAttribute("href");
            s && (n.stop(), i.preventDefault(), Lf(s));
          }, { context: "$capture" }), this.listenTo(t, "keydown", (n, i) => {
            const r = e.commands.get("link").value;
            r && i.keyCode === Ae.enter && i.altKey && (n.stop(), Lf(r));
          });
        }
        _enableInsertContentSelectionAttributesFixer() {
          const e = this.editor.model, t = e.document.selection;
          this.listenTo(e, "insertContent", () => {
            const n = t.anchor.nodeBefore, i = t.anchor.nodeAfter;
            t.hasAttribute("linkHref") && n && n.hasAttribute("linkHref") && (i && i.hasAttribute("linkHref") || e.change((r) => {
              Ll(r, Vl(e.schema));
            }));
          }, { priority: "low" });
        }
        _enableClickingAfterLink() {
          const e = this.editor, t = e.model;
          e.editing.view.addObserver(tl);
          let n = !1;
          this.listenTo(e.editing.view.document, "mousedown", () => {
            n = !0;
          }), this.listenTo(e.editing.view.document, "selectionChange", () => {
            if (!n)
              return;
            n = !1;
            const i = t.document.selection;
            if (!i.isCollapsed || !i.hasAttribute("linkHref"))
              return;
            const r = i.getFirstPosition(), s = Zo(r, "linkHref", i.getAttribute("linkHref"), t);
            (r.isTouching(s.start) || r.isTouching(s.end)) && t.change((a) => {
              Ll(a, Vl(t.schema));
            });
          });
        }
        _enableTypingOverLink() {
          const e = this.editor, t = e.editing.view;
          let n = null, i = !1;
          this.listenTo(t.document, "delete", () => {
            i = !0;
          }, { priority: "high" }), this.listenTo(e.model, "deleteContent", () => {
            const r = e.model.document.selection;
            r.isCollapsed || (i ? i = !1 : Wf(e) && function(s) {
              const a = s.document.selection, l = a.getFirstPosition(), d = a.getLastPosition(), h = l.nodeAfter;
              if (!h || !h.is("$text") || !h.hasAttribute("linkHref"))
                return !1;
              const m = d.textNode || d.nodeBefore;
              return h === m ? !0 : Zo(l, "linkHref", h.getAttribute("linkHref"), s).containsRange(s.createRange(l, d), !0);
            }(e.model) && (n = r.getAttributes()));
          }, { priority: "high" }), this.listenTo(e.model, "insertContent", (r, [s]) => {
            i = !1, Wf(e) && n && (e.model.change((a) => {
              for (const [l, d] of n)
                a.setAttribute(l, d, s);
            }), n = null);
          }, { priority: "high" });
        }
        _handleDeleteContentAfterLink() {
          const e = this.editor, t = e.model, n = t.document.selection, i = e.editing.view;
          let r = !1, s = !1;
          this.listenTo(i.document, "delete", (a, l) => {
            s = l.direction === "backward";
          }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
            r = !1;
            const a = n.getFirstPosition(), l = n.getAttribute("linkHref");
            if (!l)
              return;
            const d = Zo(a, "linkHref", l, t);
            r = d.containsPosition(a) || d.end.isEqual(a);
          }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
            s && (s = !1, r || e.model.enqueueChange((a) => {
              Ll(a, Vl(t.schema));
            }));
          }, { priority: "low" });
        }
        _enableClipboardIntegration() {
          const e = this.editor, t = e.model, n = this.editor.config.get("link.defaultProtocol");
          n && this.listenTo(e.plugins.get("ClipboardPipeline"), "contentInsertion", (i, r) => {
            t.change((s) => {
              const a = s.createRangeIn(r.content);
              for (const l of a.getItems())
                if (l.hasAttribute("linkHref")) {
                  const d = $l(l.getAttribute("linkHref"), n);
                  s.setAttribute("linkHref", d, l);
                }
            });
          });
        }
      }
      function Ll(o, e) {
        o.removeSelectionAttribute("linkHref");
        for (const t of e)
          o.removeSelectionAttribute(t);
      }
      function Wf(o) {
        return o.model.change((e) => e.batch).isTyping;
      }
      function Vl(o) {
        return o.getDefinition("$text").allowAttributes.filter((e) => e.startsWith("link"));
      }
      var Gf = k(7754), vx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Gf.Z, vx), Gf.Z.locals;
      class _x extends we {
        constructor(e, t) {
          super(e), this.focusTracker = new Gt(), this.keystrokes = new un(), this._focusables = new Zn();
          const n = e.t;
          this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n("Save"), qe.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n("Cancel"), qe.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(t), this.children = this._createFormChildren(t.manualDecorators), this._focusCycler = new Si({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } });
          const i = ["ck", "ck-link-form", "ck-responsive-form"];
          t.manualDecorators.length && i.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({ tag: "form", attributes: { class: i, tabindex: "-1" }, children: this.children });
        }
        getDecoratorSwitchesState() {
          return Array.from(this._manualDecoratorSwitches).reduce((e, t) => (e[t.name] = t.isOn, e), {});
        }
        render() {
          super.render(), p({ view: this }), [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach((e) => {
            this._focusables.add(e), this.focusTracker.add(e.element);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createUrlInput() {
          const e = this.locale.t, t = new Eu(this.locale, Zg);
          return t.label = e("Link URL"), t;
        }
        _createButton(e, t, n, i) {
          const r = new je(this.locale);
          return r.set({ label: e, icon: t, tooltip: !0 }), r.extendTemplate({ attributes: { class: n } }), i && r.delegate("execute").to(this, i), r;
        }
        _createManualDecoratorSwitches(e) {
          const t = this.createCollection();
          for (const n of e.manualDecorators) {
            const i = new Tr(this.locale);
            i.set({ name: n.id, label: n.label, withText: !0 }), i.bind("isOn").toMany([n, e], "value", (r, s) => s === void 0 && r === void 0 ? !!n.defaultValue : !!r), i.on("execute", () => {
              n.set("value", !i.isOn);
            }), t.add(i);
          }
          return t;
        }
        _createFormChildren(e) {
          const t = this.createCollection();
          if (t.add(this.urlInputView), e.length) {
            const n = new we();
            n.setTemplate({ tag: "ul", children: this._manualDecoratorSwitches.map((i) => ({ tag: "li", children: [i], attributes: { class: ["ck", "ck-list__item"] } })), attributes: { class: ["ck", "ck-reset", "ck-list"] } }), t.add(n);
          }
          return t.add(this.saveButtonView), t.add(this.cancelButtonView), t;
        }
      }
      var Kf = k(2347), Ax = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Kf.Z, Ax), Kf.Z.locals;
      class Cx extends we {
        constructor(e) {
          super(e), this.focusTracker = new Gt(), this.keystrokes = new un(), this._focusables = new Zn();
          const t = e.t;
          this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(t("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"), this.editButtonView = this._createButton(t("Edit link"), qe.pencil, "edit"), this.set("href", void 0), this._focusCycler = new Si({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1" }, children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView] });
        }
        render() {
          super.render(), [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach((e) => {
            this._focusables.add(e), this.focusTracker.add(e.element);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createButton(e, t, n) {
          const i = new je(this.locale);
          return i.set({ label: e, icon: t, tooltip: !0 }), i.delegate("execute").to(this, n), i;
        }
        _createPreviewButton() {
          const e = new je(this.locale), t = this.bindTemplate, n = this.t;
          return e.set({ withText: !0, tooltip: n("Open link in new tab") }), e.extendTemplate({ attributes: { class: ["ck", "ck-link-actions__preview"], href: t.to("href", (i) => i && Ff(i)), target: "_blank", rel: "noopener noreferrer" } }), e.bind("label").to(this, "href", (i) => i || n("This link has no URL")), e.bind("isEnabled").to(this, "href", (i) => !!i), e.template.tag = "a", e.template.eventListeners = {}, e;
        }
      }
      const an = "link-ui";
      class yx extends G {
        constructor() {
          super(...arguments), this.actionsView = null, this.formView = null;
        }
        static get requires() {
          return [os];
        }
        static get pluginName() {
          return "LinkUI";
        }
        init() {
          const e = this.editor;
          e.editing.view.addObserver(D1), this._balloon = e.plugins.get(os), this._createToolbarLinkButton(), this._enableBalloonActivators(), e.conversion.for("editingDowncast").markerToHighlight({ model: an, view: { classes: ["ck-fake-link-selection"] } }), e.conversion.for("editingDowncast").markerToElement({ model: an, view: { name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"] } });
        }
        destroy() {
          super.destroy(), this.formView && this.formView.destroy(), this.actionsView && this.actionsView.destroy();
        }
        _createViews() {
          this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._enableUserBalloonInteractions();
        }
        _createActionsView() {
          const e = this.editor, t = new Cx(e.locale), n = e.commands.get("link"), i = e.commands.get("unlink");
          return t.bind("href").to(n, "value"), t.editButtonView.bind("isEnabled").to(n), t.unlinkButtonView.bind("isEnabled").to(i), this.listenTo(t, "edit", () => {
            this._addFormView();
          }), this.listenTo(t, "unlink", () => {
            e.execute("unlink"), this._hideUI();
          }), t.keystrokes.set("Esc", (r, s) => {
            this._hideUI(), s();
          }), t.keystrokes.set(Nl, (r, s) => {
            this._addFormView(), s();
          }), t;
        }
        _createFormView() {
          const e = this.editor, t = e.commands.get("link"), n = e.config.get("link.defaultProtocol"), i = new (x(_x))(e.locale, t);
          return i.urlInputView.fieldView.bind("value").to(t, "value"), i.urlInputView.bind("isEnabled").to(t, "isEnabled"), i.saveButtonView.bind("isEnabled").to(t), this.listenTo(i, "submit", () => {
            const { value: r } = i.urlInputView.fieldView.element, s = $l(r, n);
            e.execute("link", s, i.getDecoratorSwitchesState()), this._closeFormView();
          }), this.listenTo(i, "cancel", () => {
            this._closeFormView();
          }), i.keystrokes.set("Esc", (r, s) => {
            this._closeFormView(), s();
          }), i;
        }
        _createToolbarLinkButton() {
          const e = this.editor, t = e.commands.get("link"), n = e.t;
          e.ui.componentFactory.add("link", (i) => {
            const r = new je(i);
            return r.isEnabled = !0, r.label = n("Link"), r.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', r.keystroke = Nl, r.tooltip = !0, r.isToggleable = !0, r.bind("isEnabled").to(t, "isEnabled"), r.bind("isOn").to(t, "value", (s) => !!s), this.listenTo(r, "execute", () => this._showUI(!0)), r;
          });
        }
        _enableBalloonActivators() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "click", () => {
            this._getSelectedLinkElement() && this._showUI();
          }), e.keystrokes.set(Nl, (n, i) => {
            i(), e.commands.get("link").isEnabled && this._showUI(!0);
          });
        }
        _enableUserBalloonInteractions() {
          this.editor.keystrokes.set("Tab", (e, t) => {
            this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), t());
          }, { priority: "high" }), this.editor.keystrokes.set("Esc", (e, t) => {
            this._isUIVisible && (this._hideUI(), t());
          }), v({ emitter: this.formView, activator: () => this._isUIInPanel, contextElements: () => [this._balloon.view.element], callback: () => this._hideUI() });
        }
        _addActionsView() {
          this.actionsView || this._createViews(), this._areActionsInPanel || this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() });
        }
        _addFormView() {
          if (this.formView || this._createViews(), this._isFormInPanel)
            return;
          const e = this.editor.commands.get("link");
          this.formView.disableCssTransitions(), this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions(), this.formView.urlInputView.fieldView.element.value = e.value || "";
        }
        _closeFormView() {
          const e = this.editor.commands.get("link");
          e.restoreManualDecoratorStates(), e.value !== void 0 ? this._removeFormView() : this._hideUI();
        }
        _removeFormView() {
          this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection());
        }
        _showUI(e = !1) {
          this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), e && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), e && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
        }
        _hideUI() {
          if (!this._isUIInPanel)
            return;
          const e = this.editor;
          this.stopListening(e.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), e.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection();
        }
        _startUpdatingUI() {
          const e = this.editor, t = e.editing.view.document;
          let n = this._getSelectedLinkElement(), i = s();
          const r = () => {
            const a = this._getSelectedLinkElement(), l = s();
            n && !a || !n && l !== i ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n = a, i = l;
          };
          function s() {
            return t.selection.focus.getAncestors().reverse().find((a) => a.is("element"));
          }
          this.listenTo(e.ui, "update", r), this.listenTo(this._balloon, "change:visibleView", r);
        }
        get _isFormInPanel() {
          return !!this.formView && this._balloon.hasView(this.formView);
        }
        get _areActionsInPanel() {
          return !!this.actionsView && this._balloon.hasView(this.actionsView);
        }
        get _areActionsVisible() {
          return !!this.actionsView && this._balloon.visibleView === this.actionsView;
        }
        get _isUIInPanel() {
          return this._isFormInPanel || this._areActionsInPanel;
        }
        get _isUIVisible() {
          const e = this._balloon.visibleView;
          return !!this.formView && e == this.formView || this._areActionsVisible;
        }
        _getBalloonPositionData() {
          const e = this.editor.editing.view, t = this.editor.model, n = e.document;
          let i;
          if (t.markers.has(an)) {
            const r = Array.from(this.editor.editing.mapper.markerNameToElements(an)), s = e.createRange(e.createPositionBefore(r[0]), e.createPositionAfter(r[r.length - 1]));
            i = e.domConverter.viewRangeToDom(s);
          } else
            i = () => {
              const r = this._getSelectedLinkElement();
              return r ? e.domConverter.mapViewToDom(r) : e.domConverter.viewRangeToDom(n.selection.getFirstRange());
            };
          return { target: i };
        }
        _getSelectedLinkElement() {
          const e = this.editor.editing.view, t = e.document.selection, n = t.getSelectedElement();
          if (t.isCollapsed || n && Je(n))
            return jl(t.getFirstPosition());
          {
            const i = t.getFirstRange().getTrimmed(), r = jl(i.start), s = jl(i.end);
            return r && r == s && e.createRangeIn(r).getTrimmed().isEqual(i) ? r : null;
          }
        }
        _showFakeVisualSelection() {
          const e = this.editor.model;
          e.change((t) => {
            const n = e.document.selection.getFirstRange();
            if (e.markers.has(an))
              t.updateMarker(an, { range: n });
            else if (n.start.isAtEnd) {
              const i = n.start.getLastMatchingPosition(({ item: r }) => !e.schema.isContent(r), { boundaries: n });
              t.addMarker(an, { usingOperation: !1, affectsData: !1, range: t.createRange(i, n.end) });
            } else
              t.addMarker(an, { usingOperation: !1, affectsData: !1, range: n });
          });
        }
        _hideFakeVisualSelection() {
          const e = this.editor.model;
          e.markers.has(an) && e.change((t) => {
            t.removeMarker(an);
          });
        }
      }
      function jl(o) {
        return o.getAncestors().find((e) => {
          return (t = e).is("attributeElement") && !!t.getCustomProperty("link");
          var t;
        }) || null;
      }
      const Ex = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i");
      class xx extends G {
        static get requires() {
          return [Go];
        }
        static get pluginName() {
          return "AutoLink";
        }
        init() {
          const e = this.editor.model.document.selection;
          e.on("change:range", () => {
            this.isEnabled = !e.anchor.parent.is("element", "codeBlock");
          }), this._enableTypingHandling();
        }
        afterInit() {
          this._enableEnterHandling(), this._enableShiftEnterHandling();
        }
        _enableTypingHandling() {
          const e = this.editor, t = new Vm(e.model, (n) => {
            if (!function(r) {
              return r.length > 4 && r[r.length - 1] === " " && r[r.length - 2] !== " ";
            }(n))
              return;
            const i = Zf(n.substr(0, n.length - 1));
            return i ? { url: i } : void 0;
          });
          t.on("matched:data", (n, i) => {
            const { batch: r, range: s, url: a } = i;
            if (!r.isTyping)
              return;
            const l = s.end.getShiftedBy(-1), d = l.getShiftedBy(-a.length), h = e.model.createRange(d, l);
            this._applyAutoLink(a, h);
          }), t.bind("isEnabled").to(this);
        }
        _enableEnterHandling() {
          const e = this.editor, t = e.model, n = e.commands.get("enter");
          n && n.on("execute", () => {
            const i = t.document.selection.getFirstPosition();
            if (!i.parent.previousSibling)
              return;
            const r = t.createRangeIn(i.parent.previousSibling);
            this._checkAndApplyAutoLinkOnRange(r);
          });
        }
        _enableShiftEnterHandling() {
          const e = this.editor, t = e.model, n = e.commands.get("shiftEnter");
          n && n.on("execute", () => {
            const i = t.document.selection.getFirstPosition(), r = t.createRange(t.createPositionAt(i.parent, 0), i.getShiftedBy(-1));
            this._checkAndApplyAutoLinkOnRange(r);
          });
        }
        _checkAndApplyAutoLinkOnRange(e) {
          const t = this.editor.model, { text: n, range: i } = Lm(e, t), r = Zf(n);
          if (r) {
            const s = t.createRange(i.end.getShiftedBy(-r.length), i.end);
            this._applyAutoLink(r, s);
          }
        }
        _applyAutoLink(e, t) {
          const n = this.editor.model, i = $l(e, this.editor.config.get("link.defaultProtocol"));
          this.isEnabled && function(r, s) {
            return s.schema.checkAttributeInSelection(s.createSelection(r), "linkHref");
          }(t, n) && $f(i) && !function(r) {
            const s = r.start.nodeAfter;
            return !!s && s.hasAttribute("linkHref");
          }(t) && this._persistAutoLink(i, t);
        }
        _persistAutoLink(e, t) {
          const n = this.editor.model, i = this.editor.plugins.get("Delete");
          n.enqueueChange((r) => {
            r.setAttribute("linkHref", e, t), n.enqueueChange(() => {
              i.requestUndoOnBackspace();
            });
          });
        }
      }
      function Zf(o) {
        const e = Ex.exec(o);
        return e ? e[2] : null;
      }
      var Jf = k(111), Sx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Jf.Z, Sx), Jf.Z.locals;
      var Yf = k(5730), Dx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Yf.Z, Dx), Yf.Z.locals;
      var Qf = k(4564), Bx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Qf.Z, Bx), Qf.Z.locals;
      function Tx(o, e) {
        const t = e.mapper, n = e.writer, i = o.getAttribute("listType") == "numbered" ? "ol" : "ul", r = function(a) {
          const l = a.createContainerElement("li");
          return l.getFillerOffset = Ox, l;
        }(n), s = n.createContainerElement(i, null);
        return n.insert(n.createPositionAt(s, 0), r), t.bindElements(o, r), r;
      }
      function Xf(o, e, t, n) {
        const i = e.parent, r = t.mapper, s = t.writer;
        let a = r.toViewPosition(n.createPositionBefore(o));
        const l = tb(o.previousSibling, { sameIndent: !0, smallerIndent: !0, listIndent: o.getAttribute("listIndent") }), d = o.previousSibling;
        if (l && l.getAttribute("listIndent") == o.getAttribute("listIndent")) {
          const h = r.toViewElement(l);
          a = s.breakContainer(s.createPositionAfter(h));
        } else if (d && d.name == "listItem") {
          a = r.toViewPosition(n.createPositionAt(d, "end"));
          const h = r.findMappedViewAncestor(a), m = function(f) {
            for (const _ of f.getChildren())
              if (_.name == "ul" || _.name == "ol")
                return _;
            return null;
          }(h);
          a = m ? s.createPositionBefore(m) : s.createPositionAt(h, "end");
        } else
          a = r.toViewPosition(n.createPositionBefore(o));
        if (a = eb(a), s.insert(a, i), d && d.name == "listItem") {
          const h = r.toViewElement(d), m = s.createRange(s.createPositionAt(h, 0), a).getWalker({ ignoreElementEnd: !0 });
          for (const f of m)
            if (f.item.is("element", "li")) {
              const _ = s.breakContainer(s.createPositionBefore(f.item)), E = f.item.parent, B = s.createPositionAt(e, "end");
              Ht(s, B.nodeBefore, B.nodeAfter), s.move(s.createRangeOn(E), B), m._position = _;
            }
        } else {
          const h = i.nextSibling;
          if (h && (h.is("element", "ul") || h.is("element", "ol"))) {
            let m = null;
            for (const f of h.getChildren()) {
              const _ = r.toModelElement(f);
              if (!(_ && _.getAttribute("listIndent") > o.getAttribute("listIndent")))
                break;
              m = f;
            }
            m && (s.breakContainer(s.createPositionAfter(m)), s.move(s.createRangeOn(m.parent), s.createPositionAt(e, "end")));
          }
        }
        Ht(s, i, i.nextSibling), Ht(s, i.previousSibling, i);
      }
      function Ht(o, e, t) {
        return !e || !t || e.name != "ul" && e.name != "ol" || e.name != t.name || e.getAttribute("class") !== t.getAttribute("class") ? null : o.mergeContainers(o.createPositionAfter(e));
      }
      function eb(o) {
        return o.getLastMatchingPosition((e) => e.item.is("uiElement"));
      }
      function tb(o, e) {
        const t = !!e.sameIndent, n = !!e.smallerIndent, i = e.listIndent;
        let r = o;
        for (; r && r.name == "listItem"; ) {
          const s = r.getAttribute("listIndent");
          if (t && i == s || n && i > s)
            return r;
          r = e.direction === "forward" ? r.nextSibling : r.previousSibling;
        }
        return null;
      }
      function nb(o, e, t, n) {
        o.ui.componentFactory.add(e, (i) => {
          const r = o.commands.get(e), s = new je(i);
          return s.set({ label: t, icon: n, tooltip: !0, isToggleable: !0 }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), s.on("execute", () => {
            o.execute(e), o.editing.view.focus();
          }), s;
        });
      }
      function Hl(o, e) {
        const t = [], n = o.parent, i = { ignoreElementEnd: !1, startPosition: o, shallow: !0, direction: e }, r = n.getAttribute("listIndent"), s = [...new rn(i)].filter((a) => a.item.is("element")).map((a) => a.item);
        for (const a of s) {
          if (!a.is("element", "listItem") || a.getAttribute("listIndent") < r)
            break;
          if (!(a.getAttribute("listIndent") > r)) {
            if (a.getAttribute("listType") !== n.getAttribute("listType") || a.getAttribute("listStyle") !== n.getAttribute("listStyle") || a.getAttribute("listReversed") !== n.getAttribute("listReversed") || a.getAttribute("listStart") !== n.getAttribute("listStart"))
              break;
            e === "backward" ? t.unshift(a) : t.push(a);
          }
        }
        return t;
      }
      const Px = ["disc", "circle", "square"], Ix = ["decimal", "decimal-leading-zero", "lower-roman", "upper-roman", "lower-latin", "upper-latin"];
      function Ox() {
        const o = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
        return this.isEmpty || o ? 0 : Yu.call(this);
      }
      class Rx extends G {
        static get pluginName() {
          return "ListUI";
        }
        init() {
          const e = this.editor.t;
          nb(this.editor, "numberedList", e("Numbered List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'), nb(this.editor, "bulletedList", e("Bulleted List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>');
        }
      }
      const zx = [{ listStyle: "disc", typeAttribute: "disc", listType: "bulleted" }, { listStyle: "circle", typeAttribute: "circle", listType: "bulleted" }, { listStyle: "square", typeAttribute: "square", listType: "bulleted" }, { listStyle: "decimal", typeAttribute: "1", listType: "numbered" }, { listStyle: "decimal-leading-zero", typeAttribute: null, listType: "numbered" }, { listStyle: "lower-roman", typeAttribute: "i", listType: "numbered" }, { listStyle: "upper-roman", typeAttribute: "I", listType: "numbered" }, { listStyle: "lower-alpha", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-alpha", typeAttribute: "A", listType: "numbered" }, { listStyle: "lower-latin", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-latin", typeAttribute: "A", listType: "numbered" }];
      for (const { listStyle: o, typeAttribute: e, listType: t } of zx)
        ;
      var ob = k(4721), Mx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(ob.Z, Mx), ob.Z.locals;
      var ib = k(6082), Nx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(ib.Z, Nx), ib.Z.locals;
      var rb = k(2417), Fx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(rb.Z, Fx), rb.Z.locals;
      class sb extends pe {
        constructor(e, t) {
          super(e), this._indentBy = t == "forward" ? 1 : -1;
        }
        refresh() {
          this.isEnabled = this._checkEnabled();
        }
        execute() {
          const e = this.editor.model, t = e.document;
          let n = Array.from(t.selection.getSelectedBlocks());
          e.change((i) => {
            const r = n[n.length - 1];
            let s = r.nextSibling;
            for (; s && s.name == "listItem" && s.getAttribute("listIndent") > r.getAttribute("listIndent"); )
              n.push(s), s = s.nextSibling;
            this._indentBy < 0 && (n = n.reverse());
            for (const a of n) {
              const l = a.getAttribute("listIndent") + this._indentBy;
              l < 0 ? i.rename(a, "paragraph") : i.setAttribute("listIndent", l, a);
            }
            this.fire("_executeCleanup", n);
          });
        }
        _checkEnabled() {
          const e = it(this.editor.model.document.selection.getSelectedBlocks());
          if (!e || !e.is("element", "listItem"))
            return !1;
          if (this._indentBy > 0) {
            const t = e.getAttribute("listIndent"), n = e.getAttribute("listType");
            let i = e.previousSibling;
            for (; i && i.is("element", "listItem") && i.getAttribute("listIndent") >= t; ) {
              if (i.getAttribute("listIndent") == t)
                return i.getAttribute("listType") == n;
              i = i.previousSibling;
            }
            return !1;
          }
          return !0;
        }
      }
      class ab extends pe {
        constructor(e, t) {
          super(e), this.type = t;
        }
        refresh() {
          this.value = this._getValue(), this.isEnabled = this._checkEnabled();
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document, i = Array.from(n.selection.getSelectedBlocks()).filter((s) => cb(s, t.schema)), r = e.forceValue !== void 0 ? !e.forceValue : this.value;
          t.change((s) => {
            if (r) {
              let a = i[i.length - 1].nextSibling, l = Number.POSITIVE_INFINITY, d = [];
              for (; a && a.name == "listItem" && a.getAttribute("listIndent") !== 0; ) {
                const h = a.getAttribute("listIndent");
                h < l && (l = h);
                const m = h - l;
                d.push({ element: a, listIndent: m }), a = a.nextSibling;
              }
              d = d.reverse();
              for (const h of d)
                s.setAttribute("listIndent", h.listIndent, h.element);
            }
            if (!r) {
              let a = Number.POSITIVE_INFINITY;
              for (const l of i)
                l.is("element", "listItem") && l.getAttribute("listIndent") < a && (a = l.getAttribute("listIndent"));
              a = a === 0 ? 1 : a, lb(i, !0, a), lb(i, !1, a);
            }
            for (const a of i.reverse())
              r && a.name == "listItem" ? s.rename(a, "paragraph") : r || a.name == "listItem" ? r || a.name != "listItem" || a.getAttribute("listType") == this.type || s.setAttribute("listType", this.type, a) : (s.setAttributes({ listType: this.type, listIndent: 0 }, a), s.rename(a, "listItem"));
            this.fire("_executeCleanup", i);
          });
        }
        _getValue() {
          const e = it(this.editor.model.document.selection.getSelectedBlocks());
          return !!e && e.is("element", "listItem") && e.getAttribute("listType") == this.type;
        }
        _checkEnabled() {
          if (this.value)
            return !0;
          const e = this.editor.model.document.selection, t = this.editor.model.schema, n = it(e.getSelectedBlocks());
          return !!n && cb(n, t);
        }
      }
      function lb(o, e, t) {
        const n = e ? o[0] : o[o.length - 1];
        if (n.is("element", "listItem")) {
          let i = n[e ? "previousSibling" : "nextSibling"], r = n.getAttribute("listIndent");
          for (; i && i.is("element", "listItem") && i.getAttribute("listIndent") >= t; )
            r > i.getAttribute("listIndent") && (r = i.getAttribute("listIndent")), i.getAttribute("listIndent") == r && o[e ? "unshift" : "push"](i), i = i[e ? "previousSibling" : "nextSibling"];
        }
      }
      function cb(o, e) {
        return e.checkChild(o.parent, "listItem") && !e.isObject(o);
      }
      class $x extends G {
        static get pluginName() {
          return "ListUtils";
        }
        getListTypeFromListStyleType(e) {
          return function(t) {
            return Px.includes(t) ? "bulleted" : Ix.includes(t) ? "numbered" : null;
          }(e);
        }
        getSelectedListItems(e) {
          return function(t) {
            let n = [...t.document.selection.getSelectedBlocks()].filter((i) => i.is("element", "listItem")).map((i) => {
              const r = t.change((s) => s.createPositionAt(i, 0));
              return [...Hl(r, "backward"), ...Hl(r, "forward")];
            }).flat();
            return n = [...new Set(n)], n;
          }(e);
        }
        getSiblingNodes(e, t) {
          return Hl(e, t);
        }
      }
      function db(o) {
        return (e, t, n) => {
          const i = n.consumable;
          if (!i.test(t.item, "insert") || !i.test(t.item, "attribute:listType") || !i.test(t.item, "attribute:listIndent"))
            return;
          i.consume(t.item, "insert"), i.consume(t.item, "attribute:listType"), i.consume(t.item, "attribute:listIndent");
          const r = t.item;
          Xf(r, Tx(r, n), n, o);
        };
      }
      const Lx = (o, e, t) => {
        if (!t.consumable.test(e.item, o.name))
          return;
        const n = t.mapper.toViewElement(e.item), i = t.writer;
        i.breakContainer(i.createPositionBefore(n)), i.breakContainer(i.createPositionAfter(n));
        const r = n.parent, s = e.attributeNewValue == "numbered" ? "ol" : "ul";
        i.rename(s, r);
      }, Vx = (o, e, t) => {
        t.consumable.consume(e.item, o.name);
        const n = t.mapper.toViewElement(e.item).parent, i = t.writer;
        Ht(i, n, n.nextSibling), Ht(i, n.previousSibling, n);
      }, ub = (o, e, t) => {
        if (t.consumable.test(e.item, o.name) && e.item.name != "listItem") {
          let n = t.mapper.toViewPosition(e.range.start);
          const i = t.writer, r = [];
          for (; (n.parent.name == "ul" || n.parent.name == "ol") && (n = i.breakContainer(n), n.parent.name == "li"); ) {
            const s = n, a = i.createPositionAt(n.parent, "end");
            if (!s.isEqual(a)) {
              const l = i.remove(i.createRange(s, a));
              r.push(l);
            }
            n = i.createPositionAfter(n.parent);
          }
          if (r.length > 0) {
            for (let s = 0; s < r.length; s++) {
              const a = n.nodeBefore;
              if (n = i.insert(n, r[s]).end, s > 0) {
                const l = Ht(i, a, a.nextSibling);
                l && l.parent == a && n.offset--;
              }
            }
            Ht(i, n.nodeBefore, n.nodeAfter);
          }
        }
      }, jx = (o, e, t) => {
        const n = t.mapper.toViewPosition(e.position), i = n.nodeBefore, r = n.nodeAfter;
        Ht(t.writer, i, r);
      }, Hx = (o, e, t) => {
        if (t.consumable.consume(e.viewItem, { name: !0 })) {
          const n = t.writer, i = n.createElement("listItem"), r = function(l) {
            let d = 0, h = l.parent;
            for (; h; ) {
              if (h.is("element", "li"))
                d++;
              else {
                const m = h.previousSibling;
                m && m.is("element", "li") && d++;
              }
              h = h.parent;
            }
            return d;
          }(e.viewItem);
          n.setAttribute("listIndent", r, i);
          const s = e.viewItem.parent && e.viewItem.parent.name == "ol" ? "numbered" : "bulleted";
          if (n.setAttribute("listType", s, i), !t.safeInsert(i, e.modelCursor))
            return;
          const a = function(l, d, h) {
            const { writer: m, schema: f } = h;
            let _ = m.createPositionAfter(l);
            for (const E of d)
              if (E.name == "ul" || E.name == "ol")
                _ = h.convertItem(E, _).modelCursor;
              else {
                const B = h.convertItem(E, m.createPositionAt(l, "end")), T = B.modelRange.start.nodeAfter;
                T && T.is("element") && !f.checkChild(l, T.name) && (l = B.modelCursor.parent.is("element", "listItem") ? B.modelCursor.parent : Wx(B.modelCursor), _ = m.createPositionAfter(l));
              }
            return _;
          }(i, e.viewItem.getChildren(), t);
          e.modelRange = n.createRange(e.modelCursor, a), t.updateConversionResult(i, e);
        }
      }, hb = (o, e, t) => {
        if (t.consumable.test(e.viewItem, { name: !0 })) {
          const n = Array.from(e.viewItem.getChildren());
          for (const i of n)
            !(i.is("element", "li") || Qo(i)) && i._remove();
        }
      }, Ux = (o, e, t) => {
        if (t.consumable.test(e.viewItem, { name: !0 })) {
          if (e.viewItem.childCount === 0)
            return;
          const n = [...e.viewItem.getChildren()];
          let i = !1;
          for (const r of n)
            i && !Qo(r) && r._remove(), Qo(r) && (i = !0);
        }
      };
      function gb(o) {
        return (e, t) => {
          if (t.isPhantom)
            return;
          const n = t.modelPosition.nodeBefore;
          if (n && n.is("element", "listItem")) {
            const i = t.mapper.toViewElement(n), r = i.getAncestors().find(Qo), s = o.createPositionAt(i, 0).getWalker();
            for (const a of s) {
              if (a.type == "elementStart" && a.item.is("element", "li")) {
                t.viewPosition = a.previousPosition;
                break;
              }
              if (a.type == "elementEnd" && a.item == r) {
                t.viewPosition = a.nextPosition;
                break;
              }
            }
          }
        };
      }
      const qx = function(o, [e, t]) {
        const n = this;
        let i, r = e.is("documentFragment") ? e.getChild(0) : e;
        if (i = t ? n.createSelection(t) : n.document.selection, r && r.is("element", "listItem")) {
          const s = i.getFirstPosition();
          let a = null;
          if (s.parent.is("element", "listItem") ? a = s.parent : s.nodeBefore && s.nodeBefore.is("element", "listItem") && (a = s.nodeBefore), a) {
            const l = a.getAttribute("listIndent");
            if (l > 0)
              for (; r && r.is("element", "listItem"); )
                r._setAttribute("listIndent", r.getAttribute("listIndent") + l), r = r.nextSibling;
          }
        }
      };
      function Wx(o) {
        const e = new rn({ startPosition: o });
        let t;
        do
          t = e.next();
        while (!t.value.item.is("element", "listItem"));
        return t.value.item;
      }
      function mb(o, e, t, n, i, r) {
        const s = tb(e.nodeBefore, { sameIndent: !0, smallerIndent: !0, listIndent: o }), a = i.mapper, l = i.writer, d = s ? s.getAttribute("listIndent") : null;
        let h;
        if (s)
          if (d == o) {
            const m = a.toViewElement(s).parent;
            h = l.createPositionAfter(m);
          } else {
            const m = r.createPositionAt(s, "end");
            h = a.toViewPosition(m);
          }
        else
          h = t;
        h = eb(h);
        for (const m of [...n.getChildren()])
          Qo(m) && (h = l.move(l.createRangeOn(m), h).end, Ht(l, m, m.nextSibling), Ht(l, m.previousSibling, m));
      }
      function Qo(o) {
        return o.is("element", "ol") || o.is("element", "ul");
      }
      class Gx extends G {
        static get pluginName() {
          return "ListEditing";
        }
        static get requires() {
          return [qi, Go, $x];
        }
        init() {
          const e = this.editor;
          e.model.schema.register("listItem", { inheritAllFrom: "$block", allowAttributes: ["listType", "listIndent"] });
          const t = e.data, n = e.editing;
          var i;
          e.model.document.registerPostFixer((s) => function(a, l) {
            const d = a.document.differ.getChanges(), h = /* @__PURE__ */ new Map();
            let m = !1;
            for (const B of d)
              if (B.type == "insert" && B.name == "listItem")
                f(B.position);
              else if (B.type == "insert" && B.name != "listItem") {
                if (B.name != "$text") {
                  const T = B.position.nodeAfter;
                  T.hasAttribute("listIndent") && (l.removeAttribute("listIndent", T), m = !0), T.hasAttribute("listType") && (l.removeAttribute("listType", T), m = !0), T.hasAttribute("listStyle") && (l.removeAttribute("listStyle", T), m = !0), T.hasAttribute("listReversed") && (l.removeAttribute("listReversed", T), m = !0), T.hasAttribute("listStart") && (l.removeAttribute("listStart", T), m = !0);
                  for (const O of Array.from(a.createRangeIn(T)).filter((N) => N.item.is("element", "listItem")))
                    f(O.previousPosition);
                }
                f(B.position.getShiftedBy(B.length));
              } else
                B.type == "remove" && B.name == "listItem" ? f(B.position) : (B.type == "attribute" && B.attributeKey == "listIndent" || B.type == "attribute" && B.attributeKey == "listType") && f(B.range.start);
            for (const B of h.values())
              _(B), E(B);
            return m;
            function f(B) {
              const T = B.nodeBefore;
              if (T && T.is("element", "listItem")) {
                let O = T;
                if (h.has(O))
                  return;
                for (let N = O.previousSibling; N && N.is("element", "listItem"); N = O.previousSibling)
                  if (O = N, h.has(O))
                    return;
                h.set(T, O);
              } else {
                const O = B.nodeAfter;
                O && O.is("element", "listItem") && h.set(O, O);
              }
            }
            function _(B) {
              let T = 0, O = null;
              for (; B && B.is("element", "listItem"); ) {
                const N = B.getAttribute("listIndent");
                if (N > T) {
                  let H;
                  O === null ? (O = N - T, H = T) : (O > N && (O = N), H = N - O), l.setAttribute("listIndent", H, B), m = !0;
                } else
                  O = null, T = B.getAttribute("listIndent") + 1;
                B = B.nextSibling;
              }
            }
            function E(B) {
              let T = [], O = null;
              for (; B && B.is("element", "listItem"); ) {
                const N = B.getAttribute("listIndent");
                if (O && O.getAttribute("listIndent") > N && (T = T.slice(0, N + 1)), N != 0)
                  if (T[N]) {
                    const H = T[N];
                    B.getAttribute("listType") != H && (l.setAttribute("listType", H, B), m = !0);
                  } else
                    T[N] = B.getAttribute("listType");
                O = B, B = B.nextSibling;
              }
            }
          }(e.model, s)), n.mapper.registerViewToModelLength("li", Ul), t.mapper.registerViewToModelLength("li", Ul), n.mapper.on("modelToViewPosition", gb(n.view)), n.mapper.on("viewToModelPosition", (i = e.model, (s, a) => {
            const l = a.viewPosition, d = l.parent, h = a.mapper;
            if (d.name == "ul" || d.name == "ol") {
              if (l.isAtEnd) {
                const m = h.toModelElement(l.nodeBefore), f = h.getModelLength(l.nodeBefore);
                a.modelPosition = i.createPositionBefore(m).getShiftedBy(f);
              } else {
                const m = h.toModelElement(l.nodeAfter);
                a.modelPosition = i.createPositionBefore(m);
              }
              s.stop();
            } else if (d.name == "li" && l.nodeBefore && (l.nodeBefore.name == "ul" || l.nodeBefore.name == "ol")) {
              const m = h.toModelElement(d);
              let f = 1, _ = l.nodeBefore;
              for (; _ && Qo(_); )
                f += h.getModelLength(_), _ = _.previousSibling;
              a.modelPosition = i.createPositionBefore(m).getShiftedBy(f), s.stop();
            }
          })), t.mapper.on("modelToViewPosition", gb(n.view)), e.conversion.for("editingDowncast").add((s) => {
            s.on("insert", ub, { priority: "high" }), s.on("insert:listItem", db(e.model)), s.on("attribute:listType:listItem", Lx, { priority: "high" }), s.on("attribute:listType:listItem", Vx, { priority: "low" }), s.on("attribute:listIndent:listItem", /* @__PURE__ */ function(a) {
              return (l, d, h) => {
                if (!h.consumable.consume(d.item, "attribute:listIndent"))
                  return;
                const m = h.mapper.toViewElement(d.item), f = h.writer;
                f.breakContainer(f.createPositionBefore(m)), f.breakContainer(f.createPositionAfter(m));
                const _ = m.parent, E = _.previousSibling, B = f.createRangeOn(_);
                f.remove(B), E && E.nextSibling && Ht(f, E, E.nextSibling), mb(d.attributeOldValue + 1, d.range.start, B.start, m, h, a), Xf(d.item, m, h, a);
                for (const T of d.item.getChildren())
                  h.consumable.consume(T, "insert");
              };
            }(e.model)), s.on("remove:listItem", /* @__PURE__ */ function(a) {
              return (l, d, h) => {
                const m = h.mapper.toViewPosition(d.position).getLastMatchingPosition((O) => !O.item.is("element", "li")).nodeAfter, f = h.writer;
                f.breakContainer(f.createPositionBefore(m)), f.breakContainer(f.createPositionAfter(m));
                const _ = m.parent, E = _.previousSibling, B = f.createRangeOn(_), T = f.remove(B);
                E && E.nextSibling && Ht(f, E, E.nextSibling), mb(h.mapper.toModelElement(m).getAttribute("listIndent") + 1, d.position, B.start, m, h, a);
                for (const O of f.createRangeIn(T).getItems())
                  h.mapper.unbindViewElement(O);
                l.stop();
              };
            }(e.model)), s.on("remove", jx, { priority: "low" });
          }), e.conversion.for("dataDowncast").add((s) => {
            s.on("insert", ub, { priority: "high" }), s.on("insert:listItem", db(e.model));
          }), e.conversion.for("upcast").add((s) => {
            s.on("element:ul", hb, { priority: "high" }), s.on("element:ol", hb, { priority: "high" }), s.on("element:li", Ux, { priority: "high" }), s.on("element:li", Hx);
          }), e.model.on("insertContent", qx, { priority: "high" }), e.commands.add("numberedList", new ab(e, "numbered")), e.commands.add("bulletedList", new ab(e, "bulleted")), e.commands.add("indentList", new sb(e, "forward")), e.commands.add("outdentList", new sb(e, "backward"));
          const r = n.view.document;
          this.listenTo(r, "enter", (s, a) => {
            const l = this.editor.model.document, d = l.selection.getLastPosition().parent;
            l.selection.isCollapsed && d.name == "listItem" && d.isEmpty && (this.editor.execute("outdentList"), a.preventDefault(), s.stop());
          }, { context: "li" }), this.listenTo(r, "delete", (s, a) => {
            if (a.direction !== "backward")
              return;
            const l = this.editor.model.document.selection;
            if (!l.isCollapsed)
              return;
            const d = l.getFirstPosition();
            if (!d.isAtStart)
              return;
            const h = d.parent;
            h.name === "listItem" && (h.previousSibling && h.previousSibling.name === "listItem" || (this.editor.execute("outdentList"), a.preventDefault(), s.stop()));
          }, { context: "li" }), this.listenTo(e.editing.view.document, "tab", (s, a) => {
            const l = a.shiftKey ? "outdentList" : "indentList";
            this.editor.commands.get(l).isEnabled && (e.execute(l), a.stopPropagation(), a.preventDefault(), s.stop());
          }, { context: "li" });
        }
        afterInit() {
          const e = this.editor.commands, t = e.get("indent"), n = e.get("outdent");
          t && t.registerChildCommand(e.get("indentList")), n && n.registerChildCommand(e.get("outdentList"));
        }
      }
      function Ul(o) {
        let e = 1;
        for (const t of o.getChildren())
          if (t.name == "ul" || t.name == "ol")
            for (const n of t.getChildren())
              e += Ul(n);
        return e;
      }
      Sr("Ctrl+Enter");
      var pb = k(1199), Kx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(pb.Z, Kx), pb.Z.locals;
      function tt(o, e, t, n, i = 1) {
        e != null && i != null && e > i ? n.setAttribute(o, e, t) : n.removeAttribute(o, t);
      }
      function ao(o, e, t = {}) {
        const n = o.createElement("tableCell", t);
        return o.insertElement("paragraph", n), o.insert(n, e), n;
      }
      function ql(o, e) {
        const t = e.parent.parent, n = parseInt(t.getAttribute("headingColumns") || "0"), { column: i } = o.getCellLocation(e);
        return !!n && i < n;
      }
      function Zx() {
        return (o) => {
          o.on("element:table", (e, t, n) => {
            const i = t.viewItem;
            if (!n.consumable.test(i, { name: !0 }))
              return;
            const { rows: r, headingRows: s, headingColumns: a } = function(h) {
              let m, f = 0;
              const _ = [], E = [];
              let B;
              for (const T of Array.from(h.getChildren())) {
                if (T.name !== "tbody" && T.name !== "thead" && T.name !== "tfoot")
                  continue;
                T.name !== "thead" || B || (B = T);
                const O = Array.from(T.getChildren()).filter((N) => N.is("element", "tr"));
                for (const N of O)
                  if (B && T === B || T.name === "tbody" && Array.from(N.getChildren()).length && Array.from(N.getChildren()).every((H) => H.is("element", "th")))
                    f++, _.push(N);
                  else {
                    E.push(N);
                    const H = Jx(N);
                    (!m || H < m) && (m = H);
                  }
              }
              return { headingRows: f, headingColumns: m || 0, rows: [..._, ...E] };
            }(i), l = {};
            a && (l.headingColumns = a), s && (l.headingRows = s);
            const d = n.writer.createElement("table", l);
            if (n.safeInsert(d, t.modelCursor)) {
              if (n.consumable.consume(i, { name: !0 }), r.forEach((h) => n.convertItem(h, n.writer.createPositionAt(d, "end"))), n.convertChildren(i, n.writer.createPositionAt(d, "end")), d.isEmpty) {
                const h = n.writer.createElement("tableRow");
                n.writer.insert(h, n.writer.createPositionAt(d, "end")), ao(n.writer, n.writer.createPositionAt(h, "end"));
              }
              n.updateConversionResult(d, t);
            }
          });
        };
      }
      function fb(o) {
        return (e) => {
          e.on(`element:${o}`, (t, n, { writer: i }) => {
            if (!n.modelRange)
              return;
            const r = n.modelRange.start.nodeAfter, s = i.createPositionAt(r, 0);
            if (n.viewItem.isEmpty)
              return void i.insertElement("paragraph", s);
            const a = Array.from(r.getChildren());
            if (a.every((l) => l.is("element", "$marker"))) {
              const l = i.createElement("paragraph");
              i.insert(l, i.createPositionAt(r, 0));
              for (const d of a)
                i.move(i.createRangeOn(d), i.createPositionAt(l, "end"));
            }
          }, { priority: "low" });
        };
      }
      function Jx(o) {
        let e = 0, t = 0;
        const n = Array.from(o.getChildren()).filter((i) => i.name === "th" || i.name === "td");
        for (; t < n.length && n[t].name === "th"; ) {
          const i = n[t];
          e += parseInt(i.getAttribute("colspan") || "1"), t++;
        }
        return e;
      }
      class Re {
        constructor(e, t = {}) {
          this._table = e, this._startRow = t.row !== void 0 ? t.row : t.startRow || 0, this._endRow = t.row !== void 0 ? t.row : t.endRow, this._startColumn = t.column !== void 0 ? t.column : t.startColumn || 0, this._endColumn = t.column !== void 0 ? t.column : t.endColumn, this._includeAllSlots = !!t.includeAllSlots, this._skipRows = /* @__PURE__ */ new Set(), this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = /* @__PURE__ */ new Map(), this._nextCellAtColumn = -1;
        }
        [Symbol.iterator]() {
          return this;
        }
        next() {
          const e = this._table.getChild(this._rowIndex);
          if (!e || this._isOverEndRow())
            return { done: !0, value: void 0 };
          if (!e.is("element", "tableRow"))
            return this._rowIndex++, this.next();
          if (this._isOverEndColumn())
            return this._advanceToNextRow();
          let t = null;
          const n = this._getSpanned();
          if (n)
            this._includeAllSlots && !this._shouldSkipSlot() && (t = this._formatOutValue(n.cell, n.row, n.column));
          else {
            const i = e.getChild(this._cellIndex);
            if (!i)
              return this._advanceToNextRow();
            const r = parseInt(i.getAttribute("colspan") || "1"), s = parseInt(i.getAttribute("rowspan") || "1");
            (r > 1 || s > 1) && this._recordSpans(i, s, r), this._shouldSkipSlot() || (t = this._formatOutValue(i)), this._nextCellAtColumn = this._column + r;
          }
          return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, t || this.next();
        }
        skipRow(e) {
          this._skipRows.add(e);
        }
        _advanceToNextRow() {
          return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next();
        }
        _isOverEndRow() {
          return this._endRow !== void 0 && this._row > this._endRow;
        }
        _isOverEndColumn() {
          return this._endColumn !== void 0 && this._column > this._endColumn;
        }
        _formatOutValue(e, t = this._row, n = this._column) {
          return { done: !1, value: new Yx(this, e, t, n) };
        }
        _shouldSkipSlot() {
          const e = this._skipRows.has(this._row), t = this._row < this._startRow, n = this._column < this._startColumn, i = this._endColumn !== void 0 && this._column > this._endColumn;
          return e || t || n || i;
        }
        _getSpanned() {
          const e = this._spannedCells.get(this._row);
          return e && e.get(this._column) || null;
        }
        _recordSpans(e, t, n) {
          const i = { cell: e, row: this._row, column: this._column };
          for (let r = this._row; r < this._row + t; r++)
            for (let s = this._column; s < this._column + n; s++)
              r == this._row && s == this._column || this._markSpannedCell(r, s, i);
        }
        _markSpannedCell(e, t, n) {
          this._spannedCells.has(e) || this._spannedCells.set(e, /* @__PURE__ */ new Map()), this._spannedCells.get(e).set(t, n);
        }
      }
      class Yx {
        constructor(e, t, n, i) {
          this.cell = t, this.row = e._row, this.column = e._column, this.cellAnchorRow = n, this.cellAnchorColumn = i, this._cellIndex = e._cellIndex, this._rowIndex = e._rowIndex, this._table = e._table;
        }
        get isAnchor() {
          return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
        }
        get cellWidth() {
          return parseInt(this.cell.getAttribute("colspan") || "1");
        }
        get cellHeight() {
          return parseInt(this.cell.getAttribute("rowspan") || "1");
        }
        get rowIndex() {
          return this._rowIndex;
        }
        getPositionBefore() {
          return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
        }
      }
      function bb(o, e) {
        return (t, { writer: n }) => {
          const i = t.getAttribute("headingRows") || 0, r = n.createContainerElement("table", null, []), s = n.createContainerElement("figure", { class: "table" }, r);
          i > 0 && n.insert(n.createPositionAt(r, "end"), n.createContainerElement("thead", null, n.createSlot((a) => a.is("element", "tableRow") && a.index < i))), i < o.getRows(t) && n.insert(n.createPositionAt(r, "end"), n.createContainerElement("tbody", null, n.createSlot((a) => a.is("element", "tableRow") && a.index >= i)));
          for (const { positionOffset: a, filter: l } of e.additionalSlots)
            n.insert(n.createPositionAt(r, a), n.createSlot(l));
          return n.insert(n.createPositionAt(r, "after"), n.createSlot((a) => !a.is("element", "tableRow") && !e.additionalSlots.some(({ filter: l }) => l(a)))), e.asWidget ? function(a, l) {
            return l.setCustomProperty("table", !0, a), yl(a, l, { hasSelectionHandle: !0 });
          }(s, n) : s;
        };
      }
      function kb(o = {}) {
        return (e, { writer: t }) => {
          const n = e.parent, i = n.parent, r = i.getChildIndex(n), s = new Re(i, { row: r }), a = i.getAttribute("headingRows") || 0, l = i.getAttribute("headingColumns") || 0;
          let d = null;
          for (const h of s)
            if (h.cell == e) {
              const m = h.row < a || h.column < l ? "th" : "td";
              d = o.asWidget ? t2(t.createEditableElement(m), t) : t.createContainerElement(m);
              break;
            }
          return d;
        };
      }
      function wb(o = {}) {
        return (e, { writer: t }) => {
          if (!e.parent.is("element", "tableCell") || !vb(e))
            return null;
          if (o.asWidget)
            return t.createContainerElement("span", { class: "ck-table-bogus-paragraph" });
          {
            const n = t.createContainerElement("p");
            return t.setCustomProperty("dataPipeline:transparentRendering", !0, n), n;
          }
        };
      }
      function vb(o) {
        return o.parent.childCount == 1 && !!o.getAttributeKeys().next().done;
      }
      class Qx extends pe {
        refresh() {
          const e = this.editor.model, t = e.document.selection, n = e.schema;
          this.isEnabled = function(i, r) {
            const s = i.getFirstPosition().parent, a = s === s.root ? s : s.parent;
            return r.checkChild(a, "table");
          }(t, n);
        }
        execute(e = {}) {
          const t = this.editor, n = t.model, i = t.plugins.get("TableUtils"), r = t.config.get("table.defaultHeadings.rows"), s = t.config.get("table.defaultHeadings.columns");
          e.headingRows === void 0 && r && (e.headingRows = r), e.headingColumns === void 0 && s && (e.headingColumns = s), n.change((a) => {
            const l = i.createTable(a, e);
            n.insertObject(l, null, null, { findOptimalPosition: "auto" }), a.setSelection(a.createPositionAt(l.getNodeByPath([0, 0, 0]), 0));
          });
        }
      }
      class _b extends pe {
        constructor(e, t = {}) {
          super(e), this.order = t.order || "below";
        }
        refresh() {
          const e = this.editor.model.document.selection, t = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
          this.isEnabled = t;
        }
        execute() {
          const e = this.editor, t = e.model.document.selection, n = e.plugins.get("TableUtils"), i = this.order === "above", r = n.getSelectionAffectedTableCells(t), s = n.getRowIndexes(r), a = i ? s.first : s.last, l = r[0].findAncestor("table");
          n.insertRows(l, { at: i ? a : a + 1, copyStructureFromAbove: !i });
        }
      }
      class Ab extends pe {
        constructor(e, t = {}) {
          super(e), this.order = t.order || "right";
        }
        refresh() {
          const e = this.editor.model.document.selection, t = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
          this.isEnabled = t;
        }
        execute() {
          const e = this.editor, t = e.model.document.selection, n = e.plugins.get("TableUtils"), i = this.order === "left", r = n.getSelectionAffectedTableCells(t), s = n.getColumnIndexes(r), a = i ? s.first : s.last, l = r[0].findAncestor("table");
          n.insertColumns(l, { columns: 1, at: i ? a : a + 1 });
        }
      }
      class Cb extends pe {
        constructor(e, t = {}) {
          super(e), this.direction = t.direction || "horizontally";
        }
        refresh() {
          const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.length === 1;
        }
        execute() {
          const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
          this.direction === "horizontally" ? e.splitCellHorizontally(t, 2) : e.splitCellVertically(t, 2);
        }
      }
      function yb(o, e, t) {
        const { startRow: n, startColumn: i, endRow: r, endColumn: s } = e, a = t.createElement("table"), l = r - n + 1;
        for (let h = 0; h < l; h++)
          t.insertElement("tableRow", a, "end");
        const d = [...new Re(o, { startRow: n, endRow: r, startColumn: i, endColumn: s, includeAllSlots: !0 })];
        for (const { row: h, column: m, cell: f, isAnchor: _, cellAnchorRow: E, cellAnchorColumn: B } of d) {
          const T = h - n, O = a.getChild(T);
          if (_) {
            const N = t.cloneElement(f);
            t.append(N, O), Bb(N, h, m, r, s, t);
          } else
            (E < n || B < i) && ao(t, t.createPositionAt(O, "end"));
        }
        return function(h, m, f, _, E) {
          const B = parseInt(m.getAttribute("headingRows") || "0");
          B > 0 && tt("headingRows", B - f, h, E, 0);
          const T = parseInt(m.getAttribute("headingColumns") || "0");
          T > 0 && tt("headingColumns", T - _, h, E, 0);
        }(a, o, n, i, t), a;
      }
      function Eb(o, e, t = 0) {
        const n = [], i = new Re(o, { startRow: t, endRow: e - 1 });
        for (const r of i) {
          const { row: s, cellHeight: a } = r;
          s < e && e <= s + a - 1 && n.push(r);
        }
        return n;
      }
      function xb(o, e, t) {
        const n = o.parent, i = n.parent, r = n.index, s = e - r, a = {}, l = parseInt(o.getAttribute("rowspan")) - s;
        l > 1 && (a.rowspan = l);
        const d = parseInt(o.getAttribute("colspan") || "1");
        d > 1 && (a.colspan = d);
        const h = r + s, m = [...new Re(i, { startRow: r, endRow: h, includeAllSlots: !0 })];
        let f, _ = null;
        for (const E of m) {
          const { row: B, column: T, cell: O } = E;
          O === o && f === void 0 && (f = T), f !== void 0 && f === T && B === h && (_ = ao(t, E.getPositionBefore(), a));
        }
        return tt("rowspan", s, o, t), _;
      }
      function Sb(o, e) {
        const t = [], n = new Re(o);
        for (const i of n) {
          const { column: r, cellWidth: s } = i;
          r < e && e <= r + s - 1 && t.push(i);
        }
        return t;
      }
      function Db(o, e, t, n) {
        const i = t - e, r = {}, s = parseInt(o.getAttribute("colspan")) - i;
        s > 1 && (r.colspan = s);
        const a = parseInt(o.getAttribute("rowspan") || "1");
        a > 1 && (r.rowspan = a);
        const l = ao(n, n.createPositionAfter(o), r);
        return tt("colspan", i, o, n), l;
      }
      function Bb(o, e, t, n, i, r) {
        const s = parseInt(o.getAttribute("colspan") || "1"), a = parseInt(o.getAttribute("rowspan") || "1");
        t + s - 1 > i && tt("colspan", i - t + 1, o, r, 1), e + a - 1 > n && tt("rowspan", n - e + 1, o, r, 1);
      }
      function Wl(o, e) {
        const t = e.getColumns(o), n = new Array(t).fill(0);
        for (const { column: r } of new Re(o))
          n[r]++;
        const i = n.reduce((r, s, a) => s ? r : [...r, a], []);
        if (i.length > 0) {
          const r = i[i.length - 1];
          return e.removeColumns(o, { at: r }), !0;
        }
        return !1;
      }
      function Gl(o, e) {
        const t = [], n = e.getRows(o);
        for (let i = 0; i < n; i++)
          o.getChild(i).isEmpty && t.push(i);
        if (t.length > 0) {
          const i = t[t.length - 1];
          return e.removeRows(o, { at: i }), !0;
        }
        return !1;
      }
      function Kl(o, e) {
        Wl(o, e) || Gl(o, e);
      }
      function Tb(o, e) {
        const t = Array.from(new Re(o, { startColumn: e.firstColumn, endColumn: e.lastColumn, row: e.lastRow }));
        if (t.every(({ cellHeight: i }) => i === 1))
          return e.lastRow;
        const n = t[0].cellHeight - 1;
        return e.lastRow + n;
      }
      function Pb(o, e) {
        const t = Array.from(new Re(o, { startRow: e.firstRow, endRow: e.lastRow, column: e.lastColumn }));
        if (t.every(({ cellWidth: i }) => i === 1))
          return e.lastColumn;
        const n = t[0].cellWidth - 1;
        return e.lastColumn + n;
      }
      class ps extends pe {
        constructor(e, t) {
          super(e), this.direction = t.direction, this.isHorizontal = this.direction == "right" || this.direction == "left";
        }
        refresh() {
          const e = this._getMergeableCell();
          this.value = e, this.isEnabled = !!e;
        }
        execute() {
          const e = this.editor.model, t = e.document, n = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(t.selection)[0], i = this.value, r = this.direction;
          e.change((s) => {
            const a = r == "right" || r == "down", l = a ? n : i, d = a ? i : n, h = d.parent;
            (function(B, T, O) {
              Ib(B) || (Ib(T) && O.remove(O.createRangeIn(T)), O.move(O.createRangeIn(B), O.createPositionAt(T, "end"))), O.remove(B);
            })(d, l, s);
            const m = this.isHorizontal ? "colspan" : "rowspan", f = parseInt(n.getAttribute(m) || "1"), _ = parseInt(i.getAttribute(m) || "1");
            s.setAttribute(m, f + _, l), s.setSelection(s.createRangeIn(l));
            const E = this.editor.plugins.get("TableUtils");
            Kl(h.findAncestor("table"), E);
          });
        }
        _getMergeableCell() {
          const e = this.editor.model.document, t = this.editor.plugins.get("TableUtils"), n = t.getTableCellsContainingSelection(e.selection)[0];
          if (!n)
            return;
          const i = this.isHorizontal ? function(a, l, d) {
            const h = a.parent, m = h.parent, f = l == "right" ? a.nextSibling : a.previousSibling, _ = (m.getAttribute("headingColumns") || 0) > 0;
            if (!f)
              return;
            const E = l == "right" ? a : f, B = l == "right" ? f : a, { column: T } = d.getCellLocation(E), { column: O } = d.getCellLocation(B), N = parseInt(E.getAttribute("colspan") || "1"), H = ql(d, E), X = ql(d, B);
            if (!(_ && H != X))
              return T + N === O ? f : void 0;
          }(n, this.direction, t) : function(a, l, d) {
            const h = a.parent, m = h.parent, f = m.getChildIndex(h);
            if (l == "down" && f === d.getRows(m) - 1 || l == "up" && f === 0)
              return null;
            const _ = parseInt(a.getAttribute("rowspan") || "1"), E = m.getAttribute("headingRows") || 0, B = l == "down" && f + _ === E, T = l == "up" && f === E;
            if (E && (B || T))
              return null;
            const O = parseInt(a.getAttribute("rowspan") || "1"), N = l == "down" ? f + O : f, H = [...new Re(m, { endRow: N })], X = H.find((Pe) => Pe.cell === a), be = X.column, Ge = H.find(({ row: Pe, cellHeight: _n, column: Nt }) => Nt === be && (l == "down" ? Pe === N : N === Pe + _n));
            return Ge && Ge.cell ? Ge.cell : null;
          }(n, this.direction, t);
          if (!i)
            return;
          const r = this.isHorizontal ? "rowspan" : "colspan", s = parseInt(n.getAttribute(r) || "1");
          return parseInt(i.getAttribute(r) || "1") === s ? i : void 0;
        }
      }
      function Ib(o) {
        const e = o.getChild(0);
        return o.childCount == 1 && e.is("element", "paragraph") && e.isEmpty;
      }
      class Xx extends pe {
        refresh() {
          const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), n = t[0];
          if (n) {
            const i = n.findAncestor("table"), r = e.getRows(i) - 1, s = e.getRowIndexes(t), a = s.first === 0 && s.last === r;
            this.isEnabled = !a;
          } else
            this.isEnabled = !1;
        }
        execute() {
          const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), i = t.getRowIndexes(n), r = n[0], s = r.findAncestor("table"), a = t.getCellLocation(r).column;
          e.change((l) => {
            const d = i.last - i.first + 1;
            t.removeRows(s, { at: i.first, rows: d });
            const h = function(m, f, _, E) {
              const B = m.getChild(Math.min(f, E - 1));
              let T = B.getChild(0), O = 0;
              for (const N of B.getChildren()) {
                if (O > _)
                  return T;
                T = N, O += parseInt(N.getAttribute("colspan") || "1");
              }
              return T;
            }(s, i.first, a, t.getRows(s));
            l.setSelection(l.createPositionAt(h, 0));
          });
        }
      }
      class e5 extends pe {
        refresh() {
          const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), n = t[0];
          if (n) {
            const i = n.findAncestor("table"), r = e.getColumns(i), { first: s, last: a } = e.getColumnIndexes(t);
            this.isEnabled = a - s < r - 1;
          } else
            this.isEnabled = !1;
        }
        execute() {
          const e = this.editor.plugins.get("TableUtils"), [t, n] = function(l, d) {
            const h = d.getSelectionAffectedTableCells(l), m = h[0], f = h.pop(), _ = [m, f];
            return m.isBefore(f) ? _ : _.reverse();
          }(this.editor.model.document.selection, e), i = t.parent.parent, r = [...new Re(i)], s = { first: r.find((l) => l.cell === t).column, last: r.find((l) => l.cell === n).column }, a = function(l, d, h, m) {
            return parseInt(h.getAttribute("colspan") || "1") > 1 ? h : d.previousSibling || h.nextSibling ? h.nextSibling || d.previousSibling : m.first ? l.reverse().find(({ column: _ }) => _ < m.first).cell : l.reverse().find(({ column: _ }) => _ > m.last).cell;
          }(r, t, n, s);
          this.editor.model.change((l) => {
            const d = s.last - s.first + 1;
            e.removeColumns(i, { at: s.first, columns: d }), l.setSelection(l.createPositionAt(a, 0));
          });
        }
      }
      class t5 extends pe {
        refresh() {
          const e = this.editor.plugins.get("TableUtils"), t = this.editor.model, n = e.getSelectionAffectedTableCells(t.document.selection), i = n.length > 0;
          this.isEnabled = i, this.value = i && n.every((r) => this._isInHeading(r, r.parent.parent));
        }
        execute(e = {}) {
          if (e.forceValue === this.value)
            return;
          const t = this.editor.plugins.get("TableUtils"), n = this.editor.model, i = t.getSelectionAffectedTableCells(n.document.selection), r = i[0].findAncestor("table"), { first: s, last: a } = t.getRowIndexes(i), l = this.value ? s : a + 1, d = r.getAttribute("headingRows") || 0;
          n.change((h) => {
            if (l) {
              const m = Eb(r, l, l > d ? d : 0);
              for (const { cell: f } of m)
                xb(f, l, h);
            }
            tt("headingRows", l, r, h, 0);
          });
        }
        _isInHeading(e, t) {
          const n = parseInt(t.getAttribute("headingRows") || "0");
          return !!n && e.parent.index < n;
        }
      }
      class n5 extends pe {
        refresh() {
          const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), i = n.length > 0;
          this.isEnabled = i, this.value = i && n.every((r) => ql(t, r));
        }
        execute(e = {}) {
          if (e.forceValue === this.value)
            return;
          const t = this.editor.plugins.get("TableUtils"), n = this.editor.model, i = t.getSelectionAffectedTableCells(n.document.selection), r = i[0].findAncestor("table"), { first: s, last: a } = t.getColumnIndexes(i), l = this.value ? s : a + 1;
          n.change((d) => {
            if (l) {
              const h = Sb(r, l);
              for (const { cell: m, column: f } of h)
                Db(m, f, l, d);
            }
            tt("headingColumns", l, r, d, 0);
          });
        }
      }
      class wt extends G {
        static get pluginName() {
          return "TableUtils";
        }
        init() {
          this.decorate("insertColumns"), this.decorate("insertRows");
        }
        getCellLocation(e) {
          const t = e.parent, n = t.parent, i = n.getChildIndex(t), r = new Re(n, { row: i });
          for (const { cell: s, row: a, column: l } of r)
            if (s === e)
              return { row: a, column: l };
        }
        createTable(e, t) {
          const n = e.createElement("table"), i = t.rows || 2, r = t.columns || 2;
          return Zl(e, n, 0, i, r), t.headingRows && tt("headingRows", Math.min(t.headingRows, i), n, e, 0), t.headingColumns && tt("headingColumns", Math.min(t.headingColumns, r), n, e, 0), n;
        }
        insertRows(e, t = {}) {
          const n = this.editor.model, i = t.at || 0, r = t.rows || 1, s = t.copyStructureFromAbove !== void 0, a = t.copyStructureFromAbove ? i - 1 : i, l = this.getRows(e), d = this.getColumns(e);
          if (i > l)
            throw new I("tableutils-insertrows-insert-out-of-range", this, { options: t });
          n.change((h) => {
            const m = e.getAttribute("headingRows") || 0;
            if (m > i && tt("headingRows", m + r, e, h, 0), !s && (i === 0 || i === l))
              return void Zl(h, e, i, r, d);
            const f = s ? Math.max(i, a) : i, _ = new Re(e, { endRow: f }), E = new Array(d).fill(1);
            for (const { row: B, column: T, cellHeight: O, cellWidth: N, cell: H } of _) {
              const X = B + O - 1, be = B <= a && a <= X;
              B < i && i <= X ? (h.setAttribute("rowspan", O + r, H), E[T] = -N) : s && be && (E[T] = N);
            }
            for (let B = 0; B < r; B++) {
              const T = h.createElement("tableRow");
              h.insert(T, e, i);
              for (let O = 0; O < E.length; O++) {
                const N = E[O], H = h.createPositionAt(T, "end");
                N > 0 && ao(h, H, N > 1 ? { colspan: N } : void 0), O += Math.abs(N) - 1;
              }
            }
          });
        }
        insertColumns(e, t = {}) {
          const n = this.editor.model, i = t.at || 0, r = t.columns || 1;
          n.change((s) => {
            const a = e.getAttribute("headingColumns");
            i < a && s.setAttribute("headingColumns", a + r, e);
            const l = this.getColumns(e);
            if (i === 0 || l === i) {
              for (const h of e.getChildren())
                h.is("element", "tableRow") && Xo(r, s, s.createPositionAt(h, i ? "end" : 0));
              return;
            }
            const d = new Re(e, { column: i, includeAllSlots: !0 });
            for (const h of d) {
              const { row: m, cell: f, cellAnchorColumn: _, cellAnchorRow: E, cellWidth: B, cellHeight: T } = h;
              if (_ < i) {
                s.setAttribute("colspan", B + r, f);
                const O = E + T - 1;
                for (let N = m; N <= O; N++)
                  d.skipRow(N);
              } else
                Xo(r, s, h.getPositionBefore());
            }
          });
        }
        removeRows(e, t) {
          const n = this.editor.model, i = t.rows || 1, r = this.getRows(e), s = t.at, a = s + i - 1;
          if (a > r - 1)
            throw new I("tableutils-removerows-row-index-out-of-range", this, { table: e, options: t });
          n.change((l) => {
            const d = { first: s, last: a }, { cellsToMove: h, cellsToTrim: m } = function(f, { first: _, last: E }) {
              const B = /* @__PURE__ */ new Map(), T = [];
              for (const { row: O, column: N, cellHeight: H, cell: X } of new Re(f, { endRow: E })) {
                const be = O + H - 1;
                if (O >= _ && O <= E && be > E) {
                  const Ge = H - (E - O + 1);
                  B.set(N, { cell: X, rowspan: Ge });
                }
                if (O < _ && be >= _) {
                  let Ge;
                  Ge = be >= E ? E - _ + 1 : be - _ + 1, T.push({ cell: X, rowspan: H - Ge });
                }
              }
              return { cellsToMove: B, cellsToTrim: T };
            }(e, d);
            h.size && function(f, _, E, B) {
              const T = new Re(f, { includeAllSlots: !0, row: _ }), O = [...T], N = f.getChild(_);
              let H;
              for (const { column: X, cell: be, isAnchor: Ge } of O)
                if (E.has(X)) {
                  const { cell: Pe, rowspan: _n } = E.get(X), Nt = H ? B.createPositionAfter(H) : B.createPositionAt(N, 0);
                  B.move(B.createRangeOn(Pe), Nt), tt("rowspan", _n, Pe, B), H = Pe;
                } else
                  Ge && (H = be);
            }(e, a + 1, h, l);
            for (let f = a; f >= s; f--)
              l.remove(e.getChild(f));
            for (const { rowspan: f, cell: _ } of m)
              tt("rowspan", f, _, l);
            (function(f, { first: _, last: E }, B) {
              const T = f.getAttribute("headingRows") || 0;
              _ < T && tt("headingRows", E < T ? T - (E - _ + 1) : _, f, B, 0);
            })(e, d, l), Wl(e, this) || Gl(e, this);
          });
        }
        removeColumns(e, t) {
          const n = this.editor.model, i = t.at, r = t.columns || 1, s = t.at + r - 1;
          n.change((a) => {
            (function(l, d, h) {
              const m = l.getAttribute("headingColumns") || 0;
              if (m && d.first < m) {
                const f = Math.min(m - 1, d.last) - d.first + 1;
                h.setAttribute("headingColumns", m - f, l);
              }
            })(e, { first: i, last: s }, a);
            for (let l = s; l >= i; l--)
              for (const { cell: d, column: h, cellWidth: m } of [...new Re(e)])
                h <= l && m > 1 && h + m > l ? tt("colspan", m - 1, d, a) : h === l && a.remove(d);
            Gl(e, this) || Wl(e, this);
          });
        }
        splitCellVertically(e, t = 2) {
          const n = this.editor.model, i = e.parent.parent, r = parseInt(e.getAttribute("rowspan") || "1"), s = parseInt(e.getAttribute("colspan") || "1");
          n.change((a) => {
            if (s > 1) {
              const { newCellsSpan: l, updatedSpan: d } = Ob(s, t);
              tt("colspan", d, e, a);
              const h = {};
              l > 1 && (h.colspan = l), r > 1 && (h.rowspan = r), Xo(s > t ? t - 1 : s - 1, a, a.createPositionAfter(e), h);
            }
            if (s < t) {
              const l = t - s, d = [...new Re(i)], { column: h } = d.find(({ cell: E }) => E === e), m = d.filter(({ cell: E, cellWidth: B, column: T }) => E !== e && T === h || T < h && T + B > h);
              for (const { cell: E, cellWidth: B } of m)
                a.setAttribute("colspan", B + l, E);
              const f = {};
              r > 1 && (f.rowspan = r), Xo(l, a, a.createPositionAfter(e), f);
              const _ = i.getAttribute("headingColumns") || 0;
              _ > h && tt("headingColumns", _ + l, i, a);
            }
          });
        }
        splitCellHorizontally(e, t = 2) {
          const n = this.editor.model, i = e.parent, r = i.parent, s = r.getChildIndex(i), a = parseInt(e.getAttribute("rowspan") || "1"), l = parseInt(e.getAttribute("colspan") || "1");
          n.change((d) => {
            if (a > 1) {
              const h = [...new Re(r, { startRow: s, endRow: s + a - 1, includeAllSlots: !0 })], { newCellsSpan: m, updatedSpan: f } = Ob(a, t);
              tt("rowspan", f, e, d);
              const { column: _ } = h.find(({ cell: B }) => B === e), E = {};
              m > 1 && (E.rowspan = m), l > 1 && (E.colspan = l);
              for (const B of h) {
                const { column: T, row: O } = B;
                O >= s + f && T === _ && (O + s + f) % m == 0 && Xo(1, d, B.getPositionBefore(), E);
              }
            }
            if (a < t) {
              const h = t - a, m = [...new Re(r, { startRow: 0, endRow: s })];
              for (const { cell: E, cellHeight: B, row: T } of m)
                if (E !== e && T + B > s) {
                  const O = B + h;
                  d.setAttribute("rowspan", O, E);
                }
              const f = {};
              l > 1 && (f.colspan = l), Zl(d, r, s + 1, h, 1, f);
              const _ = r.getAttribute("headingRows") || 0;
              _ > s && tt("headingRows", _ + h, r, d);
            }
          });
        }
        getColumns(e) {
          return [...e.getChild(0).getChildren()].reduce((t, n) => t + parseInt(n.getAttribute("colspan") || "1"), 0);
        }
        getRows(e) {
          return Array.from(e.getChildren()).reduce((t, n) => n.is("element", "tableRow") ? t + 1 : t, 0);
        }
        createTableWalker(e, t = {}) {
          return new Re(e, t);
        }
        getSelectedTableCells(e) {
          const t = [];
          for (const n of this.sortRanges(e.getRanges())) {
            const i = n.getContainedElement();
            i && i.is("element", "tableCell") && t.push(i);
          }
          return t;
        }
        getTableCellsContainingSelection(e) {
          const t = [];
          for (const n of e.getRanges()) {
            const i = n.start.findAncestor("tableCell");
            i && t.push(i);
          }
          return t;
        }
        getSelectionAffectedTableCells(e) {
          const t = this.getSelectedTableCells(e);
          return t.length ? t : this.getTableCellsContainingSelection(e);
        }
        getRowIndexes(e) {
          const t = e.map((n) => n.parent.index);
          return this._getFirstLastIndexesObject(t);
        }
        getColumnIndexes(e) {
          const t = e[0].findAncestor("table"), n = [...new Re(t)].filter((i) => e.includes(i.cell)).map((i) => i.column);
          return this._getFirstLastIndexesObject(n);
        }
        isSelectionRectangular(e) {
          if (e.length < 2 || !this._areCellInTheSameTableSection(e))
            return !1;
          const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
          let i = 0;
          for (const s of e) {
            const { row: a, column: l } = this.getCellLocation(s), d = parseInt(s.getAttribute("rowspan")) || 1, h = parseInt(s.getAttribute("colspan")) || 1;
            t.add(a), n.add(l), d > 1 && t.add(a + d - 1), h > 1 && n.add(l + h - 1), i += d * h;
          }
          return function(s, a) {
            const l = Array.from(s.values()), d = Array.from(a.values()), h = Math.max(...l), m = Math.min(...l), f = Math.max(...d), _ = Math.min(...d);
            return (h - m + 1) * (f - _ + 1);
          }(t, n) == i;
        }
        sortRanges(e) {
          return Array.from(e).sort(o5);
        }
        _getFirstLastIndexesObject(e) {
          const t = e.sort((n, i) => n - i);
          return { first: t[0], last: t[t.length - 1] };
        }
        _areCellInTheSameTableSection(e) {
          const t = e[0].findAncestor("table"), n = this.getRowIndexes(e), i = parseInt(t.getAttribute("headingRows")) || 0;
          if (!this._areIndexesInSameSection(n, i))
            return !1;
          const r = this.getColumnIndexes(e), s = parseInt(t.getAttribute("headingColumns")) || 0;
          return this._areIndexesInSameSection(r, s);
        }
        _areIndexesInSameSection({ first: e, last: t }, n) {
          return e < n == t < n;
        }
      }
      function Zl(o, e, t, n, i, r = {}) {
        for (let s = 0; s < n; s++) {
          const a = o.createElement("tableRow");
          o.insert(a, e, t), Xo(i, o, o.createPositionAt(a, "end"), r);
        }
      }
      function Xo(o, e, t, n = {}) {
        for (let i = 0; i < o; i++)
          ao(e, t, n);
      }
      function Ob(o, e) {
        if (o < e)
          return { newCellsSpan: 1, updatedSpan: 1 };
        const t = Math.floor(o / e);
        return { newCellsSpan: t, updatedSpan: o - t * e + t };
      }
      function o5(o, e) {
        const t = o.start, n = e.start;
        return t.isBefore(n) ? -1 : 1;
      }
      class i5 extends pe {
        refresh() {
          const e = this.editor.plugins.get(wt), t = e.getSelectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.isSelectionRectangular(t);
        }
        execute() {
          const e = this.editor.model, t = this.editor.plugins.get(wt);
          e.change((n) => {
            const i = t.getSelectedTableCells(e.document.selection), r = i.shift(), { mergeWidth: s, mergeHeight: a } = function(l, d, h) {
              let m = 0, f = 0;
              for (const O of d) {
                const { row: N, column: H } = h.getCellLocation(O);
                m = zb(O, H, m, "colspan"), f = zb(O, N, f, "rowspan");
              }
              const { row: _, column: E } = h.getCellLocation(l), B = m - E, T = f - _;
              return { mergeWidth: B, mergeHeight: T };
            }(r, i, t);
            tt("colspan", s, r, n), tt("rowspan", a, r, n);
            for (const l of i)
              r5(l, r, n);
            Kl(r.findAncestor("table"), t), n.setSelection(r, "in");
          });
        }
      }
      function r5(o, e, t) {
        Rb(o) || (Rb(e) && t.remove(t.createRangeIn(e)), t.move(t.createRangeIn(o), t.createPositionAt(e, "end"))), t.remove(o);
      }
      function Rb(o) {
        const e = o.getChild(0);
        return o.childCount == 1 && e.is("element", "paragraph") && e.isEmpty;
      }
      function zb(o, e, t, n) {
        const i = parseInt(o.getAttribute(n) || "1");
        return Math.max(t, e + i);
      }
      class s5 extends pe {
        constructor(e) {
          super(e), this.affectsData = !1;
        }
        refresh() {
          const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.length > 0;
        }
        execute() {
          const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), i = t.getRowIndexes(n), r = n[0].findAncestor("table"), s = [];
          for (let a = i.first; a <= i.last; a++)
            for (const l of r.getChild(a).getChildren())
              s.push(e.createRangeOn(l));
          e.change((a) => {
            a.setSelection(s);
          });
        }
      }
      class a5 extends pe {
        constructor(e) {
          super(e), this.affectsData = !1;
        }
        refresh() {
          const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.length > 0;
        }
        execute() {
          const e = this.editor.plugins.get("TableUtils"), t = this.editor.model, n = e.getSelectionAffectedTableCells(t.document.selection), i = n[0], r = n.pop(), s = i.findAncestor("table"), a = e.getCellLocation(i), l = e.getCellLocation(r), d = Math.min(a.column, l.column), h = Math.max(a.column, l.column), m = [];
          for (const f of new Re(s, { startColumn: d, endColumn: h }))
            m.push(t.createRangeOn(f.cell));
          t.change((f) => {
            f.setSelection(m);
          });
        }
      }
      function l5(o) {
        o.document.registerPostFixer((e) => function(t, n) {
          const i = n.document.differ.getChanges();
          let r = !1;
          const s = /* @__PURE__ */ new Set();
          for (const a of i) {
            let l = null;
            a.type == "insert" && a.name == "table" && (l = a.position.nodeAfter), a.type != "insert" && a.type != "remove" || a.name != "tableRow" && a.name != "tableCell" || (l = a.position.findAncestor("table")), u5(a) && (l = a.range.start.findAncestor("table")), l && !s.has(l) && (r = c5(l, t) || r, r = d5(l, t) || r, s.add(l));
          }
          return r;
        }(e, o));
      }
      function c5(o, e) {
        let t = !1;
        const n = function(i) {
          const r = parseInt(i.getAttribute("headingRows") || "0"), s = Array.from(i.getChildren()).reduce((l, d) => d.is("element", "tableRow") ? l + 1 : l, 0), a = [];
          for (const { row: l, cell: d, cellHeight: h } of new Re(i)) {
            if (h < 2)
              continue;
            const m = l < r ? r : s;
            if (l + h > m) {
              const f = m - l;
              a.push({ cell: d, rowspan: f });
            }
          }
          return a;
        }(o);
        if (n.length) {
          t = !0;
          for (const i of n)
            tt("rowspan", i.rowspan, i.cell, e, 1);
        }
        return t;
      }
      function d5(o, e) {
        let t = !1;
        const n = function(a) {
          const l = new Array(a.childCount).fill(0);
          for (const { rowIndex: d } of new Re(a, { includeAllSlots: !0 }))
            l[d]++;
          return l;
        }(o), i = [];
        for (const [a, l] of n.entries())
          !l && o.getChild(a).is("element", "tableRow") && i.push(a);
        if (i.length) {
          t = !0;
          for (const a of i.reverse())
            e.remove(o.getChild(a)), n.splice(a, 1);
        }
        const r = n.filter((a, l) => o.getChild(l).is("element", "tableRow")), s = r[0];
        if (!r.every((a) => a === s)) {
          const a = r.reduce((l, d) => d > l ? d : l, 0);
          for (const [l, d] of r.entries()) {
            const h = a - d;
            if (h) {
              for (let m = 0; m < h; m++)
                ao(e, e.createPositionAt(o.getChild(l), "end"));
              t = !0;
            }
          }
        }
        return t;
      }
      function u5(o) {
        if (o.type !== "attribute")
          return !1;
        const e = o.attributeKey;
        return e === "headingRows" || e === "colspan" || e === "rowspan";
      }
      function h5(o) {
        o.document.registerPostFixer((e) => function(t, n) {
          const i = n.document.differ.getChanges();
          let r = !1;
          for (const s of i)
            s.type == "insert" && s.name == "table" && (r = g5(s.position.nodeAfter, t) || r), s.type == "insert" && s.name == "tableRow" && (r = Mb(s.position.nodeAfter, t) || r), s.type == "insert" && s.name == "tableCell" && (r = Jl(s.position.nodeAfter, t) || r), s.type != "remove" && s.type != "insert" || !m5(s) || (r = Jl(s.position.parent, t) || r);
          return r;
        }(e, o));
      }
      function g5(o, e) {
        let t = !1;
        for (const n of o.getChildren())
          n.is("element", "tableRow") && (t = Mb(n, e) || t);
        return t;
      }
      function Mb(o, e) {
        let t = !1;
        for (const n of o.getChildren())
          t = Jl(n, e) || t;
        return t;
      }
      function Jl(o, e) {
        if (o.childCount == 0)
          return e.insertElement("paragraph", o), !0;
        const t = Array.from(o.getChildren()).filter((n) => n.is("$text"));
        for (const n of t)
          e.wrap(e.createRangeOn(n), "paragraph");
        return !!t.length;
      }
      function m5(o) {
        return !!o.position.parent.is("element", "tableCell") && (o.type == "insert" && o.name == "$text" || o.type == "remove");
      }
      function p5(o, e) {
        if (!o.is("element", "paragraph"))
          return !1;
        const t = e.toViewElement(o);
        return !!t && vb(o) !== t.is("element", "span");
      }
      var Nb = k(3881), f5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Nb.Z, f5), Nb.Z.locals;
      class b5 extends G {
        constructor(e) {
          super(e), this._additionalSlots = [];
        }
        static get pluginName() {
          return "TableEditing";
        }
        static get requires() {
          return [wt];
        }
        init() {
          const e = this.editor, t = e.model, n = t.schema, i = e.conversion, r = e.plugins.get(wt);
          n.register("table", { inheritAllFrom: "$blockObject", allowAttributes: ["headingRows", "headingColumns"] }), n.register("tableRow", { allowIn: "table", isLimit: !0 }), n.register("tableCell", { allowContentOf: "$container", allowIn: "tableRow", allowAttributes: ["colspan", "rowspan"], isLimit: !0, isSelectable: !0 }), i.for("upcast").add((s) => {
            s.on("element:figure", (a, l, d) => {
              if (!d.consumable.test(l.viewItem, { name: !0, classes: "table" }))
                return;
              const h = function(f) {
                for (const _ of f.getChildren())
                  if (_.is("element", "table"))
                    return _;
              }(l.viewItem);
              if (!h || !d.consumable.test(h, { name: !0 }))
                return;
              d.consumable.consume(l.viewItem, { name: !0, classes: "table" });
              const m = it(d.convertItem(h, l.modelCursor).modelRange.getItems());
              m ? (d.convertChildren(l.viewItem, d.writer.createPositionAt(m, "end")), d.updateConversionResult(m, l)) : d.consumable.revert(l.viewItem, { name: !0, classes: "table" });
            });
          }), i.for("upcast").add(Zx()), i.for("editingDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: bb(r, { asWidget: !0, additionalSlots: this._additionalSlots }) }), i.for("dataDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: bb(r, { additionalSlots: this._additionalSlots }) }), i.for("upcast").elementToElement({ model: "tableRow", view: "tr" }), i.for("upcast").add((s) => {
            s.on("element:tr", (a, l) => {
              l.viewItem.isEmpty && l.modelCursor.index == 0 && a.stop();
            }, { priority: "high" });
          }), i.for("downcast").elementToElement({ model: "tableRow", view: (s, { writer: a }) => s.isEmpty ? a.createEmptyElement("tr") : a.createContainerElement("tr") }), i.for("upcast").elementToElement({ model: "tableCell", view: "td" }), i.for("upcast").elementToElement({ model: "tableCell", view: "th" }), i.for("upcast").add(fb("td")), i.for("upcast").add(fb("th")), i.for("editingDowncast").elementToElement({ model: "tableCell", view: kb({ asWidget: !0 }) }), i.for("dataDowncast").elementToElement({ model: "tableCell", view: kb() }), i.for("editingDowncast").elementToElement({ model: "paragraph", view: wb({ asWidget: !0 }), converterPriority: "high" }), i.for("dataDowncast").elementToElement({ model: "paragraph", view: wb(), converterPriority: "high" }), i.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" }), i.for("upcast").attributeToAttribute({ model: { key: "colspan", value: Fb("colspan") }, view: "colspan" }), i.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" }), i.for("upcast").attributeToAttribute({ model: { key: "rowspan", value: Fb("rowspan") }, view: "rowspan" }), e.config.define("table.defaultHeadings.rows", 0), e.config.define("table.defaultHeadings.columns", 0), e.commands.add("insertTable", new Qx(e)), e.commands.add("insertTableRowAbove", new _b(e, { order: "above" })), e.commands.add("insertTableRowBelow", new _b(e, { order: "below" })), e.commands.add("insertTableColumnLeft", new Ab(e, { order: "left" })), e.commands.add("insertTableColumnRight", new Ab(e, { order: "right" })), e.commands.add("removeTableRow", new Xx(e)), e.commands.add("removeTableColumn", new e5(e)), e.commands.add("splitTableCellVertically", new Cb(e, { direction: "vertically" })), e.commands.add("splitTableCellHorizontally", new Cb(e, { direction: "horizontally" })), e.commands.add("mergeTableCells", new i5(e)), e.commands.add("mergeTableCellRight", new ps(e, { direction: "right" })), e.commands.add("mergeTableCellLeft", new ps(e, { direction: "left" })), e.commands.add("mergeTableCellDown", new ps(e, { direction: "down" })), e.commands.add("mergeTableCellUp", new ps(e, { direction: "up" })), e.commands.add("setTableColumnHeader", new n5(e)), e.commands.add("setTableRowHeader", new t5(e)), e.commands.add("selectTableRow", new s5(e)), e.commands.add("selectTableColumn", new a5(e)), l5(t), h5(t), this.listenTo(t.document, "change:data", () => {
            (function(s, a) {
              const l = s.document.differ;
              for (const d of l.getChanges()) {
                let h, m = !1;
                if (d.type == "attribute") {
                  const B = d.range.start.nodeAfter;
                  if (!B || !B.is("element", "table") || d.attributeKey != "headingRows" && d.attributeKey != "headingColumns")
                    continue;
                  h = B, m = d.attributeKey == "headingRows";
                } else
                  d.name != "tableRow" && d.name != "tableCell" || (h = d.position.findAncestor("table"), m = d.name == "tableRow");
                if (!h)
                  continue;
                const f = h.getAttribute("headingRows") || 0, _ = h.getAttribute("headingColumns") || 0, E = new Re(h);
                for (const B of E) {
                  const T = B.row < f || B.column < _ ? "th" : "td", O = a.mapper.toViewElement(B.cell);
                  O && O.is("element") && O.name != T && a.reconvertItem(m ? B.cell.parent : B.cell);
                }
              }
            })(t, e.editing), function(s, a) {
              const l = s.document.differ, d = /* @__PURE__ */ new Set();
              for (const h of l.getChanges()) {
                const m = h.type == "attribute" ? h.range.start.parent : h.position.parent;
                m.is("element", "tableCell") && d.add(m);
              }
              for (const h of d.values()) {
                const m = Array.from(h.getChildren()).filter((f) => p5(f, a.mapper));
                for (const f of m)
                  a.reconvertItem(f);
              }
            }(t, e.editing);
          });
        }
        registerAdditionalSlot(e) {
          this._additionalSlots.push(e);
        }
      }
      function Fb(o) {
        return (e) => {
          const t = parseInt(e.getAttribute(o));
          return Number.isNaN(t) || t <= 0 ? null : t;
        };
      }
      var $b = k(1613), k5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()($b.Z, k5), $b.Z.locals;
      class w5 extends we {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.items = this._createGridCollection(), this.keystrokes = new un(), this.focusTracker = new Gt(), this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (n, i) => `${i} × ${n}`), this.setTemplate({ tag: "div", attributes: { class: ["ck"] }, children: [{ tag: "div", attributes: { class: ["ck-insert-table-dropdown__grid"] }, on: { "mouseover@.ck-insert-table-dropdown-grid-box": t.to("boxover") }, children: this.items }, { tag: "div", attributes: { class: ["ck", "ck-insert-table-dropdown__label"], "aria-hidden": !0 }, children: [{ text: t.to("label") }] }], on: { mousedown: t.to((n) => {
            n.preventDefault();
          }), click: t.to(() => {
            this.fire("execute");
          }) } }), this.on("boxover", (n, i) => {
            const { row: r, column: s } = i.target.dataset;
            this.items.get(10 * (parseInt(r, 10) - 1) + (parseInt(s, 10) - 1)).focus();
          }), this.focusTracker.on("change:focusedElement", (n, i, r) => {
            if (!r)
              return;
            const { row: s, column: a } = r.dataset;
            this.set({ rows: parseInt(s), columns: parseInt(a) });
          }), this.on("change:columns", () => this._highlightGridBoxes()), this.on("change:rows", () => this._highlightGridBoxes());
        }
        render() {
          super.render(), function({ keystrokeHandler: e, focusTracker: t, gridItems: n, numberOfColumns: i, uiLanguageDirection: r }) {
            const s = typeof i == "number" ? () => i : i;
            function a(h) {
              return (m) => {
                const f = n.find((B) => B.element === t.focusedElement), _ = n.getIndex(f), E = h(_, n);
                n.get(E).focus(), m.stopPropagation(), m.preventDefault();
              };
            }
            function l(h, m) {
              return h === m - 1 ? 0 : h + 1;
            }
            function d(h, m) {
              return h === 0 ? m - 1 : h - 1;
            }
            e.set("arrowright", a((h, m) => r === "rtl" ? d(h, m.length) : l(h, m.length))), e.set("arrowleft", a((h, m) => r === "rtl" ? l(h, m.length) : d(h, m.length))), e.set("arrowup", a((h, m) => {
              let f = h - s();
              return f < 0 && (f = h + s() * Math.floor(m.length / s()), f > m.length - 1 && (f -= s())), f;
            })), e.set("arrowdown", a((h, m) => {
              let f = h + s();
              return f > m.length - 1 && (f = h % s()), f;
            }));
          }({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.items, numberOfColumns: 10, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection });
          for (const e of this.items)
            this.focusTracker.add(e.element);
          this.keystrokes.listenTo(this.element);
        }
        focus() {
          this.items.get(0).focus();
        }
        focusLast() {
          this.items.get(0).focus();
        }
        _highlightGridBoxes() {
          const e = this.rows, t = this.columns;
          this.items.map((n, i) => {
            const r = Math.floor(i / 10) < e && i % 10 < t;
            n.set("isOn", r);
          });
        }
        _createGridButton(e, t, n, i) {
          const r = new je(e);
          return r.set({ label: i, class: "ck-insert-table-dropdown-grid-box" }), r.extendTemplate({ attributes: { "data-row": t, "data-column": n } }), r;
        }
        _createGridCollection() {
          const e = [];
          for (let t = 0; t < 100; t++) {
            const n = Math.floor(t / 10), i = t % 10, r = `${n + 1} × ${i + 1}`;
            e.push(this._createGridButton(this.locale, n + 1, i + 1, r));
          }
          return this.createCollection(e);
        }
      }
      class v5 extends G {
        static get pluginName() {
          return "TableUI";
        }
        init() {
          const e = this.editor, t = this.editor.t, n = e.locale.contentLanguageDirection === "ltr";
          e.ui.componentFactory.add("insertTable", (i) => {
            const r = e.commands.get("insertTable"), s = fn(i);
            let a;
            return s.bind("isEnabled").to(r), s.buttonView.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>', label: t("Insert table"), tooltip: !0 }), s.on("change:isOpen", () => {
              a || (a = new w5(i), s.panelView.children.add(a), a.delegate("execute").to(s), s.on("execute", () => {
                e.execute("insertTable", { rows: a.rows, columns: a.columns }), e.editing.view.focus();
              }));
            }), s;
          }), e.ui.componentFactory.add("tableColumn", (i) => {
            const r = [{ type: "switchbutton", model: { commandName: "setTableColumnHeader", label: t("Header column"), bindIsOn: !0 } }, { type: "separator" }, { type: "button", model: { commandName: n ? "insertTableColumnLeft" : "insertTableColumnRight", label: t("Insert column left") } }, { type: "button", model: { commandName: n ? "insertTableColumnRight" : "insertTableColumnLeft", label: t("Insert column right") } }, { type: "button", model: { commandName: "removeTableColumn", label: t("Delete column") } }, { type: "button", model: { commandName: "selectTableColumn", label: t("Select column") } }];
            return this._prepareDropdown(t("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', r, i);
          }), e.ui.componentFactory.add("tableRow", (i) => {
            const r = [{ type: "switchbutton", model: { commandName: "setTableRowHeader", label: t("Header row"), bindIsOn: !0 } }, { type: "separator" }, { type: "button", model: { commandName: "insertTableRowAbove", label: t("Insert row above") } }, { type: "button", model: { commandName: "insertTableRowBelow", label: t("Insert row below") } }, { type: "button", model: { commandName: "removeTableRow", label: t("Delete row") } }, { type: "button", model: { commandName: "selectTableRow", label: t("Select row") } }];
            return this._prepareDropdown(t("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', r, i);
          }), e.ui.componentFactory.add("mergeTableCells", (i) => {
            const r = [{ type: "button", model: { commandName: "mergeTableCellUp", label: t("Merge cell up") } }, { type: "button", model: { commandName: n ? "mergeTableCellRight" : "mergeTableCellLeft", label: t("Merge cell right") } }, { type: "button", model: { commandName: "mergeTableCellDown", label: t("Merge cell down") } }, { type: "button", model: { commandName: n ? "mergeTableCellLeft" : "mergeTableCellRight", label: t("Merge cell left") } }, { type: "separator" }, { type: "button", model: { commandName: "splitTableCellVertically", label: t("Split cell vertically") } }, { type: "button", model: { commandName: "splitTableCellHorizontally", label: t("Split cell horizontally") } }];
            return this._prepareMergeSplitButtonDropdown(t("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', r, i);
          });
        }
        _prepareDropdown(e, t, n, i) {
          const r = this.editor, s = fn(i), a = this._fillDropdownWithListOptions(s, n);
          return s.buttonView.set({ label: e, icon: t, tooltip: !0 }), s.bind("isEnabled").toMany(a, "isEnabled", (...l) => l.some((d) => d)), this.listenTo(s, "execute", (l) => {
            r.execute(l.source.commandName), l.source instanceof Tr || r.editing.view.focus();
          }), s;
        }
        _prepareMergeSplitButtonDropdown(e, t, n, i) {
          const r = this.editor, s = fn(i, il), a = "mergeTableCells", l = r.commands.get(a), d = this._fillDropdownWithListOptions(s, n);
          return s.buttonView.set({ label: e, icon: t, tooltip: !0, isEnabled: !0 }), s.bind("isEnabled").toMany([l, ...d], "isEnabled", (...h) => h.some((m) => m)), this.listenTo(s.buttonView, "execute", () => {
            r.execute(a), r.editing.view.focus();
          }), this.listenTo(s, "execute", (h) => {
            r.execute(h.source.commandName), r.editing.view.focus();
          }), s;
        }
        _fillDropdownWithListOptions(e, t) {
          const n = this.editor, i = [], r = new Vt();
          for (const s of t)
            _5(s, n, i, r);
          return rl(e, r), i;
        }
      }
      function _5(o, e, t, n) {
        if (o.type === "button" || o.type === "switchbutton") {
          const i = o.model = new bl(o.model), { commandName: r, bindIsOn: s } = o.model, a = e.commands.get(r);
          t.push(a), i.set({ commandName: r }), i.bind("isEnabled").to(a), s && i.bind("isOn").to(a, "value"), i.set({ withText: !0 });
        }
        n.add(o);
      }
      var Lb = k(6945), A5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Lb.Z, A5), Lb.Z.locals;
      class lo extends G {
        static get pluginName() {
          return "TableSelection";
        }
        static get requires() {
          return [wt, wt];
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view;
          this.listenTo(t, "deleteContent", (i, r) => this._handleDeleteContent(i, r), { priority: "high" }), this.listenTo(n.document, "insertText", (i, r) => this._handleInsertTextEvent(i, r), { priority: "high" }), this._defineSelectionConverter(), this._enablePluginDisabling();
        }
        getSelectedTableCells() {
          const e = this.editor.plugins.get(wt), t = this.editor.model.document.selection, n = e.getSelectedTableCells(t);
          return n.length == 0 ? null : n;
        }
        getSelectionAsFragment() {
          const e = this.editor.plugins.get(wt), t = this.getSelectedTableCells();
          return t ? this.editor.model.change((n) => {
            const i = n.createDocumentFragment(), { first: r, last: s } = e.getColumnIndexes(t), { first: a, last: l } = e.getRowIndexes(t), d = t[0].findAncestor("table");
            let h = l, m = s;
            if (e.isSelectionRectangular(t)) {
              const _ = { firstColumn: r, lastColumn: s, firstRow: a, lastRow: l };
              h = Tb(d, _), m = Pb(d, _);
            }
            const f = yb(d, { startRow: a, startColumn: r, endRow: h, endColumn: m }, n);
            return n.insert(f, i, 0), i;
          }) : null;
        }
        setCellSelection(e, t) {
          const n = this._getCellsToSelect(e, t);
          this.editor.model.change((i) => {
            i.setSelection(n.cells.map((r) => i.createRangeOn(r)), { backward: n.backward });
          });
        }
        getFocusCell() {
          const e = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
          return e && e.is("element", "tableCell") ? e : null;
        }
        getAnchorCell() {
          const e = it(this.editor.model.document.selection.getRanges()).getContainedElement();
          return e && e.is("element", "tableCell") ? e : null;
        }
        _defineSelectionConverter() {
          const e = this.editor, t = /* @__PURE__ */ new Set();
          e.conversion.for("editingDowncast").add((n) => n.on("selection", (i, r, s) => {
            const a = s.writer;
            (function(h) {
              for (const m of t)
                h.removeClass("ck-editor__editable_selected", m);
              t.clear();
            })(a);
            const l = this.getSelectedTableCells();
            if (!l)
              return;
            for (const h of l) {
              const m = s.mapper.toViewElement(h);
              a.addClass("ck-editor__editable_selected", m), t.add(m);
            }
            const d = s.mapper.toViewElement(l[l.length - 1]);
            a.setSelection(d, 0);
          }, { priority: "lowest" }));
        }
        _enablePluginDisabling() {
          const e = this.editor;
          this.on("change:isEnabled", () => {
            if (!this.isEnabled) {
              const t = this.getSelectedTableCells();
              if (!t)
                return;
              e.model.change((n) => {
                const i = n.createPositionAt(t[0], 0), r = e.model.schema.getNearestSelectionRange(i);
                n.setSelection(r);
              });
            }
          });
        }
        _handleDeleteContent(e, t) {
          const n = this.editor.plugins.get(wt), i = t[0], r = t[1], s = this.editor.model, a = !r || r.direction == "backward", l = n.getSelectedTableCells(i);
          l.length && (e.stop(), s.change((d) => {
            const h = l[a ? l.length - 1 : 0];
            s.change((f) => {
              for (const _ of l)
                s.deleteContent(f.createSelection(_, "in"));
            });
            const m = s.schema.getNearestSelectionRange(d.createPositionAt(h, 0));
            i.is("documentSelection") ? d.setSelection(m) : i.setTo(m);
          }));
        }
        _handleInsertTextEvent(e, t) {
          const n = this.editor, i = this.getSelectedTableCells();
          if (!i)
            return;
          const r = n.editing.view, s = n.editing.mapper, a = i.map((l) => r.createRangeOn(s.toViewElement(l)));
          t.selection = r.createSelection(a);
        }
        _getCellsToSelect(e, t) {
          const n = this.editor.plugins.get("TableUtils"), i = n.getCellLocation(e), r = n.getCellLocation(t), s = Math.min(i.row, r.row), a = Math.max(i.row, r.row), l = Math.min(i.column, r.column), d = Math.max(i.column, r.column), h = new Array(a - s + 1).fill(null).map(() => []), m = { startRow: s, endRow: a, startColumn: l, endColumn: d };
          for (const { row: E, cell: B } of new Re(e.findAncestor("table"), m))
            h[E - s].push(B);
          const f = r.row < i.row, _ = r.column < i.column;
          return f && h.reverse(), _ && h.forEach((E) => E.reverse()), { cells: h.flat(), backward: f || _ };
        }
      }
      class C5 extends G {
        static get pluginName() {
          return "TableClipboard";
        }
        static get requires() {
          return [lo, wt];
        }
        init() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "copy", (n, i) => this._onCopyCut(n, i)), this.listenTo(t, "cut", (n, i) => this._onCopyCut(n, i)), this.listenTo(e.model, "insertContent", (n, [i, r]) => this._onInsertContent(n, i, r), { priority: "high" }), this.decorate("_replaceTableSlotCell");
        }
        _onCopyCut(e, t) {
          const n = this.editor.plugins.get(lo);
          if (!n.getSelectedTableCells() || e.name == "cut" && !this.editor.model.canEditAt(this.editor.model.document.selection))
            return;
          t.preventDefault(), e.stop();
          const i = this.editor.data, r = this.editor.editing.view.document, s = i.toView(n.getSelectionAsFragment());
          r.fire("clipboardOutput", { dataTransfer: t.dataTransfer, content: s, method: e.name });
        }
        _onInsertContent(e, t, n) {
          if (n && !n.is("documentSelection"))
            return;
          const i = this.editor.model, r = this.editor.plugins.get(wt);
          let s = this.getTableIfOnlyTableInContent(t, i);
          if (!s)
            return;
          const a = r.getSelectionAffectedTableCells(i.document.selection);
          a.length ? (e.stop(), i.change((l) => {
            const d = { width: r.getColumns(s), height: r.getRows(s) }, h = function(T, O, N, H) {
              const X = T[0].findAncestor("table"), be = H.getColumnIndexes(T), Ge = H.getRowIndexes(T), Pe = { firstColumn: be.first, lastColumn: be.last, firstRow: Ge.first, lastRow: Ge.last }, _n = T.length === 1;
              return _n && (Pe.lastRow += O.height - 1, Pe.lastColumn += O.width - 1, function(Nt, _s, go, Mn) {
                const oi = Mn.getColumns(Nt), ii = Mn.getRows(Nt);
                go > oi && Mn.insertColumns(Nt, { at: oi, columns: go - oi }), _s > ii && Mn.insertRows(Nt, { at: ii, rows: _s - ii });
              }(X, Pe.lastRow + 1, Pe.lastColumn + 1, H)), _n || !H.isSelectionRectangular(T) ? function(Nt, _s, go) {
                const { firstRow: Mn, lastRow: oi, firstColumn: ii, lastColumn: _k } = _s, Ak = { first: Mn, last: oi }, Ck = { first: ii, last: _k };
                Ql(Nt, ii, Ak, go), Ql(Nt, _k + 1, Ak, go), Yl(Nt, Mn, Ck, go), Yl(Nt, oi + 1, Ck, go, Mn);
              }(X, Pe, N) : (Pe.lastRow = Tb(X, Pe), Pe.lastColumn = Pb(X, Pe)), Pe;
            }(a, d, l, r), m = h.lastRow - h.firstRow + 1, f = h.lastColumn - h.firstColumn + 1, _ = { startRow: 0, startColumn: 0, endRow: Math.min(m, d.height) - 1, endColumn: Math.min(f, d.width) - 1 };
            s = yb(s, _, l);
            const E = a[0].findAncestor("table"), B = this._replaceSelectedCellsWithPasted(s, d, E, h, l);
            if (this.editor.plugins.get("TableSelection").isEnabled) {
              const T = r.sortRanges(B.map((O) => l.createRangeOn(O)));
              l.setSelection(T);
            } else
              l.setSelection(B[0], 0);
          })) : Kl(s, r);
        }
        _replaceSelectedCellsWithPasted(e, t, n, i, r) {
          const { width: s, height: a } = t, l = function(T, O, N) {
            const H = new Array(N).fill(null).map(() => new Array(O).fill(null));
            for (const { column: X, row: be, cell: Ge } of new Re(T))
              H[be][X] = Ge;
            return H;
          }(e, s, a), d = [...new Re(n, { startRow: i.firstRow, endRow: i.lastRow, startColumn: i.firstColumn, endColumn: i.lastColumn, includeAllSlots: !0 })], h = [];
          let m;
          for (const T of d) {
            const { row: O, column: N } = T;
            N === i.firstColumn && (m = T.getPositionBefore());
            const H = O - i.firstRow, X = N - i.firstColumn, be = l[H % a][X % s], Ge = be ? r.cloneElement(be) : null, Pe = this._replaceTableSlotCell(T, Ge, m, r);
            Pe && (Bb(Pe, O, N, i.lastRow, i.lastColumn, r), h.push(Pe), m = r.createPositionAfter(Pe));
          }
          const f = parseInt(n.getAttribute("headingRows") || "0"), _ = parseInt(n.getAttribute("headingColumns") || "0"), E = i.firstRow < f && f <= i.lastRow, B = i.firstColumn < _ && _ <= i.lastColumn;
          if (E) {
            const T = Yl(n, f, { first: i.firstColumn, last: i.lastColumn }, r, i.firstRow);
            h.push(...T);
          }
          if (B) {
            const T = Ql(n, _, { first: i.firstRow, last: i.lastRow }, r);
            h.push(...T);
          }
          return h;
        }
        _replaceTableSlotCell(e, t, n, i) {
          const { cell: r, isAnchor: s } = e;
          return s && i.remove(r), t ? (i.insert(t, n), t) : null;
        }
        getTableIfOnlyTableInContent(e, t) {
          if (!e.is("documentFragment") && !e.is("element"))
            return null;
          if (e.is("element", "table"))
            return e;
          if (e.childCount == 1 && e.getChild(0).is("element", "table"))
            return e.getChild(0);
          const n = t.createRangeIn(e);
          for (const i of n.getItems())
            if (i.is("element", "table")) {
              const r = t.createRange(n.start, t.createPositionBefore(i));
              if (t.hasContent(r, { ignoreWhitespaces: !0 }))
                return null;
              const s = t.createRange(t.createPositionAfter(i), n.end);
              return t.hasContent(s, { ignoreWhitespaces: !0 }) ? null : i;
            }
          return null;
        }
      }
      function Yl(o, e, t, n, i = 0) {
        if (!(e < 1))
          return Eb(o, e, i).filter(({ column: r, cellWidth: s }) => Vb(r, s, t)).map(({ cell: r }) => xb(r, e, n));
      }
      function Ql(o, e, t, n) {
        if (!(e < 1))
          return Sb(o, e).filter(({ row: i, cellHeight: r }) => Vb(i, r, t)).map(({ cell: i, column: r }) => Db(i, r, e, n));
      }
      function Vb(o, e, t) {
        const n = o + e - 1, { first: i, last: r } = t;
        return o >= i && o <= r || o < i && n >= i;
      }
      class y5 extends G {
        static get pluginName() {
          return "TableKeyboard";
        }
        static get requires() {
          return [lo, wt];
        }
        init() {
          const e = this.editor.editing.view.document;
          this.listenTo(e, "arrowKey", (...t) => this._onArrowKey(...t), { context: "table" }), this.listenTo(e, "tab", (...t) => this._handleTabOnSelectedTable(...t), { context: "figure" }), this.listenTo(e, "tab", (...t) => this._handleTab(...t), { context: ["th", "td"] });
        }
        _handleTabOnSelectedTable(e, t) {
          const n = this.editor, i = n.model.document.selection.getSelectedElement();
          i && i.is("element", "table") && (t.preventDefault(), t.stopPropagation(), e.stop(), n.model.change((r) => {
            r.setSelection(r.createRangeIn(i.getChild(0).getChild(0)));
          }));
        }
        _handleTab(e, t) {
          const n = this.editor, i = this.editor.plugins.get(wt), r = this.editor.plugins.get("TableSelection"), s = n.model.document.selection, a = !t.shiftKey;
          let l = i.getTableCellsContainingSelection(s)[0];
          if (l || (l = r.getFocusCell()), !l)
            return;
          t.preventDefault(), t.stopPropagation(), e.stop();
          const d = l.parent, h = d.parent, m = h.getChildIndex(d), f = d.getChildIndex(l), _ = f === 0;
          if (!a && _ && m === 0)
            return void n.model.change((O) => {
              O.setSelection(O.createRangeOn(h));
            });
          const E = f === d.childCount - 1, B = m === i.getRows(h) - 1;
          if (a && B && E && (n.execute("insertTableRowBelow"), m === i.getRows(h) - 1))
            return void n.model.change((O) => {
              O.setSelection(O.createRangeOn(h));
            });
          let T;
          if (a && E)
            T = h.getChild(m + 1).getChild(0);
          else if (!a && _) {
            const O = h.getChild(m - 1);
            T = O.getChild(O.childCount - 1);
          } else
            T = d.getChild(f + (a ? 1 : -1));
          n.model.change((O) => {
            O.setSelection(O.createRangeIn(T));
          });
        }
        _onArrowKey(e, t) {
          const n = this.editor, i = da(t.keyCode, n.locale.contentLanguageDirection);
          this._handleArrowKeys(i, t.shiftKey) && (t.preventDefault(), t.stopPropagation(), e.stop());
        }
        _handleArrowKeys(e, t) {
          const n = this.editor.plugins.get(wt), i = this.editor.plugins.get("TableSelection"), r = this.editor.model, s = r.document.selection, a = ["right", "down"].includes(e), l = n.getSelectedTableCells(s);
          if (l.length) {
            let h;
            return h = t ? i.getFocusCell() : a ? l[l.length - 1] : l[0], this._navigateFromCellInDirection(h, e, t), !0;
          }
          const d = s.focus.findAncestor("tableCell");
          if (!d)
            return !1;
          if (!s.isCollapsed)
            if (t) {
              if (s.isBackward == a && !s.containsEntireContent(d))
                return !1;
            } else {
              const h = s.getSelectedElement();
              if (!h || !r.schema.isObject(h))
                return !1;
            }
          return !!this._isSelectionAtCellEdge(s, d, a) && (this._navigateFromCellInDirection(d, e, t), !0);
        }
        _isSelectionAtCellEdge(e, t, n) {
          const i = this.editor.model, r = this.editor.model.schema, s = n ? e.getLastPosition() : e.getFirstPosition();
          if (!r.getLimitElement(s).is("element", "tableCell"))
            return i.createPositionAt(t, n ? "end" : 0).isTouching(s);
          const a = i.createSelection(s);
          return i.modifySelection(a, { direction: n ? "forward" : "backward" }), s.isEqual(a.focus);
        }
        _navigateFromCellInDirection(e, t, n = !1) {
          const i = this.editor.model, r = e.findAncestor("table"), s = [...new Re(r, { includeAllSlots: !0 })], { row: a, column: l } = s[s.length - 1], d = s.find(({ cell: B }) => B == e);
          let { row: h, column: m } = d;
          switch (t) {
            case "left":
              m--;
              break;
            case "up":
              h--;
              break;
            case "right":
              m += d.cellWidth;
              break;
            case "down":
              h += d.cellHeight;
          }
          if (h < 0 || h > a || m < 0 && h <= 0 || m > l && h >= a)
            return void i.change((B) => {
              B.setSelection(B.createRangeOn(r));
            });
          m < 0 ? (m = n ? 0 : l, h--) : m > l && (m = n ? l : 0, h++);
          const f = s.find((B) => B.row == h && B.column == m).cell, _ = ["right", "down"].includes(t), E = this.editor.plugins.get("TableSelection");
          if (n && E.isEnabled) {
            const B = E.getAnchorCell() || e;
            E.setCellSelection(B, f);
          } else {
            const B = i.createPositionAt(f, _ ? 0 : "end");
            i.change((T) => {
              T.setSelection(B);
            });
          }
        }
      }
      class E5 extends Tn {
        constructor() {
          super(...arguments), this.domEventType = ["mousemove", "mouseleave"];
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
      }
      class x5 extends G {
        static get pluginName() {
          return "TableMouse";
        }
        static get requires() {
          return [lo, wt];
        }
        init() {
          this.editor.editing.view.addObserver(E5), this._enableShiftClickSelection(), this._enableMouseDragSelection();
        }
        _enableShiftClickSelection() {
          const e = this.editor, t = e.plugins.get(wt);
          let n = !1;
          const i = e.plugins.get(lo);
          this.listenTo(e.editing.view.document, "mousedown", (r, s) => {
            const a = e.model.document.selection;
            if (!this.isEnabled || !i.isEnabled || !s.domEvent.shiftKey)
              return;
            const l = i.getAnchorCell() || t.getTableCellsContainingSelection(a)[0];
            if (!l)
              return;
            const d = this._getModelTableCellFromDomEvent(s);
            d && jb(l, d) && (n = !0, i.setCellSelection(l, d), s.preventDefault());
          }), this.listenTo(e.editing.view.document, "mouseup", () => {
            n = !1;
          }), this.listenTo(e.editing.view.document, "selectionChange", (r) => {
            n && r.stop();
          }, { priority: "highest" });
        }
        _enableMouseDragSelection() {
          const e = this.editor;
          let t, n, i = !1, r = !1;
          const s = e.plugins.get(lo);
          this.listenTo(e.editing.view.document, "mousedown", (a, l) => {
            this.isEnabled && s.isEnabled && (l.domEvent.shiftKey || l.domEvent.ctrlKey || l.domEvent.altKey || (t = this._getModelTableCellFromDomEvent(l)));
          }), this.listenTo(e.editing.view.document, "mousemove", (a, l) => {
            if (!l.domEvent.buttons || !t)
              return;
            const d = this._getModelTableCellFromDomEvent(l);
            d && jb(t, d) && (n = d, i || n == t || (i = !0)), i && (r = !0, s.setCellSelection(t, n), l.preventDefault());
          }), this.listenTo(e.editing.view.document, "mouseup", () => {
            i = !1, r = !1, t = null, n = null;
          }), this.listenTo(e.editing.view.document, "selectionChange", (a) => {
            r && a.stop();
          }, { priority: "highest" });
        }
        _getModelTableCellFromDomEvent(e) {
          const t = e.target, n = this.editor.editing.view.createPositionAt(t, 0);
          return this.editor.editing.mapper.toModelPosition(n).parent.findAncestor("tableCell", { includeSelf: !0 });
        }
      }
      function jb(o, e) {
        return o.parent.parent == e.parent.parent;
      }
      var Hb = k(6306), S5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Hb.Z, S5), Hb.Z.locals;
      function D5(o) {
        const e = o.getSelectedElement();
        return e && Ub(e) ? e : null;
      }
      function B5(o) {
        const e = o.getFirstPosition();
        if (!e)
          return null;
        let t = e.parent;
        for (; t; ) {
          if (t.is("element") && Ub(t))
            return t;
          t = t.parent;
        }
        return null;
      }
      function Ub(o) {
        return !!o.getCustomProperty("table") && Je(o);
      }
      var qb = k(7368), T5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(qb.Z, T5), qb.Z.locals;
      var Wb = k(9247), P5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Wb.Z, P5), Wb.Z.locals;
      var Gb = k(4070), I5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Gb.Z, I5), Gb.Z.locals;
      var Kb = k(6237), O5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Kb.Z, O5), Kb.Z.locals;
      var Zb = k(5087), R5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Zb.Z, R5), Zb.Z.locals;
      const co = St.defaultPositions;
      co.northArrowSouth, co.northArrowSouthWest, co.northArrowSouthEast, co.southArrowNorth, co.southArrowNorthWest, co.southArrowNorthEast, co.viewportStickyNorth;
      var Jb = k(7341), z5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Jb.Z, z5), Jb.Z.locals;
      var Yb = k(2128), M5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Yb.Z, M5), Yb.Z.locals;
      var Qb = k(4101), N5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Qb.Z, N5), Qb.Z.locals;
      var F5 = Object.defineProperty, Xb = Object.getOwnPropertySymbols, $5 = Object.prototype.hasOwnProperty, L5 = Object.prototype.propertyIsEnumerable, ek = (o, e, t) => e in o ? F5(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, tk = (o, e) => {
        for (var t in e || (e = {}))
          $5.call(e, t) && ek(o, t, e[t]);
        if (Xb)
          for (var t of Xb(e))
            L5.call(e, t) && ek(o, t, e[t]);
        return o;
      };
      const V5 = { autoRefresh: !0 }, nk = 36e5;
      class Xl extends oe() {
        constructor(e, t = {}) {
          if (super(), !e)
            throw new I("token-missing-token-url", this);
          t.initValue && this._validateTokenValue(t.initValue), this.set("value", t.initValue), this._refresh = typeof e == "function" ? e : () => {
            return n = e, new Promise((i, r) => {
              const s = new XMLHttpRequest();
              s.open("GET", n), s.addEventListener("load", () => {
                const a = s.status, l = s.response;
                return a < 200 || a > 299 ? r(new I("token-cannot-download-new-token", null)) : i(l);
              }), s.addEventListener("error", () => r(new Error("Network Error"))), s.addEventListener("abort", () => r(new Error("Abort"))), s.send();
            });
            var n;
          }, this._options = tk(tk({}, V5), t);
        }
        init() {
          return new Promise((e, t) => {
            this.value ? (this._options.autoRefresh && this._registerRefreshTokenTimeout(), e(this)) : this.refreshToken().then(e).catch(t);
          });
        }
        refreshToken() {
          return this._refresh().then((e) => (this._validateTokenValue(e), this.set("value", e), this._options.autoRefresh && this._registerRefreshTokenTimeout(), this));
        }
        destroy() {
          clearTimeout(this._tokenRefreshTimeout);
        }
        _validateTokenValue(e) {
          const t = typeof e == "string", n = !/^".*"$/.test(e), i = t && e.split(".").length === 3;
          if (!n || !i)
            throw new I("token-not-in-jwt-format", this);
        }
        _registerRefreshTokenTimeout() {
          const e = this._getTokenRefreshTimeoutTime();
          clearTimeout(this._tokenRefreshTimeout), this._tokenRefreshTimeout = setTimeout(() => {
            this.refreshToken();
          }, e);
        }
        _getTokenRefreshTimeoutTime() {
          try {
            const [, e] = this.value.split("."), { exp: t } = JSON.parse(atob(e));
            return t ? Math.floor((1e3 * t - Date.now()) / 2) : nk;
          } catch {
            return nk;
          }
        }
        static create(e, t = {}) {
          return new Xl(e, t).init();
        }
      }
      const ec = /^data:(\S*?);base64,/;
      class j5 extends De() {
        constructor(e, t, n) {
          if (super(), !e)
            throw new I("fileuploader-missing-file", null);
          if (!t)
            throw new I("fileuploader-missing-token", null);
          if (!n)
            throw new I("fileuploader-missing-api-address", null);
          this.file = function(i) {
            if (typeof i != "string")
              return !1;
            const r = i.match(ec);
            return !(!r || !r.length);
          }(e) ? function(i, r = 512) {
            try {
              const s = i.match(ec)[1], a = atob(i.replace(ec, "")), l = [];
              for (let d = 0; d < a.length; d += r) {
                const h = a.slice(d, d + r), m = new Array(h.length);
                for (let f = 0; f < h.length; f++)
                  m[f] = h.charCodeAt(f);
                l.push(new Uint8Array(m));
              }
              return new Blob(l, { type: s });
            } catch {
              throw new I("fileuploader-decoding-image-data-error", null);
            }
          }(e) : e, this._token = t, this._apiAddress = n;
        }
        onProgress(e) {
          return this.on("progress", (t, n) => e(n)), this;
        }
        onError(e) {
          return this.once("error", (t, n) => e(n)), this;
        }
        abort() {
          this.xhr.abort();
        }
        send() {
          return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest();
        }
        _prepareRequest() {
          const e = new XMLHttpRequest();
          e.open("POST", this._apiAddress), e.setRequestHeader("Authorization", this._token.value), e.responseType = "json", this.xhr = e;
        }
        _attachXHRListeners() {
          const e = this.xhr, t = (n) => () => this.fire("error", n);
          e.addEventListener("error", t("Network Error")), e.addEventListener("abort", t("Abort")), e.upload && e.upload.addEventListener("progress", (n) => {
            n.lengthComputable && this.fire("progress", { total: n.total, uploaded: n.loaded });
          }), e.addEventListener("load", () => {
            const n = e.status, i = e.response;
            if (n < 200 || n > 299)
              return this.fire("error", i.message || i.error);
          });
        }
        _sendRequest() {
          const e = new FormData(), t = this.xhr;
          return e.append("file", this.file), new Promise((n, i) => {
            t.addEventListener("load", () => {
              const r = t.status, s = t.response;
              return r < 200 || r > 299 ? s.message ? i(new I("fileuploader-uploading-data-failed", this, { message: s.message })) : i(s.error) : n(s);
            }), t.addEventListener("error", () => i(new Error("Network Error"))), t.addEventListener("abort", () => i(new Error("Abort"))), t.send(e);
          });
        }
      }
      class H5 {
        constructor(e, t) {
          if (!e)
            throw new I("uploadgateway-missing-token", null);
          if (!t)
            throw new I("uploadgateway-missing-api-address", null);
          this._token = e, this._apiAddress = t;
        }
        upload(e) {
          return new j5(e, this._token, this._apiAddress);
        }
      }
      class U5 extends Pr {
        static get pluginName() {
          return "CloudServicesCore";
        }
        createToken(e, t) {
          return new Xl(e, t);
        }
        createUploadGateway(e, t) {
          return new H5(e, t);
        }
      }
      var ok = (o, e, t) => new Promise((n, i) => {
        var r = (l) => {
          try {
            a(t.next(l));
          } catch (d) {
            i(d);
          }
        }, s = (l) => {
          try {
            a(t.throw(l));
          } catch (d) {
            i(d);
          }
        }, a = (l) => l.done ? n(l.value) : Promise.resolve(l.value).then(r, s);
        a((t = t.apply(o, e)).next());
      });
      const tc = ["left", "right", "center", "justify"];
      function ik(o) {
        return tc.includes(o);
      }
      function rk(o, e) {
        return e.contentLanguageDirection == "rtl" ? o === "right" : o === "left";
      }
      function sk(o) {
        const e = o.map((n) => {
          let i;
          return i = typeof n == "string" ? { name: n } : n, i;
        }).filter((n) => {
          const i = tc.includes(n.name);
          return i || ne("alignment-config-name-not-recognized", { option: n }), i;
        }), t = e.filter((n) => !!n.className).length;
        if (t && t < e.length)
          throw new I("alignment-config-classnames-are-missing", { configuredOptions: o });
        return e.forEach((n, i, r) => {
          const s = r.slice(i + 1);
          if (s.some((a) => a.name == n.name))
            throw new I("alignment-config-name-already-defined", { option: n, configuredOptions: o });
          if (n.className && s.some((a) => a.className == n.className))
            throw new I("alignment-config-classname-already-defined", { option: n, configuredOptions: o });
        }), e;
      }
      const nc = "alignment";
      class q5 extends pe {
        refresh() {
          const e = this.editor.locale, t = it(this.editor.model.document.selection.getSelectedBlocks());
          this.isEnabled = !!t && this._canBeAligned(t), this.isEnabled && t.hasAttribute("alignment") ? this.value = t.getAttribute("alignment") : this.value = e.contentLanguageDirection === "rtl" ? "right" : "left";
        }
        execute(e = {}) {
          const t = this.editor, n = t.locale, i = t.model, r = i.document, s = e.value;
          i.change((a) => {
            const l = Array.from(r.selection.getSelectedBlocks()).filter((h) => this._canBeAligned(h)), d = l[0].getAttribute("alignment");
            rk(s, n) || d === s || !s ? function(h, m) {
              for (const f of h)
                m.removeAttribute(nc, f);
            }(l, a) : function(h, m, f) {
              for (const _ of h)
                m.setAttribute(nc, f, _);
            }(l, a, s);
          });
        }
        _canBeAligned(e) {
          return this.editor.model.schema.checkAttribute(e, nc);
        }
      }
      class W5 extends G {
        static get pluginName() {
          return "AlignmentEditing";
        }
        constructor(e) {
          super(e), e.config.define("alignment", { options: tc.map((t) => ({ name: t })) });
        }
        init() {
          const e = this.editor, t = e.locale, n = e.model.schema, i = sk(e.config.get("alignment.options")).filter((l) => ik(l.name) && !rk(l.name, t)), r = i.some((l) => !!l.className);
          n.extend("$block", { allowAttributes: "alignment" }), e.model.schema.setAttributeProperties("alignment", { isFormatting: !0 }), r ? e.conversion.attributeToAttribute(function(l) {
            const d = {};
            for (const m of l)
              d[m.name] = { key: "class", value: m.className };
            return { model: { key: "alignment", values: l.map((m) => m.name) }, view: d };
          }(i)) : e.conversion.for("downcast").attributeToAttribute(function(l) {
            const d = {};
            for (const { name: m } of l)
              d[m] = { key: "style", value: { "text-align": m } };
            return { model: { key: "alignment", values: l.map((m) => m.name) }, view: d };
          }(i));
          const s = function(l) {
            const d = [];
            for (const { name: h } of l)
              d.push({ view: { key: "style", value: { "text-align": h } }, model: { key: "alignment", value: h } });
            return d;
          }(i);
          for (const l of s)
            e.conversion.for("upcast").attributeToAttribute(l);
          const a = function(l) {
            const d = [];
            for (const { name: h } of l)
              d.push({ view: { key: "align", value: h }, model: { key: "alignment", value: h } });
            return d;
          }(i);
          for (const l of a)
            e.conversion.for("upcast").attributeToAttribute(l);
          e.commands.add("alignment", new q5(e));
        }
      }
      const fs = /* @__PURE__ */ new Map([["left", qe.alignLeft], ["right", qe.alignRight], ["center", qe.alignCenter], ["justify", qe.alignJustify]]);
      class G5 extends G {
        get localizedOptionTitles() {
          const e = this.editor.t;
          return { left: e("Align left"), right: e("Align right"), center: e("Align center"), justify: e("Justify") };
        }
        static get pluginName() {
          return "AlignmentUI";
        }
        init() {
          const e = this.editor, t = e.ui.componentFactory, n = e.t, i = sk(e.config.get("alignment.options"));
          i.map((r) => r.name).filter(ik).forEach((r) => this._addButton(r)), t.add("alignment", (r) => {
            const s = fn(r);
            Yr(s, () => i.map((d) => t.create(`alignment:${d.name}`)), { enableActiveItemFocusOnDropdownOpen: !0, isVertical: !0, ariaLabel: n("Text alignment toolbar") }), s.buttonView.set({ label: n("Text alignment"), tooltip: !0 }), s.extendTemplate({ attributes: { class: "ck-alignment-dropdown" } });
            const a = r.contentLanguageDirection === "rtl" ? fs.get("right") : fs.get("left"), l = e.commands.get("alignment");
            return s.buttonView.bind("icon").to(l, "value", (d) => fs.get(d) || a), s.bind("isEnabled").to(l, "isEnabled"), this.listenTo(s, "execute", () => {
              e.editing.view.focus();
            }), s;
          });
        }
        _addButton(e) {
          const t = this.editor;
          t.ui.componentFactory.add(`alignment:${e}`, (n) => {
            const i = t.commands.get("alignment"), r = new je(n);
            return r.set({ label: this.localizedOptionTitles[e], icon: fs.get(e), tooltip: !0, isToggleable: !0 }), r.bind("isEnabled").to(i), r.bind("isOn").to(i, "value", (s) => s === e), this.listenTo(r, "execute", () => {
              t.execute("alignment", { value: e }), t.editing.view.focus();
            }), r;
          });
        }
      }
      function K5(o) {
        const e = [{ name: "address", isVoid: !1 }, { name: "article", isVoid: !1 }, { name: "aside", isVoid: !1 }, { name: "blockquote", isVoid: !1 }, { name: "br", isVoid: !0 }, { name: "details", isVoid: !1 }, { name: "dialog", isVoid: !1 }, { name: "dd", isVoid: !1 }, { name: "div", isVoid: !1 }, { name: "dl", isVoid: !1 }, { name: "dt", isVoid: !1 }, { name: "fieldset", isVoid: !1 }, { name: "figcaption", isVoid: !1 }, { name: "figure", isVoid: !1 }, { name: "footer", isVoid: !1 }, { name: "form", isVoid: !1 }, { name: "h1", isVoid: !1 }, { name: "h2", isVoid: !1 }, { name: "h3", isVoid: !1 }, { name: "h4", isVoid: !1 }, { name: "h5", isVoid: !1 }, { name: "h6", isVoid: !1 }, { name: "header", isVoid: !1 }, { name: "hgroup", isVoid: !1 }, { name: "hr", isVoid: !0 }, { name: "input", isVoid: !0 }, { name: "li", isVoid: !1 }, { name: "main", isVoid: !1 }, { name: "nav", isVoid: !1 }, { name: "ol", isVoid: !1 }, { name: "p", isVoid: !1 }, { name: "section", isVoid: !1 }, { name: "table", isVoid: !1 }, { name: "tbody", isVoid: !1 }, { name: "td", isVoid: !1 }, { name: "textarea", isVoid: !1 }, { name: "th", isVoid: !1 }, { name: "thead", isVoid: !1 }, { name: "tr", isVoid: !1 }, { name: "ul", isVoid: !1 }], t = e.map((r) => r.name).join("|"), n = o.replace(new RegExp(`</?(${t})( .*?)?>`, "g"), `
$&
`).split(`
`);
        let i = 0;
        return n.filter((r) => r.length).map((r) => function(s, a) {
          return a.some((l) => !l.isVoid && !!new RegExp(`<${l.name}( .*?)?>`).test(s));
        }(r, e) ? oc(r, i++) : function(s, a) {
          return a.some((l) => new RegExp(`</${l.name}>`).test(s));
        }(r, e) ? oc(r, --i) : oc(r, i)).join(`
`);
      }
      function oc(o, e, t = "    ") {
        return `${t.repeat(Math.max(0, e))}${o}`;
      }
      var ak = k(2896), Z5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(ak.Z, Z5), ak.Z.locals;
      const lk = "SourceEditingMode";
      function J5(o) {
        return function(e) {
          return e.startsWith("<");
        }(o) ? K5(o) : o;
      }
      const ic = "removeFormat";
      class Y5 extends G {
        static get pluginName() {
          return "RemoveFormatUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(ic, (n) => {
            const i = e.commands.get(ic), r = new je(n);
            return r.set({ label: t("Remove Format"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>', tooltip: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(ic), e.editing.view.focus();
            }), r;
          });
        }
      }
      class Q5 extends pe {
        refresh() {
          const e = this.editor.model;
          this.isEnabled = !!it(this._getFormattingItems(e.document.selection, e.schema));
        }
        execute() {
          const e = this.editor.model, t = e.schema;
          e.change((n) => {
            for (const i of this._getFormattingItems(e.document.selection, t))
              if (i.is("selection"))
                for (const r of this._getFormattingAttributes(i, t))
                  n.removeSelectionAttribute(r);
              else {
                const r = n.createRangeOn(i);
                for (const s of this._getFormattingAttributes(i, t))
                  n.removeAttribute(s, r);
              }
          });
        }
        *_getFormattingItems(e, t) {
          const n = (i) => !!it(this._getFormattingAttributes(i, t));
          for (const i of e.getRanges())
            for (const r of i.getItems())
              !t.isBlock(r) && n(r) && (yield r);
          for (const i of e.getSelectedBlocks())
            n(i) && (yield i);
          n(e) && (yield e);
        }
        *_getFormattingAttributes(e, t) {
          for (const [n] of e.getAttributes()) {
            const i = t.getAttributeProperties(n);
            i && i.isFormatting && (yield n);
          }
        }
      }
      class X5 extends G {
        static get pluginName() {
          return "RemoveFormatEditing";
        }
        init() {
          const e = this.editor;
          e.commands.add("removeFormat", new Q5(e));
        }
      }
      var eS = Object.defineProperty, ck = Object.getOwnPropertySymbols, tS = Object.prototype.hasOwnProperty, nS = Object.prototype.propertyIsEnumerable, dk = (o, e, t) => e in o ? eS(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, uk = (o, e) => {
        for (var t in e || (e = {}))
          tS.call(e, t) && dk(o, t, e[t]);
        if (ck)
          for (var t of ck(e))
            nS.call(e, t) && dk(o, t, e[t]);
        return o;
      };
      function uo(o, e, t, n) {
        e && function(i, r, s) {
          if (r.attributes)
            for (const [a] of Object.entries(r.attributes))
              i.removeAttribute(a, s);
          if (r.styles)
            for (const a of Object.keys(r.styles))
              i.removeStyle(a, s);
          r.classes && i.removeClass(r.classes, s);
        }(o, e, n), t && zn(o, t, n);
      }
      function zn(o, e, t) {
        if (e.attributes)
          for (const [n, i] of Object.entries(e.attributes))
            o.setAttribute(n, i, t);
        e.styles && o.setStyle(e.styles, t), e.classes && o.addClass(e.classes, t);
      }
      function oS(o, e) {
        const t = In(o);
        let n = "attributes";
        for (n in e)
          t[n] = n == "classes" ? Array.from(/* @__PURE__ */ new Set([...o[n] || [], ...e[n]])) : uk(uk({}, o[n]), e[n]);
        return t;
      }
      function ho(o, e, t, n, i) {
        const r = e.getAttribute(t), s = {};
        for (const a of ["attributes", "styles", "classes"]) {
          if (a != n) {
            r && r[a] && (s[a] = r[a]);
            continue;
          }
          if (n == "classes") {
            const d = new Set(r && r.classes || []);
            i(d), d.size && (s[a] = Array.from(d));
            continue;
          }
          const l = new Map(Object.entries(r && r[a] || {}));
          i(l), l.size && (s[a] = Object.fromEntries(l));
        }
        Object.keys(s).length ? e.is("documentSelection") ? o.setSelectionAttribute(t, s) : o.setAttribute(t, s, e) : r && (e.is("documentSelection") ? o.removeSelectionAttribute(t) : o.removeAttribute(t, e));
      }
      function rc({ model: o }) {
        return (e, t) => t.writer.createElement(o, { htmlContent: e.getCustomProperty("$rawContent") });
      }
      function iS(o, { view: e, isInline: t }) {
        const n = o.t;
        return (i, { writer: r }) => {
          const s = n("HTML object"), a = bs(e, i, r), l = i.getAttribute("htmlAttributes");
          return r.addClass("html-object-embed__content", a), l && zn(r, l, a), yl(r.createContainerElement(t ? "span" : "div", { class: "html-object-embed", "data-html-object-embed-label": s }, a), r, { label: s });
        };
      }
      function bs(o, e, t) {
        return t.createRawElement(o, null, (n, i) => {
          i.setContentOf(n, e.getAttribute("htmlContent"));
        });
      }
      function rS({ priority: o, view: e }) {
        return (t, n) => {
          if (!t)
            return;
          const { writer: i } = n, r = i.createAttributeElement(e, null, { priority: o });
          return zn(i, t, r), r;
        };
      }
      function Ki({ view: o }, e) {
        return (t) => {
          t.on(`element:${o}`, (n, i, r) => {
            if (!i.modelRange || i.modelRange.isCollapsed)
              return;
            const s = e.processViewAttributes(i.viewItem, r);
            s && r.writer.setAttribute("htmlAttributes", s, i.modelRange);
          }, { priority: "low" });
        };
      }
      function Zi({ model: o }) {
        return (e) => {
          e.on(`attribute:htmlAttributes:${o}`, (t, n, i) => {
            if (!i.consumable.consume(n.item, t.name))
              return;
            const { attributeOldValue: r, attributeNewValue: s } = n;
            uo(i.writer, r, s, i.mapper.toViewElement(n.item));
          });
        };
      }
      const sS = [{ model: "codeBlock", view: "pre" }, { model: "paragraph", view: "p" }, { model: "blockQuote", view: "blockquote" }, { model: "listItem", view: "li" }, { model: "pageBreak", view: "div" }, { model: "rawHtml", view: "div" }, { model: "table", view: "table" }, { model: "tableRow", view: "tr" }, { model: "tableCell", view: "td" }, { model: "tableCell", view: "th" }, { model: "tableColumnGroup", view: "colgroup" }, { model: "tableColumn", view: "col" }, { model: "caption", view: "caption" }, { model: "caption", view: "figcaption" }, { model: "imageBlock", view: "img" }, { model: "imageInline", view: "img" }, { model: "htmlP", view: "p", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlBlockquote", view: "blockquote", modelSchema: { inheritAllFrom: "$container" } }, { model: "htmlTable", view: "table", modelSchema: { allowWhere: "$block", isBlock: !0 } }, { model: "htmlTbody", view: "tbody", modelSchema: { allowIn: "htmlTable", isBlock: !1 } }, { model: "htmlThead", view: "thead", modelSchema: { allowIn: "htmlTable", isBlock: !1 } }, { model: "htmlTfoot", view: "tfoot", modelSchema: { allowIn: "htmlTable", isBlock: !1 } }, { model: "htmlCaption", view: "caption", modelSchema: { allowIn: "htmlTable", allowChildren: "$text", isBlock: !1 } }, { model: "htmlColgroup", view: "colgroup", modelSchema: { allowIn: "htmlTable", allowChildren: "col", isBlock: !1 } }, { model: "htmlCol", view: "col", modelSchema: { allowIn: "htmlColgroup", isBlock: !1 } }, { model: "htmlTr", view: "tr", modelSchema: { allowIn: ["htmlTable", "htmlThead", "htmlTbody"], isLimit: !0 } }, { model: "htmlTd", view: "td", modelSchema: { allowIn: "htmlTr", allowContentOf: "$container", isLimit: !0, isBlock: !1 } }, { model: "htmlTh", view: "th", modelSchema: { allowIn: "htmlTr", allowContentOf: "$container", isLimit: !0, isBlock: !1 } }, { model: "htmlFigure", view: "figure", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlFigcaption", view: "figcaption", modelSchema: { allowIn: "htmlFigure", allowChildren: "$text", isBlock: !1 } }, { model: "htmlAddress", view: "address", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlAside", view: "aside", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlMain", view: "main", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlDetails", view: "details", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlSummary", view: "summary", modelSchema: { allowChildren: "$text", allowIn: "htmlDetails", isBlock: !1 } }, { model: "htmlDiv", view: "div", paragraphLikeModel: "htmlDivParagraph", modelSchema: { inheritAllFrom: "$container" } }, { model: "htmlFieldset", view: "fieldset", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlLegend", view: "legend", modelSchema: { allowIn: "htmlFieldset", allowChildren: "$text" } }, { model: "htmlHeader", view: "header", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlFooter", view: "footer", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlForm", view: "form", modelSchema: { inheritAllFrom: "$container", isBlock: !0 } }, { model: "htmlHgroup", view: "hgroup", modelSchema: { allowChildren: ["htmlH1", "htmlH2", "htmlH3", "htmlH4", "htmlH5", "htmlH6"], isBlock: !1 } }, { model: "htmlH1", view: "h1", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH2", view: "h2", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH3", view: "h3", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH4", view: "h4", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH5", view: "h5", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH6", view: "h6", modelSchema: { inheritAllFrom: "$block" } }, { model: "$htmlList", modelSchema: { allowWhere: "$container", allowChildren: ["$htmlList", "htmlLi"], isBlock: !1 } }, { model: "htmlDir", view: "dir", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlMenu", view: "menu", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlUl", view: "ul", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlOl", view: "ol", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlLi", view: "li", modelSchema: { allowIn: "$htmlList", allowChildren: "$text", isBlock: !1 } }, { model: "htmlPre", view: "pre", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlArticle", view: "article", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlSection", view: "section", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlNav", view: "nav", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlDivDl", view: "div", modelSchema: { allowChildren: ["htmlDt", "htmlDd"], allowIn: "htmlDl" } }, { model: "htmlDl", view: "dl", modelSchema: { allowWhere: "$container", allowChildren: ["htmlDt", "htmlDd", "htmlDivDl"], isBlock: !1 } }, { model: "htmlDt", view: "dt", modelSchema: { allowChildren: "$block", isBlock: !1 } }, { model: "htmlDd", view: "dd", modelSchema: { allowChildren: "$block", isBlock: !1 } }, { model: "htmlCenter", view: "center", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }], aS = [{ model: "htmlLiAttributes", view: "li", appliesToBlock: !0 }, { model: "htmlListAttributes", view: "ol", appliesToBlock: !0 }, { model: "htmlListAttributes", view: "ul", appliesToBlock: !0 }, { model: "htmlFigureAttributes", view: "figure", appliesToBlock: "table" }, { model: "htmlTheadAttributes", view: "thead", appliesToBlock: "table" }, { model: "htmlTbodyAttributes", view: "tbody", appliesToBlock: "table" }, { model: "htmlFigureAttributes", view: "figure", appliesToBlock: "imageBlock" }, { model: "htmlAcronym", view: "acronym", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlTt", view: "tt", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlFont", view: "font", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlTime", view: "time", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlVar", view: "var", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlBig", view: "big", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSmall", view: "small", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSamp", view: "samp", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlQ", view: "q", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlOutput", view: "output", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlKbd", view: "kbd", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlBdi", view: "bdi", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlBdo", view: "bdo", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlAbbr", view: "abbr", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlA", view: "a", priority: 5, coupledAttribute: "linkHref", attributeProperties: { copyOnEnter: !0 } }, { model: "htmlStrong", view: "strong", coupledAttribute: "bold", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlB", view: "b", coupledAttribute: "bold", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlI", view: "i", coupledAttribute: "italic", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlEm", view: "em", coupledAttribute: "italic", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlS", view: "s", coupledAttribute: "strikethrough", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlDel", view: "del", coupledAttribute: "strikethrough", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlIns", view: "ins", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlU", view: "u", coupledAttribute: "underline", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSub", view: "sub", coupledAttribute: "subscript", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSup", view: "sup", coupledAttribute: "superscript", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlCode", view: "code", coupledAttribute: "code", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlMark", view: "mark", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSpan", view: "span", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlCite", view: "cite", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlLabel", view: "label", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlDfn", view: "dfn", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlObject", view: "object", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlIframe", view: "iframe", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlInput", view: "input", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlButton", view: "button", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlTextarea", view: "textarea", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlSelect", view: "select", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlVideo", view: "video", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlEmbed", view: "embed", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlOembed", view: "oembed", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlAudio", view: "audio", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlImg", view: "img", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlCanvas", view: "canvas", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlMeter", view: "meter", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlProgress", view: "progress", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlScript", view: "script", modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 } }, { model: "htmlStyle", view: "style", modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 } }, { model: "htmlCustomElement", view: "$customElement", modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 } }], lS = Sa(function(o, e, t, n) {
        Wu(o, e, t, n);
      });
      var cS = Object.defineProperty, dS = Object.defineProperties, uS = Object.getOwnPropertyDescriptors, hk = Object.getOwnPropertySymbols, hS = Object.prototype.hasOwnProperty, gS = Object.prototype.propertyIsEnumerable, gk = (o, e, t) => e in o ? cS(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, ks = (o, e) => {
        for (var t in e || (e = {}))
          hS.call(e, t) && gk(o, t, e[t]);
        if (hk)
          for (var t of hk(e))
            gS.call(e, t) && gk(o, t, e[t]);
        return o;
      }, ws = (o, e) => dS(o, uS(e));
      class ei extends G {
        constructor() {
          super(...arguments), this._definitions = [];
        }
        static get pluginName() {
          return "DataSchema";
        }
        init() {
          for (const e of sS)
            this.registerBlockElement(e);
          for (const e of aS)
            this.registerInlineElement(e);
        }
        registerBlockElement(e) {
          this._definitions.push(ws(ks({}, e), { isBlock: !0 }));
        }
        registerInlineElement(e) {
          this._definitions.push(ws(ks({}, e), { isInline: !0 }));
        }
        extendBlockElement(e) {
          this._extendDefinition(ws(ks({}, e), { isBlock: !0 }));
        }
        extendInlineElement(e) {
          this._extendDefinition(ws(ks({}, e), { isInline: !0 }));
        }
        getDefinitionsForView(e, t = !1) {
          const n = /* @__PURE__ */ new Set();
          for (const i of this._getMatchingViewDefinitions(e)) {
            if (t)
              for (const r of this._getReferences(i.model))
                n.add(r);
            n.add(i);
          }
          return n;
        }
        getDefinitionsForModel(e) {
          return this._definitions.filter((t) => t.model == e);
        }
        _getMatchingViewDefinitions(e) {
          return this._definitions.filter((t) => t.view && function(n, i) {
            return typeof n == "string" ? n === i : n instanceof RegExp ? n.test(i) : !1;
          }(e, t.view));
        }
        *_getReferences(e) {
          const t = ["inheritAllFrom", "inheritTypesFrom", "allowWhere", "allowContentOf", "allowAttributesOf"], n = this._definitions.filter((i) => i.model == e);
          for (const { modelSchema: i } of n)
            if (i)
              for (const r of t)
                for (const s of Xe(i[r] || [])) {
                  const a = this._definitions.filter((l) => l.model == s);
                  for (const l of a)
                    s !== e && (yield* this._getReferences(l.model), yield l);
                }
        }
        _extendDefinition(e) {
          const t = Array.from(this._definitions.entries()).filter(([, n]) => n.model == e.model);
          if (t.length != 0)
            for (const [n, i] of t)
              this._definitions[n] = lS({}, i, e, (r, s) => Array.isArray(r) ? r.concat(s) : void 0);
          else
            this._definitions.push(e);
        }
      }
      const mS = function(o, e, t, n) {
        for (var i = o.length, r = t + (n ? 1 : -1); n ? r-- : ++r < i; )
          if (e(o[r], r, o))
            return r;
        return -1;
      }, pS = function(o) {
        return o != o;
      }, fS = function(o, e, t) {
        for (var n = t - 1, i = o.length; ++n < i; )
          if (o[n] === e)
            return n;
        return -1;
      }, bS = function(o, e, t) {
        return e == e ? fS(o, e, t) : mS(o, pS, t);
      }, kS = function(o, e, t, n) {
        for (var i = t - 1, r = o.length; ++i < r; )
          if (n(o[i], e))
            return i;
        return -1;
      };
      var mk = Array.prototype.splice;
      const wS = function(o, e, t, n) {
        var i = n ? kS : bS, r = -1, s = e.length, a = o;
        for (o === e && (e = Js(e)), t && (a = Vu(o, wr(t))); ++r < s; )
          for (var l = 0, d = e[r], h = t ? t(d) : d; (l = i(a, h, l, n)) > -1; )
            a !== o && mk.call(a, l, 1), mk.call(o, l, 1);
        return o;
      }, vS = Ku(function(o, e) {
        return o && o.length && e && e.length ? wS(o, e) : o;
      });
      var pk = k(5049), _S = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(pk.Z, _S), pk.Z.locals;
      class st extends G {
        constructor(e) {
          super(e), this._dataSchema = e.plugins.get("DataSchema"), this._allowedAttributes = new Fo(), this._disallowedAttributes = new Fo(), this._allowedElements = /* @__PURE__ */ new Set(), this._disallowedElements = /* @__PURE__ */ new Set(), this._dataInitialized = !1, this._coupledAttributes = null, this._registerElementsAfterInit(), this._registerElementHandlers(), this._registerModelPostFixer();
        }
        static get pluginName() {
          return "DataFilter";
        }
        static get requires() {
          return [ei, Wi];
        }
        loadAllowedConfig(e) {
          for (const t of e) {
            const n = t.name || /[\s\S]+/, i = kk(t);
            this.allowElement(n), i.forEach((r) => this.allowAttributes(r));
          }
        }
        loadDisallowedConfig(e) {
          for (const t of e) {
            const n = t.name || /[\s\S]+/, i = kk(t);
            i.length == 0 ? this.disallowElement(n) : i.forEach((r) => this.disallowAttributes(r));
          }
        }
        allowElement(e) {
          for (const t of this._dataSchema.getDefinitionsForView(e, !0))
            this._addAllowedElement(t), this._coupledAttributes = null;
        }
        disallowElement(e) {
          for (const t of this._dataSchema.getDefinitionsForView(e, !1))
            this._disallowedElements.add(t.view);
        }
        allowAttributes(e) {
          this._allowedAttributes.add(e);
        }
        disallowAttributes(e) {
          this._disallowedAttributes.add(e);
        }
        processViewAttributes(e, t) {
          return fk(e, t, this._disallowedAttributes), fk(e, t, this._allowedAttributes);
        }
        _addAllowedElement(e) {
          if (!this._allowedElements.has(e)) {
            if (this._allowedElements.add(e), "appliesToBlock" in e && typeof e.appliesToBlock == "string")
              for (const t of this._dataSchema.getDefinitionsForModel(e.appliesToBlock))
                t.isBlock && this._addAllowedElement(t);
            this._dataInitialized && this.editor.data.once("set", () => {
              this._fireRegisterEvent(e);
            }, { priority: ce.get("highest") + 1 });
          }
        }
        _registerElementsAfterInit() {
          this.editor.data.on("init", () => {
            this._dataInitialized = !0;
            for (const e of this._allowedElements)
              this._fireRegisterEvent(e);
          }, { priority: ce.get("highest") + 1 });
        }
        _registerElementHandlers() {
          this.on("register", (e, t) => {
            const n = this.editor.model.schema;
            if (t.isObject && !n.isRegistered(t.model))
              this._registerObjectElement(t);
            else if (t.isBlock)
              this._registerBlockElement(t);
            else {
              if (!t.isInline)
                throw new I("data-filter-invalid-definition", null, t);
              this._registerInlineElement(t);
            }
            e.stop();
          }, { priority: "lowest" });
        }
        _registerModelPostFixer() {
          const e = this.editor.model;
          e.document.registerPostFixer((t) => {
            const n = e.document.differ.getChanges();
            let i = !1;
            const r = this._getCoupledAttributesMap();
            for (const s of n) {
              if (s.type != "attribute" || s.attributeNewValue !== null)
                continue;
              const a = r.get(s.attributeKey);
              if (a)
                for (const { item: l } of s.range.getWalker({ shallow: !0 }))
                  for (const d of a)
                    l.hasAttribute(d) && (t.removeAttribute(d, l), i = !0);
            }
            return i;
          });
        }
        _getCoupledAttributesMap() {
          if (this._coupledAttributes)
            return this._coupledAttributes;
          this._coupledAttributes = /* @__PURE__ */ new Map();
          for (const e of this._allowedElements)
            if (e.coupledAttribute && e.model) {
              const t = this._coupledAttributes.get(e.coupledAttribute);
              t ? t.push(e.model) : this._coupledAttributes.set(e.coupledAttribute, [e.model]);
            }
          return this._coupledAttributes;
        }
        _fireRegisterEvent(e) {
          e.view && this._disallowedElements.has(e.view) || this.fire(e.view ? `register:${e.view}` : "register", e);
        }
        _registerObjectElement(e) {
          const t = this.editor, n = t.model.schema, i = t.conversion, { view: r, model: s } = e;
          n.register(s, e.modelSchema), r && (n.extend(e.model, { allowAttributes: ["htmlAttributes", "htmlContent"] }), t.data.registerRawContentMatcher({ name: r }), i.for("upcast").elementToElement({ view: r, model: rc(e), converterPriority: ce.get("low") + 1 }), i.for("upcast").add(Ki(e, this)), i.for("editingDowncast").elementToStructure({ model: { name: s, attributes: ["htmlAttributes"] }, view: iS(t, e) }), i.for("dataDowncast").elementToElement({ model: s, view: (a, { writer: l }) => bs(r, a, l) }), i.for("dataDowncast").add(Zi(e)));
        }
        _registerBlockElement(e) {
          const t = this.editor, n = t.model.schema, i = t.conversion, { view: r, model: s } = e;
          if (!n.isRegistered(e.model)) {
            if (n.register(e.model, e.modelSchema), !r)
              return;
            i.for("upcast").elementToElement({ model: s, view: r, converterPriority: ce.get("low") + 1 }), i.for("downcast").elementToElement({ model: s, view: r });
          }
          r && (n.extend(e.model, { allowAttributes: "htmlAttributes" }), i.for("upcast").add(Ki(e, this)), i.for("downcast").add(Zi(e)));
        }
        _registerInlineElement(e) {
          const t = this.editor, n = t.model.schema, i = t.conversion, r = e.model;
          e.appliesToBlock || (n.extend("$text", { allowAttributes: r }), e.attributeProperties && n.setAttributeProperties(r, e.attributeProperties), i.for("upcast").add(function({ view: s, model: a }, l) {
            return (d) => {
              d.on(`element:${s}`, (h, m, f) => {
                let _ = l.processViewAttributes(m.viewItem, f);
                if (_ || f.consumable.test(m.viewItem, { name: !0 })) {
                  _ = _ || {}, f.consumable.consume(m.viewItem, { name: !0 }), m.modelRange || (m = Object.assign(m, f.convertChildren(m.viewItem, m.modelCursor)));
                  for (const E of m.modelRange.getItems())
                    if (f.schema.checkAttribute(E, a)) {
                      const B = oS(_, E.getAttribute(a) || {});
                      f.writer.setAttribute(a, B, E);
                    }
                }
              }, { priority: "low" });
            };
          }(e, this)), i.for("downcast").attributeToElement({ model: r, view: rS(e) }));
        }
      }
      function fk(o, e, t) {
        const n = function(l, { consumable: d }, h) {
          const m = h.matchAll(l) || [], f = [];
          for (const _ of m)
            AS(d, l, _), delete _.match.name, d.consume(l, _.match), f.push(_);
          return f;
        }(o, e, t), { attributes: i, styles: r, classes: s } = function(l) {
          const d = { attributes: /* @__PURE__ */ new Set(), classes: /* @__PURE__ */ new Set(), styles: /* @__PURE__ */ new Set() };
          for (const h of l)
            for (const m in d)
              (h.match[m] || []).forEach((f) => d[m].add(f));
          return d;
        }(n), a = {};
        if (i.size)
          for (const l of i)
            Gd(l) || i.delete(l);
        return i.size && (a.attributes = bk(i, (l) => o.getAttribute(l))), r.size && (a.styles = bk(r, (l) => o.getStyle(l))), s.size && (a.classes = Array.from(s)), Object.keys(a).length ? a : null;
      }
      function AS(o, e, t) {
        for (const n of ["attributes", "classes", "styles"]) {
          const i = t.match[n];
          if (i)
            for (const r of Array.from(i))
              o.test(e, { [n]: [r] }) || vS(i, r);
        }
      }
      function bk(o, e) {
        const t = {};
        for (const n of o)
          e(n) !== void 0 && (t[n] = e(n));
        return t;
      }
      function sc(o, e) {
        const { name: t } = o, n = o[e];
        return Ct(n) ? Object.entries(n).map(([i, r]) => ({ name: t, [e]: { [i]: r } })) : Array.isArray(n) ? n.map((i) => ({ name: t, [e]: [i] })) : [o];
      }
      function kk(o) {
        const { name: e, attributes: t, classes: n, styles: i } = o, r = [];
        return t && r.push(...sc({ name: e, attributes: t }, "attributes")), n && r.push(...sc({ name: e, classes: n }, "classes")), i && r.push(...sc({ name: e, styles: i }, "styles")), r;
      }
      class CS extends G {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "CodeBlockElementSupport";
        }
        init() {
          if (!this.editor.plugins.has("CodeBlockEditing"))
            return;
          const e = this.editor.plugins.get(st);
          e.on("register:pre", (t, n) => {
            if (n.model !== "codeBlock")
              return;
            const i = this.editor, r = i.model.schema, s = i.conversion;
            r.extend("codeBlock", { allowAttributes: ["htmlAttributes", "htmlContentAttributes"] }), s.for("upcast").add(/* @__PURE__ */ function(a) {
              return (l) => {
                l.on("element:code", (d, h, m) => {
                  const f = h.viewItem, _ = f.parent;
                  function E(B, T) {
                    const O = a.processViewAttributes(B, m);
                    O && m.writer.setAttribute(T, O, h.modelRange);
                  }
                  _ && _.is("element", "pre") && (E(_, "htmlAttributes"), E(f, "htmlContentAttributes"));
                }, { priority: "low" });
              };
            }(e)), s.for("downcast").add((a) => {
              a.on("attribute:htmlAttributes:codeBlock", (l, d, h) => {
                if (!h.consumable.consume(d.item, l.name))
                  return;
                const { attributeOldValue: m, attributeNewValue: f } = d, _ = h.mapper.toViewElement(d.item).parent;
                uo(h.writer, m, f, _);
              }), a.on("attribute:htmlContentAttributes:codeBlock", (l, d, h) => {
                if (!h.consumable.consume(d.item, l.name))
                  return;
                const { attributeOldValue: m, attributeNewValue: f } = d, _ = h.mapper.toViewElement(d.item);
                uo(h.writer, m, f, _);
              });
            }), t.stop();
          });
        }
      }
      class yS extends G {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "DualContentModelElementSupport";
        }
        init() {
          this.editor.plugins.get(st).on("register", (e, t) => {
            const n = t, i = this.editor, r = i.model.schema, s = i.conversion;
            if (!n.paragraphLikeModel || r.isRegistered(n.model) || r.isRegistered(n.paragraphLikeModel))
              return;
            const a = { model: n.paragraphLikeModel, view: n.view };
            r.register(n.model, n.modelSchema), r.register(a.model, { inheritAllFrom: "$block" }), s.for("upcast").elementToElement({ view: n.view, model: (l, { writer: d }) => this._hasBlockContent(l) ? d.createElement(n.model) : d.createElement(a.model), converterPriority: ce.get("low") + 0.5 }), s.for("downcast").elementToElement({ view: n.view, model: n.model }), this._addAttributeConversion(n), s.for("downcast").elementToElement({ view: a.view, model: a.model }), this._addAttributeConversion(a), e.stop();
          });
        }
        _hasBlockContent(e) {
          const t = this.editor.editing.view, n = t.domConverter.blockElements;
          for (const i of t.createRangeIn(e).getItems())
            if (i.is("element") && n.includes(i.name))
              return !0;
          return !1;
        }
        _addAttributeConversion(e) {
          const t = this.editor, n = t.conversion, i = t.plugins.get(st);
          t.model.schema.extend(e.model, { allowAttributes: "htmlAttributes" }), n.for("upcast").add(Ki(e, i)), n.for("downcast").add(Zi(e));
        }
      }
      class ES extends G {
        static get requires() {
          return [ei, qi];
        }
        static get pluginName() {
          return "HeadingElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("HeadingEditing"))
            return;
          const t = e.config.get("heading.options");
          this.registerHeadingElements(e, t), this.removeClassesOnEnter(e, t);
        }
        registerHeadingElements(e, t) {
          const n = e.plugins.get(ei), i = [];
          for (const r of t)
            "model" in r && "view" in r && (n.registerBlockElement({ view: r.view, model: r.model }), i.push(r.model));
          n.extendBlockElement({ model: "htmlHgroup", modelSchema: { allowChildren: i } });
        }
        removeClassesOnEnter(e, t) {
          const n = e.commands.get("enter");
          this.listenTo(n, "afterExecute", (i, r) => {
            const s = e.model.document.selection.getFirstPosition().parent;
            t.some((a) => s.is("element", a.model)) && s.childCount === 0 && ho(r.writer, s, "htmlAttributes", "classes", (a) => a.clear());
          });
        }
      }
      function vs(o, e, t) {
        const n = o.createRangeOn(e);
        for (const { item: i } of n.getWalker())
          if (i.is("element", t))
            return i;
      }
      class xS extends G {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "ImageElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("ImageInlineEditing") && !e.plugins.has("ImageBlockEditing"))
            return;
          const t = e.model.schema, n = e.conversion, i = e.plugins.get(st);
          i.on("register:figure", () => {
            n.for("upcast").add(/* @__PURE__ */ function(r) {
              return (s) => {
                s.on("element:figure", (a, l, d) => {
                  const h = l.viewItem;
                  if (!l.modelRange || !h.hasClass("image"))
                    return;
                  const m = r.processViewAttributes(h, d);
                  m && d.writer.setAttribute("htmlFigureAttributes", m, l.modelRange);
                }, { priority: "low" });
              };
            }(i));
          }), i.on("register:img", (r, s) => {
            s.model !== "imageBlock" && s.model !== "imageInline" || (t.isRegistered("imageBlock") && t.extend("imageBlock", { allowAttributes: ["htmlAttributes", "htmlFigureAttributes", "htmlLinkAttributes"] }), t.isRegistered("imageInline") && t.extend("imageInline", { allowAttributes: ["htmlA", "htmlAttributes"] }), n.for("upcast").add(/* @__PURE__ */ function(a) {
              return (l) => {
                l.on("element:img", (d, h, m) => {
                  if (!h.modelRange)
                    return;
                  const f = h.viewItem, _ = f.parent;
                  function E(T, O) {
                    const N = a.processViewAttributes(T, m);
                    N && m.writer.setAttribute(O, N, h.modelRange);
                  }
                  function B(T) {
                    h.modelRange && h.modelRange.getContainedElement().is("element", "imageBlock") && E(T, "htmlLinkAttributes");
                  }
                  E(f, "htmlAttributes"), _.is("element", "a") && B(_);
                }, { priority: "low" });
              };
            }(i)), n.for("downcast").add((a) => {
              function l(h) {
                a.on(`attribute:${h}:imageInline`, (m, f, _) => {
                  if (!_.consumable.consume(f.item, m.name))
                    return;
                  const { attributeOldValue: E, attributeNewValue: B } = f, T = _.mapper.toViewElement(f.item);
                  uo(_.writer, E, B, T);
                }, { priority: "low" });
              }
              function d(h, m) {
                a.on(`attribute:${m}:imageBlock`, (f, _, E) => {
                  if (!E.consumable.test(_.item, f.name))
                    return;
                  const { attributeOldValue: B, attributeNewValue: T } = _, O = E.mapper.toViewElement(_.item), N = vs(E.writer, O, h);
                  N && (uo(E.writer, B, T, N), E.consumable.consume(_.item, f.name));
                }, { priority: "low" }), h === "a" && a.on("attribute:linkHref:imageBlock", (f, _, E) => {
                  if (!E.consumable.consume(_.item, "attribute:htmlLinkAttributes:imageBlock"))
                    return;
                  const B = E.mapper.toViewElement(_.item), T = vs(E.writer, B, "a");
                  zn(E.writer, _.item.getAttribute("htmlLinkAttributes"), T);
                }, { priority: "low" });
              }
              l("htmlAttributes"), d("img", "htmlAttributes"), d("figure", "htmlFigureAttributes"), d("a", "htmlLinkAttributes");
            }), r.stop());
          });
        }
      }
      class SS extends G {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "MediaEmbedElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("MediaEmbed") || e.config.get("mediaEmbed.previewsInData"))
            return;
          const t = e.model.schema, n = e.conversion, i = this.editor.plugins.get(st), r = this.editor.plugins.get(ei), s = e.config.get("mediaEmbed.elementName");
          r.registerBlockElement({ model: "media", view: s }), i.on("register:figure", () => {
            n.for("upcast").add(/* @__PURE__ */ function(a) {
              return (l) => {
                l.on("element:figure", (d, h, m) => {
                  const f = h.viewItem;
                  if (!h.modelRange || !f.hasClass("media"))
                    return;
                  const _ = a.processViewAttributes(f, m);
                  _ && m.writer.setAttribute("htmlFigureAttributes", _, h.modelRange);
                }, { priority: "low" });
              };
            }(i));
          }), i.on(`register:${s}`, (a, l) => {
            l.model === "media" && (t.extend("media", { allowAttributes: ["htmlAttributes", "htmlFigureAttributes"] }), n.for("upcast").add(/* @__PURE__ */ function(d, h) {
              const m = (f, _, E) => {
                function B(T, O) {
                  const N = d.processViewAttributes(T, E);
                  N && E.writer.setAttribute(O, N, _.modelRange);
                }
                B(_.viewItem, "htmlAttributes");
              };
              return (f) => {
                f.on(`element:${h}`, m, { priority: "low" });
              };
            }(i, s)), n.for("dataDowncast").add(/* @__PURE__ */ function(d) {
              return (h) => {
                function m(f, _) {
                  h.on(`attribute:${_}:media`, (E, B, T) => {
                    if (!T.consumable.consume(B.item, E.name))
                      return;
                    const { attributeOldValue: O, attributeNewValue: N } = B, H = T.mapper.toViewElement(B.item), X = vs(T.writer, H, f);
                    uo(T.writer, O, N, X);
                  });
                }
                m(d, "htmlAttributes"), m("figure", "htmlFigureAttributes");
              };
            }(s)), a.stop());
          });
        }
      }
      class DS extends G {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "ScriptElementSupport";
        }
        init() {
          const e = this.editor.plugins.get(st);
          e.on("register:script", (t, n) => {
            const i = this.editor, r = i.model.schema, s = i.conversion;
            r.register("htmlScript", n.modelSchema), r.extend("htmlScript", { allowAttributes: ["htmlAttributes", "htmlContent"], isContent: !0 }), i.data.registerRawContentMatcher({ name: "script" }), s.for("upcast").elementToElement({ view: "script", model: rc(n) }), s.for("upcast").add(Ki(n, e)), s.for("downcast").elementToElement({ model: "htmlScript", view: (a, { writer: l }) => bs("script", a, l) }), s.for("downcast").add(Zi(n)), t.stop();
          });
        }
      }
      class BS extends G {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "TableElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("TableEditing"))
            return;
          const t = e.model.schema, n = e.conversion, i = e.plugins.get(st), r = e.plugins.get("TableUtils");
          i.on("register:figure", () => {
            n.for("upcast").add(/* @__PURE__ */ function(s) {
              return (a) => {
                a.on("element:figure", (l, d, h) => {
                  const m = d.viewItem;
                  if (!d.modelRange || !m.hasClass("table"))
                    return;
                  const f = s.processViewAttributes(m, h);
                  f && h.writer.setAttribute("htmlFigureAttributes", f, d.modelRange);
                }, { priority: "low" });
              };
            }(i));
          }), i.on("register:table", (s, a) => {
            a.model === "table" && (t.extend("table", { allowAttributes: ["htmlAttributes", "htmlFigureAttributes", "htmlTheadAttributes", "htmlTbodyAttributes"] }), n.for("upcast").add(/* @__PURE__ */ function(l) {
              return (d) => {
                d.on("element:table", (h, m, f) => {
                  if (!m.modelRange)
                    return;
                  const _ = m.viewItem;
                  E(_, "htmlAttributes");
                  for (const B of _.getChildren())
                    B.is("element", "thead") && E(B, "htmlTheadAttributes"), B.is("element", "tbody") && E(B, "htmlTbodyAttributes");
                  function E(B, T) {
                    const O = l.processViewAttributes(B, f);
                    O && f.writer.setAttribute(T, O, m.modelRange);
                  }
                }, { priority: "low" });
              };
            }(i)), n.for("downcast").add((l) => {
              function d(h, m) {
                l.on(`attribute:${m}:table`, (f, _, E) => {
                  if (!E.consumable.test(_.item, f.name))
                    return;
                  const B = E.mapper.toViewElement(_.item), T = vs(E.writer, B, h);
                  T && (E.consumable.consume(_.item, f.name), uo(E.writer, _.attributeOldValue, _.attributeNewValue, T));
                });
              }
              d("table", "htmlAttributes"), d("figure", "htmlFigureAttributes"), d("thead", "htmlTheadAttributes"), d("tbody", "htmlTbodyAttributes");
            }), e.model.document.registerPostFixer(/* @__PURE__ */ function(l, d) {
              return (h) => {
                const m = l.document.differ.getChanges();
                let f = !1;
                for (const _ of m) {
                  if (_.type != "attribute" || _.attributeKey != "headingRows")
                    continue;
                  const E = _.range.start.nodeAfter, B = E.getAttribute("htmlTheadAttributes"), T = E.getAttribute("htmlTbodyAttributes");
                  B && !_.attributeNewValue ? (h.removeAttribute("htmlTheadAttributes", E), f = !0) : T && _.attributeNewValue == d.getRows(E) && (h.removeAttribute("htmlTbodyAttributes", E), f = !0);
                }
                return f;
              };
            }(e.model, r)), s.stop());
          });
        }
      }
      class TS extends G {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "StyleElementSupport";
        }
        init() {
          const e = this.editor.plugins.get(st);
          e.on("register:style", (t, n) => {
            const i = this.editor, r = i.model.schema, s = i.conversion;
            r.register("htmlStyle", n.modelSchema), r.extend("htmlStyle", { allowAttributes: ["htmlAttributes", "htmlContent"], isContent: !0 }), i.data.registerRawContentMatcher({ name: "style" }), s.for("upcast").elementToElement({ view: "style", model: rc(n) }), s.for("upcast").add(Ki(n, e)), s.for("downcast").elementToElement({ model: "htmlStyle", view: (a, { writer: l }) => bs("style", a, l) }), s.for("downcast").add(Zi(n)), t.stop();
          });
        }
      }
      class PS extends G {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "DocumentListElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("DocumentListEditing"))
            return;
          const t = e.model.schema, n = e.conversion, i = e.plugins.get(st), r = e.plugins.get("DocumentListEditing");
          r.registerDowncastStrategy({ scope: "item", attributeName: "htmlLiAttributes", setAttributeOnDowncast(s, a, l) {
            zn(s, a, l);
          } }), r.registerDowncastStrategy({ scope: "list", attributeName: "htmlListAttributes", setAttributeOnDowncast(s, a, l) {
            zn(s, a, l);
          } }), i.on("register", (s, a) => {
            ["ul", "ol", "li"].includes(a.view) && (s.stop(), t.checkAttribute("$block", "htmlListAttributes") || (t.extend("$block", { allowAttributes: ["htmlListAttributes", "htmlLiAttributes"] }), t.extend("$blockObject", { allowAttributes: ["htmlListAttributes", "htmlLiAttributes"] }), t.extend("$container", { allowAttributes: ["htmlListAttributes", "htmlLiAttributes"] }), n.for("upcast").add((l) => {
              l.on("element:ul", ac("htmlListAttributes", i), { priority: "low" }), l.on("element:ol", ac("htmlListAttributes", i), { priority: "low" }), l.on("element:li", ac("htmlLiAttributes", i), { priority: "low" });
            })));
          }), r.on("postFixer", (s, { listNodes: a, writer: l }) => {
            const d = [];
            for (const { node: h, previous: m } of a) {
              if (!m)
                continue;
              const f = h.getAttribute("listIndent"), _ = m.getAttribute("listIndent");
              let E = null;
              if (f > _ ? d[_] = m : f < _ ? (E = d[f], d.length = f) : E = m, E) {
                if (E.getAttribute("listType") == h.getAttribute("listType")) {
                  const B = E.getAttribute("htmlListAttributes");
                  Wr(h.getAttribute("htmlListAttributes"), B) || (l.setAttribute("htmlListAttributes", B, h), s.return = !0);
                }
                if (E.getAttribute("listItemId") == h.getAttribute("listItemId")) {
                  const B = E.getAttribute("htmlLiAttributes");
                  Wr(h.getAttribute("htmlLiAttributes"), B) || (l.setAttribute("htmlLiAttributes", B, h), s.return = !0);
                }
              }
            }
          });
        }
        afterInit() {
          const e = this.editor;
          if (!e.commands.get("indentList"))
            return;
          const t = e.commands.get("indentList");
          this.listenTo(t, "afterExecute", (n, i) => {
            e.model.change((r) => {
              for (const s of i)
                r.setAttribute("htmlListAttributes", {}, s);
            });
          });
        }
      }
      function ac(o, e) {
        return (t, n, i) => {
          const r = n.viewItem;
          n.modelRange || Object.assign(n, i.convertChildren(n.viewItem, n.modelCursor));
          const s = e.processViewAttributes(r, i);
          for (const a of n.modelRange.getItems({ shallow: !0 }))
            a.hasAttribute("listItemId") && (a.hasAttribute(o) || i.writer.setAttribute(o, s || {}, a));
        };
      }
      class IS extends G {
        static get requires() {
          return [st, ei];
        }
        static get pluginName() {
          return "CustomElementSupport";
        }
        init() {
          const e = this.editor.plugins.get(st), t = this.editor.plugins.get(ei);
          e.on("register:$customElement", (n, i) => {
            n.stop();
            const r = this.editor, s = r.model.schema, a = r.conversion, l = r.editing.view.domConverter.unsafeElements, d = r.data.htmlProcessor.domConverter.preElements;
            s.register(i.model, i.modelSchema), s.extend(i.model, { allowAttributes: ["htmlElementName", "htmlAttributes", "htmlContent"], isContent: !0 }), a.for("upcast").elementToElement({ view: /.*/, model: (h, m) => {
              if (h.name == "$comment" || !function(T) {
                try {
                  document.createElement(T);
                } catch {
                  return !1;
                }
                return !0;
              }(h.name) || t.getDefinitionsForView(h.name).size)
                return null;
              l.includes(h.name) || l.push(h.name), d.includes(h.name) || d.push(h.name);
              const f = m.writer.createElement(i.model, { htmlElementName: h.name }), _ = e.processViewAttributes(h, m);
              _ && m.writer.setAttribute("htmlAttributes", _, f);
              const E = new Kr(h.document).createDocumentFragment(h), B = r.data.processor.toData(E);
              m.writer.setAttribute("htmlContent", B, f);
              for (const { item: T } of r.editing.view.createRangeIn(h))
                m.consumable.consume(T, { name: !0 });
              return f;
            }, converterPriority: "low" }), a.for("editingDowncast").elementToElement({ model: { name: i.model, attributes: ["htmlElementName", "htmlAttributes", "htmlContent"] }, view: (h, { writer: m }) => {
              const f = h.getAttribute("htmlElementName"), _ = m.createRawElement(f);
              return h.hasAttribute("htmlAttributes") && zn(m, h.getAttribute("htmlAttributes"), _), _;
            } }), a.for("dataDowncast").elementToElement({ model: { name: i.model, attributes: ["htmlElementName", "htmlAttributes", "htmlContent"] }, view: (h, { writer: m }) => {
              const f = h.getAttribute("htmlElementName"), _ = h.getAttribute("htmlContent"), E = m.createRawElement(f, null, (B, T) => {
                T.setContentOf(B, _);
                const O = B.firstChild;
                for (O.remove(); O.firstChild; )
                  B.appendChild(O.firstChild);
              });
              return h.hasAttribute("htmlAttributes") && zn(m, h.getAttribute("htmlAttributes"), E), E;
            } });
          });
        }
      }
      function* ti(o, e, t) {
        if (e)
          if (!(Symbol.iterator in e) && e.is("documentSelection") && e.isCollapsed)
            o.schema.checkAttributeInSelection(e, t) && (yield e);
          else
            for (const n of function(i, r, s) {
              return !(Symbol.iterator in r) && (r.is("node") || r.is("$text") || r.is("$textProxy")) ? i.schema.checkAttribute(r, s) ? [i.createRangeOn(r)] : [] : i.schema.getValidRanges(i.createSelection(r).getRanges(), s);
            }(o, e, t))
              yield* n.getItems({ shallow: !0 });
      }
      var ni = (o, e, t) => new Promise((n, i) => {
        var r = (l) => {
          try {
            a(t.next(l));
          } catch (d) {
            i(d);
          }
        }, s = (l) => {
          try {
            a(t.throw(l));
          } catch (d) {
            i(d);
          }
        }, a = (l) => l.done ? n(l.value) : Promise.resolve(l.value).then(r, s);
        a((t = t.apply(o, e)).next());
      });
      function wk(o, e) {
        let t = new URL(o);
        if (e && Object.keys(e).length > 0) {
          const n = new URLSearchParams();
          for (const [i, r] of Object.entries(e))
            if (Array.isArray(r))
              for (const s of r)
                n.append(i, s);
            else
              n.append(i, r);
          t.search = n.toString();
        }
        return t.toString();
      }
      class OS {
        constructor(e, t) {
          this.loader = e, this.api_url = t;
        }
        _getUploadUrl(e, t) {
          return ni(this, null, function* () {
            const n = yield fetch(this.api_url + "/vi/skey", { credentials: "include" }).catch((a) => {
              t(a);
            }), i = yield n.json(), r = { fileName: e.name, mimeType: e.type || "application/octet-stream", size: e.size.toString(), skey: i }, s = yield fetch(wk(this.api_url + "/vi/file/getUploadURL", r), { method: "POST", credentials: "include" }).catch((a) => {
              t(a);
            });
            return this.loader.uploaded = 10, s;
          });
        }
        fileUpload(e, t, n) {
          return ni(this, null, function* () {
            yield fetch(t.values.uploadUrl, { mode: "no-cors", method: "POST", body: e }).catch((l) => {
              n(l);
            }), this.loader.uploaded = 50;
            const i = yield fetch(this.api_url + "/vi/skey", { credentials: "include" }).catch((l) => {
              n(l);
            }), r = yield i.json(), s = { key: t.values.uploadKey, node: void 0, skelType: "leaf", skey: r }, a = yield fetch(wk(this.api_url + "/vi/file/add", s), { method: "POST", credentials: "include" }).catch((l) => {
              n(l);
            });
            return this.loader.uploaded = 75, a;
          });
        }
        upload() {
          return ni(this, null, function* () {
            return this.loader.uploadTotal = 100, this.loader.uploaded = 0, this.loader.file.then((e) => ni(this, null, function* () {
              return new Promise((t, n) => {
                this._getUploadUrl(e, n).then((i) => ni(this, null, function* () {
                  const r = yield i.json();
                  this.fileUpload(e, r, n).then((s) => ni(this, null, function* () {
                    const a = yield s.json();
                    this.loader.uploaded = 100, t({ default: this.api_url + a.values.downloadUrl });
                  }));
                }));
              });
            }));
          });
        }
        abort() {
          this.xhr && this.xhr.abort();
        }
      }
      var vk = k(2245), RS = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(vk.Z, RS), vk.Z.locals;
      class lc extends is {
      }
      lc.builtinPlugins = [class extends G {
        static get requires() {
          return [g2, qi, k2, Ky, Fy, D2];
        }
        static get pluginName() {
          return "Essentials";
        }
      }, class extends G {
        static get requires() {
          return [wn];
        }
        static get pluginName() {
          return "CKFinderUploadAdapter";
        }
        init() {
          const o = this.editor.config.get("ckfinder.uploadUrl");
          o && (this.editor.plugins.get(wn).createUploadAdapter = (e) => new O2(e, o, this.editor.t));
        }
      }, class extends Pr {
        constructor() {
          super(...arguments), this.token = null, this._tokens = /* @__PURE__ */ new Map();
        }
        static get pluginName() {
          return "CloudServices";
        }
        static get requires() {
          return [U5];
        }
        init() {
          return ok(this, null, function* () {
            const o = this.context.config.get("cloudServices") || {};
            for (const [t, n] of Object.entries(o))
              this[t] = n;
            if (!this.tokenUrl)
              return void (this.token = null);
            const e = this.context.plugins.get("CloudServicesCore");
            this.token = yield e.createToken(this.tokenUrl).init(), this._tokens.set(this.tokenUrl, this.token);
          });
        }
        registerTokenUrl(o) {
          return ok(this, null, function* () {
            if (this._tokens.has(o))
              return this.getTokenFor(o);
            const e = this.context.plugins.get("CloudServicesCore"), t = yield e.createToken(o).init();
            return this._tokens.set(o, t), t;
          });
        }
        getTokenFor(o) {
          const e = this._tokens.get(o);
          if (!e)
            throw new I("cloudservices-token-not-registered", this);
          return e;
        }
        destroy() {
          super.destroy();
          for (const o of this._tokens.values())
            o.destroy();
        }
      }, class extends G {
        static get requires() {
          return [R2, z2];
        }
        static get pluginName() {
          return "Bold";
        }
      }, class extends G {
        static get requires() {
          return [N2, F2];
        }
        static get pluginName() {
          return "Italic";
        }
      }, class extends G {
        static get requires() {
          return [j2, U2];
        }
        static get pluginName() {
          return "BlockQuote";
        }
      }, class extends G {
        static get pluginName() {
          return "EasyImage";
        }
        static get requires() {
          return [q2, "ImageUpload"];
        }
        init() {
          const o = this.editor;
          o.plugins.has("ImageBlockEditing") || o.plugins.has("ImageInlineEditing") || ne("easy-image-image-feature-missing", o);
        }
      }, class extends G {
        static get requires() {
          return [J2, Q2];
        }
        static get pluginName() {
          return "Heading";
        }
      }, class extends G {
        static get requires() {
          return [fE, kE];
        }
        static get pluginName() {
          return "Image";
        }
      }, class extends G {
        static get requires() {
          return [_f, qE];
        }
        static get pluginName() {
          return "ImageStyle";
        }
      }, class extends G {
        static get requires() {
          return [cs, vn];
        }
        static get pluginName() {
          return "ImageToolbar";
        }
        afterInit() {
          const o = this.editor, e = o.t, t = o.plugins.get(cs), n = o.plugins.get("ImageUtils");
          var i;
          t.register("image", { ariaLabel: e("Image toolbar"), items: (i = o.config.get("image.toolbar") || [], i.map((r) => K(r) ? r.name : r)), getRelatedElement: (r) => n.getClosestSelectedImageWidget(r) });
        }
      }, class extends G {
        static get pluginName() {
          return "ImageUpload";
        }
        static get requires() {
          return [IE, _E, EE];
        }
      }, class extends G {
        constructor(o) {
          super(o), this._resizeUnit = o.config.get("image.resizeUnit");
        }
        static get requires() {
          return [NE];
        }
        static get pluginName() {
          return "ImageResizeButtons";
        }
        init() {
          const o = this.editor, e = o.config.get("image.resizeOptions"), t = o.commands.get("resizeImage");
          this.bind("isEnabled").to(t);
          for (const n of e)
            this._registerImageResizeButton(n);
          this._registerImageResizeDropdown(e);
        }
        _registerImageResizeButton(o) {
          const e = this.editor, { name: t, value: n, icon: i } = o, r = n ? n + this._resizeUnit : null;
          e.ui.componentFactory.add(t, (s) => {
            const a = new je(s), l = e.commands.get("resizeImage"), d = this._getOptionLabelValue(o, !0);
            if (!Pl[i])
              throw new I("imageresizebuttons-missing-icon", e, o);
            return a.set({ label: d, icon: Pl[i], tooltip: d, isToggleable: !0 }), a.bind("isEnabled").to(this), a.bind("isOn").to(l, "value", lf(r)), this.listenTo(a, "execute", () => {
              e.execute("resizeImage", { width: r });
            }), a;
          });
        }
        _registerImageResizeDropdown(o) {
          const e = this.editor, t = e.t, n = o.find((r) => !r.value), i = (r) => {
            const s = e.commands.get("resizeImage"), a = fn(r, Bu), l = a.buttonView, d = t("Resize image");
            return l.set({ tooltip: d, commandValue: n.value, icon: Pl.medium, isToggleable: !0, label: this._getOptionLabelValue(n), withText: !0, class: "ck-resize-image-button", ariaLabel: d, ariaLabelledBy: void 0 }), l.bind("label").to(s, "value", (h) => h && h.width ? h.width : this._getOptionLabelValue(n)), a.bind("isEnabled").to(this), rl(a, () => this._getResizeDropdownListItemDefinitions(o, s), { ariaLabel: t("Image resize list"), role: "menu" }), this.listenTo(a, "execute", (h) => {
              e.execute(h.source.commandName, { width: h.source.commandValue }), e.editing.view.focus();
            }), a;
          };
          e.ui.componentFactory.add("resizeImage", i), e.ui.componentFactory.add("imageResize", i);
        }
        _getOptionLabelValue(o, e = !1) {
          const t = this.editor.t;
          return o.label ? o.label : e ? o.value ? t("Resize image to %0", o.value + this._resizeUnit) : t("Resize image to the original size") : o.value ? o.value + this._resizeUnit : t("Original");
        }
        _getResizeDropdownListItemDefinitions(o, e) {
          const t = new Vt();
          return o.map((n) => {
            const i = n.value ? n.value + this._resizeUnit : null, r = { type: "button", model: new bl({ commandName: "resizeImage", commandValue: i, label: this._getOptionLabelValue(n), role: "menuitemradio", withText: !0, icon: null }) };
            r.model.bind("isOn").to(e, "value", lf(i)), t.add(r);
          }), t;
        }
      }, class extends G {
        static get pluginName() {
          return "Indent";
        }
        static get requires() {
          return [WE, GE];
        }
      }, class extends G {
        constructor(o) {
          super(o), o.config.define("indentBlock", { offset: 40, unit: "px" });
        }
        static get pluginName() {
          return "IndentBlock";
        }
        init() {
          const o = this.editor, e = o.config.get("indentBlock");
          e.classes && e.classes.length ? (this._setupConversionUsingClasses(e.classes), o.commands.add("indentBlock", new ms(o, new Bf({ direction: "forward", classes: e.classes }))), o.commands.add("outdentBlock", new ms(o, new Bf({ direction: "backward", classes: e.classes })))) : (o.data.addStyleProcessorRules(P1), this._setupConversionUsingOffset(), o.commands.add("indentBlock", new ms(o, new Df({ direction: "forward", offset: e.offset, unit: e.unit }))), o.commands.add("outdentBlock", new ms(o, new Df({ direction: "backward", offset: e.offset, unit: e.unit }))));
        }
        afterInit() {
          const o = this.editor, e = o.model.schema, t = o.commands.get("indent"), n = o.commands.get("outdent"), i = o.config.get("heading.options");
          (i && i.map((r) => r.model) || KE).forEach((r) => {
            e.isRegistered(r) && e.extend(r, { allowAttributes: "blockIndent" });
          }), e.setAttributeProperties("blockIndent", { isFormatting: !0 }), t.registerChildCommand(o.commands.get("indentBlock")), n.registerChildCommand(o.commands.get("outdentBlock"));
        }
        _setupConversionUsingOffset() {
          const o = this.editor.conversion, e = this.editor.locale.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left";
          o.for("upcast").attributeToAttribute({ view: { styles: { [e]: /[\s\S]+/ } }, model: { key: "blockIndent", value: (t) => t.getStyle(e) } }), o.for("downcast").attributeToAttribute({ model: "blockIndent", view: (t) => ({ key: "style", value: { [e]: t } }) });
        }
        _setupConversionUsingClasses(o) {
          const e = { model: { key: "blockIndent", values: [] }, view: {} };
          for (const t of o)
            e.model.values.push(t), e.view[t] = { key: "class", value: [t] };
          this.editor.conversion.attributeToAttribute(e);
        }
      }, class extends G {
        static get requires() {
          return [wx, yx, xx];
        }
        static get pluginName() {
          return "Link";
        }
      }, class extends G {
        static get requires() {
          return [Gx, Rx];
        }
        static get pluginName() {
          return "List";
        }
      }, Bl, class extends G {
        static get requires() {
          return [b5, v5, lo, x5, y5, C5, Wi];
        }
        static get pluginName() {
          return "Table";
        }
      }, class extends G {
        static get requires() {
          return [cs];
        }
        static get pluginName() {
          return "TableToolbar";
        }
        afterInit() {
          const o = this.editor, e = o.t, t = o.plugins.get(cs), n = o.config.get("table.contentToolbar"), i = o.config.get("table.tableToolbar");
          n && t.register("tableContent", { ariaLabel: e("Table toolbar"), items: n, getRelatedElement: B5 }), i && t.register("table", { ariaLabel: e("Table toolbar"), items: i, getRelatedElement: D5 });
        }
      }, class extends G {
        static get requires() {
          return ["Delete", "Input"];
        }
        static get pluginName() {
          return "TextTransformation";
        }
        constructor(o) {
          super(o), o.config.define("typing", { transformations: { include: Vy } });
        }
        init() {
          const o = this.editor.model.document.selection;
          o.on("change:range", () => {
            this.isEnabled = !o.anchor.parent.is("element", "codeBlock");
          }), this._enableTransformationWatchers();
        }
        _enableTransformationWatchers() {
          const o = this.editor, e = o.model, t = o.plugins.get("Delete"), n = function(r) {
            const s = r.extra || [], a = r.remove || [], l = (d) => !a.includes(d);
            return function(d) {
              const h = /* @__PURE__ */ new Set();
              for (const m of d)
                if (typeof m == "string" && qm[m])
                  for (const f of qm[m])
                    h.add(f);
                else
                  h.add(m);
              return Array.from(h);
            }(r.include.concat(s).filter(l)).filter(l).map((d) => typeof d == "string" && Um[d] ? Um[d] : d).filter((d) => typeof d == "object").map((d) => ({ from: jy(d.from), to: Hy(d.to) }));
          }(o.config.get("typing.transformations")), i = new Vm(o.model, (r) => {
            for (const s of n)
              if (s.from.test(r))
                return { normalizedTransformation: s };
          });
          i.on("matched:data", (r, s) => {
            if (!s.batch.isTyping)
              return;
            const { from: a, to: l } = s.normalizedTransformation, d = a.exec(s.text), h = l(d.slice(1)), m = s.range;
            let f = d.index;
            e.enqueueChange((_) => {
              for (let E = 1; E < d.length; E++) {
                const B = d[E], T = h[E - 1];
                if (T == null) {
                  f += B.length;
                  continue;
                }
                const O = m.start.getShiftedBy(f), N = e.createRange(O, O.getShiftedBy(B.length)), H = Uy(O);
                e.insertContent(_.createText(T, H), N), f += T.length;
              }
              e.enqueueChange(() => {
                t.requestUndoOnBackspace();
              });
            });
          }), i.bind("isEnabled").to(this);
        }
      }, class extends G {
        static get requires() {
          return [$2, L2];
        }
        static get pluginName() {
          return "Underline";
        }
      }, class extends G {
        static get requires() {
          return [W5, G5];
        }
        static get pluginName() {
          return "Alignment";
        }
      }, class extends G {
        constructor(o) {
          super(o), this.set("isSourceEditingMode", !1), this._elementReplacer = new Kc(), this._replacedRoots = /* @__PURE__ */ new Map(), this._dataFromRoots = /* @__PURE__ */ new Map();
        }
        static get pluginName() {
          return "SourceEditing";
        }
        static get requires() {
          return [Jr];
        }
        init() {
          const o = this.editor;
          o.t, o.ui.componentFactory.add("sourceEditing", (e) => {
            const t = new je(e);
            return t.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 0 5 4.5v15.003h-16V0h11zM3 1.5v3.25l-1.497 1-.003 8 1.5 1v3.254L7.685 18l-.001 1.504H17.5V8.002L16 9.428l-.004-4.22-4.222-3.692L3 1.5z"/><path d="M4.06 6.64a.75.75 0 0 1 .958 1.15l-.085.07L2.29 9.75l2.646 1.89c.302.216.4.62.232.951l-.058.095a.75.75 0 0 1-.951.232l-.095-.058-3.5-2.5V9.14l3.496-2.5zm4.194 6.22a.75.75 0 0 1-.958-1.149l.085-.07 2.643-1.89-2.646-1.89a.75.75 0 0 1-.232-.952l.058-.095a.75.75 0 0 1 .95-.232l.096.058 3.5 2.5v1.22l-3.496 2.5zm7.644-.836 2.122 2.122-5.825 5.809-2.125-.005.003-2.116zm2.539-1.847 1.414 1.414a.5.5 0 0 1 0 .707l-1.06 1.06-2.122-2.12 1.061-1.061a.5.5 0 0 1 .707 0z"/></svg>', tooltip: !0, withText: !0, class: "ck-source-editing-button" }), t.bind("isOn").to(this, "isSourceEditingMode"), t.bind("isEnabled").to(this, "isEnabled", o, "isReadOnly", o.plugins.get(Jr), "hasAny", (n, i, r) => !!n && !i && !r), this.listenTo(t, "execute", () => {
              this.isSourceEditingMode = !this.isSourceEditingMode;
            }), t;
          }), this._isAllowedToHandleSourceEditingMode() && (this.on("change:isSourceEditingMode", (e, t, n) => {
            n ? (this._showSourceEditing(), this._disableCommands()) : (this._hideSourceEditing(), this._enableCommands());
          }), this.on("change:isEnabled", (e, t, n) => this._handleReadOnlyMode(!n)), this.listenTo(o, "change:isReadOnly", (e, t, n) => this._handleReadOnlyMode(n))), o.data.on("get", () => {
            this.isSourceEditingMode && this.updateEditorData();
          }, { priority: "high" });
        }
        afterInit() {
          const o = this.editor;
          ["RealTimeCollaborativeEditing", "CommentsEditing", "TrackChangesEditing", "RevisionHistory"].some((e) => o.plugins.has(e)) && console.warn("You initialized the editor with the source editing feature and at least one of the collaboration features. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the collaboration features."), o.plugins.has("RestrictedEditingModeEditing") && console.warn("You initialized the editor with the source editing feature and restricted editing feature. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the restricted editing feature.");
        }
        updateEditorData() {
          const o = this.editor, e = {};
          for (const [t, n] of this._replacedRoots) {
            const i = this._dataFromRoots.get(t), r = n.dataset.value;
            i !== r && (e[t] = r);
          }
          Object.keys(e).length && o.data.set(e, { batchType: { isUndoable: !0 } });
        }
        _showSourceEditing() {
          const o = this.editor, e = o.editing.view, t = o.model;
          t.change((n) => {
            n.setSelection(null), n.removeSelectionAttribute(t.document.selection.getAttributeKeys());
          });
          for (const [n, i] of e.domRoots) {
            const r = J5(o.data.get({ rootName: n })), s = $s(i.ownerDocument, "textarea", { rows: "1", "aria-label": "Source code editing area" }), a = $s(i.ownerDocument, "div", { class: "ck-source-editing-area", "data-value": r }, [s]);
            s.value = r, s.setSelectionRange(0, 0), s.addEventListener("input", () => {
              a.dataset.value = s.value, o.ui.update();
            }), e.change((l) => {
              const d = e.document.getRoot(n);
              l.addClass("ck-hidden", d);
            }), o.ui.setEditableElement("sourceEditing:" + n, s), this._replacedRoots.set(n, a), this._elementReplacer.replace(i, a), this._dataFromRoots.set(n, r);
          }
          this._focusSourceEditing();
        }
        _hideSourceEditing() {
          const o = this.editor.editing.view;
          this.updateEditorData(), o.change((e) => {
            for (const [t] of this._replacedRoots)
              e.removeClass("ck-hidden", o.document.getRoot(t));
          }), this._elementReplacer.restore(), this._replacedRoots.clear(), this._dataFromRoots.clear(), o.focus();
        }
        _focusSourceEditing() {
          const o = this.editor, [e] = this._replacedRoots.values(), t = e.querySelector("textarea");
          o.editing.view.document.isFocused = !1, t.focus();
        }
        _disableCommands() {
          const o = this.editor;
          for (const e of o.commands.commands())
            e.forceDisabled(lk);
        }
        _enableCommands() {
          const o = this.editor;
          for (const e of o.commands.commands())
            e.clearForceDisabled(lk);
        }
        _handleReadOnlyMode(o) {
          if (this.isSourceEditingMode)
            for (const [, e] of this._replacedRoots)
              e.querySelector("textarea").readOnly = o;
        }
        _isAllowedToHandleSourceEditingMode() {
          const o = this.editor.ui.view.editable;
          return o && !o.hasExternalElement;
        }
      }, class extends G {
        static get requires() {
          return [X5, Y5];
        }
        static get pluginName() {
          return "RemoveFormat";
        }
      }, class extends G {
        static get pluginName() {
          return "GeneralHtmlSupport";
        }
        static get requires() {
          return [st, CS, yS, ES, xS, SS, DS, BS, TS, PS, IS];
        }
        init() {
          const o = this.editor, e = o.plugins.get(st);
          e.loadAllowedConfig(o.config.get("htmlSupport.allow") || []), e.loadDisallowedConfig(o.config.get("htmlSupport.disallow") || []);
        }
        getGhsAttributeNameForElement(o) {
          const e = this.editor.plugins.get("DataSchema"), t = Array.from(e.getDefinitionsForView(o, !1)), n = t.find((i) => i.isInline && !t[0].isObject);
          return n ? n.model : "htmlAttributes";
        }
        addModelHtmlClass(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ti(n, t, i))
              ho(r, s, i, "classes", (a) => {
                for (const l of Xe(e))
                  a.add(l);
              });
          });
        }
        removeModelHtmlClass(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ti(n, t, i))
              ho(r, s, i, "classes", (a) => {
                for (const l of Xe(e))
                  a.delete(l);
              });
          });
        }
        setModelHtmlAttributes(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ti(n, t, i))
              ho(r, s, i, "attributes", (a) => {
                for (const [l, d] of Object.entries(e))
                  a.set(l, d);
              });
          });
        }
        removeModelHtmlAttributes(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ti(n, t, i))
              ho(r, s, i, "attributes", (a) => {
                for (const l of Xe(e))
                  a.delete(l);
              });
          });
        }
        setModelHtmlStyles(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ti(n, t, i))
              ho(r, s, i, "styles", (a) => {
                for (const [l, d] of Object.entries(e))
                  a.set(l, d);
              });
          });
        }
        removeModelHtmlStyles(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ti(n, t, i))
              ho(r, s, i, "styles", (a) => {
                for (const l of Xe(e))
                  a.delete(l);
              });
          });
        }
      }], lc.defaultConfig = { extraPlugins: [function(o) {
        o.plugins.get("FileRepository").createUploadAdapter = (e) => new OS(e, o.config.get("viur_api_url"));
      }, function(o) {
        o.conversion.attributeToElement({ model: "bold", view: "b", upcastAlso: [(e) => {
          const t = e.getStyle("font-weight");
          return t && (t == "bold" || Number(t) >= 600) ? { name: !0, styles: ["font-weight"] } : null;
        }] });
      }], toolbar: { items: ["heading", "|", "bold", "italic", "underline", "|", "alignment", "numberedList", "bulletedList", "blockQuote", "|", "indent", "outdent", "|", "link", "insertTable", "imageUpload", "|", "undo", "redo", "RemoveFormat", "sourceEditing"] }, image: { toolbar: ["imageStyle:inline", "imageStyle:block", "imageStyle:side", "|", "resizeImage:50", "resizeImage:75", "resizeImage:original", "imageTextAlternative"], resizeOptions: [{ name: "resizeImage:original", value: null, icon: "original" }, { name: "resizeImage:50", value: "50", icon: "medium" }, { name: "resizeImage:75", value: "75", icon: "large" }] }, table: { contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"] }, heading: { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h1", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h2", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h3", title: "Heading 3", class: "ck-heading_heading3" }, { model: "heading4", view: "h4", title: "Heading 4", class: "ck-heading_heading4" }, { model: "heading5", view: "h5", title: "Heading 5", class: "ck-heading_heading5" }, { model: "heading6", view: "h6", title: "Heading 6", class: "ck-heading_heading6" }] }, alignment: { options: [{ name: "left", className: "viur-txt-align--left" }, { name: "right", className: "viur-txt-align--right" }, { name: "center", className: "viur-txt-align--center" }, { name: "justify", className: "viur-txt-align--justify" }] }, indentBlock: { classes: ["viur-txt-indent--1", "viur-txt-indent--2", "viur-txt-indent--3", "viur-txt-indent--4", "viur-txt-indent--5", "viur-txt-indent--6", "viur-txt-indent--7", "viur-txt-indent--8", "viur-txt-indent--9", "viur-txt-indent--10"] }, htmlSupport: { allow: [{ name: "a", attributes: { target: !0, rel: !0 } }] }, language: "de", viur_api_url: "http://localhost:8080" };
    })(), S = S.default;
  })());
})(Bs, Bs.exports);
var N3 = Bs.exports;
const nw = /* @__PURE__ */ M3(N3), F3 = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({
      value: "",
      editorConfig: {},
      editor: le(() => nw)
    });
    function k(x) {
      u.emit("change", c.name, w.value, c.lang, c.index);
    }
    function S(x) {
      w.value = x.target.value, u.emit("change", c.name, w.value, c.lang, c.index);
    }
    lt(() => {
      c.value !== null && (w.value = c.value), u.emit("change", c.name, c.value, c.lang, c.index);
    });
    function v(x) {
      x.editing.view.change((p) => {
        p.setStyle("min-height", "250px", x.editing.view.document.getRoot());
      });
    }
    return hi(
      () => c.value,
      (x, p) => {
        w.value = x;
      }
    ), {
      state: w,
      ClassicEditor: nw,
      boneState: g,
      changeEvent: k,
      onReady: v,
      changeEventTextarea: S
    };
  }
}), $3 = ["disabled", "value"];
function L3(c, u, g, w, k, S) {
  var x, p;
  const v = yo("ckeditor");
  return c.state.editor ? (j(), q(ye, { key: 0 }, [
    c.boneState.bonestructure.validHtml ? (j(), ut(v, {
      key: 0,
      modelValue: c.state.value,
      "onUpdate:modelValue": u[0] || (u[0] = (D) => c.state.value = D),
      editor: c.state.editor,
      config: c.state.editorConfig,
      disabled: (x = c.boneState) == null ? void 0 : x.readonly,
      onReady: c.onReady,
      onInput: c.changeEvent
    }, null, 8, ["modelValue", "editor", "config", "disabled", "onReady", "onInput"])) : (j(), q("sl-textarea", {
      key: 1,
      disabled: (p = c.boneState) == null ? void 0 : p.readonly,
      value: c.value,
      onInput: u[1] || (u[1] = (...D) => c.changeEventTextarea && c.changeEventTextarea(...D))
    }, null, 40, $3))
  ], 64)) : he("", !0);
}
const ow = /* @__PURE__ */ Ee(F3, [["render", L3]]), V3 = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({
      valueLat: null,
      valueLng: null
    });
    function k() {
      u.emit("change", c.name, [w.valueLat, w.valueLng], c.lang, c.index);
    }
    return lt(() => {
      try {
        w.valueLat = c.value[0], w.valueLng = c.value[1];
      } catch {
      }
      u.emit("change", c.name, [w.valueLat, w.valueLng], c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: k
    };
  }
}), j3 = ["name", "min", "max", "disabled"], H3 = ["name", "min", "max", "disabled"];
function U3(c, u, g, w, k, S) {
  return j(), q(ye, null, [
    cn(M("sl-input", {
      "onUpdate:modelValue": u[0] || (u[0] = (v) => c.state.valueLat = v),
      index: "lat",
      type: "number",
      name: c.name,
      min: c.boneState.bonestructure.boundslat[0],
      max: c.boneState.bonestructure.boundslat[1],
      disabled: c.boneState.readonly,
      "value-as-number": "",
      step: "0.000001",
      onSlChange: u[1] || (u[1] = (...v) => c.changeEvent && c.changeEvent(...v)),
      placeholder: "Lat"
    }, null, 40, j3), [
      [wo, c.state.valueLat]
    ]),
    cn(M("sl-input", {
      "onUpdate:modelValue": u[2] || (u[2] = (v) => c.state.valueLng = v),
      index: "lng",
      type: "number",
      name: c.name,
      min: c.boneState.bonestructure.boundslat[0],
      max: c.boneState.bonestructure.boundslat[1],
      disabled: c.boneState.readonly,
      "value-as-number": "",
      step: "0.000001",
      onSlChange: u[3] || (u[3] = (...v) => c.changeEvent && c.changeEvent(...v)),
      placeholder: "Long"
    }, null, 40, H3), [
      [wo, c.state.valueLng]
    ])
  ], 64);
}
const iw = /* @__PURE__ */ Ee(V3, [["render", U3], ["__scopeId", "data-v-7bc31020"]]), q3 = Ye({
  props: {
    name: String,
    value: Object,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = _e({
      counter: 0,
      debounce: null
    }), k = Te("addMultipleEntry"), S = Te("removeMultipleEntries");
    function v() {
      w.counter += 1;
      let p = 200;
      w.counter > 1 && (p = 500), w.debounce && clearTimeout(w.debounce), w.debounce = setTimeout(() => {
        for (let D = w.counter; D--; )
          k(c.lang);
        w.counter = 0;
      }, p);
    }
    function x() {
      let p = 200;
      w.debounce && clearTimeout(w.debounce), w.debounce = setTimeout(() => {
        S(c.lang);
      }, p);
    }
    return lt(() => {
      (!c.value || c.value.length === 0) && u.emit("change", c.name, [], c.lang);
    }), {
      state: w,
      boneState: g,
      handleAdd: v,
      handleRemove: x,
      removeMultipleEntries: S
    };
  }
}), e0 = (c) => (bt("data-v-63e75dee"), c = c(), kt(), c), W3 = { class: "actionbar" }, G3 = ["title"], K3 = /* @__PURE__ */ e0(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), Z3 = [
  K3
], J3 = ["title"], Y3 = /* @__PURE__ */ e0(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  name: "plus-lg"
}, null, -1));
function Q3(c, u, g, w, k, S) {
  return j(), q("div", W3, [
    c.boneState.multiple && !c.readonly ? (j(), q("sl-button", {
      key: 0,
      variant: "danger",
      title: c.$t("bone.del"),
      outline: "",
      class: "delete-btn",
      onClick: u[0] || (u[0] = (v) => c.handleRemove(c.lang))
    }, Z3, 8, G3)) : he("", !0),
    c.boneState.multiple && !c.readonly ? (j(), q("sl-button", {
      key: 1,
      variant: "success",
      title: c.$t("bone.add"),
      outline: "",
      class: "add-btn",
      onClick: u[1] || (u[1] = (v) => c.handleAdd(c.lang))
    }, [
      Y3,
      se(" " + Se(c.$t("bone.add")) + " ", 1),
      c.state.counter > 1 ? (j(), q(ye, { key: 0 }, [
        se("(" + Se(c.state.counter) + ")", 1)
      ], 64)) : he("", !0)
    ], 8, J3)) : he("", !0)
  ]);
}
const X3 = /* @__PURE__ */ Ee(q3, [["render", Q3], ["__scopeId", "data-v-63e75dee"]]), e4 = Ye({
  props: {
    name: String,
    value: Object,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = Te("addMultipleEntry"), k = Te("formatString"), S = null, v = _e({
      skels: {},
      hasUsing: le(() => g == null ? void 0 : g.bonestructure.using)
    });
    function x(p) {
      let D = "";
      return g.bonestructure.type === "relational.tree.leaf.file" ? D = "skelType=leaf&" : g.bonestructure.type === "relational.tree.node.file" && (D = "skelType=node&"), ve.get(
        `/json/${g.bonestructure.module}/list?${D}limit=99`
      ).then(async (y) => {
        var b;
        const C = await y.json();
        return v.skels = C.skellist.reduce((A, P) => (A[P.key] = P, A), {}), (b = C.skellist) == null ? void 0 : b.map((A) => ({ text: k(g.bonestructure.format, { dest: A }), value: A.key, data: A }));
      });
    }
    return lt(() => {
      (!c.value || c.value.length === 0) && u.emit("change", c.name, [], c.lang);
    }), {
      state: v,
      boneState: g,
      addMultipleEntry: w,
      removeMultipleEntries: S,
      getList: x
    };
  }
}), t0 = (c) => (bt("data-v-eeea51c6"), c = c(), kt(), c), t4 = { class: "actionbar" }, n4 = ["title"], o4 = /* @__PURE__ */ t0(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), i4 = [
  o4
], r4 = ["source"], s4 = ["title"], a4 = /* @__PURE__ */ t0(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  name: "plus-lg"
}, null, -1));
function l4(c, u, g, w, k, S) {
  return j(), q("div", t4, [
    c.boneState.multiple && !c.readonly ? (j(), q("sl-button", {
      key: 0,
      variant: "danger",
      title: c.$t("bone.del"),
      outline: "",
      class: "delete-btn",
      onClick: u[0] || (u[0] = (v) => c.openSelector())
    }, i4, 8, n4)) : he("", !0),
    M("sl-combobox", {
      source: c.getList,
      hoist: "",
      onSlItemSelect: u[1] || (u[1] = (v) => {
        var x;
        return c.addMultipleEntry(c.lang, {
          dest: (x = c.state.skels) == null ? void 0 : x[v.detail.item.value],
          rel: c.state.hasUsing ? void 0 : null
        });
      })
    }, null, 40, r4),
    c.boneState.multiple && !c.readonly ? (j(), q("sl-button", {
      key: 1,
      variant: "success",
      title: c.$t("bone.add"),
      outline: "",
      class: "add-btn",
      onClick: u[2] || (u[2] = (v) => c.addMultipleEntry(c.lang))
    }, [
      a4,
      se(" " + Se(c.$t("bone.list")), 1)
    ], 8, s4)) : he("", !0)
  ]);
}
const c4 = /* @__PURE__ */ Ee(e4, [["render", l4], ["__scopeId", "data-v-eeea51c6"]]), d4 = Ye({
  props: {
    name: String,
    value: Object,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Te("boneState"), w = Te("addMultipleEntry");
    Te("formatString");
    const k = null, S = Ft(), v = _e({
      skels: {},
      uploadinput: null,
      loading: !1,
      droparea: !1,
      hasUsing: le(() => g == null ? void 0 : g.bonestructure.using)
    });
    function x(y) {
      const C = {
        fileName: y.name,
        mimeType: y.type || "application/octet-stream",
        size: y.size.toString()
      };
      return new Promise((b, A) => {
        ve.securePost("/json/file/getUploadURL", { dataObj: C }).then(async (P) => {
          let R = await P.json();
          console.log(R), ve.post(R.values.uploadUrl, { dataObj: y, mode: "no-cors" }).then(async (z) => {
            const F = {
              key: R.values.uploadKey,
              node: void 0,
              skelType: "leaf"
            };
            ve.securePost("/json/file/add", { dataObj: F }).then(async (L) => {
              let U = await L.json();
              U.action === "addSuccess" ? b(U.values) : A(U);
            }).catch((L) => {
              A(L);
            });
          }).catch((z) => {
            A(z);
          });
        }).catch((P) => {
          A(P);
        });
      });
    }
    async function p(y) {
      v.loading = !0;
      for (let C of y.target.files) {
        let b = await x(C), A = null;
        v.hasUsing && (A = void 0), w(c.lang, { dest: b, rel: A });
      }
      v.loading = !1;
    }
    async function D(y) {
      v.loading = !0, v.droparea = !1;
      for (let C of y.dataTransfer.files) {
        let b = await x(C), A = null;
        v.hasUsing && (A = void 0), w(c.lang, { dest: b, rel: A });
      }
      v.loading = !1;
    }
    return lt(() => {
      (!c.value || c.value.length === 0) && u.emit("change", c.name, [], c.lang);
    }), {
      state: v,
      boneState: g,
      addMultipleEntry: w,
      removeMultipleEntries: k,
      uploadFile: x,
      uploadinput: S,
      handleUpload: p,
      handleDrop: D
    };
  }
}), Lc = (c) => (bt("data-v-34f8f5a4"), c = c(), kt(), c), u4 = ["title"], h4 = /* @__PURE__ */ Lc(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), g4 = [
  h4
], m4 = {
  key: 1,
  class: "droparea"
}, p4 = ["multiple"], f4 = ["title"], b4 = /* @__PURE__ */ Lc(() => /* @__PURE__ */ M("sl-icon", {
  slot: "prefix",
  name: "plus-lg"
}, null, -1)), k4 = [
  b4
], w4 = ["title"], v4 = /* @__PURE__ */ Lc(() => /* @__PURE__ */ M("sl-icon", { name: "upload" }, null, -1)), _4 = {
  key: 0,
  slot: "suffix"
};
function A4(c, u, g, w, k, S) {
  return j(), q("div", {
    class: "actionbar",
    onDragover: u[4] || (u[4] = li((v) => c.state.droparea = !0, ["prevent"])),
    onDragleave: u[5] || (u[5] = (v) => c.state.droparea = !1),
    onDrop: u[6] || (u[6] = li((...v) => c.handleDrop && c.handleDrop(...v), ["prevent"]))
  }, [
    c.boneState.multiple && !c.readonly ? (j(), q("sl-button", {
      key: 0,
      variant: "danger",
      title: c.$t("bone.del"),
      outline: "",
      class: "delete-btn",
      onClick: u[0] || (u[0] = (v) => c.openSelector())
    }, g4, 8, u4)) : he("", !0),
    c.state.droparea ? (j(), q("div", m4, " Dateien hier hinziehen ")) : he("", !0),
    M("input", {
      ref: "uploadinput",
      hidden: "",
      type: "file",
      multiple: c.boneState.multiple,
      onChange: u[1] || (u[1] = (...v) => c.handleUpload && c.handleUpload(...v))
    }, null, 40, p4),
    c.boneState.multiple && !c.readonly ? (j(), q("sl-button", {
      key: 2,
      outline: "",
      title: c.$t("bone.list"),
      class: "add-btn",
      onClick: u[2] || (u[2] = (v) => c.addMultipleEntry(c.lang))
    }, k4, 8, f4)) : he("", !0),
    c.boneState.multiple && !c.readonly ? (j(), q("sl-button", {
      key: 3,
      variant: "success",
      outline: "",
      title: c.$t("bone.upload"),
      class: "upload-btn",
      onClick: u[3] || (u[3] = (v) => c.uploadinput.click())
    }, [
      v4,
      se(" " + Se(c.$t("bone.upload")) + " ", 1),
      c.state.loading ? (j(), q("sl-spinner", _4)) : he("", !0)
    ], 8, w4)) : he("", !0)
  ], 32);
}
const C4 = /* @__PURE__ */ Ee(d4, [["render", A4], ["__scopeId", "data-v-34f8f5a4"]]), y4 = Oc("boneStore", () => {
  const c = _e({
    additionalBones: ln({}),
    defaultBones: ln({
      rawBone: Hk,
      keyBone: Uk,
      stringBone: qk,
      emailBone: Wk,
      dateBone: Gk,
      booleanBone: Zk,
      selectBone: Kk,
      passwordBone: Jk,
      recordBone: Yk,
      numericBone: Xk,
      colorBone: Qk,
      relationalBone: ew,
      jsonBone: h3,
      fileBone: tw,
      textBone: ow,
      spatialBone: iw
    }),
    actionbars: ln({
      "relational.tree.leaf.file.file": C4,
      "relational.": c4
    }),
    multibones: ln(["select", "select."])
  });
  function u(v, x) {
    c.additionalBones[v] = x;
  }
  function g() {
    let v = c.defaultBones;
    for (const [x, p] of Object.entries(c.additionalBones))
      v.add(p);
    return v;
  }
  function w(v) {
    if (Object.keys(c.additionalBones).includes(v))
      return c.additionalBones[v];
    {
      let x = v.split("."), p = Object.entries(c.additionalBones).filter(
        (D) => D[0].startsWith(x[0] + ".")
      );
      if (p.length > 0) {
        p.sort((D, y) => y.length - D.length);
        for (let D of p)
          if (v.startsWith(D[0]))
            return c.additionalBones[D[0]];
      }
    }
    return v === "date" ? Gk : v === "key" ? Uk : v === "str.email" ? Wk : v === "str" || v.startsWith("str.") ? qk : v === "select" || v.startsWith("select.") ? Kk : v === "bool" ? Zk : v === "password" ? Jk : v === "record" ? Yk : v === "numeric" || v.startsWith("numeric.") ? Xk : v === "relational.tree.leaf.file.file" ? tw : v === "relational" || v.startsWith("relational.") ? ew : v === "color" ? Qk : v === "text" ? ow : v === "spatial" ? iw : Hk;
  }
  function k(v, x) {
    c.actionbars[v] = x;
  }
  function S(v) {
    if (Object.keys(c.actionbars).includes(v))
      return c.actionbars[v];
    {
      let x = v.split("."), p = Object.entries(c.actionbars).filter(
        (D) => D[0].startsWith(x[0] + ".")
      );
      if (p.length > 0) {
        p.sort((D, y) => y.length - D.length);
        for (let D of p)
          if (v.startsWith(D[0]))
            return c.actionbars[D[0]];
      }
    }
    return X3;
  }
  return {
    state: c,
    addBoneWidget: u,
    getBoneWidget: w,
    importWidgets: g,
    addBoneActionbar: k,
    getBoneActionbar: S
  };
});
function vo(c) {
  return y4().getBoneWidget(c);
}
const Eo = (c) => (bt("data-v-afafe54d"), c = c(), kt(), c), E4 = /* @__PURE__ */ Eo(() => /* @__PURE__ */ M("h2", { class: "viur-shop-form-headline headline" }, "Nutzterdaten", -1)), x4 = /* @__PURE__ */ Eo(() => /* @__PURE__ */ M("h2", { class: "viur-shop-form-headline headline" }, "Lieferadresse", -1)), S4 = ["onSlChange", "onSlClear", "label"], D4 = ["value"], B4 = { key: 0 }, T4 = /* @__PURE__ */ Eo(() => /* @__PURE__ */ M("h2", { class: "viur-shop-form-headline headline" }, "Rechnungsadresse", -1)), P4 = /* @__PURE__ */ Eo(() => /* @__PURE__ */ M("sl-icon", {
  name: "x-lg",
  slot: "prefix"
}, null, -1)), I4 = [
  P4
], O4 = /* @__PURE__ */ Eo(() => /* @__PURE__ */ M("sl-icon", {
  name: "plus-lg",
  slot: "prefix"
}, null, -1)), R4 = /* @__PURE__ */ Eo(() => /* @__PURE__ */ M("sl-icon", {
  slot: "icon",
  name: "exclamation-triangle"
}, null, -1)), z4 = /* @__PURE__ */ Eo(() => /* @__PURE__ */ M("br", null, null, -1)), M4 = {
  __name: "UserInfoMulti",
  props: {
    mode: { type: String, default: "form" }
  },
  setup(c) {
    const u = En(), g = _e({
      formValues: {},
      requiredFieldsFilled: le(() => {
        if (g.isCustomAdress)
          return Object.keys(g.formValues).includes("city") && Object.keys(g.formValues).includes("street") && Object.keys(g.formValues).includes("billing.city") && Object.keys(g.formValues).includes("billing.street") && Object.keys(g.formValues).includes("email") && Object.keys(g.formValues).includes("firstname") && Object.keys(g.formValues).includes("lastname");
        if (!g.isCustomAdress)
          return Object.keys(g.formValues).includes("city") && Object.keys(g.formValues).includes("street") && Object.keys(g.formValues).includes("email") && Object.keys(g.formValues).includes("firstname") && Object.keys(g.formValues).includes("lastname");
      }),
      isCustomAdress: !1,
      shippingAdressAmount: 1,
      maxShippingAdress: le(
        () => Object.keys(u.state.carts).length + 2
      ),
      amountAlert: { title: "", msg: "" },
      items: null,
      addSkel: null,
      errors: {},
      selectedItem: {},
      isInit: le(() => !!u.state.carts[u.state.basket])
    }), w = Ft(null), k = Ft(null);
    function S(b) {
      b.target.checked && (g.isCustomAdress = !1), b.target.checked || (g.isCustomAdress = !0);
    }
    function v() {
      if (g.shippingAdressAmount === g.maxShippingAdress) {
        g.amountAlert.title = "Zu viele Lieferadressen", g.amountAlert.msg = `Sie können nur maximal: "${g.maxShippingAdress}" Lieferadressen verwenden.`, k.value.show();
        return;
      }
      g.shippingAdressAmount += 1;
    }
    function x(b, A) {
      for (const [P, R] of Object.entries(A.value[0]))
        g.formValues[P] = R;
    }
    function p() {
      if (g.shippingAdressAmount === 1) {
        g.amountAlert.title = "Zu wenig Lieferadressen", g.amountAlert.msg = "Mindestens eine Lieferadresse muss angegeben werden.", k.value.show();
        return;
      }
      g.shippingAdressAmount -= 1;
    }
    function D(b, A) {
      if (console.log(b.target.value), !b.target.value.length) {
        y();
        return;
      }
      g.selectedItem[A] = b.target.value, g.isItemSelected = !0;
    }
    function y(b, A) {
      console.log("clearing..."), delete g.selectedItem[A], g.isItemSelected = !1;
    }
    function C(b) {
      let A = {};
      return b.forEach((P) => {
        let R = P[0], z = P[1];
        A[R] = z;
      }), A;
    }
    return hi(g.formValues, (b) => {
      Object.entries(b).forEach(([A, P]) => {
        P === "" && delete g.formValues[A];
      });
    }), jn(async () => {
      await u.getAdressStructure(), g.addSkel = u.state.structure.address;
    }), (b, A) => {
      const P = yo("bone");
      return j(), q(ye, null, [
        M("div", null, [
          E4,
          (j(!0), q(ye, null, dt(g.addSkel, (R) => (j(), q(ye, {
            key: R[0]
          }, [
            R[1].visible && R[1].params.group === "Customer Info" ? (j(), ut(P, {
              key: 0,
              is: ae(vo)(R[1].type),
              name: R[0],
              structure: C(g.addSkel),
              errors: g.errors[R[0]] ? g.errors[R[0]] : [],
              skel: g.formValues,
              onChange: (z) => x(R[0], z),
              class: "viur-shop-form-grid-w-2"
            }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : he("", !0)
          ], 64))), 128))
        ]),
        x4,
        (j(!0), q(ye, null, dt(g.shippingAdressAmount, (R) => (j(), q("div", { key: R }, [
          M("sl-select", {
            clearable: "",
            ref_for: !0,
            ref_key: "itemSelection",
            ref: w,
            onSlChange: (z) => D(z, R),
            onSlClear: (z) => y(z, R),
            label: g.selectedItem[R] ? ae(u).state.carts[g.selectedItem[R]].info.name : "Warenkorb für Adresse wählen.",
            class: "grid-w-4"
          }, [
            (j(!0), q(ye, null, dt(ae(u).state.carts, (z, F) => (j(), q("sl-option", { value: F }, Se(z.info.name), 9, D4))), 256))
          ], 40, S4),
          (j(!0), q(ye, null, dt(g.addSkel, (z) => (j(), q(ye, {
            key: z[0]
          }, [
            z[1].visible && z[1].params.group === "Customer Address" ? (j(), ut(P, {
              key: 0,
              is: ae(vo)(z[1].type),
              name: z[0],
              structure: C(g.addSkel),
              errors: g.errors[z[0]] ? g.errors[z[0]] : [],
              skel: g.formValues,
              onChange: (F) => x(z[0], F)
            }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : he("", !0)
          ], 64))), 128))
        ]))), 128)),
        g.isCustomAdress ? (j(), q("div", B4, [
          T4,
          (j(!0), q(ye, null, dt(g.addSkel, (R) => (j(), q(ye, {
            key: R[0]
          }, [
            R[1].visible && R[1].params.group === "Customer Address" ? (j(), ut(P, {
              key: 0,
              is: ae(vo)(R[1].type),
              name: R[0],
              structure: C(g.addSkel),
              errors: g.errors[R[0]] ? g.errors[R[0]] : [],
              skel: g.formValues,
              onChange: (z) => x(R[0], z)
            }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : he("", !0)
          ], 64))), 128))
        ])) : he("", !0),
        M("div", { class: "viur-shop-form-btn-wrap" }, [
          M("sl-button", {
            size: "medium",
            onClick: p,
            title: "Lieferadresse entfernen"
          }, I4),
          M("sl-button", {
            size: "medium",
            variant: "primary",
            onClick: v
          }, [
            O4,
            se(" Lieferadresse hinzufügen ")
          ])
        ]),
        M("sl-alert", {
          variant: "warning",
          duration: "2000",
          ref_key: "shippingWarning",
          ref: k,
          closable: ""
        }, [
          R4,
          M("strong", null, Se(g.amountAlert.title), 1),
          z4,
          se(" " + Se(g.amountAlert.msg), 1)
        ], 512),
        M("sl-checkbox", {
          onSlChange: S,
          checked: ""
        }, " Rechnungsadresse wie Lieferadresse ", 32)
      ], 64);
    };
  }
}, N4 = /* @__PURE__ */ Ee(M4, [["__scopeId", "data-v-afafe54d"]]), Vc = (c) => (bt("data-v-25f20336"), c = c(), kt(), c), F4 = /* @__PURE__ */ Vc(() => /* @__PURE__ */ M("h2", { class: "viur-shop-form-headline headline" }, "Nutzterdaten", -1)), $4 = /* @__PURE__ */ Vc(() => /* @__PURE__ */ M("h2", { class: "viur-shop-form-headline headline" }, "Lieferadresse", -1)), L4 = { key: 0 }, V4 = /* @__PURE__ */ Vc(() => /* @__PURE__ */ M("h2", { class: "viur-shop-form-headline headline" }, "Rechnungsadresse", -1)), j4 = {
  __name: "UserInformation",
  props: {
    mode: { type: String, default: "form" },
    conditions: { type: Function }
  },
  setup(c) {
    const u = En(), g = _e({
      formValues: {},
      requiredFieldsFilled: le(() => {
        if (g.isCustomAdress)
          return Object.keys(g.formValues).includes("city") && Object.keys(g.formValues).includes("street") && Object.keys(g.formValues).includes("billing.city") && Object.keys(g.formValues).includes("billing.street") && Object.keys(g.formValues).includes("email") && Object.keys(g.formValues).includes("firstname") && Object.keys(g.formValues).includes("lastname");
        if (!g.isCustomAdress)
          return Object.keys(g.formValues).includes("city") && Object.keys(g.formValues).includes("street") && Object.keys(g.formValues).includes("email") && Object.keys(g.formValues).includes("firstname") && Object.keys(g.formValues).includes("lastname");
      }),
      isCustomAdress: !1,
      addSkel: null,
      errors: {}
    });
    function w(v) {
      v.target.checked && (g.isCustomAdress = !1), v.target.checked || (g.isCustomAdress = !0);
    }
    function k(v, x) {
      for (const [p, D] of Object.entries(x.value[0]))
        g.formValues[p] = D;
    }
    function S(v) {
      let x = {};
      return v.forEach((p) => {
        let D = p[0], y = p[1];
        x[D] = y;
      }), x;
    }
    return hi(g.formValues, (v) => {
      Object.entries(v).forEach(([x, p]) => {
        p === "" && delete g.formValues[x];
      });
    }), jn(async () => {
      await u.getAdressStructure(), g.addSkel = u.state.structure.address;
    }), (v, x) => {
      const p = yo("bone");
      return j(), q(ye, null, [
        M("div", null, [
          F4,
          (j(!0), q(ye, null, dt(g.addSkel, (D) => (j(), q(ye, {
            key: D[0]
          }, [
            D[1].visible && D[1].params.group === "Customer Info" ? (j(), ut(p, {
              key: 0,
              is: ae(vo)(D[1].type),
              name: D[0],
              structure: S(g.addSkel),
              errors: g.errors[D[0]] ? g.errors[D[0]] : [],
              skel: g.formValues,
              onChange: (y) => k(D[0], y),
              class: "viur-shop-form-grid-w-2"
            }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : he("", !0)
          ], 64))), 128))
        ]),
        M("div", null, [
          $4,
          (j(!0), q(ye, null, dt(g.addSkel, (D) => (j(), q(ye, {
            key: D[0]
          }, [
            D[1].visible && D[1].params.group === "Customer Address" ? (j(), ut(p, {
              key: 0,
              is: ae(vo)(D[1].type),
              name: D[0],
              structure: S(g.addSkel),
              errors: g.errors[D[0]] ? g.errors[D[0]] : [],
              skel: g.formValues,
              onChange: (y) => k(D[0], y)
            }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : he("", !0)
          ], 64))), 128))
        ]),
        g.isCustomAdress ? (j(), q("div", L4, [
          V4,
          (j(!0), q(ye, null, dt(g.addSkel, (D) => (j(), q(ye, {
            key: D[0]
          }, [
            D[1].visible && D[1].params.group === "Customer Address" ? (j(), ut(p, {
              key: 0,
              is: ae(vo)(D[1].type),
              name: D[0],
              structure: S(g.addSkel),
              errors: g.errors[D[0]] ? g.errors[D[0]] : [],
              skel: g.formValues,
              onChange: (y) => k(D[0], y)
            }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : he("", !0)
          ], 64))), 128))
        ])) : he("", !0),
        M("sl-checkbox", {
          onSlChange: w,
          checked: ""
        }, " Rechnungsadresse wie Lieferadresse ", 32)
      ], 64);
    };
  }
}, H4 = /* @__PURE__ */ Ee(j4, [["__scopeId", "data-v-25f20336"]]);
function rw(c, u, g) {
  const w = (k) => Object.is(k, -0) ? 0 : k;
  return c < u ? w(u) : c > g ? w(g) : w(c);
}
var U4 = class {
  constructor(c, u) {
    this.timerId = 0, this.activeInteractions = 0, this.paused = !1, this.stopped = !0, this.pause = () => {
      this.activeInteractions++ || (this.paused = !0, this.host.requestUpdate());
    }, this.resume = () => {
      --this.activeInteractions || (this.paused = !1, this.host.requestUpdate());
    }, c.addController(this), this.host = c, this.tickCallback = u;
  }
  hostConnected() {
    this.host.addEventListener("mouseenter", this.pause), this.host.addEventListener("mouseleave", this.resume), this.host.addEventListener("focusin", this.pause), this.host.addEventListener("focusout", this.resume), this.host.addEventListener("touchstart", this.pause, { passive: !0 }), this.host.addEventListener("touchend", this.resume);
  }
  hostDisconnected() {
    this.stop(), this.host.removeEventListener("mouseenter", this.pause), this.host.removeEventListener("mouseleave", this.resume), this.host.removeEventListener("focusin", this.pause), this.host.removeEventListener("focusout", this.resume), this.host.removeEventListener("touchstart", this.pause), this.host.removeEventListener("touchend", this.resume);
  }
  start(c) {
    this.stop(), this.stopped = !1, this.timerId = window.setInterval(() => {
      this.paused || this.tickCallback();
    }, c);
  }
  stop() {
    clearInterval(this.timerId), this.stopped = !0, this.host.requestUpdate();
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ss = globalThis, jc = Ss.ShadowRoot && (Ss.ShadyCSS === void 0 || Ss.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Hc = Symbol(), sw = /* @__PURE__ */ new WeakMap();
let n0 = class {
  constructor(u, g, w) {
    if (this._$cssResult$ = !0, w !== Hc)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = u, this.t = g;
  }
  get styleSheet() {
    let u = this.o;
    const g = this.t;
    if (jc && u === void 0) {
      const w = g !== void 0 && g.length === 1;
      w && (u = sw.get(g)), u === void 0 && ((this.o = u = new CSSStyleSheet()).replaceSync(this.cssText), w && sw.set(g, u));
    }
    return u;
  }
  toString() {
    return this.cssText;
  }
};
const q4 = (c) => new n0(typeof c == "string" ? c : c + "", void 0, Hc), Uc = (c, ...u) => {
  const g = c.length === 1 ? c[0] : u.reduce((w, k, S) => w + ((v) => {
    if (v._$cssResult$ === !0)
      return v.cssText;
    if (typeof v == "number")
      return v;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + v + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(k) + c[S + 1], c[0]);
  return new n0(g, c, Hc);
}, W4 = (c, u) => {
  if (jc)
    c.adoptedStyleSheets = u.map((g) => g instanceof CSSStyleSheet ? g : g.styleSheet);
  else
    for (const g of u) {
      const w = document.createElement("style"), k = Ss.litNonce;
      k !== void 0 && w.setAttribute("nonce", k), w.textContent = g.cssText, c.appendChild(w);
    }
}, aw = jc ? (c) => c : (c) => c instanceof CSSStyleSheet ? ((u) => {
  let g = "";
  for (const w of u.cssRules)
    g += w.cssText;
  return q4(g);
})(c) : c;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: G4, defineProperty: K4, getOwnPropertyDescriptor: Z4, getOwnPropertyNames: J4, getOwnPropertySymbols: Y4, getPrototypeOf: Q4 } = Object, Ln = globalThis, lw = Ln.trustedTypes, X4 = lw ? lw.emptyScript : "", mc = Ln.reactiveElementPolyfillSupport, nr = (c, u) => c, Ts = { toAttribute(c, u) {
  switch (u) {
    case Boolean:
      c = c ? X4 : null;
      break;
    case Object:
    case Array:
      c = c == null ? c : JSON.stringify(c);
  }
  return c;
}, fromAttribute(c, u) {
  let g = c;
  switch (u) {
    case Boolean:
      g = c !== null;
      break;
    case Number:
      g = c === null ? null : Number(c);
      break;
    case Object:
    case Array:
      try {
        g = JSON.parse(c);
      } catch {
        g = null;
      }
  }
  return g;
} }, qc = (c, u) => !G4(c, u), cw = { attribute: !0, type: String, converter: Ts, reflect: !1, hasChanged: qc };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Ln.litPropertyMetadata ?? (Ln.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class si extends HTMLElement {
  static addInitializer(u) {
    this._$Ei(), (this.l ?? (this.l = [])).push(u);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(u, g = cw) {
    if (g.state && (g.attribute = !1), this._$Ei(), this.elementProperties.set(u, g), !g.noAccessor) {
      const w = Symbol(), k = this.getPropertyDescriptor(u, w, g);
      k !== void 0 && K4(this.prototype, u, k);
    }
  }
  static getPropertyDescriptor(u, g, w) {
    const { get: k, set: S } = Z4(this.prototype, u) ?? { get() {
      return this[g];
    }, set(v) {
      this[g] = v;
    } };
    return { get() {
      return k == null ? void 0 : k.call(this);
    }, set(v) {
      const x = k == null ? void 0 : k.call(this);
      S.call(this, v), this.requestUpdate(u, x, w);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(u) {
    return this.elementProperties.get(u) ?? cw;
  }
  static _$Ei() {
    if (this.hasOwnProperty(nr("elementProperties")))
      return;
    const u = Q4(this);
    u.finalize(), u.l !== void 0 && (this.l = [...u.l]), this.elementProperties = new Map(u.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(nr("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(nr("properties"))) {
      const g = this.properties, w = [...J4(g), ...Y4(g)];
      for (const k of w)
        this.createProperty(k, g[k]);
    }
    const u = this[Symbol.metadata];
    if (u !== null) {
      const g = litPropertyMetadata.get(u);
      if (g !== void 0)
        for (const [w, k] of g)
          this.elementProperties.set(w, k);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [g, w] of this.elementProperties) {
      const k = this._$Eu(g, w);
      k !== void 0 && this._$Eh.set(k, g);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(u) {
    const g = [];
    if (Array.isArray(u)) {
      const w = new Set(u.flat(1 / 0).reverse());
      for (const k of w)
        g.unshift(aw(k));
    } else
      u !== void 0 && g.push(aw(u));
    return g;
  }
  static _$Eu(u, g) {
    const w = g.attribute;
    return w === !1 ? void 0 : typeof w == "string" ? w : typeof u == "string" ? u.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var u;
    this._$ES = new Promise((g) => this.enableUpdating = g), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (u = this.constructor.l) == null || u.forEach((g) => g(this));
  }
  addController(u) {
    var g;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(u), this.renderRoot !== void 0 && this.isConnected && ((g = u.hostConnected) == null || g.call(u));
  }
  removeController(u) {
    var g;
    (g = this._$EO) == null || g.delete(u);
  }
  _$E_() {
    const u = /* @__PURE__ */ new Map(), g = this.constructor.elementProperties;
    for (const w of g.keys())
      this.hasOwnProperty(w) && (u.set(w, this[w]), delete this[w]);
    u.size > 0 && (this._$Ep = u);
  }
  createRenderRoot() {
    const u = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return W4(u, this.constructor.elementStyles), u;
  }
  connectedCallback() {
    var u;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (u = this._$EO) == null || u.forEach((g) => {
      var w;
      return (w = g.hostConnected) == null ? void 0 : w.call(g);
    });
  }
  enableUpdating(u) {
  }
  disconnectedCallback() {
    var u;
    (u = this._$EO) == null || u.forEach((g) => {
      var w;
      return (w = g.hostDisconnected) == null ? void 0 : w.call(g);
    });
  }
  attributeChangedCallback(u, g, w) {
    this._$AK(u, w);
  }
  _$EC(u, g) {
    var S;
    const w = this.constructor.elementProperties.get(u), k = this.constructor._$Eu(u, w);
    if (k !== void 0 && w.reflect === !0) {
      const v = (((S = w.converter) == null ? void 0 : S.toAttribute) !== void 0 ? w.converter : Ts).toAttribute(g, w.type);
      this._$Em = u, v == null ? this.removeAttribute(k) : this.setAttribute(k, v), this._$Em = null;
    }
  }
  _$AK(u, g) {
    var S;
    const w = this.constructor, k = w._$Eh.get(u);
    if (k !== void 0 && this._$Em !== k) {
      const v = w.getPropertyOptions(k), x = typeof v.converter == "function" ? { fromAttribute: v.converter } : ((S = v.converter) == null ? void 0 : S.fromAttribute) !== void 0 ? v.converter : Ts;
      this._$Em = k, this[k] = x.fromAttribute(g, v.type), this._$Em = null;
    }
  }
  requestUpdate(u, g, w) {
    if (u !== void 0) {
      if (w ?? (w = this.constructor.getPropertyOptions(u)), !(w.hasChanged ?? qc)(this[u], g))
        return;
      this.P(u, g, w);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(u, g, w) {
    this._$AL.has(u) || this._$AL.set(u, g), w.reflect === !0 && this._$Em !== u && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(u);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (g) {
      Promise.reject(g);
    }
    const u = this.scheduleUpdate();
    return u != null && await u, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var w;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [S, v] of this._$Ep)
          this[S] = v;
        this._$Ep = void 0;
      }
      const k = this.constructor.elementProperties;
      if (k.size > 0)
        for (const [S, v] of k)
          v.wrapped !== !0 || this._$AL.has(S) || this[S] === void 0 || this.P(S, this[S], v);
    }
    let u = !1;
    const g = this._$AL;
    try {
      u = this.shouldUpdate(g), u ? (this.willUpdate(g), (w = this._$EO) == null || w.forEach((k) => {
        var S;
        return (S = k.hostUpdate) == null ? void 0 : S.call(k);
      }), this.update(g)) : this._$EU();
    } catch (k) {
      throw u = !1, this._$EU(), k;
    }
    u && this._$AE(g);
  }
  willUpdate(u) {
  }
  _$AE(u) {
    var g;
    (g = this._$EO) == null || g.forEach((w) => {
      var k;
      return (k = w.hostUpdated) == null ? void 0 : k.call(w);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(u)), this.updated(u);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(u) {
    return !0;
  }
  update(u) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((g) => this._$EC(g, this[g]))), this._$EU();
  }
  updated(u) {
  }
  firstUpdated(u) {
  }
}
si.elementStyles = [], si.shadowRootOptions = { mode: "open" }, si[nr("elementProperties")] = /* @__PURE__ */ new Map(), si[nr("finalized")] = /* @__PURE__ */ new Map(), mc == null || mc({ ReactiveElement: si }), (Ln.reactiveElementVersions ?? (Ln.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const or = globalThis, Ps = or.trustedTypes, dw = Ps ? Ps.createPolicy("lit-html", { createHTML: (c) => c }) : void 0, o0 = "$lit$", $n = `lit$${Math.random().toFixed(9).slice(2)}$`, i0 = "?" + $n, eO = `<${i0}>`, _o = document, ar = () => _o.createComment(""), lr = (c) => c === null || typeof c != "object" && typeof c != "function", r0 = Array.isArray, tO = (c) => r0(c) || typeof (c == null ? void 0 : c[Symbol.iterator]) == "function", pc = `[ 	
\f\r]`, Qi = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, uw = /-->/g, hw = />/g, fo = RegExp(`>|${pc}(?:([^\\s"'>=/]+)(${pc}*=${pc}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), gw = /'/g, mw = /"/g, s0 = /^(?:script|style|textarea|title)$/i, nO = (c) => (u, ...g) => ({ _$litType$: c, strings: u, values: g }), yn = nO(1), Ao = Symbol.for("lit-noChange"), gt = Symbol.for("lit-nothing"), pw = /* @__PURE__ */ new WeakMap(), ko = _o.createTreeWalker(_o, 129);
function a0(c, u) {
  if (!Array.isArray(c) || !c.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return dw !== void 0 ? dw.createHTML(u) : u;
}
const oO = (c, u) => {
  const g = c.length - 1, w = [];
  let k, S = u === 2 ? "<svg>" : "", v = Qi;
  for (let x = 0; x < g; x++) {
    const p = c[x];
    let D, y, C = -1, b = 0;
    for (; b < p.length && (v.lastIndex = b, y = v.exec(p), y !== null); )
      b = v.lastIndex, v === Qi ? y[1] === "!--" ? v = uw : y[1] !== void 0 ? v = hw : y[2] !== void 0 ? (s0.test(y[2]) && (k = RegExp("</" + y[2], "g")), v = fo) : y[3] !== void 0 && (v = fo) : v === fo ? y[0] === ">" ? (v = k ?? Qi, C = -1) : y[1] === void 0 ? C = -2 : (C = v.lastIndex - y[2].length, D = y[1], v = y[3] === void 0 ? fo : y[3] === '"' ? mw : gw) : v === mw || v === gw ? v = fo : v === uw || v === hw ? v = Qi : (v = fo, k = void 0);
    const A = v === fo && c[x + 1].startsWith("/>") ? " " : "";
    S += v === Qi ? p + eO : C >= 0 ? (w.push(D), p.slice(0, C) + o0 + p.slice(C) + $n + A) : p + $n + (C === -2 ? x : A);
  }
  return [a0(c, S + (c[g] || "<?>") + (u === 2 ? "</svg>" : "")), w];
};
class cr {
  constructor({ strings: u, _$litType$: g }, w) {
    let k;
    this.parts = [];
    let S = 0, v = 0;
    const x = u.length - 1, p = this.parts, [D, y] = oO(u, g);
    if (this.el = cr.createElement(D, w), ko.currentNode = this.el.content, g === 2) {
      const C = this.el.content.firstChild;
      C.replaceWith(...C.childNodes);
    }
    for (; (k = ko.nextNode()) !== null && p.length < x; ) {
      if (k.nodeType === 1) {
        if (k.hasAttributes())
          for (const C of k.getAttributeNames())
            if (C.endsWith(o0)) {
              const b = y[v++], A = k.getAttribute(C).split($n), P = /([.?@])?(.*)/.exec(b);
              p.push({ type: 1, index: S, name: P[2], strings: A, ctor: P[1] === "." ? rO : P[1] === "?" ? sO : P[1] === "@" ? aO : zs }), k.removeAttribute(C);
            } else
              C.startsWith($n) && (p.push({ type: 6, index: S }), k.removeAttribute(C));
        if (s0.test(k.tagName)) {
          const C = k.textContent.split($n), b = C.length - 1;
          if (b > 0) {
            k.textContent = Ps ? Ps.emptyScript : "";
            for (let A = 0; A < b; A++)
              k.append(C[A], ar()), ko.nextNode(), p.push({ type: 2, index: ++S });
            k.append(C[b], ar());
          }
        }
      } else if (k.nodeType === 8)
        if (k.data === i0)
          p.push({ type: 2, index: S });
        else {
          let C = -1;
          for (; (C = k.data.indexOf($n, C + 1)) !== -1; )
            p.push({ type: 7, index: S }), C += $n.length - 1;
        }
      S++;
    }
  }
  static createElement(u, g) {
    const w = _o.createElement("template");
    return w.innerHTML = u, w;
  }
}
function ui(c, u, g = c, w) {
  var v, x;
  if (u === Ao)
    return u;
  let k = w !== void 0 ? (v = g._$Co) == null ? void 0 : v[w] : g._$Cl;
  const S = lr(u) ? void 0 : u._$litDirective$;
  return (k == null ? void 0 : k.constructor) !== S && ((x = k == null ? void 0 : k._$AO) == null || x.call(k, !1), S === void 0 ? k = void 0 : (k = new S(c), k._$AT(c, g, w)), w !== void 0 ? (g._$Co ?? (g._$Co = []))[w] = k : g._$Cl = k), k !== void 0 && (u = ui(c, k._$AS(c, u.values), k, w)), u;
}
class iO {
  constructor(u, g) {
    this._$AV = [], this._$AN = void 0, this._$AD = u, this._$AM = g;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(u) {
    const { el: { content: g }, parts: w } = this._$AD, k = ((u == null ? void 0 : u.creationScope) ?? _o).importNode(g, !0);
    ko.currentNode = k;
    let S = ko.nextNode(), v = 0, x = 0, p = w[0];
    for (; p !== void 0; ) {
      if (v === p.index) {
        let D;
        p.type === 2 ? D = new hr(S, S.nextSibling, this, u) : p.type === 1 ? D = new p.ctor(S, p.name, p.strings, this, u) : p.type === 6 && (D = new lO(S, this, u)), this._$AV.push(D), p = w[++x];
      }
      v !== (p == null ? void 0 : p.index) && (S = ko.nextNode(), v++);
    }
    return ko.currentNode = _o, k;
  }
  p(u) {
    let g = 0;
    for (const w of this._$AV)
      w !== void 0 && (w.strings !== void 0 ? (w._$AI(u, w, g), g += w.strings.length - 2) : w._$AI(u[g])), g++;
  }
}
class hr {
  get _$AU() {
    var u;
    return ((u = this._$AM) == null ? void 0 : u._$AU) ?? this._$Cv;
  }
  constructor(u, g, w, k) {
    this.type = 2, this._$AH = gt, this._$AN = void 0, this._$AA = u, this._$AB = g, this._$AM = w, this.options = k, this._$Cv = (k == null ? void 0 : k.isConnected) ?? !0;
  }
  get parentNode() {
    let u = this._$AA.parentNode;
    const g = this._$AM;
    return g !== void 0 && (u == null ? void 0 : u.nodeType) === 11 && (u = g.parentNode), u;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(u, g = this) {
    u = ui(this, u, g), lr(u) ? u === gt || u == null || u === "" ? (this._$AH !== gt && this._$AR(), this._$AH = gt) : u !== this._$AH && u !== Ao && this._(u) : u._$litType$ !== void 0 ? this.$(u) : u.nodeType !== void 0 ? this.T(u) : tO(u) ? this.k(u) : this._(u);
  }
  S(u) {
    return this._$AA.parentNode.insertBefore(u, this._$AB);
  }
  T(u) {
    this._$AH !== u && (this._$AR(), this._$AH = this.S(u));
  }
  _(u) {
    this._$AH !== gt && lr(this._$AH) ? this._$AA.nextSibling.data = u : this.T(_o.createTextNode(u)), this._$AH = u;
  }
  $(u) {
    var S;
    const { values: g, _$litType$: w } = u, k = typeof w == "number" ? this._$AC(u) : (w.el === void 0 && (w.el = cr.createElement(a0(w.h, w.h[0]), this.options)), w);
    if (((S = this._$AH) == null ? void 0 : S._$AD) === k)
      this._$AH.p(g);
    else {
      const v = new iO(k, this), x = v.u(this.options);
      v.p(g), this.T(x), this._$AH = v;
    }
  }
  _$AC(u) {
    let g = pw.get(u.strings);
    return g === void 0 && pw.set(u.strings, g = new cr(u)), g;
  }
  k(u) {
    r0(this._$AH) || (this._$AH = [], this._$AR());
    const g = this._$AH;
    let w, k = 0;
    for (const S of u)
      k === g.length ? g.push(w = new hr(this.S(ar()), this.S(ar()), this, this.options)) : w = g[k], w._$AI(S), k++;
    k < g.length && (this._$AR(w && w._$AB.nextSibling, k), g.length = k);
  }
  _$AR(u = this._$AA.nextSibling, g) {
    var w;
    for ((w = this._$AP) == null ? void 0 : w.call(this, !1, !0, g); u && u !== this._$AB; ) {
      const k = u.nextSibling;
      u.remove(), u = k;
    }
  }
  setConnected(u) {
    var g;
    this._$AM === void 0 && (this._$Cv = u, (g = this._$AP) == null || g.call(this, u));
  }
}
class zs {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(u, g, w, k, S) {
    this.type = 1, this._$AH = gt, this._$AN = void 0, this.element = u, this.name = g, this._$AM = k, this.options = S, w.length > 2 || w[0] !== "" || w[1] !== "" ? (this._$AH = Array(w.length - 1).fill(new String()), this.strings = w) : this._$AH = gt;
  }
  _$AI(u, g = this, w, k) {
    const S = this.strings;
    let v = !1;
    if (S === void 0)
      u = ui(this, u, g, 0), v = !lr(u) || u !== this._$AH && u !== Ao, v && (this._$AH = u);
    else {
      const x = u;
      let p, D;
      for (u = S[0], p = 0; p < S.length - 1; p++)
        D = ui(this, x[w + p], g, p), D === Ao && (D = this._$AH[p]), v || (v = !lr(D) || D !== this._$AH[p]), D === gt ? u = gt : u !== gt && (u += (D ?? "") + S[p + 1]), this._$AH[p] = D;
    }
    v && !k && this.j(u);
  }
  j(u) {
    u === gt ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, u ?? "");
  }
}
class rO extends zs {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(u) {
    this.element[this.name] = u === gt ? void 0 : u;
  }
}
class sO extends zs {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(u) {
    this.element.toggleAttribute(this.name, !!u && u !== gt);
  }
}
class aO extends zs {
  constructor(u, g, w, k, S) {
    super(u, g, w, k, S), this.type = 5;
  }
  _$AI(u, g = this) {
    if ((u = ui(this, u, g, 0) ?? gt) === Ao)
      return;
    const w = this._$AH, k = u === gt && w !== gt || u.capture !== w.capture || u.once !== w.once || u.passive !== w.passive, S = u !== gt && (w === gt || k);
    k && this.element.removeEventListener(this.name, this, w), S && this.element.addEventListener(this.name, this, u), this._$AH = u;
  }
  handleEvent(u) {
    var g;
    typeof this._$AH == "function" ? this._$AH.call(((g = this.options) == null ? void 0 : g.host) ?? this.element, u) : this._$AH.handleEvent(u);
  }
}
class lO {
  constructor(u, g, w) {
    this.element = u, this.type = 6, this._$AN = void 0, this._$AM = g, this.options = w;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(u) {
    ui(this, u);
  }
}
const fc = or.litHtmlPolyfillSupport;
fc == null || fc(cr, hr), (or.litHtmlVersions ?? (or.litHtmlVersions = [])).push("3.1.3");
const cO = (c, u, g) => {
  const w = (g == null ? void 0 : g.renderBefore) ?? u;
  let k = w._$litPart$;
  if (k === void 0) {
    const S = (g == null ? void 0 : g.renderBefore) ?? null;
    w._$litPart$ = k = new hr(u.insertBefore(ar(), S), S, void 0, g ?? {});
  }
  return k._$AI(c), k;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class ir extends si {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var g;
    const u = super.createRenderRoot();
    return (g = this.renderOptions).renderBefore ?? (g.renderBefore = u.firstChild), u;
  }
  update(u) {
    const g = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(u), this._$Do = cO(g, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var u;
    super.connectedCallback(), (u = this._$Do) == null || u.setConnected(!0);
  }
  disconnectedCallback() {
    var u;
    super.disconnectedCallback(), (u = this._$Do) == null || u.setConnected(!1);
  }
  render() {
    return Ao;
  }
}
var xw;
ir._$litElement$ = !0, ir.finalized = !0, (xw = globalThis.litElementHydrateSupport) == null || xw.call(globalThis, { LitElement: ir });
const bc = globalThis.litElementPolyfillSupport;
bc == null || bc({ LitElement: ir });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.5");
var dO = Uc`
  :host {
    --slide-gap: var(--sl-spacing-medium, 1rem);
    --aspect-ratio: 16 / 9;
    --scroll-hint: 0px;

    display: flex;
  }

  .carousel {
    display: grid;
    grid-template-columns: min-content 1fr min-content;
    grid-template-rows: 1fr min-content;
    grid-template-areas:
      '. slides .'
      '. pagination .';
    gap: var(--sl-spacing-medium);
    align-items: center;
    min-height: 100%;
    min-width: 100%;
    position: relative;
  }

  .carousel__pagination {
    grid-area: pagination;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--sl-spacing-small);
  }

  .carousel__slides {
    grid-area: slides;

    display: grid;
    height: 100%;
    width: 100%;
    align-items: center;
    justify-items: center;
    overflow: auto;
    overscroll-behavior-x: contain;
    scrollbar-width: none;
    aspect-ratio: calc(var(--aspect-ratio) * var(--slides-per-page));
    border-radius: var(--sl-border-radius-small);

    --slide-size: calc((100% - (var(--slides-per-page) - 1) * var(--slide-gap)) / var(--slides-per-page));
  }

  @media (prefers-reduced-motion) {
    :where(.carousel__slides) {
      scroll-behavior: auto;
    }
  }

  .carousel__slides--horizontal {
    grid-auto-flow: column;
    grid-auto-columns: var(--slide-size);
    grid-auto-rows: 100%;
    column-gap: var(--slide-gap);
    scroll-snap-type: x mandatory;
    scroll-padding-inline: var(--scroll-hint);
    padding-inline: var(--scroll-hint);
    overflow-y: hidden;
  }

  .carousel__slides--vertical {
    grid-auto-flow: row;
    grid-auto-columns: 100%;
    grid-auto-rows: var(--slide-size);
    row-gap: var(--slide-gap);
    scroll-snap-type: y mandatory;
    scroll-padding-block: var(--scroll-hint);
    padding-block: var(--scroll-hint);
    overflow-x: hidden;
  }

  .carousel__slides--dragging {
  }

  :host([vertical]) ::slotted(sl-carousel-item) {
    height: 100%;
  }

  .carousel__slides::-webkit-scrollbar {
    display: none;
  }

  .carousel__navigation {
    grid-area: navigation;
    display: contents;
    font-size: var(--sl-font-size-x-large);
  }

  .carousel__navigation-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-small);
    font-size: inherit;
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-medium) color;
    appearance: none;
  }

  .carousel__navigation-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .carousel__navigation-button--disabled::part(base) {
    pointer-events: none;
  }

  .carousel__navigation-button--previous {
    grid-column: 1;
    grid-row: 1;
  }

  .carousel__navigation-button--next {
    grid-column: 3;
    grid-row: 1;
  }

  .carousel__pagination-item {
    display: block;
    cursor: pointer;
    background: none;
    border: 0;
    border-radius: var(--sl-border-radius-circle);
    width: var(--sl-spacing-small);
    height: var(--sl-spacing-small);
    background-color: var(--sl-color-neutral-300);
    padding: 0;
    margin: 0;
  }

  .carousel__pagination-item--active {
    background-color: var(--sl-color-neutral-700);
    transform: scale(1.2);
  }

  /* Focus styles */
  .carousel__slides:focus-visible,
  .carousel__navigation-button:focus-visible,
  .carousel__pagination-item:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`, l0 = Object.defineProperty, uO = Object.getOwnPropertyDescriptor, fw = Object.getOwnPropertySymbols, hO = Object.prototype.hasOwnProperty, gO = Object.prototype.propertyIsEnumerable, bw = (c, u, g) => u in c ? l0(c, u, { enumerable: !0, configurable: !0, writable: !0, value: g }) : c[u] = g, c0 = (c, u) => {
  for (var g in u || (u = {}))
    hO.call(u, g) && bw(c, g, u[g]);
  if (fw)
    for (var g of fw(u))
      gO.call(u, g) && bw(c, g, u[g]);
  return c;
}, Oe = (c, u, g, w) => {
  for (var k = w > 1 ? void 0 : w ? uO(u, g) : u, S = c.length - 1, v; S >= 0; S--)
    (v = c[S]) && (k = (w ? v(u, g, k) : v(k)) || k);
  return w && k && l0(u, g, k), k;
};
function mO(c, u) {
  return new Promise((g) => {
    function w(k) {
      k.target === c && (c.removeEventListener(u, w), g());
    }
    c.addEventListener(u, w);
  });
}
function kw() {
  return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
}
const Dc = /* @__PURE__ */ new Set(), pO = new MutationObserver(g0), ai = /* @__PURE__ */ new Map();
let d0 = document.documentElement.dir || "ltr", u0 = document.documentElement.lang || navigator.language, bo;
pO.observe(document.documentElement, {
  attributes: !0,
  attributeFilter: ["dir", "lang"]
});
function h0(...c) {
  c.map((u) => {
    const g = u.$code.toLowerCase();
    ai.has(g) ? ai.set(g, Object.assign(Object.assign({}, ai.get(g)), u)) : ai.set(g, u), bo || (bo = u);
  }), g0();
}
function g0() {
  d0 = document.documentElement.dir || "ltr", u0 = document.documentElement.lang || navigator.language, [...Dc.keys()].map((c) => {
    typeof c.requestUpdate == "function" && c.requestUpdate();
  });
}
let fO = class {
  constructor(u) {
    this.host = u, this.host.addController(this);
  }
  hostConnected() {
    Dc.add(this.host);
  }
  hostDisconnected() {
    Dc.delete(this.host);
  }
  dir() {
    return `${this.host.dir || d0}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || u0}`.toLowerCase();
  }
  getTranslationData(u) {
    var g, w;
    const k = new Intl.Locale(u.replace(/_/g, "-")), S = k == null ? void 0 : k.language.toLowerCase(), v = (w = (g = k == null ? void 0 : k.region) === null || g === void 0 ? void 0 : g.toLowerCase()) !== null && w !== void 0 ? w : "", x = ai.get(`${S}-${v}`), p = ai.get(S);
    return { locale: k, language: S, region: v, primary: x, secondary: p };
  }
  exists(u, g) {
    var w;
    const { primary: k, secondary: S } = this.getTranslationData((w = g.lang) !== null && w !== void 0 ? w : this.lang());
    return g = Object.assign({ includeFallback: !1 }, g), !!(k && k[u] || S && S[u] || g.includeFallback && bo && bo[u]);
  }
  term(u, ...g) {
    const { primary: w, secondary: k } = this.getTranslationData(this.lang());
    let S;
    if (w && w[u])
      S = w[u];
    else if (k && k[u])
      S = k[u];
    else if (bo && bo[u])
      S = bo[u];
    else
      return console.error(`No translation found for: ${String(u)}`), String(u);
    return typeof S == "function" ? S(...g) : S;
  }
  date(u, g) {
    return u = new Date(u), new Intl.DateTimeFormat(this.lang(), g).format(u);
  }
  number(u, g) {
    return u = Number(u), isNaN(u) ? "" : new Intl.NumberFormat(this.lang(), g).format(u);
  }
  relativeTime(u, g, w) {
    return new Intl.RelativeTimeFormat(this.lang(), w).format(u, g);
  }
};
var m0 = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (c, u) => `Go to slide ${c} of ${u}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextMonth: "Next month",
  nextSlide: "Next slide",
  numOptionsSelected: (c) => c === 0 ? "No options selected" : c === 1 ? "1 option selected" : `${c} options selected`,
  previousMonth: "Previous month",
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (c) => `Slide ${c}`,
  toggleColorFormat: "Toggle color format"
};
h0(m0);
var bO = m0, kO = class extends fO {
};
h0(bO);
var Bc = "";
function ww(c) {
  Bc = c;
}
function Tc(c = "") {
  if (!Bc) {
    const u = [...document.getElementsByTagName("script")], g = u.find((w) => w.hasAttribute("data-shoelace"));
    if (g)
      ww(g.getAttribute("data-shoelace"));
    else {
      const w = u.find((S) => /shoelace(\.min)?\.js($|\?)/.test(S.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(S.src));
      let k = "";
      w && (k = w.getAttribute("src")), ww(k.split("/").slice(0, -1).join("/"));
    }
  }
  return Bc.replace(/\/$/, "") + (c ? `/${c.replace(/^\//, "")}` : "");
}
var wO = {
  name: "default",
  resolver: (c, u = !1) => Tc(u ? `assets/bootstrap-icons/${c}.svg` : `assets/bootstrap-icons/${c.substring(0, 1)}/${c}.svg`)
}, vO = wO, _O = {
  name: "viur",
  resolver: (c, u = !1) => Tc(`/assets/icons/${c}.svg`),
  mutator: (c) => {
    c.setAttribute("fill", "currentColor"), [...c.querySelectorAll("*")].map((u) => u.setAttribute("fill", "inherit"));
  }
}, AO = _O, vw = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  checked: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <rect x="2" y="2" width="12" height="12" stroke-width="2"></rect>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="2" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="6"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `,
  search: `
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
      <path d="M11.742 10.344a6.5 6.5 0 10-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 001.415-1.414l-3.85-3.85a1.007 1.007 0 00-.115-.1zM12 6.5a5.5 5.5 0 11-11 0 5.5 5.5 0 0111 0z"></path>
    </svg>
  `
}, CO = {
  name: "system",
  resolver: (c, u = !1) => c in vw ? `data:image/svg+xml,${encodeURIComponent(vw[c])}` : ""
}, yO = CO, EO = [AO, vO, yO], Pc = [];
function xO(c) {
  Pc.push(c);
}
function SO(c) {
  Pc = Pc.filter((u) => u !== c);
}
function _w(c) {
  return EO.find((u) => u.name === c);
}
var DO = Uc`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;
function Co(c, u) {
  const g = c0({
    waitUntilFirstUpdate: !1
  }, u);
  return (w, k) => {
    const { update: S } = w, v = Array.isArray(c) ? c : [c];
    w.update = function(x) {
      v.forEach((p) => {
        const D = p;
        if (x.has(D)) {
          const y = x.get(D), C = this[D];
          y !== C && (!g.waitUntilFirstUpdate || this.hasUpdated) && this[k](y, C);
        }
      }), S.call(this, x);
    };
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const BO = { attribute: !0, type: String, converter: Ts, reflect: !1, hasChanged: qc }, TO = (c = BO, u, g) => {
  const { kind: w, metadata: k } = g;
  let S = globalThis.litPropertyMetadata.get(k);
  if (S === void 0 && globalThis.litPropertyMetadata.set(k, S = /* @__PURE__ */ new Map()), S.set(g.name, c), w === "accessor") {
    const { name: v } = g;
    return { set(x) {
      const p = u.get.call(this);
      u.set.call(this, x), this.requestUpdate(v, p, c);
    }, init(x) {
      return x !== void 0 && this.P(v, void 0, c), x;
    } };
  }
  if (w === "setter") {
    const { name: v } = g;
    return function(x) {
      const p = this[v];
      u.call(this, x), this.requestUpdate(v, p, c);
    };
  }
  throw Error("Unsupported decorator location: " + w);
};
function mt(c) {
  return (u, g) => typeof g == "object" ? TO(c, u, g) : ((w, k, S) => {
    const v = k.hasOwnProperty(S);
    return k.constructor.createProperty(S, v ? { ...w, wrapped: !0 } : w), v ? Object.getOwnPropertyDescriptor(k, S) : void 0;
  })(c, u, g);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Ms(c) {
  return mt({ ...c, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function PO(c) {
  return (u, g) => {
    const w = typeof u == "function" ? u : u[g];
    Object.assign(w, c);
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Aw = (c, u, g) => (g.configurable = !0, g.enumerable = !0, Reflect.decorate && typeof u != "object" && Object.defineProperty(c, u, g), g);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function p0(c, u) {
  return (g, w, k) => {
    const S = (v) => {
      var x;
      return ((x = v.renderRoot) == null ? void 0 : x.querySelector(c)) ?? null;
    };
    if (u) {
      const { get: v, set: x } = typeof w == "object" ? g : k ?? (() => {
        const p = Symbol();
        return { get() {
          return this[p];
        }, set(D) {
          this[p] = D;
        } };
      })();
      return Aw(g, w, { get() {
        let p = v.call(this);
        return p === void 0 && (p = S(this), (p !== null || this.hasUpdated) && x.call(this, p)), p;
      } });
    }
    return Aw(g, w, { get() {
      return S(this);
    } });
  };
}
var gi = class extends ir {
  constructor() {
    super(), Object.entries(this.constructor.dependencies).forEach(([c, u]) => {
      this.constructor.define(c, u);
    });
  }
  emit(c, u) {
    const g = new CustomEvent(c, c0({
      bubbles: !0,
      cancelable: !1,
      composed: !0,
      detail: {}
    }, u));
    return this.dispatchEvent(g), g;
  }
  /* eslint-enable */
  static define(c, u = this, g = {}) {
    const w = customElements.get(c);
    if (!w) {
      customElements.define(c, class extends u {
      }, g);
      return;
    }
    let k = " (unknown version)", S = k;
    "version" in u && u.version && (k = " v" + u.version), "version" in w && w.version && (S = " v" + w.version), !(k && S && k === S) && console.warn(
      `Attempted to register <${c}>${k}, but <${c}>${S} has already been registered.`
    );
  }
};
gi.version = "1.0.6-v2.15.0";
gi.dependencies = {};
Oe([
  mt()
], gi.prototype, "dir", 2);
Oe([
  mt()
], gi.prototype, "lang", 2);
var f0 = Uc`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: border-box;
  }

  [hidden] {
    display: none !important;
  }
`;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const IO = (c, u) => u === void 0 ? (c == null ? void 0 : c._$litType$) !== void 0 : (c == null ? void 0 : c._$litType$) === u;
var Xi = Symbol(), Es = Symbol(), kc, wc = /* @__PURE__ */ new Map(), Jt = class extends gi {
  constructor() {
    super(...arguments), this.initialRender = !1, this.svg = null, this.label = "", this.library = "default", this.vueonce = !0, this.sprite = !1;
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(c, u) {
    var g;
    let w;
    if (u != null && u.spriteSheet) {
      this.svg = yn`<svg part="svg">
        <use part="use" href="${c}"></use>
      </svg>`, await this.updateComplete;
      const k = this.shadowRoot.querySelector("[part='svg']");
      return typeof u.mutator == "function" && u.mutator(k), this.svg;
    }
    try {
      if (w = await fetch(c, { mode: "cors" }), !w.ok)
        return w.status === 410 ? Xi : Es;
    } catch {
      return Es;
    }
    try {
      const k = document.createElement("div");
      k.innerHTML = await w.text();
      const S = k.firstElementChild;
      if (((g = S == null ? void 0 : S.tagName) == null ? void 0 : g.toLowerCase()) !== "svg")
        return Xi;
      kc || (kc = new DOMParser());
      const x = kc.parseFromString(S.outerHTML, "text/html").body.querySelector("svg");
      return x ? (x.part.add("svg"), document.adoptNode(x)) : Xi;
    } catch {
      return Xi;
    }
  }
  connectedCallback() {
    super.connectedCallback(), xO(this);
  }
  firstUpdated() {
    this.sprite || this.setIcon(), this.initialRender = !0, this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), SO(this);
  }
  getIconSource(c = !1) {
    const u = _w(this.library);
    return this.name && u ? {
      url: u.resolver(this.name, c),
      fromLibrary: !0
    } : {
      url: this.src,
      fromLibrary: !1
    };
  }
  getDir() {
    const { url: c } = this.getIconSource(!0);
    return c == null ? void 0 : c.substring(0, c == null ? void 0 : c.lastIndexOf("/"));
  }
  // Fetches the icon and redraws it. Used to handle library registrations.
  redraw() {
    this.sprite || this.setIcon();
  }
  handleLabelChange() {
    typeof this.label == "string" && this.label.length > 0 ? (this.setAttribute("role", "img"), this.setAttribute("aria-label", this.label), this.removeAttribute("aria-hidden")) : (this.removeAttribute("role"), this.removeAttribute("aria-label"), this.setAttribute("aria-hidden", "true"));
  }
  async setIcon() {
    var c;
    const { url: u, fromLibrary: g } = this.getIconSource(), w = g ? _w(this.library) : void 0;
    if (!u) {
      this.svg = null;
      return;
    }
    let k = wc.get(u);
    if (k || (k = this.resolveIcon(u, w), wc.set(u, k)), !this.initialRender)
      return;
    const S = await k;
    if (S === Es && wc.delete(u), u === this.getIconSource().url) {
      if (IO(S)) {
        this.svg = S;
        return;
      }
      switch (S) {
        case Es:
        case Xi:
          this.svg = null, this.emit("sl-error");
          break;
        default:
          this.svg = S.cloneNode(!0), (c = w == null ? void 0 : w.mutator) == null || c.call(w, this.svg), this.emit("sl-load");
      }
    }
  }
  handleChange() {
    this.sprite || this.setIcon();
  }
  render() {
    return yn`
    ${this.sprite ? yn`<svg width="1em" height="1em">
            <use href="${this.getDir()}/_sprite.svg#${this.name}"></use>
          </svg>` : yn`${this.svg}`}`;
  }
};
Jt.styles = [f0, DO];
Oe([
  Ms()
], Jt.prototype, "svg", 2);
Oe([
  mt({ reflect: !0 })
], Jt.prototype, "name", 2);
Oe([
  mt()
], Jt.prototype, "src", 2);
Oe([
  mt()
], Jt.prototype, "label", 2);
Oe([
  mt({ reflect: !0 })
], Jt.prototype, "library", 2);
Oe([
  mt({ reflect: !0, type: Boolean, attribute: "v-once" })
], Jt.prototype, "vueonce", 2);
Oe([
  mt({ reflect: !0, type: Boolean })
], Jt.prototype, "sprite", 2);
Oe([
  Co("label")
], Jt.prototype, "handleLabelChange", 1);
Oe([
  Co(["name", "src", "library"])
], Jt.prototype, "setIcon", 1);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const OO = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, RO = (c) => (...u) => ({ _$litDirective$: c, values: u });
class zO {
  constructor(u) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(u, g, w) {
    this._$Ct = u, this._$AM = g, this._$Ci = w;
  }
  _$AS(u, g) {
    return this.update(u, g);
  }
  update(u, g) {
    return this.render(...g);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const xs = RO(class extends zO {
  constructor(c) {
    var u;
    if (super(c), c.type !== OO.ATTRIBUTE || c.name !== "class" || ((u = c.strings) == null ? void 0 : u.length) > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(c) {
    return " " + Object.keys(c).filter((u) => c[u]).join(" ") + " ";
  }
  update(c, [u]) {
    var w, k;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), c.strings !== void 0 && (this.nt = new Set(c.strings.join(" ").split(/\s/).filter((S) => S !== "")));
      for (const S in u)
        u[S] && !((w = this.nt) != null && w.has(S)) && this.st.add(S);
      return this.render(u);
    }
    const g = c.element.classList;
    for (const S of this.st)
      S in u || (g.remove(S), this.st.delete(S));
    for (const S in u) {
      const v = !!u[S];
      v === this.st.has(S) || (k = this.nt) != null && k.has(S) || (v ? (g.add(S), this.st.add(S)) : (g.remove(S), this.st.delete(S)));
    }
    return Ao;
  }
});
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* Cw(c, u) {
  if (c !== void 0) {
    let g = 0;
    for (const w of c)
      yield u(w, g++);
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* yw(c, u, g = 1) {
  const w = u === void 0 ? 0 : c;
  u ?? (u = c);
  for (let k = w; g > 0 ? k < u : u < k; k += g)
    yield k;
}
var MO = (c, u) => {
  let g = 0;
  return function(...w) {
    window.clearTimeout(g), g = window.setTimeout(() => {
      c.call(this, ...w);
    }, u);
  };
}, Ew = (c, u, g) => {
  const w = c[u];
  c[u] = function(...k) {
    w.call(this, ...k), g.call(this, w, ...k);
  };
}, NO = "onscrollend" in window;
if (!NO) {
  const c = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new WeakMap(), g = (k) => {
    for (const S of k.changedTouches)
      c.add(S.identifier);
  }, w = (k) => {
    for (const S of k.changedTouches)
      c.delete(S.identifier);
  };
  document.addEventListener("touchstart", g, !0), document.addEventListener("touchend", w, !0), document.addEventListener("touchcancel", w, !0), Ew(EventTarget.prototype, "addEventListener", function(k, S) {
    if (S !== "scrollend")
      return;
    const v = MO(() => {
      c.size ? v() : this.dispatchEvent(new Event("scrollend"));
    }, 100);
    k.call(this, "scroll", v, { passive: !0 }), u.set(this, v);
  }), Ew(EventTarget.prototype, "removeEventListener", function(k, S) {
    if (S !== "scrollend")
      return;
    const v = u.get(this);
    v && k.call(this, "scroll", v, { passive: !0 });
  });
}
var nt = class extends gi {
  constructor() {
    super(...arguments), this.loop = !1, this.navigation = !1, this.pagination = !1, this.autoplay = !1, this.autoplayInterval = 3e3, this.slidesPerPage = 1, this.slidesPerMove = 1, this.orientation = "horizontal", this.mouseDragging = !1, this.activeSlide = 0, this.scrolling = !1, this.dragging = !1, this.autoplayController = new U4(this, () => this.next()), this.localize = new kO(this), this.handleMouseDrag = (c) => {
      this.dragging || (this.scrollContainer.style.setProperty("scroll-snap-type", "none"), this.dragging = !0), this.scrollContainer.scrollBy({
        left: -c.movementX,
        top: -c.movementY,
        behavior: "instant"
      });
    }, this.handleMouseDragEnd = () => {
      const c = this.scrollContainer;
      document.removeEventListener("pointermove", this.handleMouseDrag, { capture: !0 });
      const u = c.scrollLeft, g = c.scrollTop;
      c.style.removeProperty("scroll-snap-type"), c.style.setProperty("overflow", "hidden");
      const w = c.scrollLeft, k = c.scrollTop;
      c.style.removeProperty("overflow"), c.style.setProperty("scroll-snap-type", "none"), c.scrollTo({ left: u, top: g, behavior: "instant" }), requestAnimationFrame(async () => {
        (u !== w || g !== k) && (c.scrollTo({
          left: w,
          top: k,
          behavior: kw() ? "auto" : "smooth"
        }), await mO(c, "scrollend")), c.style.removeProperty("scroll-snap-type"), this.dragging = !1, this.handleScrollEnd();
      });
    }, this.handleSlotChange = (c) => {
      c.some(
        (g) => [...g.addedNodes, ...g.removedNodes].some(
          (w) => this.isCarouselItem(w) && !w.hasAttribute("data-clone")
        )
      ) && this.initializeSlides(), this.requestUpdate();
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "region"), this.setAttribute("aria-label", this.localize.term("carousel"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.mutationObserver.disconnect();
  }
  firstUpdated() {
    this.initializeSlides(), this.mutationObserver = new MutationObserver(this.handleSlotChange), this.mutationObserver.observe(this, {
      childList: !0,
      subtree: !0
    });
  }
  willUpdate(c) {
    (c.has("slidesPerMove") || c.has("slidesPerPage")) && (this.slidesPerMove = Math.min(this.slidesPerMove, this.slidesPerPage));
  }
  getPageCount() {
    const c = this.getSlides().length, { slidesPerPage: u, slidesPerMove: g, loop: w } = this, k = w ? c / g : (c - u) / g + 1;
    return Math.ceil(k);
  }
  getCurrentPage() {
    return Math.ceil(this.activeSlide / this.slidesPerMove);
  }
  getShadowSlideCount() {
    return this.slidesPerPage - this.getSlides().length % this.slidesPerPage;
  }
  canScrollNext() {
    return this.loop || this.getCurrentPage() < this.getPageCount() - 1;
  }
  canScrollPrev() {
    return this.loop || this.getCurrentPage() > 0;
  }
  /** @internal Gets all carousel items. */
  getSlides({ excludeClones: c = !0 } = {}) {
    return [...this.children].filter(
      (u) => this.isCarouselItem(u) && (!c || !u.hasAttribute("data-clone"))
    );
  }
  handleKeyDown(c) {
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(c.key)) {
      const u = c.target, g = this.localize.dir() === "rtl", w = u.closest('[part~="pagination-item"]') !== null, k = c.key === "ArrowDown" || !g && c.key === "ArrowRight" || g && c.key === "ArrowLeft", S = c.key === "ArrowUp" || !g && c.key === "ArrowLeft" || g && c.key === "ArrowRight";
      c.preventDefault(), S && this.previous(), k && this.next(), c.key === "Home" && this.goToSlide(0), c.key === "End" && this.goToSlide(this.getSlides().length - 1), w && this.updateComplete.then(() => {
        var v;
        const x = (v = this.shadowRoot) == null ? void 0 : v.querySelector(
          '[part~="pagination-item--active"]'
        );
        x && x.focus();
      });
    }
  }
  handleMouseDragStart(c) {
    this.mouseDragging && c.button === 0 && (c.preventDefault(), document.addEventListener("pointermove", this.handleMouseDrag, { capture: !0, passive: !0 }), document.addEventListener("pointerup", this.handleMouseDragEnd, { capture: !0, once: !0 }));
  }
  handleScroll() {
    this.scrolling = !0;
  }
  /** @internal Synchronizes the slides with the IntersectionObserver API. */
  synchronizeSlides() {
    const c = new IntersectionObserver(
      (u) => {
        c.disconnect();
        for (const w of u) {
          const k = w.target;
          k.toggleAttribute("inert", !w.isIntersecting), k.classList.toggle("--in-view", w.isIntersecting), k.setAttribute("aria-hidden", w.isIntersecting ? "false" : "true");
        }
        const g = u.find((w) => w.isIntersecting);
        if (g)
          if (this.loop && g.target.hasAttribute("data-clone")) {
            const w = Number(g.target.getAttribute("data-clone"));
            this.goToSlide(w, "instant");
          } else {
            const k = this.getSlides().indexOf(g.target);
            this.activeSlide = Math.ceil(k / this.slidesPerMove) * this.slidesPerMove;
          }
      },
      {
        root: this.scrollContainer,
        threshold: 0.6
      }
    );
    this.getSlides({ excludeClones: !1 }).forEach((u) => {
      c.observe(u);
    });
  }
  handleScrollEnd() {
    !this.scrolling || this.dragging || (this.synchronizeSlides(), this.scrolling = !1);
  }
  isCarouselItem(c) {
    return c instanceof Element && c.tagName.toLowerCase() === "sl-carousel-item";
  }
  initializeSlides() {
    this.getSlides({ excludeClones: !1 }).forEach((c, u) => {
      c.classList.remove("--in-view"), c.classList.remove("--is-active"), c.setAttribute("aria-label", this.localize.term("slideNum", u + 1)), c.hasAttribute("data-clone") && c.remove();
    }), this.updateSlidesSnap(), this.loop && this.createClones(), this.synchronizeSlides(), this.goToSlide(this.activeSlide, "auto");
  }
  createClones() {
    const c = this.getSlides(), u = this.slidesPerPage, g = c.slice(-u), w = c.slice(0, u);
    g.reverse().forEach((k, S) => {
      const v = k.cloneNode(!0);
      v.setAttribute("data-clone", String(c.length - S - 1)), this.prepend(v);
    }), w.forEach((k, S) => {
      const v = k.cloneNode(!0);
      v.setAttribute("data-clone", String(S)), this.append(v);
    });
  }
  handelSlideChange() {
    const c = this.getSlides();
    c.forEach((u, g) => {
      u.classList.toggle("--is-active", g === this.activeSlide);
    }), this.hasUpdated && this.emit("sl-slide-change", {
      detail: {
        index: this.activeSlide,
        slide: c[this.activeSlide]
      }
    });
  }
  updateSlidesSnap() {
    const c = this.getSlides(), u = this.slidesPerMove;
    c.forEach((g, w) => {
      (w + u) % u === 0 ? g.style.removeProperty("scroll-snap-align") : g.style.setProperty("scroll-snap-align", "none");
    });
  }
  handleAutoplayChange() {
    this.autoplayController.stop(), this.autoplay && this.autoplayController.start(this.autoplayInterval);
  }
  /**
   * Move the carousel backward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  previous(c = "smooth") {
    this.goToSlide(this.activeSlide - this.slidesPerMove, c);
  }
  /**
   * Move the carousel forward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  next(c = "smooth") {
    this.goToSlide(this.activeSlide + this.slidesPerMove, c);
  }
  /**
   * Scrolls the carousel to the slide specified by `index`.
   *
   * @param index - The slide index.
   * @param behavior - The behavior used for scrolling.
   */
  goToSlide(c, u = "smooth") {
    const { slidesPerPage: g, loop: w } = this, k = this.getSlides(), S = this.getSlides({ excludeClones: !1 });
    if (!k.length)
      return;
    const v = w ? (c + k.length) % k.length : rw(c, 0, k.length - 1);
    this.activeSlide = v;
    const x = rw(c + (w ? g : 0), 0, S.length - 1), p = S[x];
    this.scrollToSlide(p, kw() ? "auto" : u);
  }
  scrollToSlide(c, u = "smooth") {
    const g = this.scrollContainer, w = g.getBoundingClientRect(), k = c.getBoundingClientRect(), S = k.left - w.left, v = k.top - w.top;
    g.scrollTo({
      left: S + g.scrollLeft,
      top: v + g.scrollTop,
      behavior: u
    });
  }
  render() {
    const { slidesPerMove: c, scrolling: u } = this, g = this.getPageCount(), w = this.getCurrentPage(), k = this.canScrollPrev(), S = this.canScrollNext(), v = this.localize.dir() === "ltr";
    return yn`
      <div part="base" class="carousel">
        <div
          id="scroll-container"
          part="scroll-container"
          class="${xs({
      carousel__slides: !0,
      "carousel__slides--horizontal": this.orientation === "horizontal",
      "carousel__slides--vertical": this.orientation === "vertical",
      "carousel__slides--dragging": this.dragging
    })}"
          style="--slides-per-page: ${this.slidesPerPage};"
          aria-busy="${u ? "true" : "false"}"
          aria-atomic="true"
          tabindex="0"
          @keydown=${this.handleKeyDown}
          @mousedown="${this.handleMouseDragStart}"
          @scroll="${this.handleScroll}"
          @scrollend=${this.handleScrollEnd}
        >
          <slot></slot>
          ${Cw(yw(this.getShadowSlideCount()), () => yn`
            <sl-carousel-item class="shadow-slide"></sl-carousel-item>
            `)}

        </div>

        ${this.navigation ? yn`
              <div part="navigation" class="carousel__navigation">
                <button
                  part="navigation-button navigation-button--previous"
                  class="${xs({
      "carousel__navigation-button": !0,
      "carousel__navigation-button--previous": !0,
      "carousel__navigation-button--disabled": !k
    })}"
                  aria-label="${this.localize.term("previousSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${k ? "false" : "true"}"
                  @click=${k ? () => this.previous() : null}
                >
                  <slot name="previous-icon">
                    <sl-icon library="system" name="${v ? "chevron-left" : "chevron-right"}"></sl-icon>
                  </slot>
                </button>

                <button
                  part="navigation-button navigation-button--next"
                  class=${xs({
      "carousel__navigation-button": !0,
      "carousel__navigation-button--next": !0,
      "carousel__navigation-button--disabled": !S
    })}
                  aria-label="${this.localize.term("nextSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${S ? "false" : "true"}"
                  @click=${S ? () => this.next() : null}
                >
                  <slot name="next-icon">
                    <sl-icon library="system" name="${v ? "chevron-right" : "chevron-left"}"></sl-icon>
                  </slot>
                </button>
              </div>
            ` : ""}
        ${this.pagination ? yn`
              <div part="pagination" role="tablist" class="carousel__pagination" aria-controls="scroll-container">
                ${Cw(yw(g), (x) => {
      const p = x === w;
      return yn`
                    <button
                      part="pagination-item ${p ? "pagination-item--active" : ""}"
                      class="${xs({
        "carousel__pagination-item": !0,
        "carousel__pagination-item--active": p
      })}"
                      role="tab"
                      aria-selected="${p ? "true" : "false"}"
                      aria-label="${this.localize.term("goToSlide", x + 1, g)}"
                      tabindex=${p ? "0" : "-1"}
                      @click=${() => this.goToSlide(x * c)}
                      @keydown=${this.handleKeyDown}
                    ></button>
                  `;
    })}
              </div>
            ` : ""}
      </div>
    `;
  }
};
nt.styles = [f0, dO];
nt.dependencies = { "sl-icon": Jt };
Oe([
  mt({ type: Boolean, reflect: !0 })
], nt.prototype, "loop", 2);
Oe([
  mt({ type: Boolean, reflect: !0 })
], nt.prototype, "navigation", 2);
Oe([
  mt({ type: Boolean, reflect: !0 })
], nt.prototype, "pagination", 2);
Oe([
  mt({ type: Boolean, reflect: !0 })
], nt.prototype, "autoplay", 2);
Oe([
  mt({ type: Number, attribute: "autoplay-interval" })
], nt.prototype, "autoplayInterval", 2);
Oe([
  mt({ type: Number, attribute: "slides-per-page" })
], nt.prototype, "slidesPerPage", 2);
Oe([
  mt({ type: Number, attribute: "slides-per-move" })
], nt.prototype, "slidesPerMove", 2);
Oe([
  mt()
], nt.prototype, "orientation", 2);
Oe([
  mt({ type: Boolean, reflect: !0, attribute: "mouse-dragging" })
], nt.prototype, "mouseDragging", 2);
Oe([
  p0(".carousel__slides")
], nt.prototype, "scrollContainer", 2);
Oe([
  p0(".carousel__pagination")
], nt.prototype, "paginationContainer", 2);
Oe([
  Ms()
], nt.prototype, "activeSlide", 2);
Oe([
  Ms()
], nt.prototype, "scrolling", 2);
Oe([
  Ms()
], nt.prototype, "dragging", 2);
Oe([
  PO({ passive: !0 })
], nt.prototype, "handleScroll", 1);
Oe([
  Co("loop", { waitUntilFirstUpdate: !0 }),
  Co("slidesPerPage", { waitUntilFirstUpdate: !0 })
], nt.prototype, "initializeSlides", 1);
Oe([
  Co("activeSlide")
], nt.prototype, "handelSlideChange", 1);
Oe([
  Co("slidesPerMove")
], nt.prototype, "updateSlidesSnap", 1);
Oe([
  Co("autoplay")
], nt.prototype, "handleAutoplayChange", 1);
nt.define("sl-carousel");
const mi = (c) => (bt("data-v-720fb199"), c = c(), kt(), c), FO = { class: "wrap" }, $O = { class: "viur-shop-item-view-image-wrap" }, LO = {
  class: "viur-shop-item-view-carousel-thumbnails",
  navigation: "",
  loop: ""
}, VO = ["alt", "src"], jO = { class: "viur-shop-item-view-thumbnails" }, HO = { class: "viur-shop-item-view-thumbnails-scroller" }, UO = ["alt", "src"], qO = { class: "viur-shop-item-view-info-wrap" }, WO = { class: "viur-shop-item-view-headline" }, GO = /* @__PURE__ */ mi(() => /* @__PURE__ */ M("h2", { class: "viur-shop-item-view-subline" }, "B 21 x H 6,5 x T 19 cm", -1)), KO = { class: "viur-shop-item-view-price" }, ZO = /* @__PURE__ */ mi(() => /* @__PURE__ */ M("div", { class: "viur-shop-item-view-paragraph" }, " Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. ", -1)), JO = { class: "viur-shop-item-view-btn-wrap" }, YO = /* @__PURE__ */ mi(() => /* @__PURE__ */ M("sl-icon", {
  name: "bag-plus",
  slot: "prefix"
}, null, -1)), QO = /* @__PURE__ */ mi(() => /* @__PURE__ */ M("sl-button", {
  size: "small",
  outline: "",
  class: "viur-shop-item-view-add-to-favourites-btn",
  variant: "primary",
  title: "Add to favourites"
}, [
  /* @__PURE__ */ M("sl-icon", {
    name: "heart",
    slot: "prefix"
  }),
  /* @__PURE__ */ se(" Auf die Wunschliste ")
], -1)), XO = /* @__PURE__ */ mi(() => /* @__PURE__ */ M("br", null, null, -1)), e7 = /* @__PURE__ */ mi(() => /* @__PURE__ */ M("h1", { class: "viur-shop-item-view-headline" }, "Ähnliche Artikel", -1)), t7 = { class: "viur-shop-item-view-item-grid" }, n7 = {
  __name: "ItemView",
  setup(c) {
    const u = Fc(), g = _e({
      item: {}
    });
    function w(k) {
      console.log("hier", k.dk_artikel);
      let S = "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80";
      return k != null && k.dk_artikel.dest.image ? ve.downloadUrlFor(k.dk_artikel.dest.image) : S;
    }
    return jn(async () => {
      ve.get(`/json/variante/view/${u.params.item}`).then(async (k) => {
        let S = await k.json();
        g.item = S.values;
      });
    }), (k, S) => (j(), q(ye, null, [
      M("div", FO, [
        M("div", $O, [
          M("sl-carousel", LO, [
            M("sl-carousel-item", null, [
              M("img", {
                alt: g.item.shop_name,
                src: w(g.item)
              }, null, 8, VO)
            ])
          ]),
          M("div", jO, [
            M("div", HO, [
              M("img", {
                alt: g.item.shop_name,
                class: "viur-shop-item-view-thumbnails-image active",
                src: w(g.item)
              }, null, 8, UO)
            ])
          ])
        ]),
        M("div", qO, [
          M("h1", WO, Se(g.item.shop_name), 1),
          GO,
          M("div", KO, Se(g.item.shop_price_retail) + " € ", 1),
          ZO,
          M("div", JO, [
            M("sl-button", {
              size: "small",
              class: "viur-shop-item-view-add-to-cart-btn",
              variant: "primary",
              title: "Add to cart",
              onClick: S[0] || (S[0] = li((v) => k.cartStore.addToCart(k.item.key, k.cartStore.state.currentCart), ["stop"]))
            }, [
              YO,
              se(" In den Warenkorb ")
            ]),
            QO
          ])
        ])
      ]),
      XO,
      e7,
      M("div", t7, [
        qS(Jw, {
          item: g.item
        }, null, 8, ["item"])
      ])
    ], 64));
  }
}, o7 = /* @__PURE__ */ Ee(n7, [["__scopeId", "data-v-720fb199"]]), i7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: o7
}, Symbol.toStringTag, { value: "Module" })), r7 = {}, Ns = (c) => (bt("data-v-36ccc280"), c = c(), kt(), c), s7 = { class: "bind" }, a7 = /* @__PURE__ */ Ns(() => /* @__PURE__ */ M("h1", { class: "headline" }, "Vielen Dank für Ihre Bestellung", -1)), l7 = /* @__PURE__ */ Ns(() => /* @__PURE__ */ M("br", null, null, -1)), c7 = /* @__PURE__ */ Ns(() => /* @__PURE__ */ M("p", { class: "paragraph" }, [
  /* @__PURE__ */ M("strong", null, "Ihre Bestellnummer:"),
  /* @__PURE__ */ se(" 123345670 ")
], -1)), d7 = /* @__PURE__ */ Ns(() => /* @__PURE__ */ M("p", { class: "paragraph" }, [
  /* @__PURE__ */ se(" Wir haben Ihre Bestellung erhalten und werden diese schenllstmöglich bearbeiten."),
  /* @__PURE__ */ M("br"),
  /* @__PURE__ */ se(" Sie erhalten in wenigen Minuten eine Bestätigung per E-Mail. "),
  /* @__PURE__ */ M("div", { class: "btn-wrap" }, [
    /* @__PURE__ */ M("sl-button", { size: "medium" }, " Zur Startseite "),
    /* @__PURE__ */ M("sl-button", {
      variant: "primary",
      size: "medium"
    }, " Weiter Einkaufen ")
  ])
], -1)), u7 = [
  a7,
  l7,
  c7,
  d7
];
function h7(c, u) {
  return j(), q("div", s7, u7);
}
const g7 = /* @__PURE__ */ Ee(r7, [["render", h7], ["__scopeId", "data-v-36ccc280"]]), m7 = {};
function p7(c, u) {
  return " HALLO ";
}
const q7 = /* @__PURE__ */ Ee(m7, [["render", p7]]), f7 = (c) => (bt("data-v-61488015"), c = c(), kt(), c), b7 = { class: "bind viur-shop-wrap" }, k7 = ["panel", "disabled"], w7 = { class: "viur-shop-order-step" }, v7 = ["name", "library"], _7 = { class: "viur-shop-order-status-text" }, A7 = {
  key: 0,
  name: "chevron-right",
  class: "viur-shop-order-tab-check"
}, C7 = ["name"], y7 = ["onClick"], E7 = ["onClick"], x7 = /* @__PURE__ */ f7(() => /* @__PURE__ */ M("div", {
  class: "viur-shop-sidebar",
  id: "order_sidebar"
}, null, -1)), S7 = {
  __name: "OrderView",
  props: {
    tabs: {
      type: Object,
      required: !0
    }
  },
  emits: ["tabChange"],
  setup(c, { emit: u }) {
    const g = c, w = u, k = _e({
      tabNames: le(() => v(g.tabs)),
      isFirstTab: (y) => y === 0
    }), S = Ft(null);
    function v(y) {
      let C = [], b = [];
      for (const A in y)
        y[A].position ? C.push([A, y[A].position]) : C.push([A, 0]);
      return C.sort((A, P) => A[1] - P[1]), C.forEach((A) => {
        b.push(A[0]);
      }), b;
    }
    function x(y) {
      w("tabChange", y);
    }
    function p(y) {
      S.value.show(y);
    }
    function D(y) {
      S.value.show(y);
    }
    return (y, C) => (j(), q("div", b7, [
      M("sl-tab-group", {
        class: "viur-shop-order-tab",
        noScrollControls: "",
        onSlTabShow: x,
        ref_key: "tabGroup",
        ref: S
      }, [
        (j(!0), q(ye, null, dt(k.tabNames, (b, A) => (j(), q("sl-tab", {
          slot: "nav",
          panel: b,
          key: b,
          disabled: c.tabs[b].disabled
        }, [
          M("div", w7, [
            M("sl-icon", {
              name: c.tabs[b].icon.name,
              library: c.tabs[b].icon.library
            }, null, 8, v7),
            M("div", _7, Se(A + 1) + ". " + Se(c.tabs[b].displayName), 1)
          ]),
          A < k.tabNames.length - 1 ? (j(), q("sl-icon", A7)) : he("", !0)
        ], 8, k7))), 128)),
        (j(!0), q(ye, null, dt(k.tabNames, (b, A) => (j(), q("sl-tab-panel", {
          name: b,
          key: b
        }, [
          (j(), ut(WS(c.tabs[b].component), GS({ ref_for: !0 }, c.tabs[b].props ? c.tabs[b].props : ""), null, 16)),
          A !== k.tabNames.length - 1 ? (j(), q("div", {
            key: 0,
            class: Tw(["viur-shop-form-footer", { "flex-end": k.isFirstTab(A) }])
          }, [
            cn(M("sl-button", {
              type: "submit",
              onClick: (P) => p(k.tabNames[A - 1])
            }, " Zurück ", 8, y7), [
              [vc, A !== 0]
            ]),
            M("sl-button", {
              type: "submit",
              variant: "primary",
              onClick: (P) => D(k.tabNames[A + 1])
            }, " Weiter ", 8, E7)
          ], 2)) : he("", !0)
        ], 8, C7))), 128))
      ], 544),
      x7
    ]));
  }
}, D7 = /* @__PURE__ */ Ee(S7, [["__scopeId", "data-v-61488015"]]), B7 = {
  __name: "ExampleUsage",
  setup(c) {
    const u = En(), g = _e({
      tabs: {
        cart: {
          component: ln(Iw),
          props: { sidebar: !0, mode: "basket" },
          displayName: "Warenkorb",
          icon: { name: "cart", library: "hsk" },
          position: 2,
          disabled: !1,
          atShow: null,
          atHide: null
        },
        confirm: {
          component: ln(Yw),
          props: {},
          displayName: "Bestellung prüfen",
          icon: { name: "order-check", library: "hsk" },
          position: 5,
          disabled: !1,
          atShow: null,
          atHide: null
        },
        // order: {
        //   component: shallowRef(CategoryView),
        //   props: {
        //     listHandler: ListRequest("categorystore", {
        //       module: "variante",
        //       params: { type: "dk", limit: 99 },
        //     }),
        //   },
        //   displayName: "Artikel Bestellen",
        //   icon: { name: "cart-add", library: "hsk" },
        //   position: 1,
        //   disabled: false,
        //   atShow: null,
        //   atHide: null,
        // },
        orderComplete: {
          component: ln(g7),
          props: {},
          displayName: "Bestellung Abgeschlossen",
          icon: { name: "order-confirmed", library: "hsk" },
          position: 6,
          disabled: !0,
          atShow: null,
          atHide: null
        },
        userInfo: {
          component: ln(H4),
          props: {},
          displayName: "Daten Eingeben",
          icon: { name: "user", library: "hsk" },
          position: 3,
          disabled: !1,
          atShow: null,
          atHide: null
        },
        userInfoMulti: {
          component: ln(N4),
          props: {},
          displayName: "Daten Eingeben (Multi)",
          icon: { name: "user", library: "hsk" },
          position: 4,
          disabled: !1,
          atShow: null,
          atHide: null
        }
      }
    });
    function w(k) {
      (k == null ? void 0 : k.detail.name) === "confirm" && (g.tabs.orderComplete.disabled = !1);
    }
    return jn(async () => {
      await u.getAdressStructure();
    }), (k, S) => (j(), ut(D7, {
      tabs: g.tabs,
      onTabChange: w
    }, null, 8, ["tabs"]));
  }
}, T7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: B7
}, Symbol.toStringTag, { value: "Module" })), P7 = Ye({
  props: {},
  components: {},
  setup(c, u) {
    const g = Fc();
    return { state: _e({}), route: g };
  }
}), I7 = { class: "home" };
function O7(c, u, g, w, k, S) {
  return j(), q("div", I7, "View " + Se(c.route.path) + " is missing.", 1);
}
const R7 = /* @__PURE__ */ Ee(P7, [["render", O7]]), z7 = [
  {
    path: "/:pathMatch(.*)*",
    name: "view_missing",
    component: R7
  },
  {
    path: "/shop/category/:identifier",
    name: "CategoryView",
    component: () => Promise.resolve().then(() => oP)
  },
  {
    path: "/shop/item/:item",
    name: "itemView",
    component: () => Promise.resolve().then(() => i7)
  },
  {
    path: "/shop/cart/view",
    name: "CartView",
    component: () => Promise.resolve().then(() => lB)
  },
  {
    path: "/shop/order/",
    name: "OrderView",
    component: () => Promise.resolve().then(() => T7)
  },
  {
    path: "/shop/order/confirm",
    name: "ConfirmView",
    component: () => Promise.resolve().then(() => IP)
  }
];
function W7(c, u = !1) {
  let g = [];
  return u ? g = c : g = c.concat(z7), MT({
    // @ts-ignore
    history: GB("/"),
    routes: g
  });
}
export {
  Iw as CartView,
  V7 as CategoryList,
  nP as CategoryView,
  Yw as ConfirmView,
  B7 as ExampleUsage,
  Jw as ItemCard,
  o7 as ItemView,
  g7 as OrderComplete,
  q7 as OrderTabHeader,
  D7 as OrderView,
  j7 as ShippingAdress,
  N4 as UserInfoMulti,
  H4 as UserInformation,
  W7 as createRouterInstance,
  En as useCartStore
};
