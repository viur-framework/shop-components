var U5 = Object.defineProperty;
var q5 = (c, u, g) => u in c ? U5(c, u, { enumerable: !0, configurable: !0, writable: !0, value: g }) : c[u] = g;
var fo = (c, u, g) => (q5(c, typeof u != "symbol" ? u + "" : u, g), g);
import { reactive as me, computed as ce, useCssVars as W5, openBlock as H, createBlock as yt, Transition as G5, withCtx as Mc, createElementBlock as G, createElementVNode as I, createCommentVNode as Ee, pushScopeId as dt, popScopeId as ut, toRaw as K5, ref as en, onBeforeMount as yo, withDirectives as gt, unref as le, vModelText as Ct, createTextVNode as ie, Fragment as Ve, renderList as kt, toDisplayString as ge, Teleport as Tw, inject as Be, shallowRef as Xt, shallowReactive as Z5, nextTick as J5, defineComponent as Ye, h as Iw, provide as hc, watch as ui, getCurrentInstance as Nc, watchEffect as dr, withModifiers as Hn, createVNode as ai, onMounted as lt, renderSlot as Pw, resolveComponent as hi, resolveDynamicComponent as Ow, mergeProps as Rw, vShow as Cc, readonly as Y5, getCurrentScope as Q5, onScopeDispose as X5, normalizeClass as eD } from "vue";
import { defineStore as ur } from "pinia";
const Ae = (c, u) => {
  const g = c.__vccOpts || c;
  for (const [w, b] of u)
    g[w] = b;
  return g;
}, Fc = {
  props: {
    size: {
      type: String,
      default: "2"
    },
    active: {
      type: Boolean,
      default: !0
    },
    logo: {
      default: "logo-cube.svg",
      type: String
    },
    color: {
      default: "var(--sl-color-primary-500)",
      type: String
    }
  },
  setup(c, u) {
    const g = me({
      trackWidth: ce(() => `${c.size / 30}rem`),
      outerSize: ce(() => `calc(${c.size}rem + ${g.trackWidth})`),
      spinnerSize: ce(() => `${c.size}rem`),
      logoSize: ce(() => `calc(${c.size}rem - ${g.trackWidth} * 10)`),
      shadow: ce(() => `0px 0px ${c.size / 6}rem 0 color-mix(in hsl, var(--sl-color-neutral-1000), 80% transparent)`)
    });
    return { state: g };
  }
}, Sk = () => {
  W5((c) => ({
    "93747d92": c.state.outerSize,
    "284424e5": c.state.shadow,
    "6485ca5e": c.state.logoSize,
    "5d833915": c.state.spinnerSize,
    d5b3feca: c.color,
    "2050b700": c.state.trackWidth
  }));
}, Dk = Fc.setup;
Fc.setup = Dk ? (c, u) => (Sk(), Dk(c, u)) : Sk;
const tD = (c) => (dt("data-v-46c45785"), c = c(), ut(), c), nD = {
  key: 0,
  class: "loading"
}, oD = /* @__PURE__ */ tD(() => /* @__PURE__ */ I("sl-spinner", { class: "loader" }, null, -1)), iD = { class: "logo" }, rD = ["src"];
function sD(c, u, g, w, b, x) {
  return H(), yt(G5, null, {
    default: Mc(() => [
      g.active ? (H(), G("div", nD, [
        oD,
        I("div", iD, [
          I("sl-icon", { src: g.logo }, null, 8, rD)
        ])
      ])) : Ee("", !0)
    ]),
    _: 1
  });
}
const zw = /* @__PURE__ */ Ae(Fc, [["render", sD], ["__scopeId", "data-v-46c45785"]]);
let ys = class extends Error {
  constructor(u, g, w, b) {
    super(w || g), arguments.length >= 4 && b && Object.assign(this, b), this.statusText = g, this.statusCode = u, this.response = b;
  }
}, gc = null;
function bo() {
  return gc || (gc = ur("requestStore", () => {
    const c = me({ sKeys: /* @__PURE__ */ new Set() });
    function u() {
      c.sKeys = /* @__PURE__ */ new Set();
    }
    return {
      state: c,
      $reset: u
    };
  })), gc();
}
class he {
  static resetState() {
    bo().$reset(), bo().$dispose();
  }
  static buildUrl(u) {
    return u && !(u.startsWith("http://") || u.startsWith("https://") || u.startsWith("//")) && (u = "http://localhost:8080" + u), u;
  }
  static post(u, { dataObj: g = null, callback: w = null, failedCallback: b = null, abortController: x = null, headers: v = null, mode: C = null } = {}) {
    function p() {
      if (g instanceof FormData)
        return g;
      const y = new FormData();
      for (const A in g)
        if (Array.isArray(g[A]))
          for (let k of g[A])
            y.append(A, k);
        else
          y.append(A, g[A]);
      return y;
    }
    let D = rr.post(he.buildUrl(u), p(), null, v, x, C);
    return D.then(function(y) {
      w && w(y.data);
    }).catch(function(y) {
      b && b(y);
    }), D;
  }
  static async getBatchSkeys(u = 30, g = "json") {
    await he.get(`/${g}/skey`, {
      dataObj: { amount: u }
    }).then(async (w) => {
      let b = await w.json();
      Array.isArray(b) || (b = [b]), bo().state.sKeys = new Set(b);
    });
  }
  static async securePost(u, {
    dataObj: g = null,
    callback: w = null,
    failedCallback: b = null,
    abortController: x = null,
    renderer: v = "json",
    headers: C = null,
    mode: p = null,
    amount: D = 30
  } = {}) {
    let y = null;
    bo().state.sKeys.size === 0 && await he.getBatchSkeys(D);
    const A = [...bo().state.sKeys][0];
    return g instanceof FormData ? (g.append("skey", A), bo().state.sKeys.delete(A)) : (g || (g = {}), g.skey = A, bo().state.sKeys.delete(A)), y = he.post(u, {
      dataObj: g,
      callback: w,
      abortController: x,
      headers: C,
      mode: p
    }), y;
  }
  static get(u, {
    dataObj: g = null,
    callback: w = null,
    failedCallback: b = null,
    cached: x = !1,
    clearCache: v = !1,
    abortController: C = null,
    headers: p = null,
    mode: D = null,
    //          milli  sec  min  Std  Tage
    cacheTime: y = 1e3 * 60 * 60 * 24 * 1
  } = {}) {
    let A = rr.get(he.buildUrl(u), g, v, p, C, D);
    return A.then(function(k) {
      w && w(k.data);
    }).catch(function(k) {
      b && b(k);
    }), A;
  }
  static list(u, {
    dataObj: g = null,
    callback: w = null,
    failedCallback: b = null,
    group: x = null,
    abortController: v = null,
    renderer: C = "json"
  } = {}) {
    let p = `/${C}/${u}/list`;
    return x && (p += `/${x}`), he.get(p, {
      dataObj: g,
      callback: w,
      failedCallback: b,
      abortController: v
    });
  }
  static getStructure(u, { dataObj: g = null, callback: w = null, failedCallback: b = null, group: x = null, abortController: v = null } = {}) {
    u = u.replace(/\//g, ".");
    let C = `/vi/getStructure/${u}/`;
    return x && (C += `/${x}`), he.get(C, {
      dataObj: g,
      callback: w,
      failedCallback: b,
      abortController: v
    });
  }
  static view(u, g, {
    dataObj: w = null,
    callback: b = null,
    failedCallback: x = null,
    group: v = null,
    abortController: C = null,
    renderer: p = "json"
  } = {}) {
    let D = `/${p}/${u}/view/${g}`;
    return v && (D = `/${p}/${u}/view/${v}/${g}`), he.get(D, {
      dataObj: w,
      callback: b,
      failedCallback: x,
      abortController: C
    });
  }
  static add(u, {
    dataObj: g = null,
    callback: w = null,
    failedCallback: b = null,
    group: x = null,
    abortController: v = null,
    renderer: C = "json"
  } = {}) {
    let p = `/${C}/${u}/add`;
    return x && (p = `/${C}/${u}/add/${x}`), he.securePost(p, {
      dataObj: g,
      callback: w,
      failedCallback: b,
      abortController: v
    });
  }
  static edit(u, g, {
    dataObj: w = null,
    callback: b = null,
    failedCallback: x = null,
    group: v = null,
    abortController: C = null,
    renderer: p = "json"
  } = {}) {
    let D = `/${p}/${u}/edit/${g}`;
    return v && (D = `/${p}/${u}/edit/${v}/${g}`), he.securePost(D, {
      dataObj: w,
      callback: b,
      failedCallback: x,
      abortController: C
    });
  }
  static delete(u, g, {
    dataObj: w = null,
    callback: b = null,
    failedCallback: x = null,
    group: v = null,
    abortController: C = null,
    renderer: p = "json"
  } = {}) {
    let D = `/${p}/${u}/delete/${g}`;
    return v && (D = `/${p}/${u}/delete/${v}/${g}`), he.securePost(D, {
      dataObj: w,
      callback: b,
      failedCallback: x,
      abortController: C,
      amount: 1
    });
  }
  static downloadUrlFor(u, g = !1) {
    return u && "dest" in u ? g && "thumbnail" in u.dest ? he.buildUrl(u.dest.thumbnail) : "downloadUrl" in u.dest ? he.buildUrl(u.dest.downloadUrl) : he.buildUrl(null) : he.buildUrl(u);
  }
  static uploadFile(u, g = void 0) {
    const w = {
      fileName: u.name,
      mimeType: u.type || "application/octet-stream",
      size: u.size.toString(),
      node: g
    };
    return new Promise((b, x) => {
      he.securePost("/vi/file/getUploadURL", { dataObj: w }).then(async (v) => {
        let C = await v.json();
        fetch(C.values.uploadUrl, {
          body: u,
          method: "POST",
          mode: "no-cors"
        }).then(async (p) => {
          const D = {
            key: C.values.uploadKey,
            skelType: "leaf"
          };
          he.securePost("/vi/file/add", { dataObj: D }).then(async (y) => {
            let A = await y.json();
            A.action === "addSuccess" ? b(A.values) : x(A);
          }).catch((y) => {
            x(y);
          });
        }).catch((p) => {
          x(p);
        });
      }).catch((v) => {
        x(v);
      });
    });
  }
}
class rr {
  constructor() {
    fo(this, "withCredentials", !0);
  }
  static buildOptions(u, g = null, w = null, b = null, x = null) {
    let v = { method: u };
    return v.credentials = "include", v.headers = {
      Accept: "application/json, text/plain, */*"
    }, w && (v.headers = { ...v.headers, ...w }), g && (v.body = g), b && (v.signal = b.signal), x && (v.mode = x), v;
  }
  static get(u, g = null, w = null, b = null, x = null, v = null) {
    function C(p, D) {
      let y = new URL(p);
      if (D && Object.keys(D).length > 0) {
        const A = new URLSearchParams();
        for (const [k, E] of Object.entries(D))
          if (Array.isArray(E))
            for (const P of E)
              A.append(k, P);
          else
            A.append(k, E);
        y.search = A.toString();
      }
      return y.toString();
    }
    return fetch(C(u, g), rr.buildOptions("GET", null, b, x, v)).then(async (p) => {
      if (p.ok)
        return p;
      {
        const D = `${p.status} ${p.statusText}: ${p.headers ? p.headers.get("x-error-descr") : ""}`;
        return Promise.reject(new ys(p.status, p.statusText, D, p));
      }
    }).catch((p) => {
      if (p instanceof TypeError) {
        const y = `503 ${p.message}: ${p.headers ? p.headers.get("x-error-descr") : ""}`;
        return Promise.reject(new ys(503, p.message, y, p));
      }
      if (p instanceof DOMException && p.name == "AbortError") {
        const y = `${p.code} ${p.name}: ${p.headers ? p.headers.get("x-error-descr") : ""}`;
        return Promise.reject(new ys(p.code, p.name, y, { url: u }));
      }
      const D = `${p.statusCode} ${p.statusText}: ${p.headers ? p.headers.get("x-error-descr") : ""}`;
      return Promise.reject(new ys(p.statusCode, p.statusText, D, p.response));
    });
  }
  static post(u, g = null, w = null, b = null, x = null, v = null) {
    return fetch(u, rr.buildOptions("POST", g, b, x, v));
  }
}
function aD(c, { module: u = "", params: g = {}, group: w = null, url: b = "", renderer: x = "json" } = {}) {
  return ur(c, () => {
    let C = new AbortController();
    const p = me({
      skellist: [],
      // holds our entries
      structure: [],
      // raw skelstructure
      structure_object: {},
      // raw skelstructure >= core 3.4
      cursor: "",
      // last cursor
      request_state: null,
      orders: [],
      params: g,
      //request params
      group: w,
      module: u,
      state: 0
      // 0:not fetched, 1:fetched, 2:all fetched, -1:error
    }), D = ce(() => {
      let z = {};
      if (Object.keys(p.structure_object).length > 0)
        return p.structure_object;
      if (p.structure)
        for (let M in p.structure)
          z[p.structure[M][0]] = K5(p.structure[M][1]);
      return z;
    });
    function y(z = !0, M = !1) {
      if (z && E(), p.state === 2)
        return 0;
      let F = he.list, V = p.module;
      return b !== "" && (F = he.get, V = b), C = new AbortController(), F(V, {
        dataObj: p.params,
        abortController: C,
        group: p.group,
        renderer: x
      }).then(async (j) => {
        let Z = await j.json();
        if (Z.structure === null || Object.keys(Z.structure).length === 0) {
          const ne = await he.getStructure(p.module).then(
            (X) => X.json().then((de) => de)
          );
          let se = "viewSkel";
          if (Object.keys(p.params).includes("skelType") && (se = p.params.skelType === "node" ? "viewNodeSkel" : "viewLeafSkel"), Array.isArray(ne[se]))
            p.structure = ne[se];
          else {
            p.structure_object = ne[se];
            for (const [X, de] of Object.entries(ne[se]))
              p.structure.push([X, de]);
          }
        } else if (!M)
          if (Array.isArray(Z.structure))
            p.structure = Z.structure;
          else {
            p.structure_object = Z.structure;
            for (const [ne, se] of Object.entries(Z.structure))
              p.structure.push([ne, se]);
          }
        p.request_state = parseInt(j.status), p.cursor = Z.cursor, p.orders = Z.orders || [], p.skellist.length === 0 ? p.skellist = Z.skellist : p.skellist = p.skellist.concat(Z.skellist), Z.skellist.length === 0 || !p.cursor ? p.state = 2 : p.state = 1;
      }).catch((j) => {
        throw j.response ? p.request_state = parseInt(j.response.status) : p.request_state = 501, p.state = -1, j;
      });
    }
    function A(z = !0) {
      z && E();
      let M = k();
      return M === 0 ? 0 : M.then((F) => {
        A(!1);
      });
    }
    function k() {
      if (p.state === 2 || p.state === -1)
        return 0;
      p.cursor !== "" && (p.params = { ...p.params, cursor: p.cursor });
      let z = !0;
      return p.state === 0 && (z = !1), y(!1, z);
    }
    function E() {
      C.abort(), p.structure = [], p.skellist = [], p.skellist.length = 0, p.cursor = "", Object.keys(p.params).includes("cursor") && delete p.params.cursor, p.state = 0, p.request_state = null;
    }
    function P(z) {
      return p.params = z, y();
    }
    return {
      state: p,
      structure: D,
      fetchAll: A,
      fetch: y,
      next: k,
      filter: P,
      reset: E
    };
  })();
}
class lD {
  static objectEmpty(u) {
    return Object.keys(u).length === 0 && u.constructor === Object;
  }
  static getDescr(u, g) {
    try {
      return u.values.filter((w) => w[0] === g)[0][1];
    } catch {
      return "-";
    }
  }
  static unescape(u) {
    return u || (u = ""), String(u).replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&#40;/g, "(").replace(/&#41;/g, ")").replace(/&#61;/g, "=").replace(/&#039;/g, "'").replace(/&#040;/g, "(").replace(/&#041;/g, ")").replace(/&#061;/g, "=");
  }
  static formatString(u, g) {
    function w(v) {
      let C = [], p = [], D = /\$\((.*?)\)/g;
      for (; p; ) {
        if (p = D.exec(v), !p) {
          p = !1;
          continue;
        }
        C.push(p[1]);
      }
      return C;
    }
    let b = w(u), x = [];
    Array.isArray(g) || (g = [g]);
    for (let v of g) {
      let C = u;
      for (let p of b) {
        let D = p.split("."), y = v;
        for (let A of D)
          y && y !== "-" && A in y && y[A] ? y = y[A] : y = "-";
        y = this.unescape(y), C = C.replace("$(" + p + ")", y);
      }
      x.push(C);
    }
    return x.join(", ");
  }
}
class cD extends Error {
  constructor(u, g, w, b) {
    super(w || g), arguments.length >= 4 && b && Object.assign(this, b), this.statusText = g, this.statusCode = u, this.response = b;
  }
}
function at(c, { json: u, method: g, params: w, ...b } = {}) {
  g || (g = u ? "POST" : "GET");
  const x = {
    credentials: "include",
    method: g,
    headers: {
      ...b.headers
    },
    ...b
  };
  if ((c.startsWith("/") || c.startsWith(window.location.origin)) && (x.headers["X-Requested-With"] = "Fetch"), u ? (x.body = JSON.stringify(u), x.headers["Content-Type"] = "application/json") : w && g === "POST" && (typeof w == "string" || w instanceof String ? x.body = new URLSearchParams(w) : w instanceof HTMLFormElement ? x.body = new FormData(w) : (x.body = new FormData(), Object.entries(w).forEach(([v, C]) => {
    if (Array.isArray(C))
      for (const p of C)
        x.body.append(v, p);
    else
      x.body.append(v, C);
  }))), w && (g === "GET" || u)) {
    const v = new URLSearchParams(w);
    c += `?${v.toString()}`;
  }
  return window.fetch(c, x).then(async (v) => {
    if (v.ok)
      return v;
    {
      const C = `${v.status} ${v.statusText}: ${v.headers.get("x-viur-error")}`;
      return Promise.reject(new cD(v.status, v.statusText, C, v));
    }
  });
}
function dD() {
  return at("/json/skey").then((c) => c.json());
}
class uD {
  constructor({
    host_url: u = null,
    shop_module: g = "shop"
  } = {}) {
    /**
     * URL to the shop-backend (ViUR server)
     */
    fo(this, "host_url");
    /**
     * Name of the shop root module
     */
    fo(this, "shop_module");
    /**
     * URL to shop root module with the default renderer
     */
    fo(this, "shop_url");
    /**
     * URL to shop root module with the json renderer
     */
    fo(this, "shop_json_url");
    /**
     * URL to shop API module with the default renderer
     */
    fo(this, "shop_api_url");
    if (u === null)
      try {
        this.host_url = "http://localhost:8080";
      } catch {
        this.host_url = window.location.origin;
      }
    else
      this.host_url = u;
    this.shop_module = g, this.shop_url = `${this.host_url}/${this.shop_module}`, this.shop_json_url = `${this.host_url}/json/${this.shop_module}`, this.shop_api_url = `${this.shop_url}/api`, this.getStructure_url = `${this.host_url}/vi/getStructure`;
  }
  // --- Article ------------------------------------------------------------
  article_view({
    article_key: u,
    parent_cart_key: g
  } = {}) {
    return at(`${this.shop_api_url}/article_view`, {
      params: {
        article_key: u,
        parent_cart_key: g
      }
    }).then((w) => w.json());
  }
  article_add({
    article_key: u,
    parent_cart_key: g,
    quantity: w = 1,
    quantity_mode: b = "increase"
  } = {}) {
    return at(`${this.shop_api_url}/article_add`, {
      method: "POST",
      params: {
        article_key: u,
        parent_cart_key: g,
        quantity: w,
        quantity_mode: b
      }
    }).then((x) => x.json());
  }
  article_update({
    article_key: u,
    parent_cart_key: g,
    quantity: w = 1,
    quantity_mode: b = "increase"
  } = {}) {
    return at(`${this.shop_api_url}/article_update`, {
      method: "POST",
      params: {
        article_key: u,
        parent_cart_key: g,
        quantity: w,
        quantity_mode: b
      }
    }).then((x) => x.json());
  }
  article_remove({
    article_key: u,
    parent_cart_key: g
  } = {}) {
    return at(`${this.shop_api_url}/article_remove`, {
      method: "POST",
      params: {
        article_key: u,
        parent_cart_key: g
      }
    }).then((w) => w.json());
  }
  // --- Cart ---------------------------------------------------------------
  cart_list({ cart_key: u = null } = {}) {
    return at(`${this.shop_api_url}/cart_list`, {
      params: u === null ? {} : { cart_key: u }
    }).then((g) => g.json());
  }
  cart_add({
    parent_cart_key: u,
    name: g,
    cart_type: w,
    // TODO
    customer_comment: b,
    shipping_address_key: x,
    shipping_key: v,
    discount_key: C
  } = {}) {
    return at(`${this.shop_api_url}/cart_add`, {
      method: "POST",
      params: this.removeUndefinedValues({
        parent_cart_key: u,
        name: g,
        cart_type: w,
        // TODO
        customer_comment: b,
        shipping_address_key: x,
        shipping_key: v,
        discount_key: C
      })
    }).then((p) => p.json());
  }
  //TODO
  cart_update({
    cart_key: u,
    parent_cart_key: g,
    cart_type: w,
    // TODO
    name: b,
    customer_comment: x,
    shipping_address_key: v,
    shipping_key: C,
    discount_key: p
  } = {}) {
    return at(`${this.shop_api_url}/cart_update`, {
      method: "POST",
      params: this.removeUndefinedValues({
        cart_key: u,
        parent_cart_key: g,
        cart_type: w,
        // TODO
        name: b,
        customer_comment: x,
        shipping_address_key: v,
        shipping_key: C,
        discount_key: p
      })
    }).then((D) => D.json());
  }
  cart_remove({ cart_key: u } = {}) {
    return at(`${this.shop_api_url}/cart_remove`, {
      method: "POST",
      params: {
        cart_key: u
      }
    }).then((g) => g.json());
  }
  cart_structure() {
    return at(`${this.getStructure_url}/${this.shop_module}.cart`, {
      method: "GET"
    }).then((u) => u.json());
  }
  // --- Address ------------------------------------------------------------
  address_list({} = {}) {
    return at(`${this.shop_json_url}/address/list`, {
      params: {
        limit: 100
      }
    }).then((u) => u.json()).then((u) => u.skellist);
  }
  address_add({
    customer_type: u,
    salutation: g,
    company_name: w,
    firstname: b,
    lastname: x,
    street_name: v,
    street_number: C,
    address_addition: p,
    zip_code: D,
    city: y,
    country: A,
    customer_key: k,
    is_default: E,
    address_type: P
  } = {}) {
    return dD().then((z) => at(`${this.shop_json_url}/address/add`, {
      method: "POST",
      params: this.removeUndefinedValues({
        skey: z,
        customer_type: u,
        salutation: g,
        company_name: w,
        firstname: b,
        lastname: x,
        street_name: v,
        street_number: C,
        address_addition: p,
        zip_code: D,
        city: y,
        country: A,
        customer: k,
        is_default: E,
        address_type: P
      })
    }).then((M) => M.json()).then((M) => M.values));
  }
  address_structure() {
    return at(`${this.getStructure_url}/${this.shop_module}.address`, {
      method: "GET"
    }).then((u) => u.json());
  }
  // --- Order --------------------------------------------------------------
  payment_providers_list({} = {}) {
    return at(`${this.shop_url}/order/payment_providers_list`).then((u) => u.json());
  }
  order_add({
    cart_key: u,
    payment_provider: g,
    billing_address_key: w,
    email: b,
    customer_key: x,
    state_ordered: v,
    state_paid: C,
    state_rts: p
  } = {}) {
    return at(`${this.shop_api_url}/order_add`, {
      method: "POST",
      params: this.removeUndefinedValues({
        cart_key: u,
        payment_provider: g,
        billing_address_key: w,
        email: b,
        customer_key: x,
        state_ordered: v,
        state_paid: C,
        state_rts: p
      })
    }).then((D) => D.json());
  }
  order_update({
    order_key: u,
    payment_provider: g,
    billing_address_key: w,
    email: b,
    customer_key: x,
    state_ordered: v,
    state_paid: C,
    state_rts: p
  } = {}) {
    return at(`${this.shop_api_url}/order_update`, {
      method: "POST",
      params: this.removeUndefinedValues({
        order_key: u,
        payment_provider: g,
        billing_address_key: w,
        email: b,
        customer_key: x,
        state_ordered: v,
        state_paid: C,
        state_rts: p
      })
    }).then((D) => D.json());
  }
  order_checkout_start({
    order_key: u
  } = {}) {
    return at(`${this.shop_url}/order/checkout_start`, {
      method: "POST",
      params: { order_key: u }
    }).then((g) => g.json());
  }
  order_checkout_order({
    order_key: u
  } = {}) {
    return at(`${this.shop_url}/order/checkout_order`, {
      method: "POST",
      params: { order_key: u }
    }).then((g) => g.json());
  }
  order_pp_get_settings({
    order_key: u
  } = {}) {
    return at(`${this.shop_url}/order/checkout_order`, {
      method: "POST",
      params: { order_key: u }
    }).then((g) => g.json());
  }
  // --- User ---------------------------------------------------------------
  user_view({
    user_key: u = "self"
  } = {}) {
    return at(`${this.host_url}/json/user/view/${u}`).then((g) => g.json()).then((g) => g.values);
  }
  // --- Discount -----------------------------------------------------------
  discount_add({
    code: u,
    discount_key: g
  } = {}) {
    return at(`${this.shop_api_url}/discount_add`, {
      method: "POST",
      params: this.removeUndefinedValues({
        code: u,
        discount_key: g
      })
    }).then((w) => w.json());
  }
  // --- Utils -------------------------------------------------------------
  removeUndefinedValues(u) {
    return Object.fromEntries(
      Object.entries(u).filter(([g, w]) => w !== void 0)
    );
  }
}
const Wt = ur("cartstore", () => {
  const c = new uD({
    host_url: "http://localhost:8080"
  }), u = me({
    basket: "",
    carts: {},
    structure: { address: {}, cart: {} }
  });
  async function g() {
    console.dir(c), await w();
  }
  async function w() {
    (await c.cart_list()).forEach(async (k) => {
      u.carts[k.key] = {}, u.carts[k.key].info = k, k.cart_type === "basket" && (u.basket = k.key), await b(k.key);
    });
  }
  async function b(A) {
    let k = await c.cart_list({ cart_key: A });
    u.carts[A].items = k;
  }
  async function x(A, k) {
    let E = await c.article_add({
      article_key: A,
      parent_cart_key: k
    });
    await D(k), console.log("addToCart", E);
  }
  async function v(A, k) {
    let E = await c.article_view({
      article_key: A,
      parent_cart_key: k
    });
    console.log("getArticleView", E);
  }
  async function C(A, k) {
    let E = await c.article_remove({
      article_key: A,
      parent_cart_key: k
    });
    await D(k), console.log("remove Resp", E);
  }
  async function p(A, k, E) {
    let P = await c.article_update({
      article_key: A,
      parent_cart_key: k,
      quantity: E,
      quantity_mode: "replace"
    });
    E === 0 && await D(k), console.log("update Resp", P);
  }
  async function D(A) {
    await b(A);
  }
  async function y() {
    let A = await c.address_structure();
    u.structure.address = A.addSkel, console.log("adress add", u.structure.address);
  }
  return {
    state: u,
    addToCart: x,
    getArticleView: v,
    removeItem: C,
    updateItem: p,
    init: g,
    getAdressStructure: y
  };
}), Re = (c) => (dt("data-v-19d91692"), c = c(), ut(), c), hD = {
  key: 1,
  class: "bind viur-shop-cart-wrap"
}, gD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("p", null, "Möchten Sie den Artikel wirklich aus dem Warenkorb entfernen?", -1)), mD = {
  class: "footer-wrap",
  slot: "footer"
}, pD = { class: "viur-shop-cart-list" }, fD = {
  key: 0,
  class: "viur-shop-cart-controlbar"
}, bD = { class: "viur-shop-cart-button-list left" }, kD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-icon", {
  library: "hsk",
  name: "pen",
  slot: "suffix"
}, null, -1)), wD = [
  kD
], vD = { distance: "10" }, _D = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-icon", {
  class: "dots",
  name: "dots",
  library: "hsk",
  slot: "trigger"
}, null, -1)), AD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  library: "hsk",
  name: "save",
  class: "primary-icon"
}, null, -1)), CD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  library: "hsk",
  name: "project",
  class: "primary-icon"
}, null, -1)), yD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  library: "hsk",
  name: "clone",
  class: "primary-icon"
}, null, -1)), ED = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  library: "hsk",
  name: "delete",
  class: "delete-icon"
}, null, -1)), xD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-icon", {
  library: "hsk",
  name: "pen",
  slot: "suffix"
}, null, -1)), SD = [
  xD
], DD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("br", null, null, -1)), BD = {
  ref: "cartActionInfo",
  variant: "primary",
  duration: "3000",
  closable: ""
}, TD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-icon", {
  slot: "icon",
  name: "check"
}, null, -1)), ID = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("strong", null, "Warenkorb gespeichert!", -1)), PD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("br", null, null, -1)), OD = [
  TD,
  ID,
  PD
], RD = {
  ref: "cartErrorInfo",
  variant: "danger",
  duration: "3000",
  closable: ""
}, zD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-icon", {
  slot: "icon",
  name: "error"
}, null, -1)), MD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("strong", null, "Warenkorb nicht gespeichert!", -1)), ND = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("br", null, null, -1)), FD = [
  zD,
  MD,
  ND
], $D = { key: 2 }, VD = {
  horizontal: "",
  class: "viur-shop-cart-card"
}, LD = ["src"], jD = {
  class: "viur-shop-cart-card-header",
  slot: "header"
}, HD = { class: "viur-shop-cart-card-headline headline" }, UD = { class: "viur-shop-cart-card-body-row" }, qD = { class: "viur-shop-cart-card-body-info" }, WD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("div", { class: "viur-shop-cart-card-descr" }, [
  /* @__PURE__ */ ie(" Version: 900x900x2000 "),
  /* @__PURE__ */ I("br"),
  /* @__PURE__ */ ie(" Farbe: Chromoptik "),
  /* @__PURE__ */ I("br"),
  /* @__PURE__ */ ie(" Glasart: Klar hell mit Edelglasbeschichtung"),
  /* @__PURE__ */ I("br"),
  /* @__PURE__ */ ie(" Anschlag: Beidseitig variabel"),
  /* @__PURE__ */ I("br"),
  /* @__PURE__ */ ie(" Griff: Stangengriff Exklusiv (56) ")
], -1)), GD = { class: "viur-shop-cart-card-body-footer" }, KD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-button", {
  size: "small",
  outline: "",
  class: "viur-shop-cart-card-add-to-favourites-btn",
  variant: "primary",
  title: "Add to favourites"
}, [
  /* @__PURE__ */ I("sl-icon", {
    name: "heart",
    slot: "prefix"
  })
], -1)), ZD = ["onClick"], JD = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-icon", {
  name: "trash",
  slot: "prefix"
}, null, -1)), YD = [
  JD
], QD = { class: "viur-shop-cart-card-body-amount" }, XD = ["onUpdate:modelValue", "onInput"], eB = {
  class: "viur-shop-cart-card-price-wrap",
  slot: "footer"
}, tB = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("div", { class: "viur-shop-cart-card-price-label" }, "Preis", -1)), nB = { class: "viur-shop-cart-card-price" }, oB = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("div", { class: "viur-shop-cart-card-small-print" }, "Brutto / Stk.", -1)), iB = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("h2", { class: "viur-shop-cart-sidebar-headline headline" }, "Zusammenfassung", -1)), rB = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("br", null, null, -1)), sB = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("sl-input", { label: "Rabattcode eingeben" }, null, -1)), aB = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("br", null, null, -1)), lB = { class: "viur-shop-cart-sidebar-info-line" }, cB = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("span", null, "Zwischensumme", -1)), dB = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("div", { class: "viur-shop-cart-sidebar-info-line" }, [
  /* @__PURE__ */ I("span", null, "Rabatt"),
  /* @__PURE__ */ ie(" 0 € ")
], -1)), uB = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("div", { class: "viur-shop-cart-sidebar-info-line" }, [
  /* @__PURE__ */ I("span", null, "Versandkosten"),
  /* @__PURE__ */ ie(" 0 € ")
], -1)), hB = { class: "viur-shop-cart-sidebar-info-line total" }, gB = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("span", null, "Gesamt:", -1)), mB = /* @__PURE__ */ Re(() => /* @__PURE__ */ I("div", { class: "viur-shop-cart-sidebar-btn-wrap" }, [
  /* @__PURE__ */ I("sl-button", {
    variant: "info",
    size: "small"
  }, " Jetzt Bestellen "),
  /* @__PURE__ */ I("sl-button", {
    size: "small",
    variant: "primary"
  }, [
    /* @__PURE__ */ I("sl-icon", {
      name: "paypal",
      slot: "prefix"
    }),
    /* @__PURE__ */ ie(" Paypal ")
  ])
], -1)), pB = {
  __name: "CartView",
  props: {
    mode: { type: String, default: "basket" },
    cartKey: { type: String, default: "" },
    sidebar: { type: Boolean, default: !0 }
  },
  setup(c) {
    const u = c, g = Wt(), w = en(null), b = me({
      cartIsInit: ce(() => !!g.state.basket.length),
      itemsIsInit: ce(() => !!g.state.carts[g.state.basket].items),
      images: {},
      currentItem: {}
    });
    ce(() => u.mode === "basket" ? g.state.basket : u.cartKey);
    function x(y) {
      return he.get(`/json/dk_variante/view/${y}`).then(async (A) => {
        let k = await A.json();
        k = k.values;
        let E = k.hk_artikel.dest.image ? he.downloadUrlFor(k.hk_artikel.dest.image) : "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80";
        b.images[y] = E;
      }), b.images[y];
    }
    async function v() {
      await g.updateItem(
        b.currentItem.article.dest.key,
        g.state.basket,
        0
      ), w.value.hide();
    }
    function C(y, A, k, E) {
      E === 0 ? (w.value.show(), b.currentItem = y) : g.updateItem(A, k, E);
    }
    function p(y, A, k) {
      w.value.show(), b.currentItem = y;
    }
    function D() {
      g.state.carts[g.state.basket].items.forEach((y) => {
        y.key === b.currentItem.key && (y.quantity = 1);
      }), b.currentItem = {};
    }
    return yo(async () => {
      await g.init();
    }), (y, A) => b.cartIsInit ? (H(), G("div", hD, [
      I("sl-dialog", {
        ref_key: "confirm",
        ref: w,
        onSlHide: D
      }, [
        gD,
        I("div", mD, [
          I("sl-button", {
            variant: "danger",
            onClick: A[0] || (A[0] = (k) => w.value.hide()),
            size: "medium"
          }, " Abbrechen "),
          I("sl-button", {
            variant: "success",
            onClick: v,
            size: "medium"
          }, " Aus Warenkorb entfernen ")
        ])
      ], 544),
      I("div", pD, [
        c.mode !== "basket" ? (H(), G("div", fD, [
          I("div", bD, [
            gt(I("sl-input", {
              ref: "cartNameField",
              name: "cart-name",
              placeholder: "Warenkorbname",
              "onUpdate:modelValue": A[1] || (A[1] = (k) => le(g).state.carts[le(g).state.basket].info.name = k),
              required: "true",
              inputmode: "text",
              class: "viur-shop-cart-headline"
            }, wD, 512), [
              [Ct, le(g).state.carts[le(g).state.basket].info.name]
            ])
          ]),
          I("sl-dropdown", vD, [
            _D,
            I("sl-menu", null, [
              I("sl-menu-item", {
                onClick: A[2] || (A[2] = (...k) => y.saveCart && y.saveCart(...k)),
                title: "Warenkorb speichern"
              }, [
                AD,
                ie(" Warenkorb speichern ")
              ]),
              I("sl-menu-item", {
                onClick: A[3] || (A[3] = (...k) => y.saveCart && y.saveCart(...k)),
                title: "Zu Projekt hinzufügen"
              }, [
                CD,
                ie(" Zu Projekt hinzufügen ")
              ]),
              I("sl-menu-item", {
                onClick: A[4] || (A[4] = (...k) => y.saveCart && y.saveCart(...k)),
                title: "Warenkorb kopieren"
              }, [
                yD,
                ie(" Warenkorb kopieren ")
              ]),
              I("sl-menu-item", {
                onClick: A[5] || (A[5] = (...k) => y.saveCart && y.saveCart(...k)),
                title: "Warenkorb löschen"
              }, [
                ED,
                ie(" Warenkorb löschen ")
              ])
            ])
          ])
        ])) : Ee("", !0),
        c.mode !== "basket" ? gt((H(), G("sl-input", {
          key: 1,
          name: "cart-internalCartNo",
          placeholder: "Freifeld (Kommission)",
          "onUpdate:modelValue": A[6] || (A[6] = (k) => le(g).state.carts[le(g).state.basket].info.customer_comment = k),
          inputmode: "text",
          class: "viur-shop-cart-descr"
        }, SD, 512)), [
          [
            Ct,
            le(g).state.carts[le(g).state.basket].info.customer_comment
          ]
        ]) : Ee("", !0),
        DD,
        I("sl-alert", BD, OD, 512),
        I("sl-alert", RD, FD, 512),
        b.itemsIsInit ? (H(!0), G(Ve, { key: 3 }, kt(le(g).state.carts[le(g).state.basket].items, (k) => (H(), G("sl-card", VD, [
          I("img", {
            class: "viur-shop-cart-card-img",
            slot: "image",
            src: x(k.article.dest.key)
          }, null, 8, LD),
          I("div", jD, [
            I("h4", HD, ge(k.article.dest.shop_name) + " | 425018 ", 1)
          ]),
          I("div", UD, [
            I("div", qD, [
              WD,
              I("div", GD, [
                KD,
                I("sl-button", {
                  size: "small",
                  outline: "",
                  class: "viur-shop-cart-card-delete-btn",
                  variant: "primary",
                  title: "Remove from cart",
                  onClick: (E) => p(
                    k,
                    k.article.dest.key,
                    le(g).state.basket
                  )
                }, YD, 8, ZD)
              ])
            ]),
            I("div", QD, [
              gt(I("sl-input", {
                class: "amount-input",
                type: "number",
                label: "Anzahl",
                placeholder: "Number",
                min: "0",
                "onUpdate:modelValue": (E) => k.quantity = E,
                onInput: (E) => C(
                  k,
                  k.article.dest.key,
                  le(g).state.basket,
                  k.quantity
                )
              }, null, 40, XD), [
                [Ct, k.quantity]
              ])
            ]),
            I("div", eB, [
              tB,
              I("div", nB, ge(k.price.retail) + " € ", 1),
              oB
            ])
          ])
        ]))), 256)) : (H(), G("sl-spinner", $D))
      ]),
      c.sidebar ? (H(), yt(Tw, {
        key: 0,
        to: "#order_sidebar"
      }, [
        iB,
        rB,
        sB,
        aB,
        I("div", lB, [
          cB,
          ie(" " + ge(le(g).state.carts[le(g).state.basket].info.total) + " € ", 1)
        ]),
        dB,
        uB,
        I("div", hB, [
          gB,
          ie(" " + ge(le(g).state.carts[le(g).state.basket].info.total) + " € ", 1)
        ]),
        mB
      ])) : Ee("", !0)
    ])) : (H(), yt(zw, { key: 0 }));
  }
}, Mw = /* @__PURE__ */ Ae(pB, [["__scopeId", "data-v-19d91692"]]), fB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Mw
}, Symbol.toStringTag, { value: "Module" })), Rs = ur("shopstore", () => {
  const c = me({
    hasCrossSelling: !0,
    crossSellingItems: [],
    crossSellingFunction: "",
    hasUpSelling: !0,
    upSellingItems: [],
    upSellingFunction: ""
  });
  async function u(g, w) {
    c.crossSellingItems = [];
    let b = !1;
    for (let x of w)
      he.get(`http://localhost:8080${g}?key=${x}`).then(
        async (v) => {
          let C = await v.json();
          console.log(C), c.crossSellingItems.push(C.skellist[0]), b = !0;
        }
      );
    return b;
  }
  return {
    state: c,
    getCrossSellingItems: u
  };
});
function bB() {
  return Nw().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function Nw() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const kB = typeof Proxy == "function", wB = "devtools-plugin:setup", vB = "plugin:settings:set";
let ii, yc;
function _B() {
  var c;
  return ii !== void 0 || (typeof window < "u" && window.performance ? (ii = !0, yc = window.performance) : typeof globalThis < "u" && (!((c = globalThis.perf_hooks) === null || c === void 0) && c.performance) ? (ii = !0, yc = globalThis.perf_hooks.performance) : ii = !1), ii;
}
function AB() {
  return _B() ? yc.now() : Date.now();
}
class CB {
  constructor(u, g) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = u, this.hook = g;
    const w = {};
    if (u.settings)
      for (const v in u.settings) {
        const C = u.settings[v];
        w[v] = C.defaultValue;
      }
    const b = `__vue-devtools-plugin-settings__${u.id}`;
    let x = Object.assign({}, w);
    try {
      const v = localStorage.getItem(b), C = JSON.parse(v);
      Object.assign(x, C);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return x;
      },
      setSettings(v) {
        try {
          localStorage.setItem(b, JSON.stringify(v));
        } catch {
        }
        x = v;
      },
      now() {
        return AB();
      }
    }, g && g.on(vB, (v, C) => {
      v === this.plugin.id && this.fallbacks.setSettings(C);
    }), this.proxiedOn = new Proxy({}, {
      get: (v, C) => this.target ? this.target.on[C] : (...p) => {
        this.onQueue.push({
          method: C,
          args: p
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (v, C) => this.target ? this.target[C] : C === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(C) ? (...p) => (this.targetQueue.push({
        method: C,
        args: p,
        resolve: () => {
        }
      }), this.fallbacks[C](...p)) : (...p) => new Promise((D) => {
        this.targetQueue.push({
          method: C,
          args: p,
          resolve: D
        });
      })
    });
  }
  async setRealTarget(u) {
    this.target = u;
    for (const g of this.onQueue)
      this.target.on[g.method](...g.args);
    for (const g of this.targetQueue)
      g.resolve(await this.target[g.method](...g.args));
  }
}
function yB(c, u) {
  const g = c, w = Nw(), b = bB(), x = kB && g.enableEarlyProxy;
  if (b && (w.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !x))
    b.emit(wB, c, u);
  else {
    const v = x ? new CB(g, b) : null;
    (w.__VUE_DEVTOOLS_PLUGINS__ = w.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: g,
      setupFn: u,
      proxy: v
    }), v && u(v.proxiedTarget);
  }
}
/*!
  * vue-router v4.3.2
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const xn = typeof document < "u";
function EB(c) {
  return c.__esModule || c[Symbol.toStringTag] === "Module";
}
const Ie = Object.assign;
function mc(c, u) {
  const g = {};
  for (const w in u) {
    const b = u[w];
    g[w] = Lt(b) ? b.map(c) : c(b);
  }
  return g;
}
const er = () => {
}, Lt = Array.isArray;
function fe(c) {
  const u = Array.from(arguments).slice(1);
  console.warn.apply(console, ["[Vue Router warn]: " + c].concat(u));
}
const Fw = /#/g, xB = /&/g, SB = /\//g, DB = /=/g, BB = /\?/g, $w = /\+/g, TB = /%5B/g, IB = /%5D/g, Vw = /%5E/g, PB = /%60/g, Lw = /%7B/g, OB = /%7C/g, jw = /%7D/g, RB = /%20/g;
function $c(c) {
  return encodeURI("" + c).replace(OB, "|").replace(TB, "[").replace(IB, "]");
}
function zB(c) {
  return $c(c).replace(Lw, "{").replace(jw, "}").replace(Vw, "^");
}
function Ec(c) {
  return $c(c).replace($w, "%2B").replace(RB, "+").replace(Fw, "%23").replace(xB, "%26").replace(PB, "`").replace(Lw, "{").replace(jw, "}").replace(Vw, "^");
}
function MB(c) {
  return Ec(c).replace(DB, "%3D");
}
function NB(c) {
  return $c(c).replace(Fw, "%23").replace(BB, "%3F");
}
function FB(c) {
  return c == null ? "" : NB(c).replace(SB, "%2F");
}
function li(c) {
  try {
    return decodeURIComponent("" + c);
  } catch {
    process.env.NODE_ENV !== "production" && fe(`Error decoding "${c}". Using original value`);
  }
  return "" + c;
}
const $B = /\/$/, VB = (c) => c.replace($B, "");
function pc(c, u, g = "/") {
  let w, b = {}, x = "", v = "";
  const C = u.indexOf("#");
  let p = u.indexOf("?");
  return C < p && C >= 0 && (p = -1), p > -1 && (w = u.slice(0, p), x = u.slice(p + 1, C > -1 ? C : u.length), b = c(x)), C > -1 && (w = w || u.slice(0, C), v = u.slice(C, u.length)), w = HB(w ?? u, g), {
    fullPath: w + (x && "?") + x + v,
    path: w,
    query: b,
    hash: li(v)
  };
}
function LB(c, u) {
  const g = u.query ? c(u.query) : "";
  return u.path + (g && "?") + g + (u.hash || "");
}
function Bk(c, u) {
  return !u || !c.toLowerCase().startsWith(u.toLowerCase()) ? c : c.slice(u.length) || "/";
}
function Tk(c, u, g) {
  const w = u.matched.length - 1, b = g.matched.length - 1;
  return w > -1 && w === b && Un(u.matched[w], g.matched[b]) && Hw(u.params, g.params) && c(u.query) === c(g.query) && u.hash === g.hash;
}
function Un(c, u) {
  return (c.aliasOf || c) === (u.aliasOf || u);
}
function Hw(c, u) {
  if (Object.keys(c).length !== Object.keys(u).length)
    return !1;
  for (const g in c)
    if (!jB(c[g], u[g]))
      return !1;
  return !0;
}
function jB(c, u) {
  return Lt(c) ? Ik(c, u) : Lt(u) ? Ik(u, c) : c === u;
}
function Ik(c, u) {
  return Lt(u) ? c.length === u.length && c.every((g, w) => g === u[w]) : c.length === 1 && c[0] === u;
}
function HB(c, u) {
  if (c.startsWith("/"))
    return c;
  if (process.env.NODE_ENV !== "production" && !u.startsWith("/"))
    return fe(`Cannot resolve a relative location without an absolute path. Trying to resolve "${c}" from "${u}". It should look like "/${u}".`), c;
  if (!c)
    return u;
  const g = u.split("/"), w = c.split("/"), b = w[w.length - 1];
  (b === ".." || b === ".") && w.push("");
  let x = g.length - 1, v, C;
  for (v = 0; v < w.length; v++)
    if (C = w[v], C !== ".")
      if (C === "..")
        x > 1 && x--;
      else
        break;
  return g.slice(0, x).join("/") + "/" + w.slice(v).join("/");
}
var sr;
(function(c) {
  c.pop = "pop", c.push = "push";
})(sr || (sr = {}));
var tr;
(function(c) {
  c.back = "back", c.forward = "forward", c.unknown = "";
})(tr || (tr = {}));
function UB(c) {
  if (!c)
    if (xn) {
      const u = document.querySelector("base");
      c = u && u.getAttribute("href") || "/", c = c.replace(/^\w+:\/\/[^\/]+/, "");
    } else
      c = "/";
  return c[0] !== "/" && c[0] !== "#" && (c = "/" + c), VB(c);
}
const qB = /^[^#]+#/;
function WB(c, u) {
  return c.replace(qB, "#") + u;
}
function GB(c, u) {
  const g = document.documentElement.getBoundingClientRect(), w = c.getBoundingClientRect();
  return {
    behavior: u.behavior,
    left: w.left - g.left - (u.left || 0),
    top: w.top - g.top - (u.top || 0)
  };
}
const zs = () => ({
  left: window.scrollX,
  top: window.scrollY
});
function KB(c) {
  let u;
  if ("el" in c) {
    const g = c.el, w = typeof g == "string" && g.startsWith("#");
    if (process.env.NODE_ENV !== "production" && typeof c.el == "string" && (!w || !document.getElementById(c.el.slice(1))))
      try {
        const x = document.querySelector(c.el);
        if (w && x) {
          fe(`The selector "${c.el}" should be passed as "el: document.querySelector('${c.el}')" because it starts with "#".`);
          return;
        }
      } catch {
        fe(`The selector "${c.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
        return;
      }
    const b = typeof g == "string" ? w ? document.getElementById(g.slice(1)) : document.querySelector(g) : g;
    if (!b) {
      process.env.NODE_ENV !== "production" && fe(`Couldn't find element using selector "${c.el}" returned by scrollBehavior.`);
      return;
    }
    u = GB(b, c);
  } else
    u = c;
  "scrollBehavior" in document.documentElement.style ? window.scrollTo(u) : window.scrollTo(u.left != null ? u.left : window.scrollX, u.top != null ? u.top : window.scrollY);
}
function Pk(c, u) {
  return (history.state ? history.state.position - u : -1) + c;
}
const xc = /* @__PURE__ */ new Map();
function ZB(c, u) {
  xc.set(c, u);
}
function JB(c) {
  const u = xc.get(c);
  return xc.delete(c), u;
}
let YB = () => location.protocol + "//" + location.host;
function Uw(c, u) {
  const { pathname: g, search: w, hash: b } = u, x = c.indexOf("#");
  if (x > -1) {
    let C = b.includes(c.slice(x)) ? c.slice(x).length : 1, p = b.slice(C);
    return p[0] !== "/" && (p = "/" + p), Bk(p, "");
  }
  return Bk(g, c) + w + b;
}
function QB(c, u, g, w) {
  let b = [], x = [], v = null;
  const C = ({ state: k }) => {
    const E = Uw(c, location), P = g.value, z = u.value;
    let M = 0;
    if (k) {
      if (g.value = E, u.value = k, v && v === P) {
        v = null;
        return;
      }
      M = z ? k.position - z.position : 0;
    } else
      w(E);
    b.forEach((F) => {
      F(g.value, P, {
        delta: M,
        type: sr.pop,
        direction: M ? M > 0 ? tr.forward : tr.back : tr.unknown
      });
    });
  };
  function p() {
    v = g.value;
  }
  function D(k) {
    b.push(k);
    const E = () => {
      const P = b.indexOf(k);
      P > -1 && b.splice(P, 1);
    };
    return x.push(E), E;
  }
  function y() {
    const { history: k } = window;
    k.state && k.replaceState(Ie({}, k.state, { scroll: zs() }), "");
  }
  function A() {
    for (const k of x)
      k();
    x = [], window.removeEventListener("popstate", C), window.removeEventListener("beforeunload", y);
  }
  return window.addEventListener("popstate", C), window.addEventListener("beforeunload", y, {
    passive: !0
  }), {
    pauseListeners: p,
    listen: D,
    destroy: A
  };
}
function Ok(c, u, g, w = !1, b = !1) {
  return {
    back: c,
    current: u,
    forward: g,
    replaced: w,
    position: window.history.length,
    scroll: b ? zs() : null
  };
}
function XB(c) {
  const { history: u, location: g } = window, w = {
    value: Uw(c, g)
  }, b = { value: u.state };
  b.value || x(w.value, {
    back: null,
    current: w.value,
    forward: null,
    // the length is off by one, we need to decrease it
    position: u.length - 1,
    replaced: !0,
    // don't add a scroll as the user may have an anchor, and we want
    // scrollBehavior to be triggered without a saved position
    scroll: null
  }, !0);
  function x(p, D, y) {
    const A = c.indexOf("#"), k = A > -1 ? (g.host && document.querySelector("base") ? c : c.slice(A)) + p : YB() + c + p;
    try {
      u[y ? "replaceState" : "pushState"](D, "", k), b.value = D;
    } catch (E) {
      process.env.NODE_ENV !== "production" ? fe("Error with push/replace State", E) : console.error(E), g[y ? "replace" : "assign"](k);
    }
  }
  function v(p, D) {
    const y = Ie({}, u.state, Ok(
      b.value.back,
      // keep back and forward entries but override current position
      p,
      b.value.forward,
      !0
    ), D, { position: b.value.position });
    x(p, y, !0), w.value = p;
  }
  function C(p, D) {
    const y = Ie(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      b.value,
      u.state,
      {
        forward: p,
        scroll: zs()
      }
    );
    process.env.NODE_ENV !== "production" && !u.state && fe(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`), x(y.current, y, !0);
    const A = Ie({}, Ok(w.value, p, null), { position: y.position + 1 }, D);
    x(p, A, !1), w.value = p;
  }
  return {
    location: w,
    state: b,
    push: C,
    replace: v
  };
}
function eT(c) {
  c = UB(c);
  const u = XB(c), g = QB(c, u.state, u.location, u.replace);
  function w(x, v = !0) {
    v || g.pauseListeners(), history.go(x);
  }
  const b = Ie({
    // it's overridden right after
    location: "",
    base: c,
    go: w,
    createHref: WB.bind(null, c)
  }, u, g);
  return Object.defineProperty(b, "location", {
    enumerable: !0,
    get: () => u.location.value
  }), Object.defineProperty(b, "state", {
    enumerable: !0,
    get: () => u.state.value
  }), b;
}
function tT(c) {
  return c = location.host ? c || location.pathname + location.search : "", c.includes("#") || (c += "#"), process.env.NODE_ENV !== "production" && !c.endsWith("#/") && !c.endsWith("#") && fe(`A hash base must end with a "#":
"${c}" should be "${c.replace(/#.*$/, "#")}".`), eT(c);
}
function Ts(c) {
  return typeof c == "string" || c && typeof c == "object";
}
function qw(c) {
  return typeof c == "string" || typeof c == "symbol";
}
const $n = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
}, Sc = Symbol(process.env.NODE_ENV !== "production" ? "navigation failure" : "");
var Rk;
(function(c) {
  c[c.aborted = 4] = "aborted", c[c.cancelled = 8] = "cancelled", c[c.duplicated = 16] = "duplicated";
})(Rk || (Rk = {}));
const nT = {
  1({ location: c, currentLocation: u }) {
    return `No match for
 ${JSON.stringify(c)}${u ? `
while being at
` + JSON.stringify(u) : ""}`;
  },
  2({ from: c, to: u }) {
    return `Redirected from "${c.fullPath}" to "${iT(u)}" via a navigation guard.`;
  },
  4({ from: c, to: u }) {
    return `Navigation aborted from "${c.fullPath}" to "${u.fullPath}" via a navigation guard.`;
  },
  8({ from: c, to: u }) {
    return `Navigation cancelled from "${c.fullPath}" to "${u.fullPath}" with a new navigation.`;
  },
  16({ from: c, to: u }) {
    return `Avoided redundant navigation to current location: "${c.fullPath}".`;
  }
};
function ci(c, u) {
  return process.env.NODE_ENV !== "production" ? Ie(new Error(nT[c](u)), {
    type: c,
    [Sc]: !0
  }, u) : Ie(new Error(), {
    type: c,
    [Sc]: !0
  }, u);
}
function En(c, u) {
  return c instanceof Error && Sc in c && (u == null || !!(c.type & u));
}
const oT = ["params", "query", "hash"];
function iT(c) {
  if (typeof c == "string")
    return c;
  if (c.path != null)
    return c.path;
  const u = {};
  for (const g of oT)
    g in c && (u[g] = c[g]);
  return JSON.stringify(u, null, 2);
}
const zk = "[^/]+?", rT = {
  sensitive: !1,
  strict: !1,
  start: !0,
  end: !0
}, sT = /[.+*?^${}()[\]/\\]/g;
function aT(c, u) {
  const g = Ie({}, rT, u), w = [];
  let b = g.start ? "^" : "";
  const x = [];
  for (const D of c) {
    const y = D.length ? [] : [
      90
      /* PathScore.Root */
    ];
    g.strict && !D.length && (b += "/");
    for (let A = 0; A < D.length; A++) {
      const k = D[A];
      let E = 40 + (g.sensitive ? 0.25 : 0);
      if (k.type === 0)
        A || (b += "/"), b += k.value.replace(sT, "\\$&"), E += 40;
      else if (k.type === 1) {
        const { value: P, repeatable: z, optional: M, regexp: F } = k;
        x.push({
          name: P,
          repeatable: z,
          optional: M
        });
        const V = F || zk;
        if (V !== zk) {
          E += 10;
          try {
            new RegExp(`(${V})`);
          } catch (Z) {
            throw new Error(`Invalid custom RegExp for param "${P}" (${V}): ` + Z.message);
          }
        }
        let j = z ? `((?:${V})(?:/(?:${V}))*)` : `(${V})`;
        A || (j = // avoid an optional / if there are more segments e.g. /:p?-static
        // or /:p?-:p2
        M && D.length < 2 ? `(?:/${j})` : "/" + j), M && (j += "?"), b += j, E += 20, M && (E += -8), z && (E += -20), V === ".*" && (E += -50);
      }
      y.push(E);
    }
    w.push(y);
  }
  if (g.strict && g.end) {
    const D = w.length - 1;
    w[D][w[D].length - 1] += 0.7000000000000001;
  }
  g.strict || (b += "/?"), g.end ? b += "$" : g.strict && (b += "(?:/|$)");
  const v = new RegExp(b, g.sensitive ? "" : "i");
  function C(D) {
    const y = D.match(v), A = {};
    if (!y)
      return null;
    for (let k = 1; k < y.length; k++) {
      const E = y[k] || "", P = x[k - 1];
      A[P.name] = E && P.repeatable ? E.split("/") : E;
    }
    return A;
  }
  function p(D) {
    let y = "", A = !1;
    for (const k of c) {
      (!A || !y.endsWith("/")) && (y += "/"), A = !1;
      for (const E of k)
        if (E.type === 0)
          y += E.value;
        else if (E.type === 1) {
          const { value: P, repeatable: z, optional: M } = E, F = P in D ? D[P] : "";
          if (Lt(F) && !z)
            throw new Error(`Provided param "${P}" is an array but it is not repeatable (* or + modifiers)`);
          const V = Lt(F) ? F.join("/") : F;
          if (!V)
            if (M)
              k.length < 2 && (y.endsWith("/") ? y = y.slice(0, -1) : A = !0);
            else
              throw new Error(`Missing required param "${P}"`);
          y += V;
        }
    }
    return y || "/";
  }
  return {
    re: v,
    score: w,
    keys: x,
    parse: C,
    stringify: p
  };
}
function lT(c, u) {
  let g = 0;
  for (; g < c.length && g < u.length; ) {
    const w = u[g] - c[g];
    if (w)
      return w;
    g++;
  }
  return c.length < u.length ? c.length === 1 && c[0] === 80 ? -1 : 1 : c.length > u.length ? u.length === 1 && u[0] === 80 ? 1 : -1 : 0;
}
function cT(c, u) {
  let g = 0;
  const w = c.score, b = u.score;
  for (; g < w.length && g < b.length; ) {
    const x = lT(w[g], b[g]);
    if (x)
      return x;
    g++;
  }
  if (Math.abs(b.length - w.length) === 1) {
    if (Mk(w))
      return 1;
    if (Mk(b))
      return -1;
  }
  return b.length - w.length;
}
function Mk(c) {
  const u = c[c.length - 1];
  return c.length > 0 && u[u.length - 1] < 0;
}
const dT = {
  type: 0,
  value: ""
}, uT = /[a-zA-Z0-9_]/;
function hT(c) {
  if (!c)
    return [[]];
  if (c === "/")
    return [[dT]];
  if (!c.startsWith("/"))
    throw new Error(process.env.NODE_ENV !== "production" ? `Route paths should start with a "/": "${c}" should be "/${c}".` : `Invalid path "${c}"`);
  function u(E) {
    throw new Error(`ERR (${g})/"${D}": ${E}`);
  }
  let g = 0, w = g;
  const b = [];
  let x;
  function v() {
    x && b.push(x), x = [];
  }
  let C = 0, p, D = "", y = "";
  function A() {
    D && (g === 0 ? x.push({
      type: 0,
      value: D
    }) : g === 1 || g === 2 || g === 3 ? (x.length > 1 && (p === "*" || p === "+") && u(`A repeatable param (${D}) must be alone in its segment. eg: '/:ids+.`), x.push({
      type: 1,
      value: D,
      regexp: y,
      repeatable: p === "*" || p === "+",
      optional: p === "*" || p === "?"
    })) : u("Invalid state to consume buffer"), D = "");
  }
  function k() {
    D += p;
  }
  for (; C < c.length; ) {
    if (p = c[C++], p === "\\" && g !== 2) {
      w = g, g = 4;
      continue;
    }
    switch (g) {
      case 0:
        p === "/" ? (D && A(), v()) : p === ":" ? (A(), g = 1) : k();
        break;
      case 4:
        k(), g = w;
        break;
      case 1:
        p === "(" ? g = 2 : uT.test(p) ? k() : (A(), g = 0, p !== "*" && p !== "?" && p !== "+" && C--);
        break;
      case 2:
        p === ")" ? y[y.length - 1] == "\\" ? y = y.slice(0, -1) + p : g = 3 : y += p;
        break;
      case 3:
        A(), g = 0, p !== "*" && p !== "?" && p !== "+" && C--, y = "";
        break;
      default:
        u("Unknown state");
        break;
    }
  }
  return g === 2 && u(`Unfinished custom RegExp for param "${D}"`), A(), v(), b;
}
function gT(c, u, g) {
  const w = aT(hT(c.path), g);
  if (process.env.NODE_ENV !== "production") {
    const x = /* @__PURE__ */ new Set();
    for (const v of w.keys)
      x.has(v.name) && fe(`Found duplicated params with name "${v.name}" for path "${c.path}". Only the last one will be available on "$route.params".`), x.add(v.name);
  }
  const b = Ie(w, {
    record: c,
    parent: u,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  return u && !b.record.aliasOf == !u.record.aliasOf && u.children.push(b), b;
}
function mT(c, u) {
  const g = [], w = /* @__PURE__ */ new Map();
  u = $k({ strict: !1, end: !0, sensitive: !1 }, u);
  function b(y) {
    return w.get(y);
  }
  function x(y, A, k) {
    const E = !k, P = pT(y);
    process.env.NODE_ENV !== "production" && wT(P, A), P.aliasOf = k && k.record;
    const z = $k(u, y), M = [
      P
    ];
    if ("alias" in y) {
      const j = typeof y.alias == "string" ? [y.alias] : y.alias;
      for (const Z of j)
        M.push(Ie({}, P, {
          // this allows us to hold a copy of the `components` option
          // so that async components cache is hold on the original record
          components: k ? k.record.components : P.components,
          path: Z,
          // we might be the child of an alias
          aliasOf: k ? k.record : P
          // the aliases are always of the same kind as the original since they
          // are defined on the same record
        }));
    }
    let F, V;
    for (const j of M) {
      const { path: Z } = j;
      if (A && Z[0] !== "/") {
        const ne = A.record.path, se = ne[ne.length - 1] === "/" ? "" : "/";
        j.path = A.record.path + (Z && se + Z);
      }
      if (process.env.NODE_ENV !== "production" && j.path === "*")
        throw new Error(`Catch all routes ("*") must now be defined using a param with a custom regexp.
See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.`);
      if (F = gT(j, A, z), process.env.NODE_ENV !== "production" && A && Z[0] === "/" && vT(F, A), k ? (k.alias.push(F), process.env.NODE_ENV !== "production" && kT(k, F)) : (V = V || F, V !== F && V.alias.push(F), E && y.name && !Fk(F) && v(y.name)), P.children) {
        const ne = P.children;
        for (let se = 0; se < ne.length; se++)
          x(ne[se], F, k && k.children[se]);
      }
      k = k || F, (F.record.components && Object.keys(F.record.components).length || F.record.name || F.record.redirect) && p(F);
    }
    return V ? () => {
      v(V);
    } : er;
  }
  function v(y) {
    if (qw(y)) {
      const A = w.get(y);
      A && (w.delete(y), g.splice(g.indexOf(A), 1), A.children.forEach(v), A.alias.forEach(v));
    } else {
      const A = g.indexOf(y);
      A > -1 && (g.splice(A, 1), y.record.name && w.delete(y.record.name), y.children.forEach(v), y.alias.forEach(v));
    }
  }
  function C() {
    return g;
  }
  function p(y) {
    let A = 0;
    for (; A < g.length && cT(y, g[A]) >= 0 && // Adding children with empty path should still appear before the parent
    // https://github.com/vuejs/router/issues/1124
    (y.record.path !== g[A].record.path || !Ww(y, g[A])); )
      A++;
    g.splice(A, 0, y), y.record.name && !Fk(y) && w.set(y.record.name, y);
  }
  function D(y, A) {
    let k, E = {}, P, z;
    if ("name" in y && y.name) {
      if (k = w.get(y.name), !k)
        throw ci(1, {
          location: y
        });
      if (process.env.NODE_ENV !== "production") {
        const V = Object.keys(y.params || {}).filter((j) => !k.keys.find((Z) => Z.name === j));
        V.length && fe(`Discarded invalid param(s) "${V.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);
      }
      z = k.record.name, E = Ie(
        // paramsFromLocation is a new object
        Nk(
          A.params,
          // only keep params that exist in the resolved location
          // only keep optional params coming from a parent record
          k.keys.filter((V) => !V.optional).concat(k.parent ? k.parent.keys.filter((V) => V.optional) : []).map((V) => V.name)
        ),
        // discard any existing params in the current location that do not exist here
        // #1497 this ensures better active/exact matching
        y.params && Nk(y.params, k.keys.map((V) => V.name))
      ), P = k.stringify(E);
    } else if (y.path != null)
      P = y.path, process.env.NODE_ENV !== "production" && !P.startsWith("/") && fe(`The Matcher cannot resolve relative paths but received "${P}". Unless you directly called \`matcher.resolve("${P}")\`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.`), k = g.find((V) => V.re.test(P)), k && (E = k.parse(P), z = k.record.name);
    else {
      if (k = A.name ? w.get(A.name) : g.find((V) => V.re.test(A.path)), !k)
        throw ci(1, {
          location: y,
          currentLocation: A
        });
      z = k.record.name, E = Ie({}, A.params, y.params), P = k.stringify(E);
    }
    const M = [];
    let F = k;
    for (; F; )
      M.unshift(F.record), F = F.parent;
    return {
      name: z,
      path: P,
      params: E,
      matched: M,
      meta: bT(M)
    };
  }
  return c.forEach((y) => x(y)), { addRoute: x, resolve: D, removeRoute: v, getRoutes: C, getRecordMatcher: b };
}
function Nk(c, u) {
  const g = {};
  for (const w of u)
    w in c && (g[w] = c[w]);
  return g;
}
function pT(c) {
  return {
    path: c.path,
    redirect: c.redirect,
    name: c.name,
    meta: c.meta || {},
    aliasOf: void 0,
    beforeEnter: c.beforeEnter,
    props: fT(c),
    children: c.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in c ? c.components || null : c.component && { default: c.component }
  };
}
function fT(c) {
  const u = {}, g = c.props || !1;
  if ("component" in c)
    u.default = g;
  else
    for (const w in c.components)
      u[w] = typeof g == "object" ? g[w] : g;
  return u;
}
function Fk(c) {
  for (; c; ) {
    if (c.record.aliasOf)
      return !0;
    c = c.parent;
  }
  return !1;
}
function bT(c) {
  return c.reduce((u, g) => Ie(u, g.meta), {});
}
function $k(c, u) {
  const g = {};
  for (const w in c)
    g[w] = w in u ? u[w] : c[w];
  return g;
}
function Dc(c, u) {
  return c.name === u.name && c.optional === u.optional && c.repeatable === u.repeatable;
}
function kT(c, u) {
  for (const g of c.keys)
    if (!g.optional && !u.keys.find(Dc.bind(null, g)))
      return fe(`Alias "${u.record.path}" and the original record: "${c.record.path}" must have the exact same param named "${g.name}"`);
  for (const g of u.keys)
    if (!g.optional && !c.keys.find(Dc.bind(null, g)))
      return fe(`Alias "${u.record.path}" and the original record: "${c.record.path}" must have the exact same param named "${g.name}"`);
}
function wT(c, u) {
  u && u.record.name && !c.name && !c.path && fe(`The route named "${String(u.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);
}
function vT(c, u) {
  for (const g of u.keys)
    if (!c.keys.find(Dc.bind(null, g)))
      return fe(`Absolute path "${c.record.path}" must have the exact same param named "${g.name}" as its parent "${u.record.path}".`);
}
function Ww(c, u) {
  return u.children.some((g) => g === c || Ww(c, g));
}
function _T(c) {
  const u = {};
  if (c === "" || c === "?")
    return u;
  const w = (c[0] === "?" ? c.slice(1) : c).split("&");
  for (let b = 0; b < w.length; ++b) {
    const x = w[b].replace($w, " "), v = x.indexOf("="), C = li(v < 0 ? x : x.slice(0, v)), p = v < 0 ? null : li(x.slice(v + 1));
    if (C in u) {
      let D = u[C];
      Lt(D) || (D = u[C] = [D]), D.push(p);
    } else
      u[C] = p;
  }
  return u;
}
function Vk(c) {
  let u = "";
  for (let g in c) {
    const w = c[g];
    if (g = MB(g), w == null) {
      w !== void 0 && (u += (u.length ? "&" : "") + g);
      continue;
    }
    (Lt(w) ? w.map((x) => x && Ec(x)) : [w && Ec(w)]).forEach((x) => {
      x !== void 0 && (u += (u.length ? "&" : "") + g, x != null && (u += "=" + x));
    });
  }
  return u;
}
function AT(c) {
  const u = {};
  for (const g in c) {
    const w = c[g];
    w !== void 0 && (u[g] = Lt(w) ? w.map((b) => b == null ? null : "" + b) : w == null ? w : "" + w);
  }
  return u;
}
const CT = Symbol(process.env.NODE_ENV !== "production" ? "router view location matched" : ""), Lk = Symbol(process.env.NODE_ENV !== "production" ? "router view depth" : ""), Vc = Symbol(process.env.NODE_ENV !== "production" ? "router" : ""), Lc = Symbol(process.env.NODE_ENV !== "production" ? "route location" : ""), Bc = Symbol(process.env.NODE_ENV !== "production" ? "router view location" : "");
function Ji() {
  let c = [];
  function u(w) {
    return c.push(w), () => {
      const b = c.indexOf(w);
      b > -1 && c.splice(b, 1);
    };
  }
  function g() {
    c = [];
  }
  return {
    add: u,
    list: () => c.slice(),
    reset: g
  };
}
function Vn(c, u, g, w, b, x = (v) => v()) {
  const v = w && // name is defined if record is because of the function overload
  (w.enterCallbacks[b] = w.enterCallbacks[b] || []);
  return () => new Promise((C, p) => {
    const D = (k) => {
      k === !1 ? p(ci(4, {
        from: g,
        to: u
      })) : k instanceof Error ? p(k) : Ts(k) ? p(ci(2, {
        from: u,
        to: k
      })) : (v && // since enterCallbackArray is truthy, both record and name also are
      w.enterCallbacks[b] === v && typeof k == "function" && v.push(k), C());
    }, y = x(() => c.call(w && w.instances[b], u, g, process.env.NODE_ENV !== "production" ? yT(D, u, g) : D));
    let A = Promise.resolve(y);
    if (c.length < 3 && (A = A.then(D)), process.env.NODE_ENV !== "production" && c.length > 2) {
      const k = `The "next" callback was never called inside of ${c.name ? '"' + c.name + '"' : ""}:
${c.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
      if (typeof y == "object" && "then" in y)
        A = A.then((E) => D._called ? E : (fe(k), Promise.reject(new Error("Invalid navigation guard"))));
      else if (y !== void 0 && !D._called) {
        fe(k), p(new Error("Invalid navigation guard"));
        return;
      }
    }
    A.catch((k) => p(k));
  });
}
function yT(c, u, g) {
  let w = 0;
  return function() {
    w++ === 1 && fe(`The "next" callback was called more than once in one navigation guard when going from "${g.fullPath}" to "${u.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`), c._called = !0, w === 1 && c.apply(null, arguments);
  };
}
function fc(c, u, g, w, b = (x) => x()) {
  const x = [];
  for (const v of c) {
    process.env.NODE_ENV !== "production" && !v.components && !v.children.length && fe(`Record with path "${v.path}" is either missing a "component(s)" or "children" property.`);
    for (const C in v.components) {
      let p = v.components[C];
      if (process.env.NODE_ENV !== "production") {
        if (!p || typeof p != "object" && typeof p != "function")
          throw fe(`Component "${C}" in record with path "${v.path}" is not a valid component. Received "${String(p)}".`), new Error("Invalid route component");
        if ("then" in p) {
          fe(`Component "${C}" in record with path "${v.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
          const D = p;
          p = () => D;
        } else
          p.__asyncLoader && // warn only once per component
          !p.__warnedDefineAsync && (p.__warnedDefineAsync = !0, fe(`Component "${C}" in record with path "${v.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`));
      }
      if (!(u !== "beforeRouteEnter" && !v.instances[C]))
        if (ET(p)) {
          const y = (p.__vccOpts || p)[u];
          y && x.push(Vn(y, g, w, v, C, b));
        } else {
          let D = p();
          process.env.NODE_ENV !== "production" && !("catch" in D) && (fe(`Component "${C}" in record with path "${v.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`), D = Promise.resolve(D)), x.push(() => D.then((y) => {
            if (!y)
              return Promise.reject(new Error(`Couldn't resolve component "${C}" at "${v.path}"`));
            const A = EB(y) ? y.default : y;
            v.components[C] = A;
            const E = (A.__vccOpts || A)[u];
            return E && Vn(E, g, w, v, C, b)();
          }));
        }
    }
  }
  return x;
}
function ET(c) {
  return typeof c == "object" || "displayName" in c || "props" in c || "__vccOpts" in c;
}
function jk(c) {
  const u = Be(Vc), g = Be(Lc);
  let w = !1, b = null;
  const x = ce(() => {
    const y = le(c.to);
    return process.env.NODE_ENV !== "production" && (!w || y !== b) && (Ts(y) || (w ? fe(`Invalid value for prop "to" in useLink()
- to:`, y, `
- previous to:`, b, `
- props:`, c) : fe(`Invalid value for prop "to" in useLink()
- to:`, y, `
- props:`, c)), b = y, w = !0), u.resolve(y);
  }), v = ce(() => {
    const { matched: y } = x.value, { length: A } = y, k = y[A - 1], E = g.matched;
    if (!k || !E.length)
      return -1;
    const P = E.findIndex(Un.bind(null, k));
    if (P > -1)
      return P;
    const z = Hk(y[A - 2]);
    return (
      // we are dealing with nested routes
      A > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      Hk(k) === z && // avoid comparing the child with its parent
      E[E.length - 1].path !== z ? E.findIndex(Un.bind(null, y[A - 2])) : P
    );
  }), C = ce(() => v.value > -1 && BT(g.params, x.value.params)), p = ce(() => v.value > -1 && v.value === g.matched.length - 1 && Hw(g.params, x.value.params));
  function D(y = {}) {
    return DT(y) ? u[le(c.replace) ? "replace" : "push"](
      le(c.to)
      // avoid uncaught errors are they are logged anyway
    ).catch(er) : Promise.resolve();
  }
  if (process.env.NODE_ENV !== "production" && xn) {
    const y = Nc();
    if (y) {
      const A = {
        route: x.value,
        isActive: C.value,
        isExactActive: p.value,
        error: null
      };
      y.__vrl_devtools = y.__vrl_devtools || [], y.__vrl_devtools.push(A), dr(() => {
        A.route = x.value, A.isActive = C.value, A.isExactActive = p.value, A.error = Ts(le(c.to)) ? null : 'Invalid "to" value';
      }, { flush: "post" });
    }
  }
  return {
    route: x,
    href: ce(() => x.value.href),
    isActive: C,
    isExactActive: p,
    navigate: D
  };
}
const xT = /* @__PURE__ */ Ye({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: !0
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink: jk,
  setup(c, { slots: u }) {
    const g = me(jk(c)), { options: w } = Be(Vc), b = ce(() => ({
      [Uk(c.activeClass, w.linkActiveClass, "router-link-active")]: g.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [Uk(c.exactActiveClass, w.linkExactActiveClass, "router-link-exact-active")]: g.isExactActive
    }));
    return () => {
      const x = u.default && u.default(g);
      return c.custom ? x : Iw("a", {
        "aria-current": g.isExactActive ? c.ariaCurrentValue : null,
        href: g.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: g.navigate,
        class: b.value
      }, x);
    };
  }
}), ST = xT;
function DT(c) {
  if (!(c.metaKey || c.altKey || c.ctrlKey || c.shiftKey) && !c.defaultPrevented && !(c.button !== void 0 && c.button !== 0)) {
    if (c.currentTarget && c.currentTarget.getAttribute) {
      const u = c.currentTarget.getAttribute("target");
      if (/\b_blank\b/i.test(u))
        return;
    }
    return c.preventDefault && c.preventDefault(), !0;
  }
}
function BT(c, u) {
  for (const g in u) {
    const w = u[g], b = c[g];
    if (typeof w == "string") {
      if (w !== b)
        return !1;
    } else if (!Lt(b) || b.length !== w.length || w.some((x, v) => x !== b[v]))
      return !1;
  }
  return !0;
}
function Hk(c) {
  return c ? c.aliasOf ? c.aliasOf.path : c.path : "";
}
const Uk = (c, u, g) => c ?? u ?? g, TT = /* @__PURE__ */ Ye({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: !1,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(c, { attrs: u, slots: g }) {
    process.env.NODE_ENV !== "production" && PT();
    const w = Be(Bc), b = ce(() => c.route || w.value), x = Be(Lk, 0), v = ce(() => {
      let D = le(x);
      const { matched: y } = b.value;
      let A;
      for (; (A = y[D]) && !A.components; )
        D++;
      return D;
    }), C = ce(() => b.value.matched[v.value]);
    hc(Lk, ce(() => v.value + 1)), hc(CT, C), hc(Bc, b);
    const p = en();
    return ui(() => [p.value, C.value, c.name], ([D, y, A], [k, E, P]) => {
      y && (y.instances[A] = D, E && E !== y && D && D === k && (y.leaveGuards.size || (y.leaveGuards = E.leaveGuards), y.updateGuards.size || (y.updateGuards = E.updateGuards))), D && y && // if there is no instance but to and from are the same this might be
      // the first visit
      (!E || !Un(y, E) || !k) && (y.enterCallbacks[A] || []).forEach((z) => z(D));
    }, { flush: "post" }), () => {
      const D = b.value, y = c.name, A = C.value, k = A && A.components[y];
      if (!k)
        return qk(g.default, { Component: k, route: D });
      const E = A.props[y], P = E ? E === !0 ? D.params : typeof E == "function" ? E(D) : E : null, M = Iw(k, Ie({}, P, u, {
        onVnodeUnmounted: (F) => {
          F.component.isUnmounted && (A.instances[y] = null);
        },
        ref: p
      }));
      if (process.env.NODE_ENV !== "production" && xn && M.ref) {
        const F = {
          depth: v.value,
          name: A.name,
          path: A.path,
          meta: A.meta
        };
        (Lt(M.ref) ? M.ref.map((j) => j.i) : [M.ref.i]).forEach((j) => {
          j.__vrv_devtools = F;
        });
      }
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        qk(g.default, { Component: M, route: D }) || M
      );
    };
  }
});
function qk(c, u) {
  if (!c)
    return null;
  const g = c(u);
  return g.length === 1 ? g[0] : g;
}
const IT = TT;
function PT() {
  const c = Nc(), u = c.parent && c.parent.type.name, g = c.parent && c.parent.subTree && c.parent.subTree.type;
  if (u && (u === "KeepAlive" || u.includes("Transition")) && typeof g == "object" && g.name === "RouterView") {
    const w = u === "KeepAlive" ? "keep-alive" : "transition";
    fe(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${w}>
    <component :is="Component" />
  </${w}>
</router-view>`);
  }
}
function Yi(c, u) {
  const g = Ie({}, c, {
    // remove variables that can contain vue instances
    matched: c.matched.map((w) => HT(w, ["instances", "children", "aliasOf"]))
  });
  return {
    _custom: {
      type: null,
      readOnly: !0,
      display: c.fullPath,
      tooltip: u,
      value: g
    }
  };
}
function Es(c) {
  return {
    _custom: {
      display: c
    }
  };
}
let OT = 0;
function RT(c, u, g) {
  if (u.__hasDevtools)
    return;
  u.__hasDevtools = !0;
  const w = OT++;
  yB({
    id: "org.vuejs.router" + (w ? "." + w : ""),
    label: "Vue Router",
    packageName: "vue-router",
    homepage: "https://router.vuejs.org",
    logo: "https://router.vuejs.org/logo.png",
    componentStateTypes: ["Routing"],
    app: c
  }, (b) => {
    typeof b.now != "function" && console.warn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), b.on.inspectComponent((y, A) => {
      y.instanceData && y.instanceData.state.push({
        type: "Routing",
        key: "$route",
        editable: !1,
        value: Yi(u.currentRoute.value, "Current Route")
      });
    }), b.on.visitComponentTree(({ treeNode: y, componentInstance: A }) => {
      if (A.__vrv_devtools) {
        const k = A.__vrv_devtools;
        y.tags.push({
          label: (k.name ? `${k.name.toString()}: ` : "") + k.path,
          textColor: 0,
          tooltip: "This component is rendered by &lt;router-view&gt;",
          backgroundColor: Gw
        });
      }
      Lt(A.__vrl_devtools) && (A.__devtoolsApi = b, A.__vrl_devtools.forEach((k) => {
        let E = k.route.path, P = Jw, z = "", M = 0;
        k.error ? (E = k.error, P = $T, M = VT) : k.isExactActive ? (P = Zw, z = "This is exactly active") : k.isActive && (P = Kw, z = "This link is active"), y.tags.push({
          label: E,
          textColor: M,
          tooltip: z,
          backgroundColor: P
        });
      }));
    }), ui(u.currentRoute, () => {
      p(), b.notifyComponentUpdate(), b.sendInspectorTree(C), b.sendInspectorState(C);
    });
    const x = "router:navigations:" + w;
    b.addTimelineLayer({
      id: x,
      label: `Router${w ? " " + w : ""} Navigations`,
      color: 4237508
    }), u.onError((y, A) => {
      b.addTimelineEvent({
        layerId: x,
        event: {
          title: "Error during Navigation",
          subtitle: A.fullPath,
          logType: "error",
          time: b.now(),
          data: { error: y },
          groupId: A.meta.__navigationId
        }
      });
    });
    let v = 0;
    u.beforeEach((y, A) => {
      const k = {
        guard: Es("beforeEach"),
        from: Yi(A, "Current Location during this navigation"),
        to: Yi(y, "Target location")
      };
      Object.defineProperty(y.meta, "__navigationId", {
        value: v++
      }), b.addTimelineEvent({
        layerId: x,
        event: {
          time: b.now(),
          title: "Start of navigation",
          subtitle: y.fullPath,
          data: k,
          groupId: y.meta.__navigationId
        }
      });
    }), u.afterEach((y, A, k) => {
      const E = {
        guard: Es("afterEach")
      };
      k ? (E.failure = {
        _custom: {
          type: Error,
          readOnly: !0,
          display: k ? k.message : "",
          tooltip: "Navigation Failure",
          value: k
        }
      }, E.status = Es("❌")) : E.status = Es("✅"), E.from = Yi(A, "Current Location during this navigation"), E.to = Yi(y, "Target location"), b.addTimelineEvent({
        layerId: x,
        event: {
          title: "End of navigation",
          subtitle: y.fullPath,
          time: b.now(),
          data: E,
          logType: k ? "warning" : "default",
          groupId: y.meta.__navigationId
        }
      });
    });
    const C = "router-inspector:" + w;
    b.addInspector({
      id: C,
      label: "Routes" + (w ? " " + w : ""),
      icon: "book",
      treeFilterPlaceholder: "Search routes"
    });
    function p() {
      if (!D)
        return;
      const y = D;
      let A = g.getRoutes().filter((k) => !k.parent || // these routes have a parent with no component which will not appear in the view
      // therefore we still need to include them
      !k.parent.record.components);
      A.forEach(Xw), y.filter && (A = A.filter((k) => (
        // save matches state based on the payload
        Tc(k, y.filter.toLowerCase())
      ))), A.forEach((k) => Qw(k, u.currentRoute.value)), y.rootNodes = A.map(Yw);
    }
    let D;
    b.on.getInspectorTree((y) => {
      D = y, y.app === c && y.inspectorId === C && p();
    }), b.on.getInspectorState((y) => {
      if (y.app === c && y.inspectorId === C) {
        const k = g.getRoutes().find((E) => E.record.__vd_id === y.nodeId);
        k && (y.state = {
          options: MT(k)
        });
      }
    }), b.sendInspectorTree(C), b.sendInspectorState(C);
  });
}
function zT(c) {
  return c.optional ? c.repeatable ? "*" : "?" : c.repeatable ? "+" : "";
}
function MT(c) {
  const { record: u } = c, g = [
    { editable: !1, key: "path", value: u.path }
  ];
  return u.name != null && g.push({
    editable: !1,
    key: "name",
    value: u.name
  }), g.push({ editable: !1, key: "regexp", value: c.re }), c.keys.length && g.push({
    editable: !1,
    key: "keys",
    value: {
      _custom: {
        type: null,
        readOnly: !0,
        display: c.keys.map((w) => `${w.name}${zT(w)}`).join(" "),
        tooltip: "Param keys",
        value: c.keys
      }
    }
  }), u.redirect != null && g.push({
    editable: !1,
    key: "redirect",
    value: u.redirect
  }), c.alias.length && g.push({
    editable: !1,
    key: "aliases",
    value: c.alias.map((w) => w.record.path)
  }), Object.keys(c.record.meta).length && g.push({
    editable: !1,
    key: "meta",
    value: c.record.meta
  }), g.push({
    key: "score",
    editable: !1,
    value: {
      _custom: {
        type: null,
        readOnly: !0,
        display: c.score.map((w) => w.join(", ")).join(" | "),
        tooltip: "Score used to sort routes",
        value: c.score
      }
    }
  }), g;
}
const Gw = 15485081, Kw = 2450411, Zw = 8702998, NT = 2282478, Jw = 16486972, FT = 6710886, $T = 16704226, VT = 12131356;
function Yw(c) {
  const u = [], { record: g } = c;
  g.name != null && u.push({
    label: String(g.name),
    textColor: 0,
    backgroundColor: NT
  }), g.aliasOf && u.push({
    label: "alias",
    textColor: 0,
    backgroundColor: Jw
  }), c.__vd_match && u.push({
    label: "matches",
    textColor: 0,
    backgroundColor: Gw
  }), c.__vd_exactActive && u.push({
    label: "exact",
    textColor: 0,
    backgroundColor: Zw
  }), c.__vd_active && u.push({
    label: "active",
    textColor: 0,
    backgroundColor: Kw
  }), g.redirect && u.push({
    label: typeof g.redirect == "string" ? `redirect: ${g.redirect}` : "redirects",
    textColor: 16777215,
    backgroundColor: FT
  });
  let w = g.__vd_id;
  return w == null && (w = String(LT++), g.__vd_id = w), {
    id: w,
    label: g.path,
    tags: u,
    children: c.children.map(Yw)
  };
}
let LT = 0;
const jT = /^\/(.*)\/([a-z]*)$/;
function Qw(c, u) {
  const g = u.matched.length && Un(u.matched[u.matched.length - 1], c.record);
  c.__vd_exactActive = c.__vd_active = g, g || (c.__vd_active = u.matched.some((w) => Un(w, c.record))), c.children.forEach((w) => Qw(w, u));
}
function Xw(c) {
  c.__vd_match = !1, c.children.forEach(Xw);
}
function Tc(c, u) {
  const g = String(c.re).match(jT);
  if (c.__vd_match = !1, !g || g.length < 3)
    return !1;
  if (new RegExp(g[1].replace(/\$$/, ""), g[2]).test(u))
    return c.children.forEach((v) => Tc(v, u)), c.record.path !== "/" || u === "/" ? (c.__vd_match = c.re.test(u), !0) : !1;
  const b = c.record.path.toLowerCase(), x = li(b);
  return !u.startsWith("/") && (x.includes(u) || b.includes(u)) || x.startsWith(u) || b.startsWith(u) || c.record.name && String(c.record.name).includes(u) ? !0 : c.children.some((v) => Tc(v, u));
}
function HT(c, u) {
  const g = {};
  for (const w in c)
    u.includes(w) || (g[w] = c[w]);
  return g;
}
function UT(c) {
  const u = mT(c.routes, c), g = c.parseQuery || _T, w = c.stringifyQuery || Vk, b = c.history;
  if (process.env.NODE_ENV !== "production" && !b)
    throw new Error('Provide the "history" option when calling "createRouter()": https://next.router.vuejs.org/api/#history.');
  const x = Ji(), v = Ji(), C = Ji(), p = Xt($n);
  let D = $n;
  xn && c.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
  const y = mc.bind(null, (L) => "" + L), A = mc.bind(null, FB), k = (
    // @ts-expect-error: intentionally avoid the type check
    mc.bind(null, li)
  );
  function E(L, K) {
    let Y, te;
    return qw(L) ? (Y = u.getRecordMatcher(L), process.env.NODE_ENV !== "production" && !Y && fe(`Parent route "${String(L)}" not found when adding child route`, K), te = K) : te = L, u.addRoute(te, Y);
  }
  function P(L) {
    const K = u.getRecordMatcher(L);
    K ? u.removeRoute(K) : process.env.NODE_ENV !== "production" && fe(`Cannot remove non-existent route "${String(L)}"`);
  }
  function z() {
    return u.getRoutes().map((L) => L.record);
  }
  function M(L) {
    return !!u.getRecordMatcher(L);
  }
  function F(L, K) {
    if (K = Ie({}, K || p.value), typeof L == "string") {
      const ue = pc(g, L, K.path), re = u.resolve({ path: ue.path }, K), Kt = b.createHref(ue.fullPath);
      return process.env.NODE_ENV !== "production" && (Kt.startsWith("//") ? fe(`Location "${L}" resolved to "${Kt}". A resolved location cannot start with multiple slashes.`) : re.matched.length || fe(`No match found for location with path "${L}"`)), Ie(ue, re, {
        params: k(re.params),
        hash: li(ue.hash),
        redirectedFrom: void 0,
        href: Kt
      });
    }
    process.env.NODE_ENV !== "production" && !Ts(L) && (fe(`router.resolve() was passed an invalid location. This will fail in production.
- Location:`, L), L = {});
    let Y;
    if (L.path != null)
      process.env.NODE_ENV !== "production" && "params" in L && !("name" in L) && // @ts-expect-error: the type is never
      Object.keys(L.params).length && fe(`Path "${L.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`), Y = Ie({}, L, {
        path: pc(g, L.path, K.path).path
      });
    else {
      const ue = Ie({}, L.params);
      for (const re in ue)
        ue[re] == null && delete ue[re];
      Y = Ie({}, L, {
        params: A(ue)
      }), K.params = A(K.params);
    }
    const te = u.resolve(Y, K), ve = L.hash || "";
    process.env.NODE_ENV !== "production" && ve && !ve.startsWith("#") && fe(`A \`hash\` should always start with the character "#". Replace "${ve}" with "#${ve}".`), te.params = y(k(te.params));
    const Le = LB(w, Ie({}, L, {
      hash: zB(ve),
      path: te.path
    })), pe = b.createHref(Le);
    return process.env.NODE_ENV !== "production" && (pe.startsWith("//") ? fe(`Location "${L}" resolved to "${pe}". A resolved location cannot start with multiple slashes.`) : te.matched.length || fe(`No match found for location with path "${L.path != null ? L.path : L}"`)), Ie({
      fullPath: Le,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash: ve,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/router/issues/328#issuecomment-649481567
        w === Vk ? AT(L.query) : L.query || {}
      )
    }, te, {
      redirectedFrom: void 0,
      href: pe
    });
  }
  function V(L) {
    return typeof L == "string" ? pc(g, L, p.value.path) : Ie({}, L);
  }
  function j(L, K) {
    if (D !== L)
      return ci(8, {
        from: K,
        to: L
      });
  }
  function Z(L) {
    return X(L);
  }
  function ne(L) {
    return Z(Ie(V(L), { replace: !0 }));
  }
  function se(L) {
    const K = L.matched[L.matched.length - 1];
    if (K && K.redirect) {
      const { redirect: Y } = K;
      let te = typeof Y == "function" ? Y(L) : Y;
      if (typeof te == "string" && (te = te.includes("?") || te.includes("#") ? te = V(te) : (
        // force empty params
        { path: te }
      ), te.params = {}), process.env.NODE_ENV !== "production" && te.path == null && !("name" in te))
        throw fe(`Invalid redirect found:
${JSON.stringify(te, null, 2)}
 when navigating to "${L.fullPath}". A redirect must contain a name or path. This will break in production.`), new Error("Invalid redirect");
      return Ie({
        query: L.query,
        hash: L.hash,
        // avoid transferring params if the redirect has a path
        params: te.path != null ? {} : L.params
      }, te);
    }
  }
  function X(L, K) {
    const Y = D = F(L), te = p.value, ve = L.state, Le = L.force, pe = L.replace === !0, ue = se(Y);
    if (ue)
      return X(
        Ie(V(ue), {
          state: typeof ue == "object" ? Ie({}, ve, ue.state) : ve,
          force: Le,
          replace: pe
        }),
        // keep original redirectedFrom if it exists
        K || Y
      );
    const re = Y;
    re.redirectedFrom = K;
    let Kt;
    return !Le && Tk(w, te, Y) && (Kt = ci(16, { to: re, from: te }), pi(
      te,
      te,
      // this is a push, the only way for it to be triggered from a
      // history.listen is with a redirect, which makes it become a push
      !0,
      // This cannot be the first navigation because the initial location
      // cannot be manually navigated to
      !1
    )), (Kt ? Promise.resolve(Kt) : oe(re, te)).catch((ft) => En(ft) ? (
      // navigation redirects still mark the router as ready
      En(
        ft,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? ft : Se(ft)
    ) : (
      // reject any unknown error
      Rt(ft, re, te)
    )).then((ft) => {
      if (ft) {
        if (En(
          ft,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        ))
          return process.env.NODE_ENV !== "production" && // we are redirecting to the same location we were already at
          Tk(w, F(ft.to), re) && // and we have done it a couple of times
          K && // @ts-expect-error: added only in dev
          (K._count = K._count ? (
            // @ts-expect-error
            K._count + 1
          ) : 1) > 30 ? (fe(`Detected a possibly infinite redirection in a navigation guard when going from "${te.fullPath}" to "${re.fullPath}". Aborting to avoid a Stack Overflow.
 Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.`), Promise.reject(new Error("Infinite redirect in navigation guard"))) : X(
            // keep options
            Ie({
              // preserve an existing replacement but allow the redirect to override it
              replace: pe
            }, V(ft.to), {
              state: typeof ft.to == "object" ? Ie({}, ve, ft.to.state) : ve,
              force: Le
            }),
            // preserve the original redirectedFrom if any
            K || re
          );
      } else
        ft = Ke(re, te, !0, pe, ve);
      return He(re, te, ft), ft;
    });
  }
  function de(L, K) {
    const Y = j(L, K);
    return Y ? Promise.reject(Y) : Promise.resolve();
  }
  function O(L) {
    const K = Dn.values().next().value;
    return K && typeof K.runWithContext == "function" ? K.runWithContext(L) : L();
  }
  function oe(L, K) {
    let Y;
    const [te, ve, Le] = qT(L, K);
    Y = fc(te.reverse(), "beforeRouteLeave", L, K);
    for (const ue of te)
      ue.leaveGuards.forEach((re) => {
        Y.push(Vn(re, L, K));
      });
    const pe = de.bind(null, L, K);
    return Y.push(pe), gn(Y).then(() => {
      Y = [];
      for (const ue of x.list())
        Y.push(Vn(ue, L, K));
      return Y.push(pe), gn(Y);
    }).then(() => {
      Y = fc(ve, "beforeRouteUpdate", L, K);
      for (const ue of ve)
        ue.updateGuards.forEach((re) => {
          Y.push(Vn(re, L, K));
        });
      return Y.push(pe), gn(Y);
    }).then(() => {
      Y = [];
      for (const ue of Le)
        if (ue.beforeEnter)
          if (Lt(ue.beforeEnter))
            for (const re of ue.beforeEnter)
              Y.push(Vn(re, L, K));
          else
            Y.push(Vn(ue.beforeEnter, L, K));
      return Y.push(pe), gn(Y);
    }).then(() => (L.matched.forEach((ue) => ue.enterCallbacks = {}), Y = fc(Le, "beforeRouteEnter", L, K, O), Y.push(pe), gn(Y))).then(() => {
      Y = [];
      for (const ue of v.list())
        Y.push(Vn(ue, L, K));
      return Y.push(pe), gn(Y);
    }).catch((ue) => En(
      ue,
      8
      /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? ue : Promise.reject(ue));
  }
  function He(L, K, Y) {
    C.list().forEach((te) => O(() => te(L, K, Y)));
  }
  function Ke(L, K, Y, te, ve) {
    const Le = j(L, K);
    if (Le)
      return Le;
    const pe = K === $n, ue = xn ? history.state : {};
    Y && (te || pe ? b.replace(L.fullPath, Ie({
      scroll: pe && ue && ue.scroll
    }, ve)) : b.push(L.fullPath, ve)), p.value = L, pi(L, K, Y, pe), Se();
  }
  let ze;
  function nn() {
    ze || (ze = b.listen((L, K, Y) => {
      if (!fi.listening)
        return;
      const te = F(L), ve = se(te);
      if (ve) {
        X(Ie(ve, { replace: !0 }), te).catch(er);
        return;
      }
      D = te;
      const Le = p.value;
      xn && ZB(Pk(Le.fullPath, Y.delta), zs()), oe(te, Le).catch((pe) => En(
        pe,
        12
        /* ErrorTypes.NAVIGATION_CANCELLED */
      ) ? pe : En(
        pe,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? (X(
        pe.to,
        te
        // avoid an uncaught rejection, let push call triggerError
      ).then((ue) => {
        En(
          ue,
          20
          /* ErrorTypes.NAVIGATION_DUPLICATED */
        ) && !Y.delta && Y.type === sr.pop && b.go(-1, !1);
      }).catch(er), Promise.reject()) : (Y.delta && b.go(-Y.delta, !1), Rt(pe, te, Le))).then((pe) => {
        pe = pe || Ke(
          // after navigation, all matched components are resolved
          te,
          Le,
          !1
        ), pe && (Y.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
        // entry while a different route is displayed
        !En(
          pe,
          8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        ) ? b.go(-Y.delta, !1) : Y.type === sr.pop && En(
          pe,
          20
          /* ErrorTypes.NAVIGATION_DUPLICATED */
        ) && b.go(-1, !1)), He(te, Le, pe);
      }).catch(er);
    }));
  }
  let Et = Ji(), Ot = Ji(), Gt;
  function Rt(L, K, Y) {
    Se(L);
    const te = Ot.list();
    return te.length ? te.forEach((ve) => ve(L, K, Y)) : (process.env.NODE_ENV !== "production" && fe("uncaught error during route navigation:"), console.error(L)), Promise.reject(L);
  }
  function pr() {
    return Gt && p.value !== $n ? Promise.resolve() : new Promise((L, K) => {
      Et.add([L, K]);
    });
  }
  function Se(L) {
    return Gt || (Gt = !L, nn(), Et.list().forEach(([K, Y]) => L ? Y(L) : K()), Et.reset()), L;
  }
  function pi(L, K, Y, te) {
    const { scrollBehavior: ve } = c;
    if (!xn || !ve)
      return Promise.resolve();
    const Le = !Y && JB(Pk(L.fullPath, 0)) || (te || !Y) && history.state && history.state.scroll || null;
    return J5().then(() => ve(L, K, Le)).then((pe) => pe && KB(pe)).catch((pe) => Rt(pe, L, K));
  }
  const qn = (L) => b.go(L);
  let Eo;
  const Dn = /* @__PURE__ */ new Set(), fi = {
    currentRoute: p,
    listening: !0,
    addRoute: E,
    removeRoute: P,
    hasRoute: M,
    getRoutes: z,
    resolve: F,
    options: c,
    push: Z,
    replace: ne,
    go: qn,
    back: () => qn(-1),
    forward: () => qn(1),
    beforeEach: x.add,
    beforeResolve: v.add,
    afterEach: C.add,
    onError: Ot.add,
    isReady: pr,
    install(L) {
      const K = this;
      L.component("RouterLink", ST), L.component("RouterView", IT), L.config.globalProperties.$router = K, Object.defineProperty(L.config.globalProperties, "$route", {
        enumerable: !0,
        get: () => le(p)
      }), xn && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !Eo && p.value === $n && (Eo = !0, Z(b.location).catch((ve) => {
        process.env.NODE_ENV !== "production" && fe("Unexpected error when starting the router:", ve);
      }));
      const Y = {};
      for (const ve in $n)
        Object.defineProperty(Y, ve, {
          get: () => p.value[ve],
          enumerable: !0
        });
      L.provide(Vc, K), L.provide(Lc, Z5(Y)), L.provide(Bc, p);
      const te = L.unmount;
      Dn.add(L), L.unmount = function() {
        Dn.delete(L), Dn.size < 1 && (D = $n, ze && ze(), ze = null, p.value = $n, Eo = !1, Gt = !1), te();
      }, process.env.NODE_ENV !== "production" && xn && RT(L, K, u);
    }
  };
  function gn(L) {
    return L.reduce((K, Y) => K.then(() => O(Y)), Promise.resolve());
  }
  return fi;
}
function qT(c, u) {
  const g = [], w = [], b = [], x = Math.max(u.matched.length, c.matched.length);
  for (let v = 0; v < x; v++) {
    const C = u.matched[v];
    C && (c.matched.find((D) => Un(D, C)) ? w.push(C) : g.push(C));
    const p = c.matched[v];
    p && (u.matched.find((D) => Un(D, p)) || b.push(p));
  }
  return [g, w, b];
}
function e0() {
  return Be(Lc);
}
const jc = (c) => (dt("data-v-a68884ce"), c = c(), ut(), c), WT = { class: "viur-shop-item-card-card" }, GT = ["src", "alt"], KT = { class: "viur-shop-item-card-headline" }, ZT = /* @__PURE__ */ jc(() => /* @__PURE__ */ I("h4", { class: "viur-shop-item-card-subline" }, "B 21 x H 6,5 x T 19 cm", -1)), JT = { class: "viur-shop-item-card-price" }, YT = ["disabled"], QT = /* @__PURE__ */ jc(() => /* @__PURE__ */ I("sl-icon", {
  name: "bag-plus",
  slot: "prefix"
}, null, -1)), XT = /* @__PURE__ */ jc(() => /* @__PURE__ */ I("sl-button", {
  size: "small",
  outline: "",
  class: "viur-shop-item-card-add-to-favourites-btn",
  variant: "primary",
  title: "Add to favourites"
}, [
  /* @__PURE__ */ I("sl-icon", {
    name: "heart",
    slot: "prefix"
  })
], -1)), eI = ["open"], tI = {
  __name: "CrossSellingView",
  props: {
    cartKey: { type: String, default: "" },
    item: { type: Object, default: {} }
  },
  emits: ["cancel"],
  setup(c, { emit: u }) {
    const g = c, w = Wt(), b = me({
      images: {},
      currentItem: {},
      crossselling: !1,
      disabledAddToCart: !1
    }), x = ce(() => g.item);
    function v(p) {
      let D = "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80";
      return p.hk_artikel.dest.image ? he.downloadUrlFor(p.hk_artikel.dest.image) : D;
    }
    function C(p, D) {
      console.log("item", p), w.addToCart(p.key, D), b.addedToCart = !0, b.disabledAddToCart = !0;
    }
    return (p, D) => (H(), G("sl-card", WT, [
      I("img", {
        slot: "image",
        src: v(x.value),
        alt: x.value.shop_name,
        loading: "lazy",
        class: "viur-shop-item-card-image"
      }, null, 8, GT),
      I("h3", KT, ge(x.value.shop_name), 1),
      ZT,
      I("div", JT, ge(x.value.shop_price_retail) + " €", 1),
      I("sl-button", {
        size: "small",
        class: "viur-shop-item-card-add-to-cart-btn",
        variant: "primary",
        title: "Add to cart",
        onClick: D[0] || (D[0] = Hn((y) => C(x.value, le(w).state.basket), ["stop"])),
        disabled: b.disabledAddToCart
      }, [
        QT,
        ie(" In den Warenkorb ")
      ], 8, YT),
      XT,
      I("sl-dialog", {
        open: b.addedToCart,
        onSlHide: D[1] || (D[1] = (y) => b.addedToCart = !1)
      }, [
        I("div", null, " Der Artikel " + ge(x.value.shop_name) + " wurde zum Warencorb hinzugefügt ", 1)
      ], 40, eI)
    ]));
  }
}, nI = /* @__PURE__ */ Ae(tI, [["__scopeId", "data-v-a68884ce"]]), hr = (c) => (dt("data-v-050a42bb"), c = c(), ut(), c), oI = /* @__PURE__ */ hr(() => /* @__PURE__ */ I("div", {
  class: "viur-shop-crossselling-header",
  slot: "header"
}, null, -1)), iI = { class: "viur-shop-crossselling-cart-item" }, rI = /* @__PURE__ */ hr(() => /* @__PURE__ */ I("h2", { class: "headline" }, "Folgender Artikel wurde in den Warenkorb gelegt", -1)), sI = /* @__PURE__ */ hr(() => /* @__PURE__ */ I("br", null, null, -1)), aI = {
  class: "viur-shop-cart-card",
  horizontal: ""
}, lI = ["src", "alt"], cI = { class: "viur-shop-cart-card-body-info" }, dI = { class: "viur-shop-cart-card-headline headline" }, uI = { class: "viur-shop-cart-card-descr" }, hI = /* @__PURE__ */ hr(() => /* @__PURE__ */ I("br", null, null, -1)), gI = { class: "viur-shop-cart-card-price" }, mI = /* @__PURE__ */ hr(() => /* @__PURE__ */ I("br", null, null, -1)), pI = {
  navigation: "",
  "slides-per-page": "4"
}, fI = {
  __name: "CrossSellingList",
  props: {
    mode: { type: String, default: "basket" },
    cartKey: { type: String, default: "" },
    sidebar: { type: Boolean, default: !0 },
    item: { type: Object, default: {} },
    crossSellingItems: { type: Array, default: [] }
  },
  emits: ["cancel"],
  setup(c, { emit: u }) {
    const g = c, w = Wt(), b = Rs();
    me({
      images: {},
      currentItem: {},
      crossselling: !1
    }), ce(() => g.crossSellingItems);
    function x(v) {
      let C = "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80";
      return v.hk_artikel.dest.image ? he.downloadUrlFor(v.hk_artikel.dest.image) : C;
    }
    return (v, C) => (H(), G(Ve, null, [
      oI,
      I("div", iI, [
        rI,
        sI,
        I("sl-card", aI, [
          I("img", {
            slot: "image",
            src: x(c.item),
            alt: c.item.shop_name,
            loading: "lazy",
            class: "viur-shop-cart-card-img"
          }, null, 8, lI),
          I("div", cI, [
            I("h3", dI, ge(c.item.shop_name), 1),
            I("div", uI, [
              ie(ge(c.item.key), 1),
              hI,
              ie(" B 21 x H 6,5 x T 19 cm ")
            ]),
            I("div", gI, ge(c.item.shop_price_retail) + " € ", 1)
          ])
        ])
      ]),
      mI,
      I("sl-carousel", pI, [
        (H(!0), G(Ve, null, kt(le(b).state.crossSellingItems, (p) => (H(), G("sl-carousel-item", null, [
          ai(nI, {
            cartkey: le(w).state.basket,
            item: p,
            onCancel: v.closeDialog
          }, null, 8, ["cartkey", "item", "onCancel"])
        ]))), 256))
      ])
    ], 64));
  }
}, t0 = /* @__PURE__ */ Ae(fI, [["__scopeId", "data-v-050a42bb"]]), Hc = (c) => (dt("data-v-40933df0"), c = c(), ut(), c), bI = { class: "viur-shop-item-card-card" }, kI = ["src", "alt"], wI = { class: "viur-shop-item-card-headline" }, vI = /* @__PURE__ */ Hc(() => /* @__PURE__ */ I("h4", { class: "viur-shop-item-card-subline" }, "B 21 x H 6,5 x T 19 cm", -1)), _I = { class: "viur-shop-item-card-price" }, AI = {
  class: "viur-shop-item-card-footer",
  slot: "footer"
}, CI = /* @__PURE__ */ Hc(() => /* @__PURE__ */ I("sl-icon", {
  name: "bag-plus",
  slot: "prefix"
}, null, -1)), yI = /* @__PURE__ */ Hc(() => /* @__PURE__ */ I("sl-button", {
  size: "small",
  outline: "",
  class: "viur-shop-item-card-add-to-favourites-btn",
  variant: "primary",
  title: "Add to favourites"
}, [
  /* @__PURE__ */ I("sl-icon", {
    name: "heart",
    slot: "prefix"
  })
], -1)), EI = ["open"], xI = {
  __name: "ItemCard",
  props: {
    item: {
      type: Object,
      required: !0
    },
    hasCrossSelling: { type: Boolean, required: !0, default: !1 },
    crossSellingFunction: {
      type: Function,
      default: () => {
      }
    }
  },
  setup(c) {
    const u = c, g = Wt(), w = Rs(), b = me({
      upselling: !1,
      crossSelling: !1,
      params: {}
    });
    function x(D) {
      let y = "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80";
      return D.hk_artikel.dest.image ? he.downloadUrlFor(D.hk_artikel.dest.image) : y;
    }
    function v(D, y) {
      g.addToCart(D.key, y), u.hasCrossSelling && (b.params = u.crossSellingFunction(u.item), w.getCrossSellingItems(b.params.url, b.params.keys), b.crossSelling = !0);
    }
    const C = () => {
      b.crossSelling = !1;
    }, p = () => {
      b.crossSelling = !1;
    };
    return (D, y) => (H(), G(Ve, null, [
      I("sl-card", bI, [
        I("img", {
          slot: "image",
          src: x(c.item),
          alt: c.item.shop_name,
          loading: "lazy",
          class: "viur-shop-item-card-image"
        }, null, 8, kI),
        ie(" " + ge(c.item.key) + " ", 1),
        I("h3", wI, ge(c.item.shop_name), 1),
        vI,
        I("div", _I, ge(c.item.shop_price_retail) + " €", 1),
        I("div", AI, [
          I("sl-button", {
            size: "small",
            class: "viur-shop-item-card-add-to-cart-btn",
            variant: "primary",
            title: "Add to cart",
            onClick: y[0] || (y[0] = Hn((A) => v(c.item, le(g).state.basket), ["stop"]))
          }, [
            CI,
            ie(" In den Warenkorb ")
          ]),
          yI
        ])
      ]),
      I("sl-dialog", {
        class: "crossselling-dialog",
        open: b.crossSelling,
        onSlHide: C
      }, [
        ai(t0, {
          item: c.item,
          crossSellingItems: le(w).state.crossSellingItems,
          onCancel: p
        }, null, 8, ["item", "crossSellingItems"])
      ], 40, EI)
    ], 64));
  }
}, n0 = /* @__PURE__ */ Ae(xI, [["__scopeId", "data-v-40933df0"]]);
function Wk(c, u, g) {
  const w = (b) => Object.is(b, -0) ? 0 : b;
  return c < u ? w(u) : c > g ? w(g) : w(c);
}
var SI = class {
  constructor(c, u) {
    this.timerId = 0, this.activeInteractions = 0, this.paused = !1, this.stopped = !0, this.pause = () => {
      this.activeInteractions++ || (this.paused = !0, this.host.requestUpdate());
    }, this.resume = () => {
      --this.activeInteractions || (this.paused = !1, this.host.requestUpdate());
    }, c.addController(this), this.host = c, this.tickCallback = u;
  }
  hostConnected() {
    this.host.addEventListener("mouseenter", this.pause), this.host.addEventListener("mouseleave", this.resume), this.host.addEventListener("focusin", this.pause), this.host.addEventListener("focusout", this.resume), this.host.addEventListener("touchstart", this.pause, { passive: !0 }), this.host.addEventListener("touchend", this.resume);
  }
  hostDisconnected() {
    this.stop(), this.host.removeEventListener("mouseenter", this.pause), this.host.removeEventListener("mouseleave", this.resume), this.host.removeEventListener("focusin", this.pause), this.host.removeEventListener("focusout", this.resume), this.host.removeEventListener("touchstart", this.pause), this.host.removeEventListener("touchend", this.resume);
  }
  start(c) {
    this.stop(), this.stopped = !1, this.timerId = window.setInterval(() => {
      this.paused || this.tickCallback();
    }, c);
  }
  stop() {
    clearInterval(this.timerId), this.stopped = !0, this.host.requestUpdate();
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Bs = globalThis, Uc = Bs.ShadowRoot && (Bs.ShadyCSS === void 0 || Bs.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, qc = Symbol(), Gk = /* @__PURE__ */ new WeakMap();
let o0 = class {
  constructor(u, g, w) {
    if (this._$cssResult$ = !0, w !== qc)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = u, this.t = g;
  }
  get styleSheet() {
    let u = this.o;
    const g = this.t;
    if (Uc && u === void 0) {
      const w = g !== void 0 && g.length === 1;
      w && (u = Gk.get(g)), u === void 0 && ((this.o = u = new CSSStyleSheet()).replaceSync(this.cssText), w && Gk.set(g, u));
    }
    return u;
  }
  toString() {
    return this.cssText;
  }
};
const DI = (c) => new o0(typeof c == "string" ? c : c + "", void 0, qc), Wc = (c, ...u) => {
  const g = c.length === 1 ? c[0] : u.reduce((w, b, x) => w + ((v) => {
    if (v._$cssResult$ === !0)
      return v.cssText;
    if (typeof v == "number")
      return v;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + v + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(b) + c[x + 1], c[0]);
  return new o0(g, c, qc);
}, BI = (c, u) => {
  if (Uc)
    c.adoptedStyleSheets = u.map((g) => g instanceof CSSStyleSheet ? g : g.styleSheet);
  else
    for (const g of u) {
      const w = document.createElement("style"), b = Bs.litNonce;
      b !== void 0 && w.setAttribute("nonce", b), w.textContent = g.cssText, c.appendChild(w);
    }
}, Kk = Uc ? (c) => c : (c) => c instanceof CSSStyleSheet ? ((u) => {
  let g = "";
  for (const w of u.cssRules)
    g += w.cssText;
  return DI(g);
})(c) : c;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: TI, defineProperty: II, getOwnPropertyDescriptor: PI, getOwnPropertyNames: OI, getOwnPropertySymbols: RI, getPrototypeOf: zI } = Object, jn = globalThis, Zk = jn.trustedTypes, MI = Zk ? Zk.emptyScript : "", bc = jn.reactiveElementPolyfillSupport, nr = (c, u) => c, Is = { toAttribute(c, u) {
  switch (u) {
    case Boolean:
      c = c ? MI : null;
      break;
    case Object:
    case Array:
      c = c == null ? c : JSON.stringify(c);
  }
  return c;
}, fromAttribute(c, u) {
  let g = c;
  switch (u) {
    case Boolean:
      g = c !== null;
      break;
    case Number:
      g = c === null ? null : Number(c);
      break;
    case Object:
    case Array:
      try {
        g = JSON.parse(c);
      } catch {
        g = null;
      }
  }
  return g;
} }, Gc = (c, u) => !TI(c, u), Jk = { attribute: !0, type: String, converter: Is, reflect: !1, hasChanged: Gc };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), jn.litPropertyMetadata ?? (jn.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class ri extends HTMLElement {
  static addInitializer(u) {
    this._$Ei(), (this.l ?? (this.l = [])).push(u);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(u, g = Jk) {
    if (g.state && (g.attribute = !1), this._$Ei(), this.elementProperties.set(u, g), !g.noAccessor) {
      const w = Symbol(), b = this.getPropertyDescriptor(u, w, g);
      b !== void 0 && II(this.prototype, u, b);
    }
  }
  static getPropertyDescriptor(u, g, w) {
    const { get: b, set: x } = PI(this.prototype, u) ?? { get() {
      return this[g];
    }, set(v) {
      this[g] = v;
    } };
    return { get() {
      return b == null ? void 0 : b.call(this);
    }, set(v) {
      const C = b == null ? void 0 : b.call(this);
      x.call(this, v), this.requestUpdate(u, C, w);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(u) {
    return this.elementProperties.get(u) ?? Jk;
  }
  static _$Ei() {
    if (this.hasOwnProperty(nr("elementProperties")))
      return;
    const u = zI(this);
    u.finalize(), u.l !== void 0 && (this.l = [...u.l]), this.elementProperties = new Map(u.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(nr("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(nr("properties"))) {
      const g = this.properties, w = [...OI(g), ...RI(g)];
      for (const b of w)
        this.createProperty(b, g[b]);
    }
    const u = this[Symbol.metadata];
    if (u !== null) {
      const g = litPropertyMetadata.get(u);
      if (g !== void 0)
        for (const [w, b] of g)
          this.elementProperties.set(w, b);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [g, w] of this.elementProperties) {
      const b = this._$Eu(g, w);
      b !== void 0 && this._$Eh.set(b, g);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(u) {
    const g = [];
    if (Array.isArray(u)) {
      const w = new Set(u.flat(1 / 0).reverse());
      for (const b of w)
        g.unshift(Kk(b));
    } else
      u !== void 0 && g.push(Kk(u));
    return g;
  }
  static _$Eu(u, g) {
    const w = g.attribute;
    return w === !1 ? void 0 : typeof w == "string" ? w : typeof u == "string" ? u.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var u;
    this._$ES = new Promise((g) => this.enableUpdating = g), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (u = this.constructor.l) == null || u.forEach((g) => g(this));
  }
  addController(u) {
    var g;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(u), this.renderRoot !== void 0 && this.isConnected && ((g = u.hostConnected) == null || g.call(u));
  }
  removeController(u) {
    var g;
    (g = this._$EO) == null || g.delete(u);
  }
  _$E_() {
    const u = /* @__PURE__ */ new Map(), g = this.constructor.elementProperties;
    for (const w of g.keys())
      this.hasOwnProperty(w) && (u.set(w, this[w]), delete this[w]);
    u.size > 0 && (this._$Ep = u);
  }
  createRenderRoot() {
    const u = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return BI(u, this.constructor.elementStyles), u;
  }
  connectedCallback() {
    var u;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (u = this._$EO) == null || u.forEach((g) => {
      var w;
      return (w = g.hostConnected) == null ? void 0 : w.call(g);
    });
  }
  enableUpdating(u) {
  }
  disconnectedCallback() {
    var u;
    (u = this._$EO) == null || u.forEach((g) => {
      var w;
      return (w = g.hostDisconnected) == null ? void 0 : w.call(g);
    });
  }
  attributeChangedCallback(u, g, w) {
    this._$AK(u, w);
  }
  _$EC(u, g) {
    var x;
    const w = this.constructor.elementProperties.get(u), b = this.constructor._$Eu(u, w);
    if (b !== void 0 && w.reflect === !0) {
      const v = (((x = w.converter) == null ? void 0 : x.toAttribute) !== void 0 ? w.converter : Is).toAttribute(g, w.type);
      this._$Em = u, v == null ? this.removeAttribute(b) : this.setAttribute(b, v), this._$Em = null;
    }
  }
  _$AK(u, g) {
    var x;
    const w = this.constructor, b = w._$Eh.get(u);
    if (b !== void 0 && this._$Em !== b) {
      const v = w.getPropertyOptions(b), C = typeof v.converter == "function" ? { fromAttribute: v.converter } : ((x = v.converter) == null ? void 0 : x.fromAttribute) !== void 0 ? v.converter : Is;
      this._$Em = b, this[b] = C.fromAttribute(g, v.type), this._$Em = null;
    }
  }
  requestUpdate(u, g, w) {
    if (u !== void 0) {
      if (w ?? (w = this.constructor.getPropertyOptions(u)), !(w.hasChanged ?? Gc)(this[u], g))
        return;
      this.P(u, g, w);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(u, g, w) {
    this._$AL.has(u) || this._$AL.set(u, g), w.reflect === !0 && this._$Em !== u && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(u);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (g) {
      Promise.reject(g);
    }
    const u = this.scheduleUpdate();
    return u != null && await u, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var w;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [x, v] of this._$Ep)
          this[x] = v;
        this._$Ep = void 0;
      }
      const b = this.constructor.elementProperties;
      if (b.size > 0)
        for (const [x, v] of b)
          v.wrapped !== !0 || this._$AL.has(x) || this[x] === void 0 || this.P(x, this[x], v);
    }
    let u = !1;
    const g = this._$AL;
    try {
      u = this.shouldUpdate(g), u ? (this.willUpdate(g), (w = this._$EO) == null || w.forEach((b) => {
        var x;
        return (x = b.hostUpdate) == null ? void 0 : x.call(b);
      }), this.update(g)) : this._$EU();
    } catch (b) {
      throw u = !1, this._$EU(), b;
    }
    u && this._$AE(g);
  }
  willUpdate(u) {
  }
  _$AE(u) {
    var g;
    (g = this._$EO) == null || g.forEach((w) => {
      var b;
      return (b = w.hostUpdated) == null ? void 0 : b.call(w);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(u)), this.updated(u);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(u) {
    return !0;
  }
  update(u) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((g) => this._$EC(g, this[g]))), this._$EU();
  }
  updated(u) {
  }
  firstUpdated(u) {
  }
}
ri.elementStyles = [], ri.shadowRootOptions = { mode: "open" }, ri[nr("elementProperties")] = /* @__PURE__ */ new Map(), ri[nr("finalized")] = /* @__PURE__ */ new Map(), bc == null || bc({ ReactiveElement: ri }), (jn.reactiveElementVersions ?? (jn.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const or = globalThis, Ps = or.trustedTypes, Yk = Ps ? Ps.createPolicy("lit-html", { createHTML: (c) => c }) : void 0, i0 = "$lit$", Ln = `lit$${Math.random().toFixed(9).slice(2)}$`, r0 = "?" + Ln, NI = `<${r0}>`, _o = document, ar = () => _o.createComment(""), lr = (c) => c === null || typeof c != "object" && typeof c != "function", s0 = Array.isArray, FI = (c) => s0(c) || typeof (c == null ? void 0 : c[Symbol.iterator]) == "function", kc = `[ 	
\f\r]`, Qi = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Qk = /-->/g, Xk = />/g, ko = RegExp(`>|${kc}(?:([^\\s"'>=/]+)(${kc}*=${kc}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), ew = /'/g, tw = /"/g, a0 = /^(?:script|style|textarea|title)$/i, $I = (c) => (u, ...g) => ({ _$litType$: c, strings: u, values: g }), Sn = $I(1), Ao = Symbol.for("lit-noChange"), mt = Symbol.for("lit-nothing"), nw = /* @__PURE__ */ new WeakMap(), vo = _o.createTreeWalker(_o, 129);
function l0(c, u) {
  if (!Array.isArray(c) || !c.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return Yk !== void 0 ? Yk.createHTML(u) : u;
}
const VI = (c, u) => {
  const g = c.length - 1, w = [];
  let b, x = u === 2 ? "<svg>" : "", v = Qi;
  for (let C = 0; C < g; C++) {
    const p = c[C];
    let D, y, A = -1, k = 0;
    for (; k < p.length && (v.lastIndex = k, y = v.exec(p), y !== null); )
      k = v.lastIndex, v === Qi ? y[1] === "!--" ? v = Qk : y[1] !== void 0 ? v = Xk : y[2] !== void 0 ? (a0.test(y[2]) && (b = RegExp("</" + y[2], "g")), v = ko) : y[3] !== void 0 && (v = ko) : v === ko ? y[0] === ">" ? (v = b ?? Qi, A = -1) : y[1] === void 0 ? A = -2 : (A = v.lastIndex - y[2].length, D = y[1], v = y[3] === void 0 ? ko : y[3] === '"' ? tw : ew) : v === tw || v === ew ? v = ko : v === Qk || v === Xk ? v = Qi : (v = ko, b = void 0);
    const E = v === ko && c[C + 1].startsWith("/>") ? " " : "";
    x += v === Qi ? p + NI : A >= 0 ? (w.push(D), p.slice(0, A) + i0 + p.slice(A) + Ln + E) : p + Ln + (A === -2 ? C : E);
  }
  return [l0(c, x + (c[g] || "<?>") + (u === 2 ? "</svg>" : "")), w];
};
class cr {
  constructor({ strings: u, _$litType$: g }, w) {
    let b;
    this.parts = [];
    let x = 0, v = 0;
    const C = u.length - 1, p = this.parts, [D, y] = VI(u, g);
    if (this.el = cr.createElement(D, w), vo.currentNode = this.el.content, g === 2) {
      const A = this.el.content.firstChild;
      A.replaceWith(...A.childNodes);
    }
    for (; (b = vo.nextNode()) !== null && p.length < C; ) {
      if (b.nodeType === 1) {
        if (b.hasAttributes())
          for (const A of b.getAttributeNames())
            if (A.endsWith(i0)) {
              const k = y[v++], E = b.getAttribute(A).split(Ln), P = /([.?@])?(.*)/.exec(k);
              p.push({ type: 1, index: x, name: P[2], strings: E, ctor: P[1] === "." ? jI : P[1] === "?" ? HI : P[1] === "@" ? UI : Ms }), b.removeAttribute(A);
            } else
              A.startsWith(Ln) && (p.push({ type: 6, index: x }), b.removeAttribute(A));
        if (a0.test(b.tagName)) {
          const A = b.textContent.split(Ln), k = A.length - 1;
          if (k > 0) {
            b.textContent = Ps ? Ps.emptyScript : "";
            for (let E = 0; E < k; E++)
              b.append(A[E], ar()), vo.nextNode(), p.push({ type: 2, index: ++x });
            b.append(A[k], ar());
          }
        }
      } else if (b.nodeType === 8)
        if (b.data === r0)
          p.push({ type: 2, index: x });
        else {
          let A = -1;
          for (; (A = b.data.indexOf(Ln, A + 1)) !== -1; )
            p.push({ type: 7, index: x }), A += Ln.length - 1;
        }
      x++;
    }
  }
  static createElement(u, g) {
    const w = _o.createElement("template");
    return w.innerHTML = u, w;
  }
}
function di(c, u, g = c, w) {
  var v, C;
  if (u === Ao)
    return u;
  let b = w !== void 0 ? (v = g._$Co) == null ? void 0 : v[w] : g._$Cl;
  const x = lr(u) ? void 0 : u._$litDirective$;
  return (b == null ? void 0 : b.constructor) !== x && ((C = b == null ? void 0 : b._$AO) == null || C.call(b, !1), x === void 0 ? b = void 0 : (b = new x(c), b._$AT(c, g, w)), w !== void 0 ? (g._$Co ?? (g._$Co = []))[w] = b : g._$Cl = b), b !== void 0 && (u = di(c, b._$AS(c, u.values), b, w)), u;
}
class LI {
  constructor(u, g) {
    this._$AV = [], this._$AN = void 0, this._$AD = u, this._$AM = g;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(u) {
    const { el: { content: g }, parts: w } = this._$AD, b = ((u == null ? void 0 : u.creationScope) ?? _o).importNode(g, !0);
    vo.currentNode = b;
    let x = vo.nextNode(), v = 0, C = 0, p = w[0];
    for (; p !== void 0; ) {
      if (v === p.index) {
        let D;
        p.type === 2 ? D = new gr(x, x.nextSibling, this, u) : p.type === 1 ? D = new p.ctor(x, p.name, p.strings, this, u) : p.type === 6 && (D = new qI(x, this, u)), this._$AV.push(D), p = w[++C];
      }
      v !== (p == null ? void 0 : p.index) && (x = vo.nextNode(), v++);
    }
    return vo.currentNode = _o, b;
  }
  p(u) {
    let g = 0;
    for (const w of this._$AV)
      w !== void 0 && (w.strings !== void 0 ? (w._$AI(u, w, g), g += w.strings.length - 2) : w._$AI(u[g])), g++;
  }
}
class gr {
  get _$AU() {
    var u;
    return ((u = this._$AM) == null ? void 0 : u._$AU) ?? this._$Cv;
  }
  constructor(u, g, w, b) {
    this.type = 2, this._$AH = mt, this._$AN = void 0, this._$AA = u, this._$AB = g, this._$AM = w, this.options = b, this._$Cv = (b == null ? void 0 : b.isConnected) ?? !0;
  }
  get parentNode() {
    let u = this._$AA.parentNode;
    const g = this._$AM;
    return g !== void 0 && (u == null ? void 0 : u.nodeType) === 11 && (u = g.parentNode), u;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(u, g = this) {
    u = di(this, u, g), lr(u) ? u === mt || u == null || u === "" ? (this._$AH !== mt && this._$AR(), this._$AH = mt) : u !== this._$AH && u !== Ao && this._(u) : u._$litType$ !== void 0 ? this.$(u) : u.nodeType !== void 0 ? this.T(u) : FI(u) ? this.k(u) : this._(u);
  }
  S(u) {
    return this._$AA.parentNode.insertBefore(u, this._$AB);
  }
  T(u) {
    this._$AH !== u && (this._$AR(), this._$AH = this.S(u));
  }
  _(u) {
    this._$AH !== mt && lr(this._$AH) ? this._$AA.nextSibling.data = u : this.T(_o.createTextNode(u)), this._$AH = u;
  }
  $(u) {
    var x;
    const { values: g, _$litType$: w } = u, b = typeof w == "number" ? this._$AC(u) : (w.el === void 0 && (w.el = cr.createElement(l0(w.h, w.h[0]), this.options)), w);
    if (((x = this._$AH) == null ? void 0 : x._$AD) === b)
      this._$AH.p(g);
    else {
      const v = new LI(b, this), C = v.u(this.options);
      v.p(g), this.T(C), this._$AH = v;
    }
  }
  _$AC(u) {
    let g = nw.get(u.strings);
    return g === void 0 && nw.set(u.strings, g = new cr(u)), g;
  }
  k(u) {
    s0(this._$AH) || (this._$AH = [], this._$AR());
    const g = this._$AH;
    let w, b = 0;
    for (const x of u)
      b === g.length ? g.push(w = new gr(this.S(ar()), this.S(ar()), this, this.options)) : w = g[b], w._$AI(x), b++;
    b < g.length && (this._$AR(w && w._$AB.nextSibling, b), g.length = b);
  }
  _$AR(u = this._$AA.nextSibling, g) {
    var w;
    for ((w = this._$AP) == null ? void 0 : w.call(this, !1, !0, g); u && u !== this._$AB; ) {
      const b = u.nextSibling;
      u.remove(), u = b;
    }
  }
  setConnected(u) {
    var g;
    this._$AM === void 0 && (this._$Cv = u, (g = this._$AP) == null || g.call(this, u));
  }
}
class Ms {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(u, g, w, b, x) {
    this.type = 1, this._$AH = mt, this._$AN = void 0, this.element = u, this.name = g, this._$AM = b, this.options = x, w.length > 2 || w[0] !== "" || w[1] !== "" ? (this._$AH = Array(w.length - 1).fill(new String()), this.strings = w) : this._$AH = mt;
  }
  _$AI(u, g = this, w, b) {
    const x = this.strings;
    let v = !1;
    if (x === void 0)
      u = di(this, u, g, 0), v = !lr(u) || u !== this._$AH && u !== Ao, v && (this._$AH = u);
    else {
      const C = u;
      let p, D;
      for (u = x[0], p = 0; p < x.length - 1; p++)
        D = di(this, C[w + p], g, p), D === Ao && (D = this._$AH[p]), v || (v = !lr(D) || D !== this._$AH[p]), D === mt ? u = mt : u !== mt && (u += (D ?? "") + x[p + 1]), this._$AH[p] = D;
    }
    v && !b && this.j(u);
  }
  j(u) {
    u === mt ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, u ?? "");
  }
}
class jI extends Ms {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(u) {
    this.element[this.name] = u === mt ? void 0 : u;
  }
}
class HI extends Ms {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(u) {
    this.element.toggleAttribute(this.name, !!u && u !== mt);
  }
}
class UI extends Ms {
  constructor(u, g, w, b, x) {
    super(u, g, w, b, x), this.type = 5;
  }
  _$AI(u, g = this) {
    if ((u = di(this, u, g, 0) ?? mt) === Ao)
      return;
    const w = this._$AH, b = u === mt && w !== mt || u.capture !== w.capture || u.once !== w.once || u.passive !== w.passive, x = u !== mt && (w === mt || b);
    b && this.element.removeEventListener(this.name, this, w), x && this.element.addEventListener(this.name, this, u), this._$AH = u;
  }
  handleEvent(u) {
    var g;
    typeof this._$AH == "function" ? this._$AH.call(((g = this.options) == null ? void 0 : g.host) ?? this.element, u) : this._$AH.handleEvent(u);
  }
}
class qI {
  constructor(u, g, w) {
    this.element = u, this.type = 6, this._$AN = void 0, this._$AM = g, this.options = w;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(u) {
    di(this, u);
  }
}
const wc = or.litHtmlPolyfillSupport;
wc == null || wc(cr, gr), (or.litHtmlVersions ?? (or.litHtmlVersions = [])).push("3.1.3");
const WI = (c, u, g) => {
  const w = (g == null ? void 0 : g.renderBefore) ?? u;
  let b = w._$litPart$;
  if (b === void 0) {
    const x = (g == null ? void 0 : g.renderBefore) ?? null;
    w._$litPart$ = b = new gr(u.insertBefore(ar(), x), x, void 0, g ?? {});
  }
  return b._$AI(c), b;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class ir extends ri {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var g;
    const u = super.createRenderRoot();
    return (g = this.renderOptions).renderBefore ?? (g.renderBefore = u.firstChild), u;
  }
  update(u) {
    const g = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(u), this._$Do = WI(g, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var u;
    super.connectedCallback(), (u = this._$Do) == null || u.setConnected(!0);
  }
  disconnectedCallback() {
    var u;
    super.disconnectedCallback(), (u = this._$Do) == null || u.setConnected(!1);
  }
  render() {
    return Ao;
  }
}
var Bw;
ir._$litElement$ = !0, ir.finalized = !0, (Bw = globalThis.litElementHydrateSupport) == null || Bw.call(globalThis, { LitElement: ir });
const vc = globalThis.litElementPolyfillSupport;
vc == null || vc({ LitElement: ir });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.5");
var GI = Wc`
  :host {
    --slide-gap: var(--sl-spacing-medium, 1rem);
    --aspect-ratio: 16 / 9;
    --scroll-hint: 0px;

    display: flex;
  }

  .carousel {
    display: grid;
    grid-template-columns: min-content 1fr min-content;
    grid-template-rows: 1fr min-content;
    grid-template-areas:
      '. slides .'
      '. pagination .';
    gap: var(--sl-spacing-medium);
    align-items: center;
    min-height: 100%;
    min-width: 100%;
    position: relative;
  }

  .carousel__pagination {
    grid-area: pagination;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--sl-spacing-small);
  }

  .carousel__slides {
    grid-area: slides;

    display: grid;
    height: 100%;
    width: 100%;
    align-items: center;
    justify-items: center;
    overflow: auto;
    overscroll-behavior-x: contain;
    scrollbar-width: none;
    aspect-ratio: calc(var(--aspect-ratio) * var(--slides-per-page));
    border-radius: var(--sl-border-radius-small);

    --slide-size: calc((100% - (var(--slides-per-page) - 1) * var(--slide-gap)) / var(--slides-per-page));
  }

  @media (prefers-reduced-motion) {
    :where(.carousel__slides) {
      scroll-behavior: auto;
    }
  }

  .carousel__slides--horizontal {
    grid-auto-flow: column;
    grid-auto-columns: var(--slide-size);
    grid-auto-rows: 100%;
    column-gap: var(--slide-gap);
    scroll-snap-type: x mandatory;
    scroll-padding-inline: var(--scroll-hint);
    padding-inline: var(--scroll-hint);
    overflow-y: hidden;
  }

  .carousel__slides--vertical {
    grid-auto-flow: row;
    grid-auto-columns: 100%;
    grid-auto-rows: var(--slide-size);
    row-gap: var(--slide-gap);
    scroll-snap-type: y mandatory;
    scroll-padding-block: var(--scroll-hint);
    padding-block: var(--scroll-hint);
    overflow-x: hidden;
  }

  .carousel__slides--dragging {
  }

  :host([vertical]) ::slotted(sl-carousel-item) {
    height: 100%;
  }

  .carousel__slides::-webkit-scrollbar {
    display: none;
  }

  .carousel__navigation {
    grid-area: navigation;
    display: contents;
    font-size: var(--sl-font-size-x-large);
  }

  .carousel__navigation-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-small);
    font-size: inherit;
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-medium) color;
    appearance: none;
  }

  .carousel__navigation-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .carousel__navigation-button--disabled::part(base) {
    pointer-events: none;
  }

  .carousel__navigation-button--previous {
    grid-column: 1;
    grid-row: 1;
  }

  .carousel__navigation-button--next {
    grid-column: 3;
    grid-row: 1;
  }

  .carousel__pagination-item {
    display: block;
    cursor: pointer;
    background: none;
    border: 0;
    border-radius: var(--sl-border-radius-circle);
    width: var(--sl-spacing-small);
    height: var(--sl-spacing-small);
    background-color: var(--sl-color-neutral-300);
    padding: 0;
    margin: 0;
  }

  .carousel__pagination-item--active {
    background-color: var(--sl-color-neutral-700);
    transform: scale(1.2);
  }

  /* Focus styles */
  .carousel__slides:focus-visible,
  .carousel__navigation-button:focus-visible,
  .carousel__pagination-item:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`, c0 = Object.defineProperty, KI = Object.getOwnPropertyDescriptor, ow = Object.getOwnPropertySymbols, ZI = Object.prototype.hasOwnProperty, JI = Object.prototype.propertyIsEnumerable, iw = (c, u, g) => u in c ? c0(c, u, { enumerable: !0, configurable: !0, writable: !0, value: g }) : c[u] = g, d0 = (c, u) => {
  for (var g in u || (u = {}))
    ZI.call(u, g) && iw(c, g, u[g]);
  if (ow)
    for (var g of ow(u))
      JI.call(u, g) && iw(c, g, u[g]);
  return c;
}, Pe = (c, u, g, w) => {
  for (var b = w > 1 ? void 0 : w ? KI(u, g) : u, x = c.length - 1, v; x >= 0; x--)
    (v = c[x]) && (b = (w ? v(u, g, b) : v(b)) || b);
  return w && b && c0(u, g, b), b;
};
function YI(c, u) {
  return new Promise((g) => {
    function w(b) {
      b.target === c && (c.removeEventListener(u, w), g());
    }
    c.addEventListener(u, w);
  });
}
function rw() {
  return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
}
const Ic = /* @__PURE__ */ new Set(), QI = new MutationObserver(m0), si = /* @__PURE__ */ new Map();
let u0 = document.documentElement.dir || "ltr", h0 = document.documentElement.lang || navigator.language, wo;
QI.observe(document.documentElement, {
  attributes: !0,
  attributeFilter: ["dir", "lang"]
});
function g0(...c) {
  c.map((u) => {
    const g = u.$code.toLowerCase();
    si.has(g) ? si.set(g, Object.assign(Object.assign({}, si.get(g)), u)) : si.set(g, u), wo || (wo = u);
  }), m0();
}
function m0() {
  u0 = document.documentElement.dir || "ltr", h0 = document.documentElement.lang || navigator.language, [...Ic.keys()].map((c) => {
    typeof c.requestUpdate == "function" && c.requestUpdate();
  });
}
let XI = class {
  constructor(u) {
    this.host = u, this.host.addController(this);
  }
  hostConnected() {
    Ic.add(this.host);
  }
  hostDisconnected() {
    Ic.delete(this.host);
  }
  dir() {
    return `${this.host.dir || u0}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || h0}`.toLowerCase();
  }
  getTranslationData(u) {
    var g, w;
    const b = new Intl.Locale(u.replace(/_/g, "-")), x = b == null ? void 0 : b.language.toLowerCase(), v = (w = (g = b == null ? void 0 : b.region) === null || g === void 0 ? void 0 : g.toLowerCase()) !== null && w !== void 0 ? w : "", C = si.get(`${x}-${v}`), p = si.get(x);
    return { locale: b, language: x, region: v, primary: C, secondary: p };
  }
  exists(u, g) {
    var w;
    const { primary: b, secondary: x } = this.getTranslationData((w = g.lang) !== null && w !== void 0 ? w : this.lang());
    return g = Object.assign({ includeFallback: !1 }, g), !!(b && b[u] || x && x[u] || g.includeFallback && wo && wo[u]);
  }
  term(u, ...g) {
    const { primary: w, secondary: b } = this.getTranslationData(this.lang());
    let x;
    if (w && w[u])
      x = w[u];
    else if (b && b[u])
      x = b[u];
    else if (wo && wo[u])
      x = wo[u];
    else
      return console.error(`No translation found for: ${String(u)}`), String(u);
    return typeof x == "function" ? x(...g) : x;
  }
  date(u, g) {
    return u = new Date(u), new Intl.DateTimeFormat(this.lang(), g).format(u);
  }
  number(u, g) {
    return u = Number(u), isNaN(u) ? "" : new Intl.NumberFormat(this.lang(), g).format(u);
  }
  relativeTime(u, g, w) {
    return new Intl.RelativeTimeFormat(this.lang(), w).format(u, g);
  }
};
var p0 = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (c, u) => `Go to slide ${c} of ${u}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextMonth: "Next month",
  nextSlide: "Next slide",
  numOptionsSelected: (c) => c === 0 ? "No options selected" : c === 1 ? "1 option selected" : `${c} options selected`,
  previousMonth: "Previous month",
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (c) => `Slide ${c}`,
  toggleColorFormat: "Toggle color format"
};
g0(p0);
var e3 = p0, t3 = class extends XI {
};
g0(e3);
var Pc = "";
function sw(c) {
  Pc = c;
}
function Oc(c = "") {
  if (!Pc) {
    const u = [...document.getElementsByTagName("script")], g = u.find((w) => w.hasAttribute("data-shoelace"));
    if (g)
      sw(g.getAttribute("data-shoelace"));
    else {
      const w = u.find((x) => /shoelace(\.min)?\.js($|\?)/.test(x.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(x.src));
      let b = "";
      w && (b = w.getAttribute("src")), sw(b.split("/").slice(0, -1).join("/"));
    }
  }
  return Pc.replace(/\/$/, "") + (c ? `/${c.replace(/^\//, "")}` : "");
}
var n3 = {
  name: "default",
  resolver: (c, u = !1) => Oc(u ? `assets/bootstrap-icons/${c}.svg` : `assets/bootstrap-icons/${c.substring(0, 1)}/${c}.svg`)
}, o3 = n3, i3 = {
  name: "viur",
  resolver: (c, u = !1) => Oc(`/assets/icons/${c}.svg`),
  mutator: (c) => {
    c.setAttribute("fill", "currentColor"), [...c.querySelectorAll("*")].map((u) => u.setAttribute("fill", "inherit"));
  }
}, r3 = i3, aw = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  checked: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <rect x="2" y="2" width="12" height="12" stroke-width="2"></rect>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="2" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="6"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `,
  search: `
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
      <path d="M11.742 10.344a6.5 6.5 0 10-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 001.415-1.414l-3.85-3.85a1.007 1.007 0 00-.115-.1zM12 6.5a5.5 5.5 0 11-11 0 5.5 5.5 0 0111 0z"></path>
    </svg>
  `
}, s3 = {
  name: "system",
  resolver: (c, u = !1) => c in aw ? `data:image/svg+xml,${encodeURIComponent(aw[c])}` : ""
}, a3 = s3, l3 = [r3, o3, a3], Rc = [];
function c3(c) {
  Rc.push(c);
}
function d3(c) {
  Rc = Rc.filter((u) => u !== c);
}
function lw(c) {
  return l3.find((u) => u.name === c);
}
var u3 = Wc`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;
function Co(c, u) {
  const g = d0({
    waitUntilFirstUpdate: !1
  }, u);
  return (w, b) => {
    const { update: x } = w, v = Array.isArray(c) ? c : [c];
    w.update = function(C) {
      v.forEach((p) => {
        const D = p;
        if (C.has(D)) {
          const y = C.get(D), A = this[D];
          y !== A && (!g.waitUntilFirstUpdate || this.hasUpdated) && this[b](y, A);
        }
      }), x.call(this, C);
    };
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const h3 = { attribute: !0, type: String, converter: Is, reflect: !1, hasChanged: Gc }, g3 = (c = h3, u, g) => {
  const { kind: w, metadata: b } = g;
  let x = globalThis.litPropertyMetadata.get(b);
  if (x === void 0 && globalThis.litPropertyMetadata.set(b, x = /* @__PURE__ */ new Map()), x.set(g.name, c), w === "accessor") {
    const { name: v } = g;
    return { set(C) {
      const p = u.get.call(this);
      u.set.call(this, C), this.requestUpdate(v, p, c);
    }, init(C) {
      return C !== void 0 && this.P(v, void 0, c), C;
    } };
  }
  if (w === "setter") {
    const { name: v } = g;
    return function(C) {
      const p = this[v];
      u.call(this, C), this.requestUpdate(v, p, c);
    };
  }
  throw Error("Unsupported decorator location: " + w);
};
function pt(c) {
  return (u, g) => typeof g == "object" ? g3(c, u, g) : ((w, b, x) => {
    const v = b.hasOwnProperty(x);
    return b.constructor.createProperty(x, v ? { ...w, wrapped: !0 } : w), v ? Object.getOwnPropertyDescriptor(b, x) : void 0;
  })(c, u, g);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Ns(c) {
  return pt({ ...c, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function m3(c) {
  return (u, g) => {
    const w = typeof u == "function" ? u : u[g];
    Object.assign(w, c);
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const cw = (c, u, g) => (g.configurable = !0, g.enumerable = !0, Reflect.decorate && typeof u != "object" && Object.defineProperty(c, u, g), g);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function f0(c, u) {
  return (g, w, b) => {
    const x = (v) => {
      var C;
      return ((C = v.renderRoot) == null ? void 0 : C.querySelector(c)) ?? null;
    };
    if (u) {
      const { get: v, set: C } = typeof w == "object" ? g : b ?? (() => {
        const p = Symbol();
        return { get() {
          return this[p];
        }, set(D) {
          this[p] = D;
        } };
      })();
      return cw(g, w, { get() {
        let p = v.call(this);
        return p === void 0 && (p = x(this), (p !== null || this.hasUpdated) && C.call(this, p)), p;
      } });
    }
    return cw(g, w, { get() {
      return x(this);
    } });
  };
}
var gi = class extends ir {
  constructor() {
    super(), Object.entries(this.constructor.dependencies).forEach(([c, u]) => {
      this.constructor.define(c, u);
    });
  }
  emit(c, u) {
    const g = new CustomEvent(c, d0({
      bubbles: !0,
      cancelable: !1,
      composed: !0,
      detail: {}
    }, u));
    return this.dispatchEvent(g), g;
  }
  /* eslint-enable */
  static define(c, u = this, g = {}) {
    const w = customElements.get(c);
    if (!w) {
      customElements.define(c, class extends u {
      }, g);
      return;
    }
    let b = " (unknown version)", x = b;
    "version" in u && u.version && (b = " v" + u.version), "version" in w && w.version && (x = " v" + w.version), !(b && x && b === x) && console.warn(
      `Attempted to register <${c}>${b}, but <${c}>${x} has already been registered.`
    );
  }
};
gi.version = "1.0.6-v2.15.0";
gi.dependencies = {};
Pe([
  pt()
], gi.prototype, "dir", 2);
Pe([
  pt()
], gi.prototype, "lang", 2);
var b0 = Wc`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: border-box;
  }

  [hidden] {
    display: none !important;
  }
`;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const p3 = (c, u) => u === void 0 ? (c == null ? void 0 : c._$litType$) !== void 0 : (c == null ? void 0 : c._$litType$) === u;
var Xi = Symbol(), xs = Symbol(), _c, Ac = /* @__PURE__ */ new Map(), tn = class extends gi {
  constructor() {
    super(...arguments), this.initialRender = !1, this.svg = null, this.label = "", this.library = "default", this.vueonce = !0, this.sprite = !1;
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(c, u) {
    var g;
    let w;
    if (u != null && u.spriteSheet) {
      this.svg = Sn`<svg part="svg">
        <use part="use" href="${c}"></use>
      </svg>`, await this.updateComplete;
      const b = this.shadowRoot.querySelector("[part='svg']");
      return typeof u.mutator == "function" && u.mutator(b), this.svg;
    }
    try {
      if (w = await fetch(c, { mode: "cors" }), !w.ok)
        return w.status === 410 ? Xi : xs;
    } catch {
      return xs;
    }
    try {
      const b = document.createElement("div");
      b.innerHTML = await w.text();
      const x = b.firstElementChild;
      if (((g = x == null ? void 0 : x.tagName) == null ? void 0 : g.toLowerCase()) !== "svg")
        return Xi;
      _c || (_c = new DOMParser());
      const C = _c.parseFromString(x.outerHTML, "text/html").body.querySelector("svg");
      return C ? (C.part.add("svg"), document.adoptNode(C)) : Xi;
    } catch {
      return Xi;
    }
  }
  connectedCallback() {
    super.connectedCallback(), c3(this);
  }
  firstUpdated() {
    this.sprite || this.setIcon(), this.initialRender = !0, this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), d3(this);
  }
  getIconSource(c = !1) {
    const u = lw(this.library);
    return this.name && u ? {
      url: u.resolver(this.name, c),
      fromLibrary: !0
    } : {
      url: this.src,
      fromLibrary: !1
    };
  }
  getDir() {
    const { url: c } = this.getIconSource(!0);
    return c == null ? void 0 : c.substring(0, c == null ? void 0 : c.lastIndexOf("/"));
  }
  // Fetches the icon and redraws it. Used to handle library registrations.
  redraw() {
    this.sprite || this.setIcon();
  }
  handleLabelChange() {
    typeof this.label == "string" && this.label.length > 0 ? (this.setAttribute("role", "img"), this.setAttribute("aria-label", this.label), this.removeAttribute("aria-hidden")) : (this.removeAttribute("role"), this.removeAttribute("aria-label"), this.setAttribute("aria-hidden", "true"));
  }
  async setIcon() {
    var c;
    const { url: u, fromLibrary: g } = this.getIconSource(), w = g ? lw(this.library) : void 0;
    if (!u) {
      this.svg = null;
      return;
    }
    let b = Ac.get(u);
    if (b || (b = this.resolveIcon(u, w), Ac.set(u, b)), !this.initialRender)
      return;
    const x = await b;
    if (x === xs && Ac.delete(u), u === this.getIconSource().url) {
      if (p3(x)) {
        this.svg = x;
        return;
      }
      switch (x) {
        case xs:
        case Xi:
          this.svg = null, this.emit("sl-error");
          break;
        default:
          this.svg = x.cloneNode(!0), (c = w == null ? void 0 : w.mutator) == null || c.call(w, this.svg), this.emit("sl-load");
      }
    }
  }
  handleChange() {
    this.sprite || this.setIcon();
  }
  render() {
    return Sn`
    ${this.sprite ? Sn`<svg width="1em" height="1em">
            <use href="${this.getDir()}/_sprite.svg#${this.name}"></use>
          </svg>` : Sn`${this.svg}`}`;
  }
};
tn.styles = [b0, u3];
Pe([
  Ns()
], tn.prototype, "svg", 2);
Pe([
  pt({ reflect: !0 })
], tn.prototype, "name", 2);
Pe([
  pt()
], tn.prototype, "src", 2);
Pe([
  pt()
], tn.prototype, "label", 2);
Pe([
  pt({ reflect: !0 })
], tn.prototype, "library", 2);
Pe([
  pt({ reflect: !0, type: Boolean, attribute: "v-once" })
], tn.prototype, "vueonce", 2);
Pe([
  pt({ reflect: !0, type: Boolean })
], tn.prototype, "sprite", 2);
Pe([
  Co("label")
], tn.prototype, "handleLabelChange", 1);
Pe([
  Co(["name", "src", "library"])
], tn.prototype, "setIcon", 1);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const f3 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, b3 = (c) => (...u) => ({ _$litDirective$: c, values: u });
class k3 {
  constructor(u) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(u, g, w) {
    this._$Ct = u, this._$AM = g, this._$Ci = w;
  }
  _$AS(u, g) {
    return this.update(u, g);
  }
  update(u, g) {
    return this.render(...g);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ss = b3(class extends k3 {
  constructor(c) {
    var u;
    if (super(c), c.type !== f3.ATTRIBUTE || c.name !== "class" || ((u = c.strings) == null ? void 0 : u.length) > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(c) {
    return " " + Object.keys(c).filter((u) => c[u]).join(" ") + " ";
  }
  update(c, [u]) {
    var w, b;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), c.strings !== void 0 && (this.nt = new Set(c.strings.join(" ").split(/\s/).filter((x) => x !== "")));
      for (const x in u)
        u[x] && !((w = this.nt) != null && w.has(x)) && this.st.add(x);
      return this.render(u);
    }
    const g = c.element.classList;
    for (const x of this.st)
      x in u || (g.remove(x), this.st.delete(x));
    for (const x in u) {
      const v = !!u[x];
      v === this.st.has(x) || (b = this.nt) != null && b.has(x) || (v ? (g.add(x), this.st.add(x)) : (g.remove(x), this.st.delete(x)));
    }
    return Ao;
  }
});
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* dw(c, u) {
  if (c !== void 0) {
    let g = 0;
    for (const w of c)
      yield u(w, g++);
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* uw(c, u, g = 1) {
  const w = u === void 0 ? 0 : c;
  u ?? (u = c);
  for (let b = w; g > 0 ? b < u : u < b; b += g)
    yield b;
}
var w3 = (c, u) => {
  let g = 0;
  return function(...w) {
    window.clearTimeout(g), g = window.setTimeout(() => {
      c.call(this, ...w);
    }, u);
  };
}, hw = (c, u, g) => {
  const w = c[u];
  c[u] = function(...b) {
    w.call(this, ...b), g.call(this, w, ...b);
  };
}, v3 = "onscrollend" in window;
if (!v3) {
  const c = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new WeakMap(), g = (b) => {
    for (const x of b.changedTouches)
      c.add(x.identifier);
  }, w = (b) => {
    for (const x of b.changedTouches)
      c.delete(x.identifier);
  };
  document.addEventListener("touchstart", g, !0), document.addEventListener("touchend", w, !0), document.addEventListener("touchcancel", w, !0), hw(EventTarget.prototype, "addEventListener", function(b, x) {
    if (x !== "scrollend")
      return;
    const v = w3(() => {
      c.size ? v() : this.dispatchEvent(new Event("scrollend"));
    }, 100);
    b.call(this, "scroll", v, { passive: !0 }), u.set(this, v);
  }), hw(EventTarget.prototype, "removeEventListener", function(b, x) {
    if (x !== "scrollend")
      return;
    const v = u.get(this);
    v && b.call(this, "scroll", v, { passive: !0 });
  });
}
var nt = class extends gi {
  constructor() {
    super(...arguments), this.loop = !1, this.navigation = !1, this.pagination = !1, this.autoplay = !1, this.autoplayInterval = 3e3, this.slidesPerPage = 1, this.slidesPerMove = 1, this.orientation = "horizontal", this.mouseDragging = !1, this.activeSlide = 0, this.scrolling = !1, this.dragging = !1, this.autoplayController = new SI(this, () => this.next()), this.localize = new t3(this), this.handleMouseDrag = (c) => {
      this.dragging || (this.scrollContainer.style.setProperty("scroll-snap-type", "none"), this.dragging = !0), this.scrollContainer.scrollBy({
        left: -c.movementX,
        top: -c.movementY,
        behavior: "instant"
      });
    }, this.handleMouseDragEnd = () => {
      const c = this.scrollContainer;
      document.removeEventListener("pointermove", this.handleMouseDrag, { capture: !0 });
      const u = c.scrollLeft, g = c.scrollTop;
      c.style.removeProperty("scroll-snap-type"), c.style.setProperty("overflow", "hidden");
      const w = c.scrollLeft, b = c.scrollTop;
      c.style.removeProperty("overflow"), c.style.setProperty("scroll-snap-type", "none"), c.scrollTo({ left: u, top: g, behavior: "instant" }), requestAnimationFrame(async () => {
        (u !== w || g !== b) && (c.scrollTo({
          left: w,
          top: b,
          behavior: rw() ? "auto" : "smooth"
        }), await YI(c, "scrollend")), c.style.removeProperty("scroll-snap-type"), this.dragging = !1, this.handleScrollEnd();
      });
    }, this.handleSlotChange = (c) => {
      c.some(
        (g) => [...g.addedNodes, ...g.removedNodes].some(
          (w) => this.isCarouselItem(w) && !w.hasAttribute("data-clone")
        )
      ) && this.initializeSlides(), this.requestUpdate();
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "region"), this.setAttribute("aria-label", this.localize.term("carousel"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.mutationObserver.disconnect();
  }
  firstUpdated() {
    this.initializeSlides(), this.mutationObserver = new MutationObserver(this.handleSlotChange), this.mutationObserver.observe(this, {
      childList: !0,
      subtree: !0
    });
  }
  willUpdate(c) {
    (c.has("slidesPerMove") || c.has("slidesPerPage")) && (this.slidesPerMove = Math.min(this.slidesPerMove, this.slidesPerPage));
  }
  getPageCount() {
    const c = this.getSlides().length, { slidesPerPage: u, slidesPerMove: g, loop: w } = this, b = w ? c / g : (c - u) / g + 1;
    return Math.ceil(b);
  }
  getCurrentPage() {
    return Math.ceil(this.activeSlide / this.slidesPerMove);
  }
  getShadowSlideCount() {
    return this.slidesPerPage - this.getSlides().length % this.slidesPerPage;
  }
  canScrollNext() {
    return this.loop || this.getCurrentPage() < this.getPageCount() - 1;
  }
  canScrollPrev() {
    return this.loop || this.getCurrentPage() > 0;
  }
  /** @internal Gets all carousel items. */
  getSlides({ excludeClones: c = !0 } = {}) {
    return [...this.children].filter(
      (u) => this.isCarouselItem(u) && (!c || !u.hasAttribute("data-clone"))
    );
  }
  handleKeyDown(c) {
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(c.key)) {
      const u = c.target, g = this.localize.dir() === "rtl", w = u.closest('[part~="pagination-item"]') !== null, b = c.key === "ArrowDown" || !g && c.key === "ArrowRight" || g && c.key === "ArrowLeft", x = c.key === "ArrowUp" || !g && c.key === "ArrowLeft" || g && c.key === "ArrowRight";
      c.preventDefault(), x && this.previous(), b && this.next(), c.key === "Home" && this.goToSlide(0), c.key === "End" && this.goToSlide(this.getSlides().length - 1), w && this.updateComplete.then(() => {
        var v;
        const C = (v = this.shadowRoot) == null ? void 0 : v.querySelector(
          '[part~="pagination-item--active"]'
        );
        C && C.focus();
      });
    }
  }
  handleMouseDragStart(c) {
    this.mouseDragging && c.button === 0 && (c.preventDefault(), document.addEventListener("pointermove", this.handleMouseDrag, { capture: !0, passive: !0 }), document.addEventListener("pointerup", this.handleMouseDragEnd, { capture: !0, once: !0 }));
  }
  handleScroll() {
    this.scrolling = !0;
  }
  /** @internal Synchronizes the slides with the IntersectionObserver API. */
  synchronizeSlides() {
    const c = new IntersectionObserver(
      (u) => {
        c.disconnect();
        for (const w of u) {
          const b = w.target;
          b.toggleAttribute("inert", !w.isIntersecting), b.classList.toggle("--in-view", w.isIntersecting), b.setAttribute("aria-hidden", w.isIntersecting ? "false" : "true");
        }
        const g = u.find((w) => w.isIntersecting);
        if (g)
          if (this.loop && g.target.hasAttribute("data-clone")) {
            const w = Number(g.target.getAttribute("data-clone"));
            this.goToSlide(w, "instant");
          } else {
            const b = this.getSlides().indexOf(g.target);
            this.activeSlide = Math.ceil(b / this.slidesPerMove) * this.slidesPerMove;
          }
      },
      {
        root: this.scrollContainer,
        threshold: 0.6
      }
    );
    this.getSlides({ excludeClones: !1 }).forEach((u) => {
      c.observe(u);
    });
  }
  handleScrollEnd() {
    !this.scrolling || this.dragging || (this.synchronizeSlides(), this.scrolling = !1);
  }
  isCarouselItem(c) {
    return c instanceof Element && c.tagName.toLowerCase() === "sl-carousel-item";
  }
  initializeSlides() {
    this.getSlides({ excludeClones: !1 }).forEach((c, u) => {
      c.classList.remove("--in-view"), c.classList.remove("--is-active"), c.setAttribute("aria-label", this.localize.term("slideNum", u + 1)), c.hasAttribute("data-clone") && c.remove();
    }), this.updateSlidesSnap(), this.loop && this.createClones(), this.synchronizeSlides(), this.goToSlide(this.activeSlide, "auto");
  }
  createClones() {
    const c = this.getSlides(), u = this.slidesPerPage, g = c.slice(-u), w = c.slice(0, u);
    g.reverse().forEach((b, x) => {
      const v = b.cloneNode(!0);
      v.setAttribute("data-clone", String(c.length - x - 1)), this.prepend(v);
    }), w.forEach((b, x) => {
      const v = b.cloneNode(!0);
      v.setAttribute("data-clone", String(x)), this.append(v);
    });
  }
  handelSlideChange() {
    const c = this.getSlides();
    c.forEach((u, g) => {
      u.classList.toggle("--is-active", g === this.activeSlide);
    }), this.hasUpdated && this.emit("sl-slide-change", {
      detail: {
        index: this.activeSlide,
        slide: c[this.activeSlide]
      }
    });
  }
  updateSlidesSnap() {
    const c = this.getSlides(), u = this.slidesPerMove;
    c.forEach((g, w) => {
      (w + u) % u === 0 ? g.style.removeProperty("scroll-snap-align") : g.style.setProperty("scroll-snap-align", "none");
    });
  }
  handleAutoplayChange() {
    this.autoplayController.stop(), this.autoplay && this.autoplayController.start(this.autoplayInterval);
  }
  /**
   * Move the carousel backward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  previous(c = "smooth") {
    this.goToSlide(this.activeSlide - this.slidesPerMove, c);
  }
  /**
   * Move the carousel forward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  next(c = "smooth") {
    this.goToSlide(this.activeSlide + this.slidesPerMove, c);
  }
  /**
   * Scrolls the carousel to the slide specified by `index`.
   *
   * @param index - The slide index.
   * @param behavior - The behavior used for scrolling.
   */
  goToSlide(c, u = "smooth") {
    const { slidesPerPage: g, loop: w } = this, b = this.getSlides(), x = this.getSlides({ excludeClones: !1 });
    if (!b.length)
      return;
    const v = w ? (c + b.length) % b.length : Wk(c, 0, b.length - 1);
    this.activeSlide = v;
    const C = Wk(c + (w ? g : 0), 0, x.length - 1), p = x[C];
    this.scrollToSlide(p, rw() ? "auto" : u);
  }
  scrollToSlide(c, u = "smooth") {
    const g = this.scrollContainer, w = g.getBoundingClientRect(), b = c.getBoundingClientRect(), x = b.left - w.left, v = b.top - w.top;
    g.scrollTo({
      left: x + g.scrollLeft,
      top: v + g.scrollTop,
      behavior: u
    });
  }
  render() {
    const { slidesPerMove: c, scrolling: u } = this, g = this.getPageCount(), w = this.getCurrentPage(), b = this.canScrollPrev(), x = this.canScrollNext(), v = this.localize.dir() === "ltr";
    return Sn`
      <div part="base" class="carousel">
        <div
          id="scroll-container"
          part="scroll-container"
          class="${Ss({
      carousel__slides: !0,
      "carousel__slides--horizontal": this.orientation === "horizontal",
      "carousel__slides--vertical": this.orientation === "vertical",
      "carousel__slides--dragging": this.dragging
    })}"
          style="--slides-per-page: ${this.slidesPerPage};"
          aria-busy="${u ? "true" : "false"}"
          aria-atomic="true"
          tabindex="0"
          @keydown=${this.handleKeyDown}
          @mousedown="${this.handleMouseDragStart}"
          @scroll="${this.handleScroll}"
          @scrollend=${this.handleScrollEnd}
        >
          <slot></slot>
          ${dw(uw(this.getShadowSlideCount()), () => Sn`
            <sl-carousel-item class="shadow-slide"></sl-carousel-item>
            `)}

        </div>

        ${this.navigation ? Sn`
              <div part="navigation" class="carousel__navigation">
                <button
                  part="navigation-button navigation-button--previous"
                  class="${Ss({
      "carousel__navigation-button": !0,
      "carousel__navigation-button--previous": !0,
      "carousel__navigation-button--disabled": !b
    })}"
                  aria-label="${this.localize.term("previousSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${b ? "false" : "true"}"
                  @click=${b ? () => this.previous() : null}
                >
                  <slot name="previous-icon">
                    <sl-icon library="system" name="${v ? "chevron-left" : "chevron-right"}"></sl-icon>
                  </slot>
                </button>

                <button
                  part="navigation-button navigation-button--next"
                  class=${Ss({
      "carousel__navigation-button": !0,
      "carousel__navigation-button--next": !0,
      "carousel__navigation-button--disabled": !x
    })}
                  aria-label="${this.localize.term("nextSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${x ? "false" : "true"}"
                  @click=${x ? () => this.next() : null}
                >
                  <slot name="next-icon">
                    <sl-icon library="system" name="${v ? "chevron-right" : "chevron-left"}"></sl-icon>
                  </slot>
                </button>
              </div>
            ` : ""}
        ${this.pagination ? Sn`
              <div part="pagination" role="tablist" class="carousel__pagination" aria-controls="scroll-container">
                ${dw(uw(g), (C) => {
      const p = C === w;
      return Sn`
                    <button
                      part="pagination-item ${p ? "pagination-item--active" : ""}"
                      class="${Ss({
        "carousel__pagination-item": !0,
        "carousel__pagination-item--active": p
      })}"
                      role="tab"
                      aria-selected="${p ? "true" : "false"}"
                      aria-label="${this.localize.term("goToSlide", C + 1, g)}"
                      tabindex=${p ? "0" : "-1"}
                      @click=${() => this.goToSlide(C * c)}
                      @keydown=${this.handleKeyDown}
                    ></button>
                  `;
    })}
              </div>
            ` : ""}
      </div>
    `;
  }
};
nt.styles = [b0, GI];
nt.dependencies = { "sl-icon": tn };
Pe([
  pt({ type: Boolean, reflect: !0 })
], nt.prototype, "loop", 2);
Pe([
  pt({ type: Boolean, reflect: !0 })
], nt.prototype, "navigation", 2);
Pe([
  pt({ type: Boolean, reflect: !0 })
], nt.prototype, "pagination", 2);
Pe([
  pt({ type: Boolean, reflect: !0 })
], nt.prototype, "autoplay", 2);
Pe([
  pt({ type: Number, attribute: "autoplay-interval" })
], nt.prototype, "autoplayInterval", 2);
Pe([
  pt({ type: Number, attribute: "slides-per-page" })
], nt.prototype, "slidesPerPage", 2);
Pe([
  pt({ type: Number, attribute: "slides-per-move" })
], nt.prototype, "slidesPerMove", 2);
Pe([
  pt()
], nt.prototype, "orientation", 2);
Pe([
  pt({ type: Boolean, reflect: !0, attribute: "mouse-dragging" })
], nt.prototype, "mouseDragging", 2);
Pe([
  f0(".carousel__slides")
], nt.prototype, "scrollContainer", 2);
Pe([
  f0(".carousel__pagination")
], nt.prototype, "paginationContainer", 2);
Pe([
  Ns()
], nt.prototype, "activeSlide", 2);
Pe([
  Ns()
], nt.prototype, "scrolling", 2);
Pe([
  Ns()
], nt.prototype, "dragging", 2);
Pe([
  m3({ passive: !0 })
], nt.prototype, "handleScroll", 1);
Pe([
  Co("loop", { waitUntilFirstUpdate: !0 }),
  Co("slidesPerPage", { waitUntilFirstUpdate: !0 })
], nt.prototype, "initializeSlides", 1);
Pe([
  Co("activeSlide")
], nt.prototype, "handelSlideChange", 1);
Pe([
  Co("slidesPerMove")
], nt.prototype, "updateSlidesSnap", 1);
Pe([
  Co("autoplay")
], nt.prototype, "handleAutoplayChange", 1);
nt.define("sl-carousel");
const mi = (c) => (dt("data-v-0bddd798"), c = c(), ut(), c), _3 = { class: "wrap" }, A3 = { class: "viur-shop-item-view-image-wrap" }, C3 = {
  class: "viur-shop-item-view-carousel-thumbnails",
  navigation: "",
  loop: ""
}, y3 = ["alt", "src"], E3 = { class: "viur-shop-item-view-thumbnails" }, x3 = { class: "viur-shop-item-view-thumbnails-scroller" }, S3 = ["alt", "src"], D3 = { class: "viur-shop-item-view-info-wrap" }, B3 = { class: "viur-shop-item-view-headline" }, T3 = /* @__PURE__ */ mi(() => /* @__PURE__ */ I("h2", { class: "viur-shop-item-view-subline" }, "B 21 x H 6,5 x T 19 cm", -1)), I3 = { class: "viur-shop-item-view-price" }, P3 = /* @__PURE__ */ mi(() => /* @__PURE__ */ I("div", { class: "viur-shop-item-view-paragraph" }, " Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. ", -1)), O3 = { class: "viur-shop-item-view-btn-wrap" }, R3 = /* @__PURE__ */ mi(() => /* @__PURE__ */ I("sl-icon", {
  name: "bag-plus",
  slot: "prefix"
}, null, -1)), z3 = /* @__PURE__ */ mi(() => /* @__PURE__ */ I("sl-button", {
  size: "small",
  outline: "",
  class: "viur-shop-item-view-add-to-favourites-btn",
  variant: "primary",
  title: "Add to favourites"
}, [
  /* @__PURE__ */ I("sl-icon", {
    name: "heart",
    slot: "prefix"
  }),
  /* @__PURE__ */ ie(" Auf die Wunschliste ")
], -1)), M3 = /* @__PURE__ */ mi(() => /* @__PURE__ */ I("br", null, null, -1)), N3 = /* @__PURE__ */ mi(() => /* @__PURE__ */ I("h1", { class: "viur-shop-item-view-headline" }, "Ähnliche Artikel", -1)), F3 = { class: "viur-shop-item-view-item-grid" }, $3 = ["open"], V3 = {
  __name: "ItemView",
  props: {
    item: {
      type: Object,
      required: !0
    },
    hasCrossSelling: {
      type: Boolean,
      required: !0
    },
    crossSellingFunction: {
      type: Function,
      default: () => {
      }
    },
    hasUpSelling: {
      type: Boolean,
      required: !0
    },
    upSellingFunction: {
      type: Function,
      default: () => {
      }
    }
  },
  setup(c) {
    const u = me({
      item: {},
      crossSelling: !1
    }), g = Wt(), w = Rs(), b = c;
    function x(C) {
      var D;
      console.log("hier", C);
      let p = "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80";
      return C.shop_image ? he.downloadUrlFor(C.shop_image) : (D = C == null ? void 0 : C.hk_artikel) != null && D.dest.image ? he.downloadUrlFor(C.hk_artikel.dest.image) : p;
    }
    function v(C, p) {
      g.addToCart(C.key, p), console.log("bin ich da", b.crossSellingFunction), u.params = b.crossSellingFunction(b.item), console.log(u.params), w.getCrossSellingItems(u.params.url, u.params.keys), u.crossSelling = !0;
    }
    return yo(async () => {
      console.log("itemView, komme ich hier an?", b.item), u.item = b.item;
    }), (C, p) => (H(), G(Ve, null, [
      I("div", _3, [
        I("div", A3, [
          I("sl-carousel", C3, [
            I("sl-carousel-item", null, [
              I("img", {
                alt: u.item.shop_name,
                src: x(u.item)
              }, null, 8, y3)
            ])
          ]),
          I("div", E3, [
            I("div", x3, [
              I("img", {
                alt: u.item.shop_name,
                class: "viur-shop-item-view-thumbnails-image active",
                src: x(u.item)
              }, null, 8, S3)
            ])
          ])
        ]),
        I("div", D3, [
          I("h1", B3, ge(u.item.shop_name), 1),
          T3,
          I("div", I3, ge(u.item.shop_price.retail) + " € ", 1),
          P3,
          I("div", O3, [
            ie(ge(u.crossSelling) + " ", 1),
            I("sl-button", {
              size: "small",
              class: "viur-shop-item-view-add-to-cart-btn",
              variant: "primary",
              title: "Add to cart",
              onClick: p[0] || (p[0] = Hn((D) => v(c.item, le(g).state.basket), ["stop"]))
            }, [
              R3,
              ie(" In den Warenkorb ")
            ]),
            z3
          ])
        ])
      ]),
      M3,
      N3,
      (H(!0), G(Ve, null, kt(le(w).state.upSellingItems, (D) => (H(), G("div", F3, [
        ai(n0, {
          item: D,
          hasCrossSelling: le(w).state.hasUpSelling,
          crossSellingFunction: C.getUpSellingFunction(c.item)
        }, {
          default: Mc(() => [
            ie(" > ")
          ]),
          _: 2
        }, 1032, ["item", "hasCrossSelling", "crossSellingFunction"])
      ]))), 256)),
      I("sl-dialog", {
        open: u.crossSelling,
        onSlHide: p[1] || (p[1] = (...D) => C.handleHideCrossSelling && C.handleHideCrossSelling(...D))
      }, [
        ai(t0, {
          item: c.item,
          crossSellingItems: le(w).state.crossSellingItems,
          onCancel: C.closeDialog
        }, null, 8, ["item", "crossSellingItems", "onCancel"])
      ], 40, $3)
    ], 64));
  }
}, k0 = /* @__PURE__ */ Ae(V3, [["__scopeId", "data-v-0bddd798"]]), L3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: k0
}, Symbol.toStringTag, { value: "Module" })), j3 = (c) => (dt("data-v-55667880"), c = c(), ut(), c), H3 = {
  key: 0,
  class: "viur-shop-loading-wrap"
}, U3 = /* @__PURE__ */ j3(() => /* @__PURE__ */ I("sl-spinner", null, null, -1)), q3 = [
  U3
], W3 = {
  key: 1,
  class: "bind"
}, G3 = { class: "page-header" }, K3 = { class: "viur-shop-category-view-list" }, Z3 = ["onClick"], J3 = ["open", "onSlHide"], Y3 = ["loading", "disabled"], Q3 = {
  __name: "CategoryView",
  props: {
    skellist: { type: Array },
    filter: { type: Boolean, default: !0 },
    pageHeader: { type: String, default: "Artikel Liste" },
    listHandler: { type: Object, required: !0 }
  },
  setup(c) {
    const u = c, g = e0(), w = Wt(), b = Rs(), x = me({
      skellist: [],
      loading: !0,
      currentCursor: "",
      isLastItem: !1,
      itemCount: 99,
      itemType: ce(() => g.params.identifier),
      hasUpSelling: ce(() => b.state.hasUpSelling),
      hasCrossSelling: ce(() => b.state.hasCrossSelling),
      openItemView: {}
    }), v = u.listHandler, C = (A) => x.openItemView.key === A, p = (A) => {
      console.log("geht das?"), x.openItemView = {}, A && (x.openItemView = {
        key: A,
        open: !0
      });
    };
    async function D() {
      x.loading = !0, await v.next(), x.skellist.length < v.state.skellist.length ? (x.skellist = v.state.skellist, x.loading = !1) : (x.loading = !1, x.isLastItem = !0);
    }
    b.state.crossSellingFunction = (A) => {
      let k = "/json/variante";
      const E = [];
      for (let z of A.matching_items)
        console.log(z), E.push(z.dest.key);
      return console.log(k, E), console.log("crossSelling"), {
        url: k,
        keys: E
      };
    };
    function y(A) {
      return () => b.state.crossSellingFunction(A);
    }
    return b.state.upSellingFunction = (A) => ({
      url: "/json/variante",
      keys: ["ag1oc2stdml1cjMtZGV2chULEgh2YXJpYW50ZRiAgKDSnIHGCww", "ag1oc2stdml1cjMtZGV2chULEgh2YXJpYW50ZRiAgIDg_9StCgw"]
    }), lt(async () => {
      await w.init(), await v.fetch(!0), x.skellist = v.state.skellist, x.loading = !1, x.hasCrossSelling && console.log("!!!!", b.state);
    }), (A, k) => x.loading ? (H(), G("div", H3, q3)) : (H(), G("div", W3, [
      I("div", G3, [
        I("h1", null, ge(c.pageHeader), 1)
      ]),
      c.filter ? Pw(A.$slots, "filter", { key: 0 }, () => [
        ie(" text-transform text-transform TEST ")
      ], !0) : Ee("", !0),
      I("div", K3, [
        (H(!0), G(Ve, null, kt(x.skellist, (E) => (H(), G("div", {
          key: E.shop_name
        }, [
          I("sl-button", {
            onClick: (P) => p(E.key)
          }, "ItemView", 8, Z3),
          ai(n0, {
            item: E,
            hasCrossSelling: !0,
            crossSellingFunction: y(E)
          }, null, 8, ["item", "crossSellingFunction"]),
          I("sl-dialog", {
            open: C(E.key),
            onSlHide: (P) => A.isClosed(E.key)
          }, [
            ai(k0, {
              item: E,
              hasCrossSelling: le(b).state.hasCrossselling,
              crossSellingFunction: y(E),
              hasUpSelling: le(b).state.hasUpSelling,
              upSellingFunction: y(E)
            }, null, 8, ["item", "hasCrossSelling", "crossSellingFunction", "hasUpSelling", "upSellingFunction"])
          ], 40, J3)
        ]))), 128))
      ]),
      I("sl-button", {
        onClick: D,
        loading: x.loading,
        disabled: x.isLastItem,
        class: "viur-shop-category-view-more-button"
      }, " Mehr anzeigen ", 8, Y3)
    ]));
  }
}, w0 = /* @__PURE__ */ Ae(Q3, [["__scopeId", "data-v-55667880"]]), X3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: w0
}, Symbol.toStringTag, { value: "Module" })), Pt = (c) => (dt("data-v-412209b2"), c = c(), ut(), c), eP = {
  key: 1,
  class: "list"
}, tP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("h2", { class: "viur-shop-cart-headline headline" }, "Bestellung prüfen", -1)), nP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("br", null, null, -1)), oP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("div", { class: "viur-shop-cart-address-wrap" }, [
  /* @__PURE__ */ I("div", { class: "viur-shop-cart-address" }, [
    /* @__PURE__ */ I("div", { class: "viur-shop-cart-address-headline" }, [
      /* @__PURE__ */ ie(" Versandadresse "),
      /* @__PURE__ */ I("sl-button", {
        outline: "",
        size: "small"
      }, [
        /* @__PURE__ */ I("sl-icon", {
          name: "pencil",
          slot: "prefix"
        })
      ])
    ]),
    /* @__PURE__ */ ie(" Roland Brose"),
    /* @__PURE__ */ I("br"),
    /* @__PURE__ */ ie(" Speicherstraße 33"),
    /* @__PURE__ */ I("br"),
    /* @__PURE__ */ ie(" 44147 Dortmund, DE"),
    /* @__PURE__ */ I("br"),
    /* @__PURE__ */ I("br"),
    /* @__PURE__ */ ie(" rb@mausbrand.de"),
    /* @__PURE__ */ I("br"),
    /* @__PURE__ */ ie(" 0231 21 34 68 90 ")
  ]),
  /* @__PURE__ */ I("div", { class: "viur-shop-cart-address" }, [
    /* @__PURE__ */ I("div", { class: "viur-shop-cart-address-headline" }, [
      /* @__PURE__ */ ie(" Rechnungsadresse "),
      /* @__PURE__ */ I("sl-button", {
        outline: "",
        size: "small"
      }, [
        /* @__PURE__ */ I("sl-icon", {
          name: "pencil",
          slot: "prefix"
        })
      ])
    ]),
    /* @__PURE__ */ ie(" Roland Brose"),
    /* @__PURE__ */ I("br"),
    /* @__PURE__ */ ie(" Speicherstraße 33"),
    /* @__PURE__ */ I("br"),
    /* @__PURE__ */ ie(" 44147 Dortmund, DE"),
    /* @__PURE__ */ I("br"),
    /* @__PURE__ */ I("br"),
    /* @__PURE__ */ ie(" rb@mausbrand.de"),
    /* @__PURE__ */ I("br"),
    /* @__PURE__ */ ie(" 0231 21 34 68 90 ")
  ])
], -1)), iP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("div", { class: "viur-shop-cart-payment" }, [
  /* @__PURE__ */ I("div", { class: "viur-shop-cart-payment-method" }, [
    /* @__PURE__ */ I("span", null, "Zahlungsmethode:"),
    /* @__PURE__ */ ie(" Paypal ")
  ]),
  /* @__PURE__ */ I("sl-button", {
    outline: "",
    size: "small"
  }, [
    /* @__PURE__ */ I("sl-icon", {
      name: "pencil",
      slot: "prefix"
    })
  ])
], -1)), rP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("h2", { class: "viur-shop-cart-headline headline" }, "Warenkorb", -1)), sP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("br", null, null, -1)), aP = {
  horizontal: "",
  class: "viur-shop-cart-mini-card"
}, lP = ["src"], cP = {
  class: "viur-shop-cart-mini-cart-header",
  slot: "header"
}, dP = { class: "viur-shop-cart-mini-headline headline" }, uP = { class: "viur-shop-cart-mini-card-body-row" }, hP = { class: "viur-shop-cart-mini-card-body-info" }, gP = { class: "viur-shop-cart-mini-card-info-wrap" }, mP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("div", { class: "viur-shop-cart-mini-card-info" }, [
  /* @__PURE__ */ I("span", null, "Anzahl: "),
  /* @__PURE__ */ ie(" 1 ")
], -1)), pP = { class: "viur-shop-cart-mini-card-info" }, fP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("span", null, "Preis: ", -1)), bP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("h2", { class: "viur-shop-cart-sidebar-headline headline" }, "Jetzt Bestellen", -1)), kP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("br", null, null, -1)), wP = { class: "viur-shop-cart-sidebar-info-line" }, vP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("span", null, "Zwischensumme", -1)), _P = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("div", { class: "viur-shop-cart-sidebar-info-line" }, [
  /* @__PURE__ */ I("span", null, "Rabatt"),
  /* @__PURE__ */ ie(" 0 € ")
], -1)), AP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("div", { class: "viur-shop-cart-sidebar-info-line" }, [
  /* @__PURE__ */ I("span", null, "Versandkosten"),
  /* @__PURE__ */ ie(" 0 € ")
], -1)), CP = { class: "viur-shop-cart-sidebar-info-line total" }, yP = /* @__PURE__ */ Pt(() => /* @__PURE__ */ I("span", null, "Gesamt:", -1)), EP = { class: "viur-shop-cart-sidebar-btn-wrap" }, xP = ["variant", "disabled"], SP = {
  __name: "ConfirmView",
  setup(c) {
    const u = Wt(), g = me({
      cartIsInit: ce(() => !!u.state.basket.length),
      itemsIsInit: ce(() => !!u.state.carts[u.state.basket].items),
      images: {},
      showOrderButton: !1
    });
    function w(x) {
      return he.get(`/json/dk_variante/view/${x}`).then(async (v) => {
        let C = await v.json();
        C = C.values;
        let p = C.hk_artikel.dest.image ? he.downloadUrlFor(C.hk_artikel.dest.image) : "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80";
        g.images[x] = p;
      }), g.images[x];
    }
    function b(x) {
      x.target.checked && (g.showOrderButton = !0), x.target.checked || (g.showOrderButton = !1);
    }
    return yo(async () => {
      await u.init();
    }), (x, v) => g.cartIsInit ? (H(), G("div", eP, [
      tP,
      nP,
      oP,
      iP,
      rP,
      sP,
      (H(!0), G(Ve, null, kt(le(u).state.carts[le(u).state.basket].items, (C) => (H(), G("sl-card", aP, [
        I("img", {
          class: "viur-shop-cart-mini-card-img",
          slot: "image",
          src: w(C.article.dest.key)
        }, null, 8, lP),
        I("div", cP, [
          I("h4", dP, ge(C.article.dest.shop_name) + " | 425018", 1)
        ]),
        I("div", uP, [
          I("div", hP, [
            I("div", gP, [
              mP,
              I("div", pP, [
                fP,
                ie(" " + ge(C.article.dest.shop_price_recommended) + " € ", 1)
              ])
            ])
          ])
        ])
      ]))), 256)),
      (H(), yt(Tw, { to: "#order_sidebar" }, [
        bP,
        kP,
        I("div", wP, [
          vP,
          ie(" " + ge(le(u).state.carts[le(u).state.basket].info.total) + " € ", 1)
        ]),
        _P,
        AP,
        I("div", CP, [
          yP,
          ie(" " + ge(le(u).state.carts[le(u).state.basket].info.total) + " € ", 1)
        ]),
        I("sl-checkbox", { onSlChange: b }, " Ich akzeptiere die geltenden AGBs und Datenschutzbestimmungen ", 32),
        I("div", EP, [
          I("sl-button", {
            variant: g.showOrderButton ? "info" : "disabled",
            size: "small",
            disabled: !g.showOrderButton
          }, " Zahlungspflichtig bestellen ", 8, xP)
        ])
      ]))
    ])) : (H(), yt(zw, { key: 0 }));
  }
}, v0 = /* @__PURE__ */ Ae(SP, [["__scopeId", "data-v-412209b2"]]), DP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: v0
}, Symbol.toStringTag, { value: "Module" })), _0 = (c) => (dt("data-v-5214cf3f"), c = c(), ut(), c), BP = { class: "viur-shop-category-list-item" }, TP = /* @__PURE__ */ _0(() => /* @__PURE__ */ I("img", {
  slot: "image",
  src: "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80",
  alt: "A kitten.",
  class: "viur-shop-category-list-item-img"
}, null, -1)), IP = { class: "viur-shop-category-list-item-headline" }, PP = /* @__PURE__ */ _0(() => /* @__PURE__ */ I("div", { class: "viur-shop-category-list-fake-link" }, "Alle anzeigen »", -1)), OP = {
  __name: "CategoryList",
  props: {
    list: { type: Array, required: !0 }
  },
  setup(c) {
    const u = Wt();
    return yo(async () => {
      await u.init();
    }), (g, w) => {
      const b = hi("RouterLink");
      return H(!0), G(Ve, null, kt(c.list, (x) => (H(), yt(b, {
        to: { name: "CategoryView", params: { identifier: "hk" } },
        key: x,
        class: "viur-shop-category-list-item-link"
      }, {
        default: Mc(() => [
          I("sl-card", BP, [
            TP,
            I("h2", IP, ge(x), 1),
            PP
          ])
        ]),
        _: 2
      }, 1024))), 128);
    };
  }
}, H6 = /* @__PURE__ */ Ae(OP, [["__scopeId", "data-v-5214cf3f"]]), mr = (c) => (dt("data-v-7f847de5"), c = c(), ut(), c), RP = { key: 0 }, zP = {
  key: 1,
  class: "form-wrap"
}, MP = ["label"], NP = ["value"], FP = ["disabled"], $P = /* @__PURE__ */ mr(() => /* @__PURE__ */ I("label", { slot: "label" }, "Strasse *", -1)), VP = [
  $P
], LP = ["disabled"], jP = /* @__PURE__ */ mr(() => /* @__PURE__ */ I("label", { slot: "label" }, "Hausnummer *", -1)), HP = [
  jP
], UP = ["disabled"], qP = /* @__PURE__ */ mr(() => /* @__PURE__ */ I("label", { slot: "label" }, "Postleitzahl *", -1)), WP = [
  qP
], GP = ["disabled"], KP = /* @__PURE__ */ mr(() => /* @__PURE__ */ I("label", { slot: "label" }, "Stadt*", -1)), ZP = [
  KP
], JP = ["disabled"], YP = /* @__PURE__ */ mr(() => /* @__PURE__ */ I("label", { slot: "label" }, "Bundesland", -1)), QP = [
  YP
], XP = {
  __name: "ShippingAdress",
  props: {
    multiAdress: { type: Boolean, default: !1 },
    items: { type: Array }
  },
  emits: ["adressInput", "itemSelection"],
  setup(c, { emit: u }) {
    const g = c, w = u, b = me({
      selectedItem: null,
      isItemSelected: !1,
      items: {}
    }), x = en(null), v = Wt();
    function C(y) {
      `${[b.selectedItem]}${[y.target.name]}`, w("adressInput", {
        [`${[b.selectedItem]}.${[y.target.name]}`]: y.target.value
      });
    }
    function p(y) {
      if (console.log(y.target.value), !y.target.value.length) {
        D();
        return;
      }
      b.selectedItem = y.target.value, b.isItemSelected = !0;
    }
    function D() {
      console.log("clearing..."), b.selectedItem = null, b.isItemSelected = !1;
    }
    return yo(() => {
      console.log(g.items);
    }), (y, A) => {
      var k, E;
      return (k = le(v).state.carts[le(v).state.basket]) != null && k.items ? (H(), G("div", zP, [
        c.multiAdress ? (H(), G("sl-select", {
          key: 0,
          multiple: "",
          clearable: "",
          ref_key: "itemSelection",
          ref: x,
          onSlChange: p,
          onSlClear: D,
          label: "Lieferadresse für: " + b.selectedItem,
          class: "grid-w-4"
        }, [
          (H(!0), G(Ve, null, kt((E = le(v).state.carts[le(v).state.basket]) == null ? void 0 : E.items, (P) => (H(), G("sl-option", {
            value: P.key
          }, ge(P.shop_name), 9, NP))), 256))
        ], 40, MP)) : Ee("", !0),
        I("sl-input", {
          name: "street",
          onSlChange: C,
          placeholder: "Straße",
          class: "grid-w-3",
          disabled: !b.isItemSelected
        }, VP, 40, FP),
        I("sl-input", {
          name: "street",
          onSlChange: C,
          placeholder: "Hausnummer",
          type: "number",
          disabled: !b.isItemSelected
        }, HP, 40, LP),
        I("sl-input", {
          name: "street",
          onSlChange: C,
          placeholder: "Postleitzahl",
          type: "number",
          class: "grid-w-2",
          disabled: !b.isItemSelected
        }, WP, 40, UP),
        I("sl-input", {
          name: "city",
          onSlChange: C,
          placeholder: "Stadt",
          class: "grid-w-2",
          disabled: !b.isItemSelected
        }, ZP, 40, GP),
        I("sl-input", {
          name: "province",
          onSlChange: C,
          placeholder: "Bundesland",
          class: "grid-w-2",
          disabled: !b.isItemSelected
        }, QP, 40, JP)
      ])) : (H(), G("sl-splinner", RP));
    };
  }
}, e4 = /* @__PURE__ */ Ae(XP, [["__scopeId", "data-v-7f847de5"]]), vt = (c) => (dt("data-v-5099c1bd"), c = c(), ut(), c), t4 = { key: 0 }, n4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("h2", { class: "viur-shop-form-input-headline headline" }, "Nutzterdaten", -1)), o4 = { class: "viur-shop-form-wrap" }, i4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("label", { slot: "label" }, "E-Mail*", -1)), r4 = [
  i4
], s4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("label", { slot: "label" }, "Name*", -1)), a4 = [
  s4
], l4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("label", { slot: "label" }, "Vorname*", -1)), c4 = [
  l4
], d4 = { class: "viur-shop-form-adress-wrapper" }, u4 = { class: "viur-shop-form-adress-column" }, h4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("h2", { class: "viur-shop-form-input-headline headline" }, "Lieferadresse", -1)), g4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("sl-icon", {
  name: "x-lg",
  slot: "prefix"
}, null, -1)), m4 = [
  g4
], p4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("sl-icon", {
  name: "plus-lg",
  slot: "prefix"
}, null, -1)), f4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("sl-icon", {
  slot: "icon",
  name: "exclamation-triangle"
}, null, -1)), b4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("br", null, null, -1)), k4 = { class: "viur-shop-form-adress-column" }, w4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("h2", { class: "viur-shop-form-headline headline" }, "Rechnungsadresse", -1)), v4 = { class: "viur-shop-form-wrap" }, _4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("label", { slot: "label" }, "Strasse *", -1)), A4 = [
  _4
], C4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("label", { slot: "label" }, "Hausnummer *", -1)), y4 = [
  C4
], E4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("label", { slot: "label" }, "Postleitzahl *", -1)), x4 = [
  E4
], S4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("label", { slot: "label" }, "Stadt*", -1)), D4 = [
  S4
], B4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("label", { slot: "label" }, "Bundesland", -1)), T4 = [
  B4
], I4 = { class: "viur-shop-form-footer" }, P4 = /* @__PURE__ */ vt(() => /* @__PURE__ */ I("sl-button", { type: "submit" }, " Zurück ", -1)), O4 = ["disabled"], R4 = {
  __name: "UserInfoMulti",
  props: {
    mode: { type: String, default: "form" }
  },
  setup(c) {
    const u = Wt(), g = me({
      formValues: {},
      requiredFieldsFilled: ce(() => {
        if (g.isCustomAdress)
          return Object.keys(g.formValues).includes("city") && Object.keys(g.formValues).includes("street") && Object.keys(g.formValues).includes("billing.city") && Object.keys(g.formValues).includes("billing.street") && Object.keys(g.formValues).includes("email") && Object.keys(g.formValues).includes("firstname") && Object.keys(g.formValues).includes("lastname");
        if (!g.isCustomAdress)
          return Object.keys(g.formValues).includes("city") && Object.keys(g.formValues).includes("street") && Object.keys(g.formValues).includes("email") && Object.keys(g.formValues).includes("firstname") && Object.keys(g.formValues).includes("lastname");
      }),
      isCustomAdress: !1,
      shippingAdressAmount: 1,
      maxShippingAdress: ce(
        () => u.state.carts[u.state.basket].items.length
      ),
      amountAlert: { title: "", msg: "" },
      items: null,
      isInit: ce(() => !!u.state.carts[u.state.basket])
    }), w = en(null);
    function b(D) {
      console.log("sende daten...", g.formValues);
    }
    function x(D) {
      D.target.checked && (g.isCustomAdress = !1), D.target.checked || (g.isCustomAdress = !0);
    }
    function v() {
      g.shippingAdressAmount += 1;
    }
    function C() {
      if (g.shippingAdressAmount === 1) {
        g.amountAlert.title = "Zu wenig Lieferadressen", g.amountAlert.msg = "Mindestens eine Lieferadresse muss angegeben werden.", w.value.show();
        return;
      }
      g.shippingAdressAmount -= 1;
    }
    function p(D) {
      console.log("emit hier", D), Object.assign(g.formValues, D);
    }
    return ui(g.formValues, (D) => {
      Object.entries(D).forEach(([y, A]) => {
        A === "" && delete g.formValues[y];
      });
    }), (D, y) => c.mode === "form" ? Pw(D.$slots, "form", { key: 0 }, () => [
      g.isInit ? (H(), G("form", {
        key: 1,
        onSubmit: Hn(b, ["prevent"])
      }, [
        n4,
        I("div", o4, [
          gt(I("sl-input", {
            name: "email",
            "onUpdate:modelValue": y[0] || (y[0] = (A) => g.formValues.email = A),
            placeholder: "E-Mail",
            class: "viur-shop-form-grid-w-4"
          }, r4, 512), [
            [Ct, g.formValues.email]
          ]),
          gt(I("sl-input", {
            name: "name",
            "onUpdate:modelValue": y[1] || (y[1] = (A) => g.formValues.lastname = A),
            placeholder: "Name",
            class: "viur-shop-form-grid-w-2"
          }, a4, 512), [
            [Ct, g.formValues.lastname]
          ]),
          gt(I("sl-input", {
            name: "firstname",
            "onUpdate:modelValue": y[2] || (y[2] = (A) => g.formValues.firstname = A),
            placeholder: "Vorname",
            class: "viur-shop-form-grid-w-2"
          }, c4, 512), [
            [Ct, g.formValues.firstname]
          ])
        ]),
        I("div", d4, [
          I("div", u4, [
            h4,
            (H(!0), G(Ve, null, kt(g.shippingAdressAmount, (A) => (H(), yt(Ow(e4), Rw({ ref_for: !0 }, {
              multiAdress: !0,
              items: le(u).state.carts[le(u).state.basket].items
            }, {
              key: A,
              onAdressInput: p,
              onItemSelection: p
            }), null, 16))), 128)),
            I("div", { class: "viur-shop-form-btn-wrap" }, [
              I("sl-button", {
                size: "medium",
                onClick: C,
                title: "Lieferadresse entfernen"
              }, m4),
              I("sl-button", {
                size: "medium",
                variant: "primary",
                onClick: v
              }, [
                p4,
                ie(" Lieferadresse hinzufügen ")
              ])
            ]),
            I("sl-alert", {
              variant: "warning",
              duration: "2000",
              ref_key: "shippingWarning",
              ref: w,
              closable: ""
            }, [
              f4,
              I("strong", null, ge(g.amountAlert.title), 1),
              b4,
              ie(" " + ge(g.amountAlert.msg), 1)
            ], 512)
          ]),
          I("sl-checkbox", {
            onSlChange: x,
            checked: ""
          }, " Rechnungsadresse wie Lieferadresse ", 32),
          gt(I("div", k4, [
            w4,
            I("div", v4, [
              gt(I("sl-input", {
                name: "street",
                "onUpdate:modelValue": y[3] || (y[3] = (A) => g.formValues["billing.street"] = A),
                placeholder: "Straße",
                class: "viur-shop-form-grid-w-3"
              }, A4, 512), [
                [Ct, g.formValues["billing.street"]]
              ]),
              gt(I("sl-input", {
                name: "street",
                "onUpdate:modelValue": y[4] || (y[4] = (A) => g.formValues["billing.streetnumber"] = A),
                placeholder: "Hausnummer",
                type: "number"
              }, y4, 512), [
                [Ct, g.formValues["billing.streetnumber"]]
              ]),
              gt(I("sl-input", {
                name: "street",
                "onUpdate:modelValue": y[5] || (y[5] = (A) => g.formValues["billing.areacode"] = A),
                placeholder: "Postleitzahl",
                type: "number",
                class: "viur-shop-form-grid-w-2"
              }, x4, 512), [
                [Ct, g.formValues["billing.areacode"]]
              ]),
              gt(I("sl-input", {
                name: "city",
                "onUpdate:modelValue": y[6] || (y[6] = (A) => g.formValues["billing.city"] = A),
                placeholder: "Stadt",
                class: "viur-shop-form-grid-w-2"
              }, D4, 512), [
                [Ct, g.formValues["billing.city"]]
              ]),
              gt(I("sl-input", {
                name: "province",
                "onUpdate:modelValue": y[7] || (y[7] = (A) => g.formValues["billing.province"] = A),
                placeholder: "Bundesland",
                class: "viur-shop-form-grid-w-2"
              }, T4, 512), [
                [Ct, g.formValues["billing.province"]]
              ])
            ])
          ], 512), [
            [Cc, g.isCustomAdress]
          ])
        ]),
        I("div", I4, [
          P4,
          I("sl-button", {
            disabled: !g.requiredFieldsFilled,
            type: "submit",
            variant: "primary"
          }, " Weiter ", 8, O4)
        ])
      ], 32)) : (H(), G("sl-spinner", t4))
    ], !0) : Ee("", !0);
  }
}, z4 = /* @__PURE__ */ Ae(R4, [["__scopeId", "data-v-5099c1bd"]]), M4 = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({});
    function b(x) {
      u.emit("change", c.name, x.target.value, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: b
    };
  }
}), N4 = ["disabled", "value"], F4 = ["disabled", "value"];
function $4(c, u, g, w, b, x) {
  var v, C;
  return c.boneState.bonestructure.type === "raw.json" ? (H(), G("sl-textarea", {
    key: 0,
    disabled: (v = c.boneState) == null ? void 0 : v.readonly,
    value: JSON.stringify(c.value),
    onInput: u[0] || (u[0] = (...p) => c.changeEvent && c.changeEvent(...p))
  }, null, 40, N4)) : (H(), G("sl-textarea", {
    key: 1,
    disabled: (C = c.boneState) == null ? void 0 : C.readonly,
    value: c.value,
    onInput: u[1] || (u[1] = (...p) => c.changeEvent && c.changeEvent(...p))
  }, null, 40, F4));
}
const gw = /* @__PURE__ */ Ae(M4, [["render", $4], ["__scopeId", "data-v-0ebe5f0b"]]), V4 = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = me({});
    function w(b) {
      u.emit("change", c.name, b.target.value, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: g,
      changeEvent: w
    };
  }
}), L4 = ["value"];
function j4(c, u, g, w, b, x) {
  return H(), G("sl-input", {
    disabled: "",
    value: c.value,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, L4);
}
const mw = /* @__PURE__ */ Ae(V4, [["render", j4], ["__scopeId", "data-v-b45a1311"]]);
function H4(c) {
  return Q5() ? (X5(c), !0) : !1;
}
function U4(c) {
  return typeof c == "function" ? c() : le(c);
}
const q4 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
function Fs(c, u, g = {}) {
  const {
    immediate: w = !0
  } = g, b = en(!1);
  let x = null;
  function v() {
    x && (clearTimeout(x), x = null);
  }
  function C() {
    b.value = !1, v();
  }
  function p(...D) {
    v(), b.value = !0, x = setTimeout(() => {
      b.value = !1, x = null, c(...D);
    }, U4(u));
  }
  return w && (b.value = !0, q4 && p()), H4(C), {
    isPending: Y5(b),
    start: p,
    stop: C
  };
}
const W4 = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({
      value: ce(() => c.value)
    }), b = en(null);
    function x(v) {
      u.emit("change", c.name, v.target.value, c.lang, c.index);
    }
    return dr(() => {
      if (c.autofocus && b.value && b.value !== null && b !== null) {
        const { start: v } = Fs(() => {
          b.value.focus();
        }, 600);
        v();
      }
    }), lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      Utils: lD,
      boneState: g,
      changeEvent: x,
      stringBone: b
    };
  }
}), G4 = ["disabled", "value", "required"];
function K4(c, u, g, w, b, x) {
  return H(), G("sl-input", {
    ref: "stringBone",
    disabled: c.boneState.readonly,
    value: c.Utils.unescape(c.value),
    required: c.boneState.bonestructure.required,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v)),
    onKeyup: u[1] || (u[1] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, G4);
}
const pw = /* @__PURE__ */ Ae(W4, [["render", K4], ["__scopeId", "data-v-1ccbacc0"]]), Z4 = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({}), b = en(null);
    function x(v) {
      u.emit("change", c.name, v.target.value, c.lang, c.index);
    }
    return dr(() => {
      if (c.autofocus && b.value && b.value !== null && b !== null) {
        const { start: v } = Fs(() => {
          b.value.focus();
        }, 600);
        v();
      }
    }), lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: x,
      emailBone: b
    };
  }
}), J4 = ["disabled", "value"];
function Y4(c, u, g, w, b, x) {
  return H(), G("sl-input", {
    ref: "emailBone",
    disabled: c.boneState.readonly,
    type: "email",
    value: c.value,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, J4);
}
const fw = /* @__PURE__ */ Ae(Z4, [["render", Y4], ["__scopeId", "data-v-4328e024"]]), Q4 = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({
      value: ce(() => {
        var v;
        let x = c.value;
        return g.bonestructure.time ? x = (v = c.value) == null ? void 0 : v.split("+")[0] : c.value && (x = new Date(c.value).toISOString().substr(0, 10)), x;
      }),
      typeString: ce(() => {
        let x = "datetime-local";
        return g.bonestructure.time || (x = "date"), x;
      })
    });
    function b(x) {
      u.emit("change", c.name, x.target.value, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: b
    };
  }
}), X4 = ["disabled", "type", "value"];
function eO(c, u, g, w, b, x) {
  return H(), G("sl-input", {
    disabled: c.boneState.readonly,
    type: c.state.typeString,
    value: c.state.value,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, X4);
}
const bw = /* @__PURE__ */ Ae(Q4, [["render", eO], ["__scopeId", "data-v-f1b8af8c"]]), tO = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: null,
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({
      value: ce(() => {
        let x = c.value;
        return Array.isArray(c.value) ? (x = x.filter((v) => g.bonestructure.values.map((C) => C[0].toString()).includes(v)), x.map((v) => v.toString())) : c.value ? c.value.toString() : "";
      })
    });
    function b(x) {
      u.emit("change", c.name, x.target.value, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, w.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: b
    };
  }
}), nO = ["disabled", "value", "multiple"], oO = ["value"];
function iO(c, u, g, w, b, x) {
  return H(), G("sl-select", {
    disabled: c.boneState.readonly,
    value: c.state.value,
    hoist: "",
    multiple: c.boneState.bonestructure.multiple,
    "max-options-visible": "0",
    clearable: "",
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, [
    (H(!0), G(Ve, null, kt(c.boneState.bonestructure.values, (v) => (H(), G("sl-option", {
      value: v[0]
    }, ge(v[1]), 9, oO))), 256))
  ], 40, nO);
}
const kw = /* @__PURE__ */ Ae(tO, [["render", iO], ["__scopeId", "data-v-20ff76f5"]]), rO = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({
      value: ce(() => ![!1, null, void 0, ""].includes(c.value))
    });
    function b(x) {
      u.emit("change", c.name, x.target.checked, c.lang, c.index);
    }
    return lt(() => {
      let x = c.value;
      x || (x = !1), u.emit("change", c.name, x, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: b
    };
  }
}), sO = ["disabled", "checked"];
function aO(c, u, g, w, b, x) {
  return H(), G("sl-switch", {
    disabled: c.boneState.readonly,
    checked: c.state.value,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, sO);
}
const ww = /* @__PURE__ */ Ae(rO, [["render", aO], ["__scopeId", "data-v-363598c8"]]), lO = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({
      value1: "",
      value2: null,
      equal: !1,
      passwordInfo: [],
      requiredPasswordInfo: []
    }), b = en(null);
    function x(C) {
      w.value1 === w.value2 ? w.equal = !0 : w.equal = !1, v(w.value1), w.requiredPasswordInfo.length === 0 && w.passwordInfo.length - w.requiredPasswordInfo.length <= g.bonestructure.test_threshold ? u.emit("change", c.name, w.value1, c.lang, c.index, !0) : u.emit("change", c.name, w.value1, c.lang, c.index, !1);
    }
    lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    });
    function v(C) {
      w.passwordInfo = [], w.requiredPasswordInfo = [];
      for (const p of g.bonestructure.tests)
        new RegExp(p[0]).test(C) || (p[2] ? w.requiredPasswordInfo.push(p[1]) : w.passwordInfo.push(p[1]));
      w.equal || w.requiredPasswordInfo.push("Die eingegebenen Passwörter stimmen nicht überein."), w.value1 || w.requiredPasswordInfo.push("Das eingegebene Passwort ist leer.");
    }
    return dr(() => {
      if (c.autofocus && b.value && b.value !== null && b !== null) {
        const { start: C } = Fs(() => {
          b.value.focus();
        }, 600);
        C();
      }
    }), ui(
      () => c.value,
      (C, p) => {
        w.value1 = C;
      }
    ), {
      state: w,
      boneState: g,
      changeEvent: x,
      passwordBone: b
    };
  }
}), cO = ["disabled"], dO = ["name"], uO = ["name"], hO = { class: "errors" };
function gO(c, u, g, w, b, x) {
  return H(), G(Ve, null, [
    gt(I("sl-input", {
      ref: "passwordBone",
      "onUpdate:modelValue": u[0] || (u[0] = (v) => c.state.value1 = v),
      disabled: c.boneState.readonly,
      class: eD({ "has-check": !c.boneState.readonly }),
      type: "password",
      clearable: "",
      "password-toggle": "true",
      onSlChange: u[1] || (u[1] = (...v) => c.changeEvent && c.changeEvent(...v)),
      onSlClear: u[2] || (u[2] = (v) => c.state.value1 = ""),
      onKeyup: u[3] || (u[3] = (...v) => c.changeEvent && c.changeEvent(...v))
    }, [
      I("sl-icon", {
        slot: "suffix",
        name: c.state.equal && c.state.value1.length ? "check" : "x"
      }, null, 8, dO)
    ], 42, cO), [
      [Ct, c.state.value1]
    ]),
    c.boneState.readonly ? Ee("", !0) : gt((H(), G("sl-input", {
      key: 0,
      "onUpdate:modelValue": u[4] || (u[4] = (v) => c.state.value2 = v),
      class: "password-check",
      type: "password",
      clearable: "",
      "password-toggle": "true",
      onSlChange: u[5] || (u[5] = (...v) => c.changeEvent && c.changeEvent(...v)),
      onSlClear: u[6] || (u[6] = (v) => c.state.value2 = ""),
      onKeyup: u[7] || (u[7] = (...v) => c.changeEvent && c.changeEvent(...v))
    }, [
      I("sl-icon", {
        slot: "suffix",
        name: c.state.equal && c.state.value1.length ? "check" : "x"
      }, null, 8, uO)
    ], 544)), [
      [Ct, c.state.value2]
    ]),
    I("ul", hO, [
      (H(!0), G(Ve, null, kt(c.state.passwordInfo, (v, C) => (H(), G("li", { key: C }, ge(v), 1))), 128)),
      (H(!0), G(Ve, null, kt(c.state.requiredPasswordInfo, (v, C) => (H(), G("li", {
        key: C,
        class: "requiredInfo"
      }, ge(v), 1))), 128))
    ])
  ], 64);
}
const vw = /* @__PURE__ */ Ae(lO, [["render", gO], ["__scopeId", "data-v-0ccf18c0"]]), mO = Ye({
  props: {
    name: String,
    value: null,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({
      value: ce(() => c.value),
      structure: ce(() => v(g.bonestructure.using)),
      globalRegistration: !1,
      formGroups: ce(() => {
        var D;
        let C = { default: { name: "Allgemein", bones: [], groupVisible: !1, groupOpen: !0 } };
        for (const [y, A] of Object.entries(w.structure)) {
          let k = "default", E = w.structure[y], P = w.value[y];
          (D = A == null ? void 0 : A.params) != null && D.category && (k = A.params.category.toLowerCase()), Object.keys(C).includes(k) ? C[k].bones.push({
            boneName: y,
            boneStructure: E,
            boneValue: P
          }) : C[k] = {
            name: A.params.category,
            bones: [
              {
                boneName: y,
                boneStructure: E,
                boneValue: P
              }
            ]
          }, E.visible === !0 && (C[k].groupVisible = !0);
        }
        let p = {};
        return Object.keys(C).sort().forEach(function(y) {
          p[y] = C[y];
        }), p;
      })
    });
    function b(C) {
      u.emit("change", C);
    }
    lt(() => {
      Nc().appContext.components.Bone ? w.globalRegistration = !0 : w.globalRegistration = !1, u.emit("change", c.name, c.value, c.lang, c.index);
    });
    function x(C) {
      console.log(C);
    }
    function v(C) {
      if (Array.isArray(C)) {
        let p = {};
        for (const D in C)
          p[C[D][0]] = C[D][1];
        return p;
      } else
        return C;
    }
    return {
      state: w,
      boneState: g,
      getBoneWidget: zc,
      structureToDict: v,
      changeEvent: b,
      updateValue: x
    };
  }
}), pO = {
  key: 0,
  open: "",
  variant: "danger"
}, fO = {
  key: 1,
  class: "form"
}, bO = ["summary", "open"];
function kO(c, u, g, w, b, x) {
  const v = hi("bone");
  return c.state.globalRegistration ? (H(), G("div", fO, [
    (H(!0), G(Ve, null, kt(c.state.formGroups, (C, p) => gt((H(), G("sl-details", {
      key: p,
      summary: C.name,
      open: C.groupOpen
    }, [
      (H(!0), G(Ve, null, kt(C.bones, (D) => gt((H(), yt(v, {
        key: D.name,
        is: c.getBoneWidget(c.state.structure[D.boneName].type),
        name: D.boneName,
        structure: c.state.structure,
        skel: c.state.value,
        errors: c.boneState.errors,
        readonly: c.boneState.bonestructure.readonly ? !0 : void 0,
        onChangeInternal: c.changeEvent
      }, null, 8, ["is", "name", "structure", "skel", "errors", "readonly", "onChangeInternal"])), [
        [Cc, c.state.structure[D.boneName].visible]
      ])), 128))
    ], 8, bO)), [
      [Cc, C.groupVisible]
    ])), 128))
  ])) : (H(), G("sl-alert", pO, " In Order to use this Bone register the bone component globally in your main file "));
}
const A0 = /* @__PURE__ */ Ae(mO, [["render", kO], ["__scopeId", "data-v-26bd4fa7"]]), wO = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: null,
    index: Number,
    lang: String
  },
  components: { Wrapper_nested: A0 },
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({
      value: {},
      index: ce(() => c.index),
      lang: ce(() => c.lang)
    });
    function b(x) {
      var C;
      (C = w.value) != null && C[x.name] || (w.value ? w.value[x.name] = null : w.value = { [x.name]: null });
      let v = w.value[x.name];
      x.lang ? (v === null && (v = {}), Object.keys(v).includes(x.lang) && x.index !== null ? v[x.lang][x.index] = x.value : v[x.lang] = x.value) : x.index !== null ? (v === null && (v = []), v[x.index] = x.value) : v = x.value, w.value[x.name] = v, u.emit("change", c.name, w.value, c.lang, c.index, !0);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: b
    };
  }
});
function vO(c, u, g, w, b, x) {
  const v = hi("Wrapper_nested");
  return H(), yt(v, {
    value: c.value,
    name: c.name,
    index: c.state.index,
    disabled: c.boneState.bonestructure.readonly,
    onChange: c.changeEvent
  }, null, 8, ["value", "name", "index", "disabled", "onChange"]);
}
const _w = /* @__PURE__ */ Ae(wO, [["render", vO], ["__scopeId", "data-v-84a761ce"]]), _O = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({});
    function b(x) {
      u.emit("change", c.name, x.target.value, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: b
    };
  }
}), AO = ["disabled", "value"];
function CO(c, u, g, w, b, x) {
  return H(), G("sl-color-picker", {
    disabled: c.boneState.readonly,
    value: c.value,
    onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v))
  }, null, 40, AO);
}
const Aw = /* @__PURE__ */ Ae(_O, [["render", CO], ["__scopeId", "data-v-534b9149"]]), yO = Ye({
  inheritAttrs: !1,
  emits: { change: null },
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  setup(c, u) {
    const g = Be("boneState"), w = me({
      minAmount: ce(() => g.bonestructure.minAmount),
      maxAmount: ce(() => g.bonestructure.maxAmount),
      precision: ce(() => {
        if (g.bonestructure.precision > 1)
          return parseFloat(`0.${"0".repeat(g.bonestructure.precision - 1)}1`);
      })
    }), b = en(null);
    function x(v) {
      u.emit("change", c.name, v.target.value, c.lang, c.index);
    }
    return dr(() => {
      if (c.autofocus && b.value && b.value !== null && b !== null) {
        const { start: v } = Fs(() => {
          b.value.focus();
        }, 600);
        v();
      }
    }), lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: x,
      numericBone: b
    };
  }
}), EO = ["disabled", "value", "min", "max", "step"], xO = { class: "info" }, SO = { key: 0 }, DO = { key: 1 }, BO = { key: 2 };
function TO(c, u, g, w, b, x) {
  return H(), G(Ve, null, [
    I("sl-input", {
      ref: "numericBone",
      type: "number",
      disabled: c.boneState.readonly,
      value: c.value,
      min: c.state.minAmount,
      max: c.state.maxAmount,
      step: c.state.precision,
      onSlChange: u[0] || (u[0] = (...v) => c.changeEvent && c.changeEvent(...v)),
      onKeyup: u[1] || (u[1] = (...v) => c.changeEvent && c.changeEvent(...v))
    }, null, 40, EO),
    I("ul", xO, [
      c.state.minAmount !== -9223372036854776e3 ? (H(), G("li", SO, ge(c.$t("bones.numeric.min", { val: c.state.minAmount })), 1)) : Ee("", !0),
      c.state.maxAmount !== 9223372036854776e3 ? (H(), G("li", DO, ge(c.$t("bones.numeric.max", { val: c.state.maxAmount })), 1)) : Ee("", !0),
      c.state.precision ? (H(), G("li", BO, ge(c.$t("bones.numeric.precision", { val: c.boneState.bonestructure.precision })), 1)) : Ee("", !0)
    ])
  ], 64);
}
const Cw = /* @__PURE__ */ Ae(yO, [["render", TO], ["__scopeId", "data-v-086ce547"]]), IO = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: { Wrapper_nested: A0 },
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = Be("formatString"), b = me({
      format: ce(() => g == null ? void 0 : g.bonestructure.format),
      skellistdata: null,
      selection: null
    });
    function x(p) {
      let D = "";
      return g.bonestructure.type === "relational.tree.leaf.file" ? D = "skelType=leaf&" : g.bonestructure.type === "relational.tree.node.file" && (D = "skelType=node&"), he.get(
        `/json/${g.bonestructure.module}/list?${D}limit=99`
      ).then(async (y) => {
        var k;
        const A = await y.json();
        b.skellistdata = {};
        for (let E of A.skellist)
          b.skellistdata[E.key] = E;
        return (k = A.skellist) == null ? void 0 : k.map((E) => ({ text: w(g.bonestructure.format, { dest: E }), value: E.key, data: E }));
      });
    }
    function v(p) {
      b.selection = { dest: b.skellistdata[p.detail.item.value] }, u.emit("change", c.name, b.selection, c.lang, c.index);
    }
    function C(p) {
      var y;
      b.selection || (b.selection = {}), (y = b.selection.rel) != null && y[p.name] || (b.selection.rel ? b.selection.rel[p.name] = null : b.selection.rel = { [p.name]: null });
      let D = b.selection.rel[p.name];
      p.lang ? (D === null && (D = {}), Object.keys(D).includes(p.lang) && p.index !== null ? D[p.lang][p.index] = p.value : D[p.lang] = p.value) : p.index !== null ? (D === null && (D = []), D[p.index] = p.value) : D = p.value, Object.keys(b.selection).includes("rel") && b.selection.rel ? b.selection.rel[p.name] = D : b.selection.rel = { [p.name]: D }, Object.keys(b.selection).includes("dest") && u.emit("change", c.name, b.selection, c.lang, c.index);
    }
    return lt(() => {
      b.selection = c.value, u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: b,
      boneState: g,
      formatString: w,
      changeEvent: v,
      changeEventNested: C,
      getList: x
    };
  }
}), PO = (c) => (dt("data-v-61dd72e0"), c = c(), ut(), c), OO = { class: "record" }, RO = { class: "single-entry" }, zO = ["value"], MO = ["disabled", "source"], NO = ["title"], FO = /* @__PURE__ */ PO(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), $O = [
  FO
];
function VO(c, u, g, w, b, x) {
  var C, p;
  const v = hi("Wrapper_nested");
  return H(), G("div", OO, [
    I("div", RO, [
      c.state.selection ? (H(), G("sl-input", {
        key: 0,
        disabled: !0,
        value: c.value ? c.formatString(c.state.format, c.state.selection) : ""
      }, null, 8, zO)) : (H(), G("sl-combobox", {
        key: 1,
        disabled: c.boneState.readonly,
        source: c.getList,
        hoist: "",
        onSlItemSelect: u[0] || (u[0] = (...D) => c.changeEvent && c.changeEvent(...D))
      }, null, 40, MO)),
      !c.boneState.multiple && !c.boneState.isEmpty ? (H(), G("sl-button", {
        key: 2,
        variant: "danger",
        outline: "",
        title: c.$t("bone.del"),
        class: "delete-btn square-btn",
        onClick: u[1] || (u[1] = () => {
          c.$emit("change", c.name, "", c.lang, c.index), c.state.selection = null;
        })
      }, $O, 8, NO)) : Ee("", !0)
    ]),
    (C = c.boneState) != null && C.bonestructure.using ? (H(), yt(v, {
      key: 0,
      value: (p = c.value) == null ? void 0 : p.rel,
      name: c.name,
      index: c.index,
      disabled: c.boneState.bonestructure.readonly,
      onChange: c.changeEventNested
    }, null, 8, ["value", "name", "index", "disabled", "onChange"])) : Ee("", !0)
  ]);
}
const yw = /* @__PURE__ */ Ae(IO, [["render", VO], ["__scopeId", "data-v-61dd72e0"]]), LO = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({});
    function b(x, v) {
      u.emit("change", c.name, x, c.lang, c.index);
    }
    return lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: b
    };
  }
}), jO = { class: "box" };
function HO(c, u, g, w, b, x) {
  return H(), G("div", jO, ge(c.value), 1);
}
const UO = /* @__PURE__ */ Ae(LO, [["render", HO], ["__scopeId", "data-v-343aca69"]]), qO = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = en(), b = me({
      loading: !1,
      droparea: !1,
      previewopen: !1
    });
    lt(() => {
      u.emit("change", c.name, c.value, c.lang, c.index);
    });
    function x() {
      console.log(he.downloadUrlFor(c.value)), window.open(he.downloadUrlFor(c.value));
    }
    function v() {
      return he.downloadUrlFor(c.value, !1);
    }
    function C(y) {
      const A = {
        fileName: y.name,
        mimeType: y.type || "application/octet-stream",
        size: y.size.toString()
      };
      return new Promise((k, E) => {
        he.securePost("/json/file/getUploadURL", { dataObj: A }).then(async (P) => {
          let z = await P.json();
          fetch(z.values.uploadUrl, {
            body: y,
            method: "POST",
            mode: "no-cors"
          }).then(async (M) => {
            const F = {
              key: z.values.uploadKey,
              node: void 0,
              skelType: "leaf"
            };
            he.securePost("/json/file/add", { dataObj: F }).then(async (V) => {
              let j = await V.json();
              j.action === "addSuccess" ? k(j.values) : E(j);
            }).catch((V) => {
              E(V);
            });
          }).catch((M) => {
            E(M);
          });
        }).catch((P) => {
          E(P);
        });
      });
    }
    async function p(y) {
      b.loading = !0;
      for (let A of y.target.files) {
        let k = await C(A);
        u.emit("change", c.name, { dest: k, rel: null }, c.lang, c.index);
      }
      b.loading = !1;
    }
    async function D(y) {
      b.loading = !0, b.droparea = !1;
      for (let A of y.dataTransfer.files) {
        let k = await C(A);
        u.emit("change", c.name, { dest: k, rel: null }, c.lang, c.index);
        break;
      }
      b.loading = !1;
    }
    return {
      state: b,
      boneState: g,
      downloadFile: x,
      createBackgroundImage: v,
      handleUpload: p,
      uploadinput: w,
      handleDrop: D
    };
  }
}), $s = (c) => (dt("data-v-feddfc55"), c = c(), ut(), c), WO = {
  key: 0,
  class: "loader"
}, GO = /* @__PURE__ */ $s(() => /* @__PURE__ */ I("sl-spinner", { slot: "suffix" }, null, -1)), KO = [
  GO
], ZO = {
  key: 1,
  class: "droparea"
}, JO = ["title"], YO = /* @__PURE__ */ $s(() => /* @__PURE__ */ I("sl-icon", { name: "upload" }, null, -1)), QO = [
  YO
], XO = ["multiple"], e7 = ["title"], t7 = /* @__PURE__ */ $s(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  name: "download"
}, null, -1)), n7 = [
  t7
], o7 = { class: "box" }, i7 = ["src"], r7 = ["label", "open"], s7 = ["src"], a7 = {
  key: 1,
  class: "preview"
}, l7 = {
  key: 0,
  name: "file-earmark"
}, c7 = { key: 2 }, d7 = ["title"], u7 = /* @__PURE__ */ $s(() => /* @__PURE__ */ I("sl-icon", { name: "x-lg" }, null, -1)), h7 = [
  u7
];
function g7(c, u, g, w, b, x) {
  var v, C, p, D, y, A, k, E, P, z;
  return H(), G("div", {
    class: "file-wrapper",
    onDragover: u[5] || (u[5] = Hn((M) => c.state.droparea = !0, ["prevent"])),
    onDragleave: u[6] || (u[6] = (M) => c.state.droparea = !1),
    onDrop: u[7] || (u[7] = Hn((...M) => c.handleDrop && c.handleDrop(...M), ["prevent"]))
  }, [
    c.state.loading ? (H(), G("div", WO, KO)) : Ee("", !0),
    c.state.droparea ? (H(), G("div", ZO, " Dateien hier hinziehen ")) : Ee("", !0),
    !c.boneState.readonly && (!c.value || c.state.loading) ? (H(), G("sl-button", {
      key: 2,
      title: c.$t("bone.upload"),
      outline: "",
      class: "upload-btn",
      onClick: u[0] || (u[0] = (M) => c.uploadinput.click())
    }, QO, 8, JO)) : Ee("", !0),
    I("input", {
      ref: "uploadinput",
      hidden: "",
      type: "file",
      multiple: c.boneState.multiple,
      onChange: u[1] || (u[1] = (...M) => c.handleUpload && c.handleUpload(...M))
    }, null, 40, XO),
    c.value ? (H(), G("sl-button", {
      key: 3,
      title: c.$t("bone.download"),
      onClick: u[2] || (u[2] = (...M) => c.downloadFile && c.downloadFile(...M))
    }, n7, 8, e7)) : Ee("", !0),
    I("div", o7, [
      (C = (v = c.value) == null ? void 0 : v.dest) != null && C.mimetype.includes("image") ? (H(), G("div", {
        key: 0,
        class: "preview has-preview",
        onClick: u[3] || (u[3] = (M) => c.state.previewopen = !c.state.previewopen)
      }, [
        I("img", {
          class: "preview-img",
          src: c.createBackgroundImage(),
          alt: ""
        }, null, 8, i7),
        I("sl-dialog", {
          label: decodeURIComponent((D = (p = c.value) == null ? void 0 : p.dest) == null ? void 0 : D.name),
          class: "preview-overlay",
          open: c.state.previewopen
        }, [
          I("img", {
            src: c.createBackgroundImage(),
            alt: ""
          }, null, 8, s7)
        ], 8, r7)
      ])) : (H(), G("div", a7, [
        (A = (y = c.value) == null ? void 0 : y.dest) != null && A.name ? (H(), G("sl-icon", l7)) : Ee("", !0)
      ])),
      (E = (k = c.value) == null ? void 0 : k.dest) != null && E.name ? (H(), G("div", c7, ge(decodeURIComponent((z = (P = c.value) == null ? void 0 : P.dest) == null ? void 0 : z.name)), 1)) : Ee("", !0)
    ]),
    c.boneState.multiple ? Ee("", !0) : (H(), G("sl-button", {
      key: 4,
      variant: "danger",
      outline: "",
      title: c.$t("bone.del"),
      class: "delete-btn",
      onClick: u[4] || (u[4] = (M) => c.$emit("change", c.name, "", c.lang, c.index))
    }, h7, 8, d7))
  ], 32);
}
const Ew = /* @__PURE__ */ Ae(qO, [["render", g7], ["__scopeId", "data-v-feddfc55"]]);
var Ds = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function m7(c) {
  return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c;
}
var Os = { exports: {} };
Os.exports;
(function(c, u) {
  (function(g) {
    const w = g.de = g.de || {};
    w.dictionary = Object.assign(w.dictionary || {}, { "%0 of %1": "%0 von %1", "Align cell text to the bottom": "Zellentext unten ausrichten", "Align cell text to the center": "Zellentext zentriert ausrichten", "Align cell text to the left": "Zellentext linksbündig ausrichten", "Align cell text to the middle": "Zellentext mittig ausrichten", "Align cell text to the right": "Zellentext rechtsbündig ausrichten", "Align cell text to the top": "Zellentext oben ausrichten", "Align center": "Zentriert", "Align left": "Linksbündig", "Align right": "Rechtsbündig", "Align table to the left": "Tabelle links ausrichten", "Align table to the right": "Tabelle rechts ausrichten", Alignment: "Ausrichtung", Aquamarine: "Aquamarinblau", Background: "Hintergrund", Black: "Schwarz", "Block quote": "Blockzitat", Blue: "Blau", Bold: "Fett", Border: "Rahmen", "Break text": "Bild teilt Text", "Bulleted List": "Aufzählungsliste", "Bulleted list styles toolbar": "Darstellung der ungeordneten Liste", Cancel: "Abbrechen", "Cannot upload file:": "Die Datei kann nicht hochgeladen werden:", "Caption for image: %0": "Bildunterschrift: %0", "Caption for the image": "Bildunterschrift", "Cell properties": "Zelleneigenschaften", "Center table": "Tabelle zentrieren", "Centered image": "Zentriertes Bild", "Change image text alternative": "Alternativtext ändern", "Choose heading": "Überschrift auswählen", Circle: "Leerer Kreis", Code: "Code", Color: "Farbe", "Color picker": "Farbwähler", Column: "Spalte", Dashed: "Gestrichelt", Decimal: "Dezimalzahlen", "Decimal with leading zero": "Dezimalzahlen mit vorangestellten Nullen", "Decrease indent": "Einzug verkleinern", "Delete column": "Spalte löschen", "Delete row": "Zeile löschen", "Dim grey": "Dunkelgrau", Dimensions: "Größe", Disc: "Gefüllter Kreis", Dotted: "Gepunktet", Double: "Doppelt", Downloadable: "Herunterladbar", "Dropdown toolbar": "Dropdown-Liste Werkzeugleiste", "Edit block": "Absatz bearbeiten", "Edit link": "Link bearbeiten", "Editor block content toolbar": "Editor Blockinhalt-Toolbar", "Editor contextual toolbar": "Editor kontextuelle Toolbar", "Editor editing area: %0": "Bearbeitungsbereich des Editors: %0", "Editor toolbar": "Editor Werkzeugleiste", "Enter image caption": "Bildunterschrift eingeben", "Enter table caption": "Tabellenüberschrift eingeben", "Full size image": "Bild in voller Größe", Green: "Grün", Grey: "Grau", Groove: "Eingeritzt", "Header column": "Kopfspalte", "Header row": "Kopfzeile", Heading: "Überschrift", "Heading 1": "Überschrift 1", "Heading 2": "Überschrift 2", "Heading 3": "Überschrift 3", "Heading 4": "Überschrift 4", "Heading 5": "Überschrift 5", "Heading 6": "Überschrift 6", Height: "Höhe", HEX: "", "Horizontal text alignment toolbar": "Werkzeugleiste für die horizontale Zellentext-Ausrichtung", "HTML object": "HTML-Objekt", "Image resize list": "Bildgrößen-Liste", "Image toolbar": "Bild Werkzeugleiste", "image widget": "Bild-Steuerelement", "In line": "Text in Zeile", "Increase indent": "Einzug vergrößern", Insert: "Einfügen", "Insert column left": "Spalte links einfügen", "Insert column right": "Spalte rechts einfügen", "Insert image": "Bild einfügen", "Insert image via URL": "Bild von URL einfügen", "Insert paragraph after block": "Absatz nach Block einfügen", "Insert paragraph before block": "Absatz vor Block einfügen", "Insert row above": "Zeile oben einfügen", "Insert row below": "Zeile unten einfügen", "Insert table": "Tabelle einfügen", Inset: "Eingelassen", Italic: "Kursiv", Justify: "Blocksatz", "Justify cell text": "Zellentext als Blocksatz ausrichten", "Left aligned image": "Linksbündiges Bild", "Light blue": "Hellblau", "Light green": "Hellgrün", "Light grey": "Hellgrau", Link: "Link", "Link image": "Bild verlinken", "Link URL": "Link Adresse", "List properties": "Listeneigenschaften", "Lower-latin": "Kleingeschriebene lateinische Buchstaben", "Lower–roman": "Kleingeschriebene römische Zahlen", "Merge cell down": "Zelle unten verbinden", "Merge cell left": "Zelle links verbinden", "Merge cell right": "Zelle rechts verbinden", "Merge cell up": "Zelle verbinden", "Merge cells": "Zellen verbinden", Next: "Nächste", None: "Kein Rahmen", "Numbered List": "Nummerierte Liste", "Numbered list styles toolbar": "Darstellung der geordneten Liste", "Open in a new tab": "In neuem Tab öffnen", "Open link in new tab": "Link im neuen Tab öffnen", Orange: "Orange", Original: "Original", Outset: "Geprägt", Padding: "Innenabstand", Paragraph: "Absatz", "Press Enter to type after or press Shift + Enter to type before the widget": "Drücken Sie die Eingabetaste, um nach dem Widget zu tippen oder Shift + Eingabetaste, um vor dem Widget zu tippen.", Previous: "vorherige", Purple: "Violett", Red: "Rot", Redo: "Wiederherstellen", "Remove color": "Farbe entfernen", "Remove Format": "Formatierung entfernen", "Resize image": "Bildgröße ändern", "Resize image to %0": "Bildgröße ändern in %0", "Resize image to the original size": "Bild in Originalgröße ändern", "Restore default": "Standard wiederherstellen", "Reversed order": "Umgekehrte Reihenfolge", "Rich Text Editor": "Rich Text Editor", Ridge: "Hervorgehoben", "Right aligned image": "Rechtsbündiges Bild", Row: "Zeile", Save: "Speichern", "Select all": "Alles auswählen", "Select column": "Spalte auswählen", "Select row": "Zeile auswählen", "Show more items": "Mehr anzeigen", "Side image": "Seitenbild", Solid: "Durchgezogen", "Split cell horizontally": "Zelle horizontal teilen", "Split cell vertically": "Zelle vertikal teilen", Square: "Quadrat", "Start at": "Beginnen mit", "Start index must be greater than 0.": "Der Startwert muss größer als 0 sein.", Strikethrough: "Durchgestrichen", Style: "Rahmenart", Subscript: "Tiefgestellt", Superscript: "Hochgestellt", "Table alignment toolbar": "Werkzeugleiste für die Tabellen-Ausrichtung", "Table cell text alignment": "Ausrichtung des Zellentextes", "Table properties": "Tabelleneigenschaften", "Table toolbar": "Tabelle Werkzeugleiste", "Text alignment": "Textausrichtung", "Text alignment toolbar": "Text-Ausrichtung Toolbar", "Text alternative": "Alternativtext", 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': "Die Farbe ist ungültig. Probieren Sie „#FF0000“ oder „rgb(255,0,0)“ oder „red“.", 'The value is invalid. Try "10px" or "2em" or simply "2".': "Der Wert ist ungültig. Probieren Sie „10px“ oder „2em“ oder „2“.", "This link has no URL": "Dieser Link hat keine Adresse", "To-do List": "Aufgabenliste", "Toggle caption off": "Tabellenüberschrift deaktivieren", "Toggle caption on": "Tabellenüberschrift aktivieren", "Toggle the circle list style": "Leeren Kreis einstellen", "Toggle the decimal list style": "Dezimalzahlen einstellen", "Toggle the decimal with leading zero list style": "Dezimalzahlen mit vorangestellten Nullen einstellen", "Toggle the disc list style": "Gefüllten Kreis einstellen", "Toggle the lower–latin list style": "Kleingeschriebene lateinische Buchstaben einstellen", "Toggle the lower–roman list style": "Kleingeschriebene römische Zahlen einstellen", "Toggle the square list style": "Quadrat einstellen", "Toggle the upper–latin list style": "Großgeschriebene lateinische Buchstaben einstellen", "Toggle the upper–roman list style": "Großgeschriebene römische Zahlen einstellen", Turquoise: "Türkis", "Type or paste your content here.": "Hier Inhalt einfügen.", "Type your title": "Titel eingeben", Underline: "Unterstrichen", Undo: "Rückgängig", Unlink: "Link entfernen", Update: "Aktualisieren", "Update image URL": "Bild-URL aktualisieren", "Upload failed": "Hochladen fehlgeschlagen", "Upload in progress": "Upload läuft", "Upper-latin": "Großgeschriebene lateinische Buchstaben", "Upper-roman": "Großgeschriebene römische Zahlen", "Vertical text alignment toolbar": "Werkzeugleiste für die vertikale Zellentext-Ausrichtung", White: "Weiß", "Widget toolbar": "Widget Werkzeugleiste", Width: "Breite", "Wrap text": "Text umfließt Bild", Yellow: "Gelb" }), w.getPluralForm = function(b) {
      return b != 1;
    };
  })(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})), /*!
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md.
   */
  function(g, w) {
    c.exports = w();
  }(self, () => (() => {
    var g = { 4959: (v, C, p) => {
      const D = p(1103), y = {};
      for (const k of Object.keys(D))
        y[D[k]] = k;
      const A = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
      v.exports = A;
      for (const k of Object.keys(A)) {
        if (!("channels" in A[k]))
          throw new Error("missing channels property: " + k);
        if (!("labels" in A[k]))
          throw new Error("missing channel labels property: " + k);
        if (A[k].labels.length !== A[k].channels)
          throw new Error("channel and label counts mismatch: " + k);
        const { channels: E, labels: P } = A[k];
        delete A[k].channels, delete A[k].labels, Object.defineProperty(A[k], "channels", { value: E }), Object.defineProperty(A[k], "labels", { value: P });
      }
      A.rgb.hsl = function(k) {
        const E = k[0] / 255, P = k[1] / 255, z = k[2] / 255, M = Math.min(E, P, z), F = Math.max(E, P, z), V = F - M;
        let j, Z;
        F === M ? j = 0 : E === F ? j = (P - z) / V : P === F ? j = 2 + (z - E) / V : z === F && (j = 4 + (E - P) / V), j = Math.min(60 * j, 360), j < 0 && (j += 360);
        const ne = (M + F) / 2;
        return Z = F === M ? 0 : ne <= 0.5 ? V / (F + M) : V / (2 - F - M), [j, 100 * Z, 100 * ne];
      }, A.rgb.hsv = function(k) {
        let E, P, z, M, F;
        const V = k[0] / 255, j = k[1] / 255, Z = k[2] / 255, ne = Math.max(V, j, Z), se = ne - Math.min(V, j, Z), X = function(de) {
          return (ne - de) / 6 / se + 0.5;
        };
        return se === 0 ? (M = 0, F = 0) : (F = se / ne, E = X(V), P = X(j), z = X(Z), V === ne ? M = z - P : j === ne ? M = 0.3333333333333333 + E - z : Z === ne && (M = 0.6666666666666666 + P - E), M < 0 ? M += 1 : M > 1 && (M -= 1)), [360 * M, 100 * F, 100 * ne];
      }, A.rgb.hwb = function(k) {
        const E = k[0], P = k[1];
        let z = k[2];
        const M = A.rgb.hsl(k)[0], F = 1 / 255 * Math.min(E, Math.min(P, z));
        return z = 1 - 0.00392156862745098 * Math.max(E, Math.max(P, z)), [M, 100 * F, 100 * z];
      }, A.rgb.cmyk = function(k) {
        const E = k[0] / 255, P = k[1] / 255, z = k[2] / 255, M = Math.min(1 - E, 1 - P, 1 - z);
        return [100 * ((1 - E - M) / (1 - M) || 0), 100 * ((1 - P - M) / (1 - M) || 0), 100 * ((1 - z - M) / (1 - M) || 0), 100 * M];
      }, A.rgb.keyword = function(k) {
        const E = y[k];
        if (E)
          return E;
        let P, z = 1 / 0;
        for (const V of Object.keys(D)) {
          const j = D[V], Z = (F = j, ((M = k)[0] - F[0]) ** 2 + (M[1] - F[1]) ** 2 + (M[2] - F[2]) ** 2);
          Z < z && (z = Z, P = V);
        }
        var M, F;
        return P;
      }, A.keyword.rgb = function(k) {
        return D[k];
      }, A.rgb.xyz = function(k) {
        let E = k[0] / 255, P = k[1] / 255, z = k[2] / 255;
        return E = E > 0.04045 ? ((E + 0.055) / 1.055) ** 2.4 : E / 12.92, P = P > 0.04045 ? ((P + 0.055) / 1.055) ** 2.4 : P / 12.92, z = z > 0.04045 ? ((z + 0.055) / 1.055) ** 2.4 : z / 12.92, [100 * (0.4124 * E + 0.3576 * P + 0.1805 * z), 100 * (0.2126 * E + 0.7152 * P + 0.0722 * z), 100 * (0.0193 * E + 0.1192 * P + 0.9505 * z)];
      }, A.rgb.lab = function(k) {
        const E = A.rgb.xyz(k);
        let P = E[0], z = E[1], M = E[2];
        return P /= 95.047, z /= 100, M /= 108.883, P = P > 8856e-6 ? P ** 0.3333333333333333 : 7.787 * P + 0.13793103448275862, z = z > 8856e-6 ? z ** 0.3333333333333333 : 7.787 * z + 0.13793103448275862, M = M > 8856e-6 ? M ** 0.3333333333333333 : 7.787 * M + 0.13793103448275862, [116 * z - 16, 500 * (P - z), 200 * (z - M)];
      }, A.hsl.rgb = function(k) {
        const E = k[0] / 360, P = k[1] / 100, z = k[2] / 100;
        let M, F, V;
        if (P === 0)
          return V = 255 * z, [V, V, V];
        M = z < 0.5 ? z * (1 + P) : z + P - z * P;
        const j = 2 * z - M, Z = [0, 0, 0];
        for (let ne = 0; ne < 3; ne++)
          F = E + 0.3333333333333333 * -(ne - 1), F < 0 && F++, F > 1 && F--, V = 6 * F < 1 ? j + 6 * (M - j) * F : 2 * F < 1 ? M : 3 * F < 2 ? j + (M - j) * (0.6666666666666666 - F) * 6 : j, Z[ne] = 255 * V;
        return Z;
      }, A.hsl.hsv = function(k) {
        const E = k[0];
        let P = k[1] / 100, z = k[2] / 100, M = P;
        const F = Math.max(z, 0.01);
        return z *= 2, P *= z <= 1 ? z : 2 - z, M *= F <= 1 ? F : 2 - F, [E, 100 * (z === 0 ? 2 * M / (F + M) : 2 * P / (z + P)), 100 * ((z + P) / 2)];
      }, A.hsv.rgb = function(k) {
        const E = k[0] / 60, P = k[1] / 100;
        let z = k[2] / 100;
        const M = Math.floor(E) % 6, F = E - Math.floor(E), V = 255 * z * (1 - P), j = 255 * z * (1 - P * F), Z = 255 * z * (1 - P * (1 - F));
        switch (z *= 255, M) {
          case 0:
            return [z, Z, V];
          case 1:
            return [j, z, V];
          case 2:
            return [V, z, Z];
          case 3:
            return [V, j, z];
          case 4:
            return [Z, V, z];
          case 5:
            return [z, V, j];
        }
      }, A.hsv.hsl = function(k) {
        const E = k[0], P = k[1] / 100, z = k[2] / 100, M = Math.max(z, 0.01);
        let F, V;
        V = (2 - P) * z;
        const j = (2 - P) * M;
        return F = P * M, F /= j <= 1 ? j : 2 - j, F = F || 0, V /= 2, [E, 100 * F, 100 * V];
      }, A.hwb.rgb = function(k) {
        const E = k[0] / 360;
        let P = k[1] / 100, z = k[2] / 100;
        const M = P + z;
        let F;
        M > 1 && (P /= M, z /= M);
        const V = Math.floor(6 * E), j = 1 - z;
        F = 6 * E - V, 1 & V && (F = 1 - F);
        const Z = P + F * (j - P);
        let ne, se, X;
        switch (V) {
          default:
          case 6:
          case 0:
            ne = j, se = Z, X = P;
            break;
          case 1:
            ne = Z, se = j, X = P;
            break;
          case 2:
            ne = P, se = j, X = Z;
            break;
          case 3:
            ne = P, se = Z, X = j;
            break;
          case 4:
            ne = Z, se = P, X = j;
            break;
          case 5:
            ne = j, se = P, X = Z;
        }
        return [255 * ne, 255 * se, 255 * X];
      }, A.cmyk.rgb = function(k) {
        const E = k[0] / 100, P = k[1] / 100, z = k[2] / 100, M = k[3] / 100;
        return [255 * (1 - Math.min(1, E * (1 - M) + M)), 255 * (1 - Math.min(1, P * (1 - M) + M)), 255 * (1 - Math.min(1, z * (1 - M) + M))];
      }, A.xyz.rgb = function(k) {
        const E = k[0] / 100, P = k[1] / 100, z = k[2] / 100;
        let M, F, V;
        return M = 3.2406 * E + -1.5372 * P + -0.4986 * z, F = -0.9689 * E + 1.8758 * P + 0.0415 * z, V = 0.0557 * E + -0.204 * P + 1.057 * z, M = M > 31308e-7 ? 1.055 * M ** 0.4166666666666667 - 0.055 : 12.92 * M, F = F > 31308e-7 ? 1.055 * F ** 0.4166666666666667 - 0.055 : 12.92 * F, V = V > 31308e-7 ? 1.055 * V ** 0.4166666666666667 - 0.055 : 12.92 * V, M = Math.min(Math.max(0, M), 1), F = Math.min(Math.max(0, F), 1), V = Math.min(Math.max(0, V), 1), [255 * M, 255 * F, 255 * V];
      }, A.xyz.lab = function(k) {
        let E = k[0], P = k[1], z = k[2];
        return E /= 95.047, P /= 100, z /= 108.883, E = E > 8856e-6 ? E ** 0.3333333333333333 : 7.787 * E + 0.13793103448275862, P = P > 8856e-6 ? P ** 0.3333333333333333 : 7.787 * P + 0.13793103448275862, z = z > 8856e-6 ? z ** 0.3333333333333333 : 7.787 * z + 0.13793103448275862, [116 * P - 16, 500 * (E - P), 200 * (P - z)];
      }, A.lab.xyz = function(k) {
        let E, P, z;
        P = (k[0] + 16) / 116, E = k[1] / 500 + P, z = P - k[2] / 200;
        const M = P ** 3, F = E ** 3, V = z ** 3;
        return P = M > 8856e-6 ? M : (P - 0.13793103448275862) / 7.787, E = F > 8856e-6 ? F : (E - 0.13793103448275862) / 7.787, z = V > 8856e-6 ? V : (z - 0.13793103448275862) / 7.787, E *= 95.047, P *= 100, z *= 108.883, [E, P, z];
      }, A.lab.lch = function(k) {
        const E = k[0], P = k[1], z = k[2];
        let M;
        return M = 360 * Math.atan2(z, P) / 2 / Math.PI, M < 0 && (M += 360), [E, Math.sqrt(P * P + z * z), M];
      }, A.lch.lab = function(k) {
        const E = k[0], P = k[1], z = k[2] / 360 * 2 * Math.PI;
        return [E, P * Math.cos(z), P * Math.sin(z)];
      }, A.rgb.ansi16 = function(k, E = null) {
        const [P, z, M] = k;
        let F = E === null ? A.rgb.hsv(k)[2] : E;
        if (F = Math.round(F / 50), F === 0)
          return 30;
        let V = 30 + (Math.round(M / 255) << 2 | Math.round(z / 255) << 1 | Math.round(P / 255));
        return F === 2 && (V += 60), V;
      }, A.hsv.ansi16 = function(k) {
        return A.rgb.ansi16(A.hsv.rgb(k), k[2]);
      }, A.rgb.ansi256 = function(k) {
        const E = k[0], P = k[1], z = k[2];
        return E === P && P === z ? E < 8 ? 16 : E > 248 ? 231 : Math.round((E - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(E / 255 * 5) + 6 * Math.round(P / 255 * 5) + Math.round(z / 255 * 5);
      }, A.ansi16.rgb = function(k) {
        let E = k % 10;
        if (E === 0 || E === 7)
          return k > 50 && (E += 3.5), E = E / 10.5 * 255, [E, E, E];
        const P = 0.5 * (1 + ~~(k > 50));
        return [(1 & E) * P * 255, (E >> 1 & 1) * P * 255, (E >> 2 & 1) * P * 255];
      }, A.ansi256.rgb = function(k) {
        if (k >= 232) {
          const P = 10 * (k - 232) + 8;
          return [P, P, P];
        }
        let E;
        return k -= 16, [Math.floor(k / 36) / 5 * 255, Math.floor((E = k % 36) / 6) / 5 * 255, E % 6 / 5 * 255];
      }, A.rgb.hex = function(k) {
        const E = (((255 & Math.round(k[0])) << 16) + ((255 & Math.round(k[1])) << 8) + (255 & Math.round(k[2]))).toString(16).toUpperCase();
        return "000000".substring(E.length) + E;
      }, A.hex.rgb = function(k) {
        const E = k.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!E)
          return [0, 0, 0];
        let P = E[0];
        E[0].length === 3 && (P = P.split("").map((M) => M + M).join(""));
        const z = parseInt(P, 16);
        return [z >> 16 & 255, z >> 8 & 255, 255 & z];
      }, A.rgb.hcg = function(k) {
        const E = k[0] / 255, P = k[1] / 255, z = k[2] / 255, M = Math.max(Math.max(E, P), z), F = Math.min(Math.min(E, P), z), V = M - F;
        let j, Z;
        return j = V < 1 ? F / (1 - V) : 0, Z = V <= 0 ? 0 : M === E ? (P - z) / V % 6 : M === P ? 2 + (z - E) / V : 4 + (E - P) / V, Z /= 6, Z %= 1, [360 * Z, 100 * V, 100 * j];
      }, A.hsl.hcg = function(k) {
        const E = k[1] / 100, P = k[2] / 100, z = P < 0.5 ? 2 * E * P : 2 * E * (1 - P);
        let M = 0;
        return z < 1 && (M = (P - 0.5 * z) / (1 - z)), [k[0], 100 * z, 100 * M];
      }, A.hsv.hcg = function(k) {
        const E = k[1] / 100, P = k[2] / 100, z = E * P;
        let M = 0;
        return z < 1 && (M = (P - z) / (1 - z)), [k[0], 100 * z, 100 * M];
      }, A.hcg.rgb = function(k) {
        const E = k[0] / 360, P = k[1] / 100, z = k[2] / 100;
        if (P === 0)
          return [255 * z, 255 * z, 255 * z];
        const M = [0, 0, 0], F = E % 1 * 6, V = F % 1, j = 1 - V;
        let Z = 0;
        switch (Math.floor(F)) {
          case 0:
            M[0] = 1, M[1] = V, M[2] = 0;
            break;
          case 1:
            M[0] = j, M[1] = 1, M[2] = 0;
            break;
          case 2:
            M[0] = 0, M[1] = 1, M[2] = V;
            break;
          case 3:
            M[0] = 0, M[1] = j, M[2] = 1;
            break;
          case 4:
            M[0] = V, M[1] = 0, M[2] = 1;
            break;
          default:
            M[0] = 1, M[1] = 0, M[2] = j;
        }
        return Z = (1 - P) * z, [255 * (P * M[0] + Z), 255 * (P * M[1] + Z), 255 * (P * M[2] + Z)];
      }, A.hcg.hsv = function(k) {
        const E = k[1] / 100, P = E + k[2] / 100 * (1 - E);
        let z = 0;
        return P > 0 && (z = E / P), [k[0], 100 * z, 100 * P];
      }, A.hcg.hsl = function(k) {
        const E = k[1] / 100, P = k[2] / 100 * (1 - E) + 0.5 * E;
        let z = 0;
        return P > 0 && P < 0.5 ? z = E / (2 * P) : P >= 0.5 && P < 1 && (z = E / (2 * (1 - P))), [k[0], 100 * z, 100 * P];
      }, A.hcg.hwb = function(k) {
        const E = k[1] / 100, P = E + k[2] / 100 * (1 - E);
        return [k[0], 100 * (P - E), 100 * (1 - P)];
      }, A.hwb.hcg = function(k) {
        const E = k[1] / 100, P = 1 - k[2] / 100, z = P - E;
        let M = 0;
        return z < 1 && (M = (P - z) / (1 - z)), [k[0], 100 * z, 100 * M];
      }, A.apple.rgb = function(k) {
        return [k[0] / 65535 * 255, k[1] / 65535 * 255, k[2] / 65535 * 255];
      }, A.rgb.apple = function(k) {
        return [k[0] / 255 * 65535, k[1] / 255 * 65535, k[2] / 255 * 65535];
      }, A.gray.rgb = function(k) {
        return [k[0] / 100 * 255, k[0] / 100 * 255, k[0] / 100 * 255];
      }, A.gray.hsl = function(k) {
        return [0, 0, k[0]];
      }, A.gray.hsv = A.gray.hsl, A.gray.hwb = function(k) {
        return [0, 100, k[0]];
      }, A.gray.cmyk = function(k) {
        return [0, 0, 0, k[0]];
      }, A.gray.lab = function(k) {
        return [k[0], 0, 0];
      }, A.gray.hex = function(k) {
        const E = 255 & Math.round(k[0] / 100 * 255), P = ((E << 16) + (E << 8) + E).toString(16).toUpperCase();
        return "000000".substring(P.length) + P;
      }, A.rgb.gray = function(k) {
        return [(k[0] + k[1] + k[2]) / 3 / 255 * 100];
      };
    }, 841: (v, C, p) => {
      const D = p(4959), y = p(9325), A = {};
      Object.keys(D).forEach((k) => {
        A[k] = {}, Object.defineProperty(A[k], "channels", { value: D[k].channels }), Object.defineProperty(A[k], "labels", { value: D[k].labels });
        const E = y(k);
        Object.keys(E).forEach((P) => {
          const z = E[P];
          A[k][P] = function(M) {
            const F = function(...V) {
              const j = V[0];
              if (j == null)
                return j;
              j.length > 1 && (V = j);
              const Z = M(V);
              if (typeof Z == "object")
                for (let ne = Z.length, se = 0; se < ne; se++)
                  Z[se] = Math.round(Z[se]);
              return Z;
            };
            return "conversion" in M && (F.conversion = M.conversion), F;
          }(z), A[k][P].raw = function(M) {
            const F = function(...V) {
              const j = V[0];
              return j == null ? j : (j.length > 1 && (V = j), M(V));
            };
            return "conversion" in M && (F.conversion = M.conversion), F;
          }(z);
        });
      }), v.exports = A;
    }, 9325: (v, C, p) => {
      const D = p(4959);
      function y(E) {
        const P = function() {
          const M = {}, F = Object.keys(D);
          for (let V = F.length, j = 0; j < V; j++)
            M[F[j]] = { distance: -1, parent: null };
          return M;
        }(), z = [E];
        for (P[E].distance = 0; z.length; ) {
          const M = z.pop(), F = Object.keys(D[M]);
          for (let V = F.length, j = 0; j < V; j++) {
            const Z = F[j], ne = P[Z];
            ne.distance === -1 && (ne.distance = P[M].distance + 1, ne.parent = M, z.unshift(Z));
          }
        }
        return P;
      }
      function A(E, P) {
        return function(z) {
          return P(E(z));
        };
      }
      function k(E, P) {
        const z = [P[E].parent, E];
        let M = D[P[E].parent][E], F = P[E].parent;
        for (; P[F].parent; )
          z.unshift(P[F].parent), M = A(D[P[F].parent][F], M), F = P[F].parent;
        return M.conversion = z, M;
      }
      v.exports = function(E) {
        const P = y(E), z = {}, M = Object.keys(P);
        for (let F = M.length, V = 0; V < F; V++) {
          const j = M[V];
          P[j].parent !== null && (z[j] = k(j, P));
        }
        return z;
      };
    }, 1103: (v) => {
      v.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
    }, 8603: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}", "", { version: 3, sources: ["webpack://./../ckeditor5-basic-styles/theme/code.css"], names: [], mappings: "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content code {
	background-color: hsla(0, 0%, 78%, 0.3);
	padding: .15em;
	border-radius: 2px;
}

.ck.ck-editor__editable .ck-code_selected  {
	background-color: hsla(0, 0%, 78%, 0.5);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 3062: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", { version: 3, sources: ["webpack://./../ckeditor5-block-quote/theme/blockquote.css"], names: [], mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content blockquote {
	/* See #12 */
	overflow: hidden;

	/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */
	padding-right: 1.5em;
	padding-left: 1.5em;

	margin-left: 0;
	margin-right: 0;
	font-style: italic;
	border-left: solid 5px hsl(0, 0%, 80%);
}

.ck-content[dir="rtl"] blockquote {
	border-left: 0;
	border-right: solid 5px hsl(0, 0%, 80%);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 903: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}', "", { version: 3, sources: ["webpack://./../ckeditor5-clipboard/theme/clipboard.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"], names: [], mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CChCA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		display: inline;
		position: relative;
		pointer-events: none;

		& span {
			position: absolute;
			width: 0;
		}
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		& > .ck-widget__selection-handle {
			display: none;
		}

		& > .ck-widget__type-around {
			display: none;
		}
	}
}

.ck.ck-clipboard-drop-target-line {
	position: absolute;
	pointer-events: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-clipboard-drop-target-dot-width: 12px;
	--ck-clipboard-drop-target-dot-height: 8px;
	--ck-clipboard-drop-target-color: var(--ck-color-focus-border)
}

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		& span {
			bottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			border: 1px solid var(--ck-clipboard-drop-target-color);
			background: var(--ck-clipboard-drop-target-color);
			margin-left: -1px;

			/* The triangle above the marker */
			&::after {
				content: "";
				width: 0;
				height: 0;

				display: block;
				position: absolute;
				left: 50%;
				top: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);

				transform: translateX(-50%);
				border-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;
				border-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));
				border-style: solid;
			}
		}
	}

	/*
	 * Styles of the widget that it a drop target.
	 */
	& .ck-widget.ck-clipboard-drop-target-range {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		zoom: 0.6;
		outline: none !important;
	}
}

.ck.ck-clipboard-drop-target-line {
	height: 0;
	border: 1px solid var(--ck-clipboard-drop-target-color);
	background: var(--ck-clipboard-drop-target-color);
	margin-top: -1px;
}
`], sourceRoot: "" }]);
      const E = k;
    }, 3143: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", { version: 3, sources: ["webpack://./../ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor {
	/* All the elements within \`.ck-editor\` are positioned relatively to it.
	 If any element needs to be positioned with respect to the <body>, etc.,
	 it must land outside of the \`.ck-editor\` in DOM. */
	position: relative;

	& .ck-editor__top .ck-sticky-panel .ck-toolbar {
		/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */
		z-index: var(--ck-z-modal);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

.ck.ck-editor__top {
	& .ck-sticky-panel {
		& .ck-toolbar {
			@mixin ck-rounded-corners {
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}

			border-bottom-width: 0;
		}

		& .ck-sticky-panel__content_sticky .ck-toolbar {
			border-bottom-width: 1px;

			@mixin ck-rounded-corners {
				border-radius: 0;
			}
		}
	}
}

/* Note: Use ck-editor__main to make sure these styles don't apply to other editor types */
.ck.ck-editor__main > .ck-editor__editable {
	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */
	background: var(--ck-color-base-background);

	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	&:not(.ck-focused) {
		border-color: var(--ck-color-base-border);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 4717: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}", "", { version: 3, sources: ["webpack://./../ckeditor5-engine/theme/placeholder.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"], names: [], mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* See ckeditor/ckeditor5#936. */
.ck.ck-placeholder,
.ck .ck-placeholder {
	position: relative;

	&::before {
		position: absolute;
		left: 0;
		right: 0;
		content: attr(data-placeholder);

		/* See ckeditor/ckeditor5#469. */
		pointer-events: none;
	}
}

/* See ckeditor/ckeditor5#1987. */
.ck.ck-read-only .ck-placeholder {
	&::before {
		display: none;
	}
}

/*
 * Rules for the \`ck-placeholder\` are loaded before the rules for \`ck-reset_all\` in the base CKEditor 5 DLL build.
 * This fix overwrites the incorrectly set \`position: static\` from \`ck-reset_all\`.
 * See https://github.com/ckeditor/ckeditor5/issues/11418.
 */
.ck.ck-reset_all .ck-placeholder {
	position: relative;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* See ckeditor/ckeditor5#936. */
.ck.ck-placeholder, .ck .ck-placeholder {
	&::before {
		cursor: text;
		color: var(--ck-color-engine-placeholder-text);
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 9315: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-engine/theme/renderer.css"], names: [], mappings: "AAMA,qDACC,YACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Elements marked by the Renderer as hidden should be invisible in the editor. */
.ck.ck-editor__editable span[data-ck-unsafe-element] {
	display: none;
}
`], sourceRoot: "" }]);
      const E = k;
    }, 8733: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", { version: 3, sources: ["webpack://./../ckeditor5-heading/theme/heading.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"], names: [], mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-heading_heading1 {
	font-size: 20px;
}

.ck.ck-heading_heading2 {
	font-size: 17px;
}

.ck.ck-heading_heading3 {
	font-size: 14px;
}

.ck[class*="ck-heading_heading"] {
	font-weight: bold;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Resize dropdown's button label. */
.ck.ck-dropdown.ck-heading-dropdown {
	& .ck-dropdown__button .ck-button__label {
		width: 8em;
	}

	& .ck-dropdown__panel .ck-list__item {
		min-width: 18em;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 5049: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ":root{--ck-html-object-embed-unfocused-outline-width:1px}.ck-widget.html-object-embed{background-color:var(--ck-color-base-foreground);font-size:var(--ck-font-size-base);min-width:calc(76px + var(--ck-spacing-standard));padding:var(--ck-spacing-small);padding-top:calc(var(--ck-font-size-tiny) + var(--ck-spacing-large))}.ck-widget.html-object-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.html-object-embed:before{background:#999;border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);content:attr(data-html-object-embed-label);font-family:var(--ck-font-face);font-size:var(--ck-font-size-tiny);font-style:normal;font-weight:400;left:var(--ck-spacing-standard);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);position:absolute;top:0;transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck-widget.html-object-embed .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck-widget.html-object-embed .html-object-embed__content{pointer-events:none}div.ck-widget.html-object-embed{margin:1em auto}span.ck-widget.html-object-embed{display:inline-block}", "", { version: 3, sources: ["webpack://./../ckeditor5-html-support/theme/datafilter.css"], names: [], mappings: "AAKA,MACC,kDACD,CAEA,6BAEC,gDAAiD,CADjD,kCAAmC,CAKnC,iDAAkD,CAHlD,+BAAgC,CAEhC,oEAgCD,CA7BC,kEACC,wGACD,CAEA,oCAOC,eAA4B,CAG5B,iEAAkE,CAClE,qCAAsC,CAPtC,0CAA2C,CAS3C,+BAAgC,CADhC,kCAAmC,CAVnC,iBAAkB,CADlB,eAAmB,CAKnB,+BAAgC,CAGhC,yIAA0I,CAN1I,iBAAkB,CAElB,KAAM,CAGN,0GAMD,CAGA,2HACC,gBACD,CAEA,yDAEC,mBACD,CAGD,gCACC,eACD,CAEA,iCACC,oBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-html-object-embed-unfocused-outline-width: 1px;
}

.ck-widget.html-object-embed {
	font-size: var(--ck-font-size-base);
	background-color: var(--ck-color-base-foreground);
	padding: var(--ck-spacing-small);
	/* Leave space for label */
	padding-top: calc(var(--ck-font-size-tiny) + var(--ck-spacing-large));
	min-width: calc(76px + var(--ck-spacing-standard));

	&:not(.ck-widget_selected):not(:hover) {
		outline: var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border);
	}

	&::before {
		font-weight: normal;
		font-style: normal;
		position: absolute;
		content: attr(data-html-object-embed-label);
		top: 0;
		left: var(--ck-spacing-standard);
		background: hsl(0deg 0% 60%);
		transition: background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);
		padding: calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);
		border-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);
		color: var(--ck-color-base-background);
		font-size: var(--ck-font-size-tiny);
		font-family: var(--ck-font-face);
	}

	/* Make space for label. */
	& .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before {
		margin-left: 50px;
	}

	& .html-object-embed__content {
		/* Disable user interaction with embed content */
		pointer-events: none;
	}
}

div.ck-widget.html-object-embed {
	margin: 1em auto;
}

span.ck-widget.html-object-embed {
	display: inline-block;
}

`], sourceRoot: "" }]);
      const E = k;
    }, 3508: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/image.css"], names: [], mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content {
	& .image {
		display: table;
		clear: both;
		text-align: center;

		/* Make sure there is some space between the content and the image. Center image by default. */
		/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	 	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
		margin: 0.9em auto;

		/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */
		min-width: 50px;

		& img {
			/* Prevent unnecessary margins caused by line-height (see #44). */
			display: block;

			/* Center the image if its width is smaller than the content's width. */
			margin: 0 auto;

			/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */
			max-width: 100%;

			/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */
			min-width: 100%
		}
	}

	& .image-inline {
		/*
		 * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).
		 * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.
		 * This strange behavior does not happen with inline-flex.
		 */
		display: inline-flex;

		/* While being resized, don't allow the image to exceed the width of the editing root. */
		max-width: 100%;

		/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */
		align-items: flex-start;

		/* When the picture is present it must act as a flex container to let the img resize properly */
		& picture {
			display: flex;
		}

		/* When the picture is present, it must act like a resizable img. */
		& picture,
		& img {
			/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */
			flex-grow: 1;
			flex-shrink: 1;

			/* Prevents overflowing the editing root boundaries when an inline image is very wide. */
			max-width: 100%;
		}
	}
}

.ck.ck-editor__editable {
	/*
	 * Inhertit the content styles padding of the <figcaption> in case the integration overrides \`text-align: center\`
	 * of \`.image\` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native
	 * caret does, and not at the edge of <figcaption>.
	 */
	& .image > figcaption.ck-placeholder::before {
		padding-left: inherit;
		padding-right: inherit;

		/*
		 * Make sure the image caption placeholder doesn't overflow the placeholder area.
		 * See https://github.com/ckeditor/ckeditor5/issues/9162.
		 */
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}


	/*
	 * Make sure the selected inline image always stays on top of its siblings.
	 * See https://github.com/ckeditor/ckeditor5/issues/9108.
	 */
	& .image.ck-widget_selected {
		z-index: 1;
	}

	& .image-inline.ck-widget_selected {
		z-index: 1;

		/*
		 * Make sure the native browser selection style is not displayed.
		 * Inline image widgets have their own styles for the selected state and
		 * leaving this up to the browser is asking for a visual collision.
		 */
		& ::selection {
			display: none;
		}
	}

	/* The inline image nested in the table should have its original size if not resized.
	See https://github.com/ckeditor/ckeditor5/issues/9117. */
	& td,
	& th {
		& .image-inline img {
			max-width: none;
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 2640: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imagecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-image-caption-background: hsl(0, 0%, 97%);
	--ck-color-image-caption-text: hsl(0, 0%, 20%);
	--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);
}

/* Content styles */
.ck-content .image > figcaption {
	display: table-caption;
	caption-side: bottom;
	word-break: break-word;
	color: var(--ck-color-image-caption-text);
	background-color: var(--ck-color-image-caption-background);
	padding: .6em;
	font-size: .75em;
	outline-offset: -1px;
}

/* Editing styles */
.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {
	animation: ck-image-caption-highlight .6s ease-out;
}

@keyframes ck-image-caption-highlight {
	0% {
		background-color: var(--ck-color-image-caption-highligted-background);
	}

	100% {
		background-color: var(--ck-color-image-caption-background);
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 3535: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-image-insert__panel{padding:var(--ck-spacing-large)}.ck.ck-image-insert__ck-finder-button{border:1px solid #ccc;border-radius:var(--ck-border-radius);display:block;margin:var(--ck-spacing-standard) auto;width:100%}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{border:none;margin:0;padding:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageinsert.css"], names: [], mappings: "AAKA,2BACC,+BACD,CAEA,sCAIC,qBAAiC,CACjC,qCAAsC,CAJtC,aAAc,CAEd,sCAAuC,CADvC,UAID,CAGA,oDAGC,WAAY,CADZ,QAAS,CADT,SAGD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-image-insert__panel {
	padding: var(--ck-spacing-large);
}

.ck.ck-image-insert__ck-finder-button {
	display: block;
	width: 100%;
	margin: var(--ck-spacing-standard) auto;
	border: 1px solid hsl(0, 0%, 80%);
	border-radius: var(--ck-border-radius);
}

/* https://github.com/ckeditor/ckeditor5/issues/7986 */
.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {
	padding: 0;
	margin: 0;
	border: none;
}
`], sourceRoot: "" }]);
      const E = k;
    }, 1568: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageinsertformrowview.css"], names: [], mappings: "AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-image-insert-form {
	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}
}

.ck.ck-form__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		flex-grow: 1;
	}

	&.ck-image-insert-form__action-row {
		margin-top: var(--ck-spacing-standard);

		& .ck-button-save,
		& .ck-button-cancel {
			justify-content: center;
		}

		& .ck-button .ck-button__label {
			color: var(--ck-color-text);
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 6270: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageresize.css"], names: [], mappings: "AAKA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .image.image_resized {
	max-width: 100%;
	/*
	The \`<figure>\` element for resized images must not use \`display:table\` as browsers do not support \`max-width\` for it well.
	See https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.
	Fortunately, since we control the width, there is no risk that the image will look bad.
	*/
	display: block;
	box-sizing: border-box;

	& img {
		/* For resized images it is the \`<figure>\` element that determines the image width. */
		width: 100%;
	}

	& > figcaption {
		/* The \`<figure>\` element uses \`display:block\`, so \`<figcaption>\` also has to. */
		display: block;
	}
}

.ck.ck-editor__editable {
	/* The resized inline image nested in the table should respect its parent size.
	See https://github.com/ckeditor/ckeditor5/issues/9117. */
	& td,
	& th {
		& .image-inline.image_resized img {
			max-width: 100%;
		}
	}
}

[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {
	margin-right: var(--ck-spacing-standard);
}

[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {
	margin-left: var(--ck-spacing-standard);
}

.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {
	width: 4em;
}
`], sourceRoot: "" }]);
      const E = k;
    }, 5083: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imagestyle.css"], names: [], mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-image-style-spacing: 1.5em;
	--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);
}

.ck-content {
	/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback
	confirming successful application of the style if image width exceeds the editor's size.
	See https://github.com/ckeditor/ckeditor5/issues/9342 */
	& .image-style-block-align-left,
	& .image-style-block-align-right {
		max-width: calc(100% - var(--ck-image-style-spacing));
	}

	/* Allows displaying multiple floating images in the same line.
	See https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */
	& .image-style-align-left,
	& .image-style-align-right {
		clear: none;
	}

	& .image-style-side {
		float: right;
		margin-left: var(--ck-image-style-spacing);
		max-width: 50%;
	}

	& .image-style-align-left {
		float: left;
		margin-right: var(--ck-image-style-spacing);
	}

	& .image-style-align-center {
		margin-left: auto;
		margin-right: auto;
	}

	& .image-style-align-right {
		float: right;
		margin-left: var(--ck-image-style-spacing);
	}

	& .image-style-block-align-right {
		margin-right: 0;
		margin-left: auto;
	}

	& .image-style-block-align-left {
		margin-left: 0;
		margin-right: auto;
	}

	/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */
	& p + .image-style-align-left,
	& p + .image-style-align-right,
	& p + .image-style-side {
		margin-top: 0;
	}

	& .image-inline {
		&.image-style-align-left,
		&.image-style-align-right {
			margin-top: var(--ck-inline-image-style-spacing);
			margin-bottom: var(--ck-inline-image-style-spacing);
		}

		&.image-style-align-left {
			margin-right: var(--ck-inline-image-style-spacing);
		}

		&.image-style-align-right {
			margin-left: var(--ck-inline-image-style-spacing);
		}
	}
}

.ck.ck-splitbutton {
	/* The button should display as a regular drop-down if the action button
	is forced to fire the same action as the arrow button. */
	&.ck-splitbutton_flatten {
		&:hover,
		&.ck-splitbutton_open {
			& > .ck-splitbutton__action:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {
				background-color: var(--ck-color-button-on-background);

				&::after {
					display: none;
				}
			}
		}

		&.ck-splitbutton_open:hover {
			& > .ck-splitbutton__action:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {
				background-color: var(--ck-color-button-on-hover-background);
			}
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 4036: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadicon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"], names: [], mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-image-upload-complete-icon {
	display: block;
	position: absolute;

	/*
	 * Smaller images should have the icon closer to the border.
	 * Match the icon position with the linked image indicator brought by the link image feature.
	 */
	top: min(var(--ck-spacing-medium), 6%);
	right: min(var(--ck-spacing-medium), 6%);
	border-radius: 50%;
	z-index: 1;

	&::after {
		content: "";
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-image-upload-icon: hsl(0, 0%, 100%);
	--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);

	/* Match the icon size with the linked image indicator brought by the link image feature. */
	--ck-image-upload-icon-size: 20;
	--ck-image-upload-icon-width: 2px;
	--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);
}

.ck-image-upload-complete-icon {
	opacity: 0;
	background: var(--ck-color-image-upload-icon-background);
	animation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;
	animation-fill-mode: forwards, forwards;
	animation-duration: 500ms, 500ms;

	/* To make animation scalable. */
	font-size: calc(1px * var(--ck-image-upload-icon-size));

	/* Hide completed upload icon after 3 seconds. */
	animation-delay: 0ms, 3000ms;

	/*
	 * Use CSS math to simulate container queries.
	 * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things
	 */
	overflow: hidden;
	width: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));
	height: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));

	/* This is check icon element made from border-width mixed with animations. */
	&::after {
		/* Because of border transformation we need to "hard code" left position. */
		left: 25%;

		top: 50%;
		opacity: 0;
		height: 0;
		width: 0;

		transform: scaleX(-1) rotate(135deg);
		transform-origin: left top;
		border-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);
		border-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);

		animation-name: ck-upload-complete-icon-check;
		animation-duration: 500ms;
		animation-delay: 500ms;
		animation-fill-mode: forwards;

		/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */
		box-sizing: border-box;
	}
}

@keyframes ck-upload-complete-icon-show {
	from {
		opacity: 0;
	}

	to {
		opacity: 1;
	}
}

@keyframes ck-upload-complete-icon-hide {
	from {
		opacity: 1;
	}

	to {
		opacity: 0;
	}
}

@keyframes ck-upload-complete-icon-check {
	0% {
		opacity: 1;
		width: 0;
		height: 0;
	}
	33% {
		width: 0.3em;
		height: 0;
	}
	100% {
		opacity: 1;
		width: 0.3em;
		height: 0.45em;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 3773: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadloader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"], names: [], mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-upload-placeholder-loader {
	position: absolute;
	display: flex;
	align-items: center;
	justify-content: center;
	top: 0;
	left: 0;

	&::before {
		content: '';
		position: relative;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);
	--ck-upload-placeholder-loader-size: 32px;
	--ck-upload-placeholder-image-aspect-ratio: 2.8;
}

.ck .ck-image-upload-placeholder {
	/* We need to control the full width of the SVG gray background. */
	width: 100%;
	margin: 0;

	&.image-inline {
		width: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );
	}

	& img {
		/*
		 * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.
		 * There's nothing special about this number except that it should make the image placeholder look like
		 * a real image during this short period after the upload started and before the image was read from the
		 * file system (and a rich preview was loaded).
		 */
		aspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);
	}
}

.ck .ck-upload-placeholder-loader {
	width: 100%;
	height: 100%;

	&::before {
		width: var(--ck-upload-placeholder-loader-size);
		height: var(--ck-upload-placeholder-loader-size);
		border-radius: 50%;
		border-top: 3px solid var(--ck-color-upload-placeholder-loader);
		border-right: 2px solid transparent;
		animation: ck-upload-placeholder-loader 1s linear infinite;
	}
}

@keyframes ck-upload-placeholder-loader {
	to {
		transform: rotate( 360deg );
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 3689: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadprogress.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"], names: [], mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& .image,
	& .image-inline {
		position: relative;
	}

	/* Upload progress bar. */
	& .image .ck-progress-bar,
	& .image-inline .ck-progress-bar {
		position: absolute;
		top: 0;
		left: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& .image,
	& .image-inline {
		/* Showing animation. */
		&.ck-appear {
			animation: fadeIn 700ms;
		}
	}

	/* Upload progress bar. */
	& .image .ck-progress-bar,
	& .image-inline .ck-progress-bar {
		height: 2px;
		width: 0;
		background: var(--ck-color-upload-bar-background);
		transition: width 100ms;
	}
}

@keyframes fadeIn {
	from { opacity: 0; }
	to   { opacity: 1; }
}
`], sourceRoot: "" }]);
      const E = k;
    }, 1905: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/textalternativeform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-text-alternative-form {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;

	& .ck-labeled-field-view {
		display: inline-block;
	}

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 9773: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/link.css"], names: [], mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Class added to span element surrounding currently selected link. */
.ck .ck-link_selected {
	background: var(--ck-color-link-selected-background);

	/* Give linked inline images some outline to let the user know they are also part of the link. */
	& span.image-inline {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);
	}
}

/*
 * Classes used by the "fake visual selection" displayed in the content when an input
 * in the link UI has focus (the browser does not render the native selection in this state).
 */
.ck .ck-fake-link-selection {
	background: var(--ck-color-link-fake-selection);
}

/* A collapsed fake visual selection. */
.ck .ck-fake-link-selection_collapsed {
	height: 100%;
	border-right: 1px solid var(--ck-color-base-text);
	margin-right: -1px;
	outline: solid 1px hsla(0, 0%, 100%, .5);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 2347: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkactions.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"], names: [], mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;

	& .ck-link-actions__preview {
		display: inline-block;

		& .ck-button__label {
			overflow: hidden;
		}
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-link-actions__preview {
			flex-basis: 100%;
		}

		& .ck-button:not(.ck-link-actions__preview) {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	& .ck-button.ck-link-actions__preview {
		padding-left: 0;
		padding-right: 0;

		& .ck-button__label {
			padding: 0 var(--ck-spacing-medium);
			color: var(--ck-color-link-default);
			text-overflow: ellipsis;
			cursor: pointer;

			/* Match the box model of the link editor form's input so the balloon
			does not change width when moving between actions and the form. */
			max-width: var(--ck-input-width);
			min-width: 3em;
			text-align: center;

			&:hover {
				text-decoration: underline;
			}
		}

		&,
		&:hover,
		&:focus,
		&:active {
			background: none;
		}

		&:active {
			box-shadow: none;
		}

		&:focus {
			& .ck-button__label {
				text-decoration: underline;
			}
		}
	}

	@mixin ck-dir ltr {
		& .ck-button:not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-button:not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		& .ck-button.ck-link-actions__preview {
			margin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;

			& .ck-button__label {
				min-width: 0;
				max-width: 100%;
			}
		}

		& .ck-button:not(.ck-link-actions__preview) {
			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 7754: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"], names: [], mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-form {
	display: flex;

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}

/*
 * Style link form differently when manual decorators are available.
 * See: https://github.com/ckeditor/ckeditor5-link/issues/186.
 */
.ck.ck-link-form_layout-vertical {
	display: block;

	/*
	 * Whether the form is in the responsive mode or not, if there are decorator buttons
	 * keep the top margin of action buttons medium.
	 */
	& .ck-button {
		&.ck-button-save,
		&.ck-button-cancel {
			margin-top: var(--ck-spacing-medium);
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

/*
 * Style link form differently when manual decorators are available.
 * See: https://github.com/ckeditor/ckeditor5-link/issues/186.
 */
.ck.ck-link-form_layout-vertical {
	padding: 0;
	min-width: var(--ck-input-width);

	& .ck-labeled-field-view {
		margin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);

		& .ck-input-text {
			min-width: 0;
			width: 100%;
		}
	}

	& > .ck-button {
		padding: var(--ck-spacing-standard);
		margin: 0;
		width: 50%;
		border-radius: 0;

		&:not(:focus) {
			border-top: 1px solid var(--ck-color-base-border);
		}

		@mixin ck-dir ltr {
			margin-left: 0;
		}

		@mixin ck-dir rtl {
			margin-left: 0;

			&:last-of-type {
				border-right: 1px solid var(--ck-color-base-border);
			}
		}
	}

	/* Using additional \`.ck\` class for stronger CSS specificity than \`.ck.ck-link-form > :not(:first-child)\`. */
	& .ck.ck-list {
		margin: var(--ck-spacing-standard) var(--ck-spacing-large);

		& .ck-button.ck-switchbutton {
			padding: 0;
			width: 100%;

			&:hover {
				background: none;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 111: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}', "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkimage.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css"], names: [], mappings: "AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,83BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	/* Linked image indicator */
	& figure.image > a,
	& a span.image-inline {
		&::after {
			display: block;
			position: absolute;
		}
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Match the icon size with the upload indicator brought by the image upload feature. */
	--ck-link-image-indicator-icon-size: 20;
	--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);
}

.ck.ck-editor__editable {
	/* Linked image indicator */
	& figure.image > a,
	& a span.image-inline {
		&::after {
			content: "";

			/*
			 * Smaller images should have the icon closer to the border.
			 * Match the icon position with the upload indicator brought by the image upload feature.
			 */
			top: min(var(--ck-spacing-medium), 6%);
			right: min(var(--ck-spacing-medium), 6%);

			background-color: hsla(0, 0%, 0%, .4);
			background-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");
			background-size: 14px;
			background-repeat: no-repeat;
			background-position: center;
			border-radius: 100%;

			/*
			* Use CSS math to simulate container queries.
			* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things
			*/
			overflow: hidden;
			width: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));
			height: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));
		}
	}
}

`], sourceRoot: "" }]);
      const E = k;
    }, 4721: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:0 var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/collapsible.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/collapsible.css"], names: [], mappings: "AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,wDAAyD,CAFzD,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,yDACD,CAGC,mEACC,wBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-collapsible.ck-collapsible_collapsed {
	& > .ck-collapsible__children {
		display: none;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-collapsible {
	& > .ck.ck-button {
		width: 100%;
		font-weight: bold;
		padding: var(--ck-spacing-medium) var(--ck-spacing-large);
		border-radius: 0;
		color: inherit;

		&:focus {
			background: transparent;
		}

		&:active, &:not(:focus), &:hover:not(:focus) {
			background: transparent;
			border-color: transparent;
			box-shadow: none;
		}

		& > .ck-icon {
			margin-right: var(--ck-spacing-medium);
			width: var(--ck-collapsible-arrow-size);
		}
	}

	& > .ck-collapsible__children {
		padding: 0 var(--ck-spacing-large) var(--ck-spacing-large);
	}

	&.ck-collapsible_collapsed {
		& > .ck.ck-button .ck-icon {
			transform: rotate(-90deg);
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 5730: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck-editor__editable .ck-list-bogus-paragraph{display:block}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/documentlist.css"], names: [], mappings: "AAKA,8CACC,aACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-editor__editable .ck-list-bogus-paragraph {
	display: block;
}
`], sourceRoot: "" }]);
      const E = k;
    }, 4564: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/list.css"], names: [], mappings: "AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content ol {
	list-style-type: decimal;

	& ol {
		list-style-type: lower-latin;

		& ol {
			list-style-type: lower-roman;

			& ol {
				list-style-type: upper-latin;

				& ol {
					list-style-type: upper-roman;
				}
			}
		}
	}
}

.ck-content ul {
	list-style-type: disc;

	& ul {
		list-style-type: circle;

		& ul {
			list-style-type: square;

			& ul {
				list-style-type: square;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 6082: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css"], names: [], mappings: "AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-list-properties {
	/* When there are no list styles and there is no collapsible. */
	&.ck-list-properties_without-styles {
		padding: var(--ck-spacing-large);

		& > * {
			min-width: 14em;

			& + * {
				margin-top: var(--ck-spacing-standard);
			}
		}
	}

	/*
	 * When the numbered list property fields (start at, reversed) should be displayed,
	 * more horizontal space is needed. Reconfigure the style grid to create that space.
	 */
	&.ck-list-properties_with-numbered-properties {
		& > .ck-list-styles-list {
			grid-template-columns: repeat( 4, auto );
		}

		/* When list styles are rendered and property fields are in a collapsible. */
		& > .ck-collapsible {
			border-top: 1px solid var(--ck-color-base-border);

			& > .ck-collapsible__children {
				& > * {
					width: 100%;

					& + * {
						margin-top: var(--ck-spacing-standard);
					}
				}
			}
		}
	}

	& .ck.ck-numbered-list-properties__start-index .ck-input {
		min-width: auto;
		width: 100%;
	}

	& .ck.ck-numbered-list-properties__reversed-order {
		background: transparent;
		padding-left: 0;
		padding-right: 0;
		margin-bottom: calc(-1 * var(--ck-spacing-tiny));

		&:active, &:hover {
			box-shadow: none;
			border-color: transparent;
			background: none;
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 2417: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-list-styles-list{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/liststyles.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"], names: [], mappings: "AAKA,wBACC,YACD,CCFA,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-list-styles-list {
	display: grid;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-list-style-button-size: 44px;
}

.ck.ck-list-styles-list {
	grid-template-columns: repeat( 3, auto );
	row-gap: var(--ck-spacing-medium);
	column-gap: var(--ck-spacing-medium);
	padding: var(--ck-spacing-large);

	& .ck-button {
		/* Make the button look like a thumbnail (the icon "takes it all"). */
		width: var(--ck-list-style-button-size);
		height: var(--ck-list-style-button-size);
		padding: 0;

		/*
		 * Buttons are aligned by the grid so disable default button margins to not collide with the
		 * gaps in the grid.
		 */
		margin: 0;

		/*
		 * Make sure the button border (which is displayed on focus, BTW) does not steal pixels
		 * from the button dimensions and, as a result, decrease the size of the icon
		 * (which becomes blurry as it scales down).
		 */
		box-sizing: content-box;

		& .ck-icon {
			width: var(--ck-list-style-button-size);
			height: var(--ck-list-style-button-size);
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 1199: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-content .todo-list .todo-list__label>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out,background .25s ease-in-out,border .25s ease-in-out;width:100%}.ck-content .todo-list .todo-list__label>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-editor__editable .todo-list .todo-list__label>input{cursor:pointer}.ck-editor__editable .todo-list .todo-list__label>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}', "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/todolist.css"], names: [], mappings: "AAKA,MACC,kCACD,CAEA,uBACC,eA0ED,CAxEC,0BACC,iBAKD,CAHC,qCACC,cACD,CAIA,+CACC,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAqDD,CAxCC,sDAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,0FAAgG,CAJhG,UAKD,CAEA,qDAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAIF,wEACC,qBACD,CAKF,6CACC,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAED,CAMA,wDACC,cAKD,CAHC,qEACC,mCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-todo-list-checkmark-size: 16px;
}

.ck-content .todo-list {
	list-style: none;

	& li {
		margin-bottom: 5px;

		& .todo-list {
			margin-top: 5px;
		}
	}

	& .todo-list__label {
		& > input {
			-webkit-appearance: none;
			display: inline-block;
			position: relative;
			width: var(--ck-todo-list-checkmark-size);
			height: var(--ck-todo-list-checkmark-size);
			vertical-align: middle;

			/* Needed on iOS */
			border: 0;

			/* LTR styles */
			left: -25px;
			margin-right: -15px;
			right: 0;
			margin-left: 0;

			&::before {
				display: block;
				position: absolute;
				box-sizing: border-box;
				content: '';
				width: 100%;
				height: 100%;
				border: 1px solid hsl(0, 0%, 20%);
				border-radius: 2px;
				transition: 250ms ease-in-out box-shadow, 250ms ease-in-out background, 250ms ease-in-out border;
			}

			&::after {
				display: block;
				position: absolute;
				box-sizing: content-box;
				pointer-events: none;
				content: '';

				/* Calculate tick position, size and border-width proportional to the checkmark size. */
				left: calc( var(--ck-todo-list-checkmark-size) / 3 );
				top: calc( var(--ck-todo-list-checkmark-size) / 5.3 );
				width: calc( var(--ck-todo-list-checkmark-size) / 5.3 );
				height: calc( var(--ck-todo-list-checkmark-size) / 2.6 );
				border-style: solid;
				border-color: transparent;
				border-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;
				transform: rotate(45deg);
			}

			&[checked] {
				&::before {
					background: hsl(126, 64%, 41%);
					border-color: hsl(126, 64%, 41%);
				}

				&::after {
					border-color: hsl(0, 0%, 100%);
				}
			}
		}

		& .todo-list__label__description {
			vertical-align: middle;
		}
	}
}

/* RTL styles */
[dir="rtl"] .todo-list .todo-list__label > input {
	left: 0;
	margin-right: 0;
	right: -25px;
	margin-left: -15px;
}

/*
 * To-do list should be interactive only during the editing
 * (https://github.com/ckeditor/ckeditor5/issues/2090).
 */
.ck-editor__editable .todo-list .todo-list__label > input {
	cursor: pointer;

	&:hover::before {
		box-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 2896: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, '.ck-source-editing-area{overflow:hidden;position:relative}.ck-source-editing-area textarea,.ck-source-editing-area:after{border:1px solid transparent;font-family:monospace;font-size:var(--ck-font-size-normal);line-height:var(--ck-line-height-base);margin:0;padding:var(--ck-spacing-large);white-space:pre-wrap}.ck-source-editing-area:after{content:attr(data-value) " ";display:block;visibility:hidden}.ck-source-editing-area textarea{border-color:var(--ck-color-base-border);border-radius:0;box-sizing:border-box;height:100%;outline:none;overflow:hidden;position:absolute;resize:none;width:100%}.ck-rounded-corners .ck-source-editing-area textarea,.ck-source-editing-area textarea.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck-source-editing-area textarea:not([readonly]):focus{border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}', "", { version: 3, sources: ["webpack://./../ckeditor5-source-editing/theme/sourceediting.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,wBAEC,eAAgB,CADhB,iBAED,CAEA,+DAIC,4BAA6B,CAG7B,qBAAsB,CADtB,oCAAqC,CADrC,sCAAuC,CAFvC,QAAS,CADT,+BAAgC,CAMhC,oBACD,CAEA,8BACC,4BAA6B,CAE7B,aAAc,CADd,iBAED,CAEA,iCASC,wCAAyC,CC7BzC,eAAgB,CD2BhB,qBAAsB,CAJtB,WAAY,CAEZ,YAAa,CACb,eAAgB,CALhB,iBAAkB,CAGlB,WAAY,CAFZ,UAkBD,CApBA,yGChBE,qCAAsC,CD4BtC,wBAAyB,CACzB,yBAOF,CAJC,uDEpCA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFwCA", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";
@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css";
@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";

.ck-source-editing-area {
	position: relative;
	overflow: hidden;
}

.ck-source-editing-area::after,
.ck-source-editing-area textarea {
	padding: var(--ck-spacing-large);
	margin: 0;
	border: 1px solid transparent;
	line-height: var(--ck-line-height-base);
	font-size: var(--ck-font-size-normal);
	font-family: monospace;
	white-space: pre-wrap;
}

.ck-source-editing-area::after {
	content: attr(data-value) " ";
	visibility: hidden;
	display: block;
}

.ck-source-editing-area textarea {
	position: absolute;
	width: 100%;
	height: 100%;
	resize: none;
	outline: none;
	overflow: hidden;
	box-sizing: border-box;

	border-color: var(--ck-color-base-border);

	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	&:not([readonly]):focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 7368: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-input-color {
	width: 100%;
	display: flex;
	flex-direction: row-reverse;

	& > input.ck.ck-input-text {
		min-width: auto;
		flex-grow: 1;
	}

	& > div.ck.ck-dropdown {
		min-width: auto;

		/* This dropdown has no arrow but a color preview instead. */
		& > .ck-input-color__button .ck-dropdown__arrow {
			display: none;
		}
	}

	& .ck.ck-input-color__button {
		/* Resolving issue with misaligned buttons on Safari (see #10589) */
		display: flex;

		& .ck.ck-input-color__button__preview {
			position: relative;
			overflow: hidden;

			& > .ck.ck-input-color__button__preview__no-color-indicator {
				position: absolute;
				display: block;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_rounded.css";

.ck.ck-input-color {
	& > .ck.ck-input-text {
		@mixin ck-dir ltr {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		@mixin ck-dir rtl {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* Make sure the focused input is always on top of the dropdown button so its
		   outline and border are never cropped (also when the input is read-only). */
		&:focus {
			z-index: 0;
		}
	}

	& > .ck.ck-dropdown {
		& > .ck.ck-button.ck-input-color__button {
			padding: 0;

			@mixin ck-dir ltr {
				border-top-left-radius: 0;
				border-bottom-left-radius: 0;

				&:not(:focus) {
					border-left: 1px solid transparent;
				}
			}

			@mixin ck-dir rtl {
				border-top-right-radius: 0;
				border-bottom-right-radius: 0;

				&:not(:focus) {
					border-right: 1px solid transparent;
				}
			}

			&.ck-disabled {
				background: var(--ck-color-input-disabled-background);
			}

			& > .ck.ck-input-color__button__preview {
				@mixin ck-rounded-corners;

				width: 20px;
				height: 20px;
				border: 1px solid var(--ck-color-input-border);

				& > .ck.ck-input-color__button__preview__no-color-indicator {
					top: -30%;
					left: 50%;
					height: 150%;
					width: 8%;
					background: hsl(0, 100%, 50%);
					border-radius: 2px;
					transform: rotate(45deg);
					transform-origin: 50%;
				}
			}
		}
	}

	& .ck.ck-input-color__remove-color {
		width: 100%;
		padding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);

		border-bottom-left-radius: 0;
		border-bottom-right-radius: 0;

		&:not(:focus) {
			border-bottom: 1px solid var(--ck-color-input-border);
		}

		@mixin ck-dir ltr {
			border-top-right-radius: 0;
		}

		@mixin ck-dir rtl {
			border-top-left-radius: 0;
		}

		& .ck.ck-icon {
			margin-right: var(--ck-spacing-standard);

			@mixin ck-dir rtl {
				margin-right: 0;
				margin-left: var(--ck-spacing-standard);
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 4070: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/form.css"], names: [], mappings: "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form {
	padding: 0 0 var(--ck-spacing-large);

	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}

	& .ck.ck-input-text {
		min-width: 100%;
		width: 0;
	}

	& .ck.ck-dropdown {
		min-width: 100%;

		& .ck-dropdown__button {
			&:not(:focus) {
				border: 1px solid var(--ck-color-base-border);
			}

			& .ck-button__label {
				width: 100%;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 9247: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/formrow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css"], names: [], mappings: "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		flex-grow: 1;
	}

	&.ck-table-form__action-row {
		& .ck-button-save,
		& .ck-button-cancel {
			justify-content: center;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-form__row {
	padding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		& + * {
			@mixin ck-dir ltr {
				margin-left: var(--ck-spacing-large);
			}

			@mixin ck-dir rtl {
				margin-right: var(--ck-spacing-large);
			}
		}
	}

	& > .ck-label {
		width: 100%;
		min-width: 100%;
	}

	&.ck-table-form__action-row {
		margin-top: var(--ck-spacing-large);

		& .ck-button .ck-button__label {
			color: var(--ck-color-text);
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 1613: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/inserttable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"], names: [], mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-insert-table-dropdown__grid {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-insert-table-dropdown-padding: 10px;
	--ck-insert-table-dropdown-box-height: 11px;
	--ck-insert-table-dropdown-box-width: 12px;
	--ck-insert-table-dropdown-box-margin: 1px;
}

.ck .ck-insert-table-dropdown__grid {
	/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */
	width: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);
	padding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;
}

.ck .ck-insert-table-dropdown__label,
.ck[dir=rtl] .ck-insert-table-dropdown__label {
	text-align: center;
}

.ck .ck-insert-table-dropdown-grid-box {
	min-width: var(--ck-insert-table-dropdown-box-width);
	min-height: var(--ck-insert-table-dropdown-box-height);
	margin: var(--ck-insert-table-dropdown-box-margin);
	border: 1px solid var(--ck-color-base-border);
	border-radius: 1px;
	outline: none;
	transition: none;

	&:focus {
		box-shadow: none;
	}

	&.ck-on {
		border-color: var(--ck-color-focus-border);
		background: var(--ck-color-focus-outer-shadow);
	}
}

`], sourceRoot: "" }]);
      const E = k;
    }, 6306: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/table.css"], names: [], mappings: "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .table {
	/* Give the table widget some air and center it horizontally */
	/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
	margin: 0.9em auto;
	display: table;

	& table {
		/* The table cells should have slight borders */
		border-collapse: collapse;
		border-spacing: 0;

		/* Table width and height are set on the parent <figure>. Make sure the table inside stretches
		to the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */
		width: 100%;
		height: 100%;

		/* The outer border of the table should be slightly darker than the inner lines.
		Also see https://github.com/ckeditor/ckeditor5-table/issues/50. */
		border: 1px double hsl(0, 0%, 70%);

		& td,
		& th {
			min-width: 2em;
			padding: .4em;

			/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it's not necessary here.
			However, the border is a content style, so it should use .ck-content (so it works outside the editor).
			Hence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */
			border: 1px solid hsl(0, 0%, 75%);
		}

		& th {
			font-weight: bold;
			background: hsla(0, 0%, 0%, 5%);
		}
	}
}

/* Text alignment of the table header should match the editor settings and override the native browser styling,
when content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */
.ck-content[dir="rtl"] .table th {
	text-align: right;
}

.ck-content[dir="ltr"] .table th {
	text-align: left;
}

.ck-editor__editable .ck-table-bogus-paragraph {
	/*
	 * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.
	 * See https://github.com/ckeditor/ckeditor5/issues/6062.
	 */
	display: inline-block;

	/*
	 * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.
	 * See https://github.com/ckeditor/ckeditor5/issues/9117.
	 */
	width: 100%;
}
`], sourceRoot: "" }]);
      const E = k;
    }, 2128: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ":root{--ck-color-table-caption-background:#f7f7f7;--ck-color-table-caption-text:#333;--ck-color-table-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-table-caption-background);caption-side:top;color:var(--ck-color-table-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-table-caption-highlighted-background)}to{background-color:var(--ck-color-table-caption-background)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,oDACD,CAGA,8BAMC,yDAA0D,CAJ1D,gBAAiB,CAGjB,wCAAyC,CAJzC,qBAAsB,CAOtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,iBAAkB,CADlB,qBAOD,CAIC,qEACC,iDACD,CAEA,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAGD,sCACC,GACC,qEACD,CAEA,GACC,yDACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-table-caption-background: hsl(0, 0%, 97%);
	--ck-color-table-caption-text: hsl(0, 0%, 20%);
	--ck-color-table-caption-highlighted-background: hsl(52deg 100% 50%);
}

/* Content styles */
.ck-content .table > figcaption {
	display: table-caption;
	caption-side: top;
	word-break: break-word;
	text-align: center;
	color: var(--ck-color-table-caption-text);
	background-color: var(--ck-color-table-caption-background);
	padding: .6em;
	font-size: .75em;
	outline-offset: -1px;
}

/* Editing styles */
.ck.ck-editor__editable .table > figcaption {
	&.table__caption_highlighted {
		animation: ck-table-caption-highlight .6s ease-out;
	}

	&.ck-placeholder::before {
		padding-left: inherit;
		padding-right: inherit;

		/*
		 * Make sure the table caption placeholder doesn't overflow the placeholder area.
		 * See https://github.com/ckeditor/ckeditor5/issues/9162.
		 */
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}
}

@keyframes ck-table-caption-highlight {
	0% {
		background-color: var(--ck-color-table-caption-highlighted-background);
	}

	100% {
		background-color: var(--ck-color-table-caption-background);
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 5087: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecellproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css"], names: [], mappings: "AAOE,6FACC,cAiBD,CAdE,0HAEC,cACD,CAEA,yHAEC,cACD,CAEA,uHACC,WACD,CClBJ,kCACC,WAkBD,CAfE,2FACC,mBAAoB,CACpB,SAAU,CACV,SACD,CAGC,4GACC,eAAgB,CAGhB,qCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-cell-properties-form {
	& .ck-form__row {
		&.ck-table-cell-properties-form__alignment-row {
			flex-wrap: wrap;

			& .ck.ck-toolbar {
				&:first-of-type {
					/* 4 buttons out of 7 (h-alignment + v-alignment) = 0.57 */
					flex-grow: 0.57;
				}

				&:last-of-type {
					/* 3 buttons out of 7 (h-alignment + v-alignment) = 0.43 */
					flex-grow: 0.43;
				}

				& .ck-button {
					flex-grow: 1;
				}
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-cell-properties-form {
	width: 320px;

	& .ck-form__row {
		&.ck-table-cell-properties-form__padding-row {
			align-self: flex-end;
			padding: 0;
			width: 25%;
		}

		&.ck-table-cell-properties-form__alignment-row {
			& .ck.ck-toolbar {
				background: none;

				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */
				margin-top: var(--ck-spacing-standard);
			}
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 4101: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ":root{--ck-color-table-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:-999999px;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:-999999px;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-table-column-resizer-hover);opacity:.25}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecolumnresize.css"], names: [], mappings: "AAKA,MACC,iEAAkE,CAClE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAEC,iBACD,CAEA,wDAOC,gBAAiB,CAGjB,iBAAkB,CATlB,iBAAkB,CAOlB,oDAAqD,CAFrD,aAAc,CAKd,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,2DAA4D,CAC5D,WACD,CAEA,iEACC,mDAAoD,CACpD,WACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-table-column-resizer-hover: var(--ck-color-base-active);
	--ck-table-column-resizer-width: 7px;

	/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.
	   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */
	--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);
}

.ck-content .table .ck-table-resized {
	table-layout: fixed;
}

.ck-content .table table {
	overflow: hidden;
}

.ck-content .table td,
.ck-content .table th {
	position: relative;
}

.ck.ck-editor__editable .table .ck-table-column-resizer {
	position: absolute;
	/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,
	   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as
	   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally
	   unrealistic height for a single table. */
	top: -999999px;
	bottom: -999999px;
	right: var(--ck-table-column-resizer-position-offset);
	width: var(--ck-table-column-resizer-width);
	cursor: col-resize;
	user-select: none;
	z-index: var(--ck-z-default);
}

.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {
	display: none;
}

/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,
   all resizers must be hidden while the table is dragged. */
.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {
	display: none;
}

.ck.ck-editor__editable .table .ck-table-column-resizer:hover,
.ck.ck-editor__editable .table .ck-table-column-resizer__active {
	background-color: var(--ck-color-table-column-resizer-hover);
	opacity: 0.25;
}

.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {
	left: var(--ck-table-column-resizer-position-offset);
	right: unset;
}
`], sourceRoot: "" }]);
      const E = k;
    }, 3881: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ":root{--ck-color-table-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"], names: [], mappings: "AAKA,MACC,6DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-table-focused-cell-background: hsla(212, 90%, 80%, .3);
}

.ck-widget.table {
	& td,
	& th {
		&.ck-editor__nested-editable.ck-editor__nested-editable_focused,
		&.ck-editor__nested-editable:focus {
			/* A very slight background to highlight the focused cell */
			background: var(--ck-color-table-focused-cell-background);

			/* Fixes the problem where surrounding cells cover the focused cell's border.
			It does not fix the problem in all places but the UX is improved.
			See https://github.com/ckeditor/ckeditor5-table/issues/29. */
			border-style: none;
			outline: 1px solid var(--ck-color-focus-border);
			outline-offset: -1px; /* progressive enhancement - no IE support */
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 6237: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCAyBD,CAvBC,8ECxCD,eDyDC,CAjBA,mMCpCA,qCDqDA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAUD,CAPC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-form {
	& .ck-form__row {
		&.ck-table-form__border-row {
			flex-wrap: wrap;
		}

		&.ck-table-form__background-row {
			flex-wrap: wrap;
		}

		&.ck-table-form__dimensions-row {
			flex-wrap: wrap;
			align-items: center;

			& .ck-labeled-field-view {
				display: flex;
				flex-direction: column-reverse;
				align-items: center;

				& .ck.ck-dropdown {
					flex-grow: 0;
				}
			}

			& .ck-table-form__dimension-operator {
				flex-grow: 0;
			}
		}
	}

	& .ck.ck-labeled-field-view {
		/* Allow absolute positioning of the status (error) balloons. */
		position: relative;

		& .ck.ck-labeled-field-view__status {
			position: absolute;
			left: 50%;
			bottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );
			transform: translate(-50%,100%);

			/* Make sure the balloon status stays on top of other form elements. */
			z-index: 1;

			/* The arrow pointing towards the field. */
			&::after {
				content: "";
				position: absolute;
				top: calc( -1 * var(--ck-table-properties-error-arrow-size) );
				left: 50%;
				transform: translateX( -50% );
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

:root {
	--ck-table-properties-error-arrow-size: 6px;
	--ck-table-properties-min-error-width: 150px;
}

.ck.ck-table-form {
	& .ck-form__row {
		&.ck-table-form__border-row {
			& .ck-labeled-field-view {
				& > .ck-label {
					font-size: var(--ck-font-size-tiny);
					text-align: center;
				}
			}

			& .ck-table-form__border-style,
			& .ck-table-form__border-width {
				width: 80px;
				min-width: 80px;
				max-width: 80px;
			}
		}

		&.ck-table-form__dimensions-row {
			padding: 0;

			& .ck-table-form__dimensions-row__width,
			& .ck-table-form__dimensions-row__height {
				margin: 0
			}

			& .ck-table-form__dimension-operator {
				align-self: flex-end;
				display: inline-block;
				height: var(--ck-ui-component-min-height);
				line-height: var(--ck-ui-component-min-height);
				margin: 0 var(--ck-spacing-small);
			}
		}
	}

	& .ck.ck-labeled-field-view {
		padding-top: var(--ck-spacing-standard);

		& .ck.ck-labeled-field-view__status {
			@mixin ck-rounded-corners;

			background: var(--ck-color-base-error);
			color: var(--ck-color-base-background);
			padding: var(--ck-spacing-small) var(--ck-spacing-medium);
			min-width: var(--ck-table-properties-min-error-width);
			text-align: center;

			/* The arrow pointing towards the field. */
			&::after {
				border-color: transparent transparent var(--ck-color-base-error) transparent;
				border-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);
				border-style: solid;
			}

			animation: ck-table-form-labeled-view-status-appear .15s ease both;
		}

		/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */
		& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {
			display: none;
		}
	}
}

@keyframes ck-table-form-labeled-view-status-appear {
	0% {
		opacity: 0;
	}

	100% {
		opacity: 1;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 7341: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tableproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css"], names: [], mappings: "AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-properties-form {
	& .ck-form__row {
		&.ck-table-properties-form__alignment-row {
			flex-wrap: wrap;
			flex-basis: 0;
			align-content: baseline;

			& .ck.ck-toolbar .ck-toolbar__items {
				flex-wrap: nowrap;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-properties-form {
	width: 320px;

	& .ck-form__row {
		&.ck-table-properties-form__alignment-row {
			align-self: flex-end;
			padding: 0;

			& .ck.ck-toolbar {
				background: none;

				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */
				margin-top: var(--ck-spacing-standard);

				& .ck-toolbar__items > * {
					width: 40px;
				}
			}
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 6945: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"], names: [], mappings: "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);
}

.ck.ck-editor__editable .table table {
	& td.ck-editor__editable_selected,
	& th.ck-editor__editable_selected {
		position: relative;
		caret-color: transparent;
		outline: unset;
		box-shadow: unset;

		/* https://github.com/ckeditor/ckeditor5/issues/6446 */
		&:after {
			content: '';
			pointer-events: none;
			background-color: var(--ck-table-selected-cell-background);
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
		}

		& ::selection,
		&:focus {
			background-color: transparent;
		}

		/*
		 * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.
		 * See https://github.com/ckeditor/ckeditor5/issues/9491.
		 */
		& .ck-widget {
			outline: unset;

			& > .ck-widget__selection-handle {
				display: none;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 4906: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/button/button.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-unselectable;

	position: relative;
	display: inline-flex;
	align-items: center;
	justify-content: left;

	& .ck-button__label {
		display: none;
	}

	&.ck-button_with-text {
		& .ck-button__label {
			display: inline-block;
		}
	}

	/* Center the icon horizontally in a button without text. */
	&:not(.ck-button_with-text)  {
		justify-content: center;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../mixins/_button.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-button-colors --ck-color-button-default;
	@mixin ck-rounded-corners;

	white-space: nowrap;
	cursor: default;
	vertical-align: middle;
	padding: var(--ck-spacing-tiny);
	text-align: center;

	/* A very important piece of styling. Go to variable declaration to learn more. */
	min-width: var(--ck-ui-component-min-height);
	min-height: var(--ck-ui-component-min-height);

	/* Normalize the height of the line. Removing this will break consistent height
	among text and text-less buttons (with icons). */
	line-height: 1;

	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	/* Avoid flickering when the foucs border shows up. */
	border: 1px solid transparent;

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .2s ease-in-out, border .2s ease-in-out;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */
	-webkit-appearance: none;

	&:active,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	/* Allow icon coloring using the text "color" property. */
	& .ck-button__icon {
		& use,
		& use * {
			color: inherit;
		}
	}

	& .ck-button__label {
		/* Enable font size inheritance, which allows fluid UI scaling. */
		font-size: inherit;
		font-weight: inherit;
		color: inherit;
		cursor: inherit;

		/* Must be consistent with .ck-icon's vertical align. Otherwise, buttons with and
		without labels (but with icons) have different sizes in Chrome */
		vertical-align: middle;

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}
	}

	& .ck-button__keystroke {
		color: inherit;

		@mixin ck-dir ltr {
			margin-left: var(--ck-spacing-large);
		}

		@mixin ck-dir rtl {
			margin-right: var(--ck-spacing-large);
		}

		font-weight: bold;
		opacity: .7;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
	&.ck-disabled {
		&:active,
		&:focus {
			/* The disabled button should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}

		& .ck-button__icon {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
		& .ck-button__label {
			@mixin ck-disabled;
		}

		& .ck-button__keystroke {
			opacity: .3;
		}
	}

	&.ck-button_with-text {
		padding: var(--ck-spacing-tiny) var(--ck-spacing-standard);

		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__icon {
			@mixin ck-dir ltr {
				margin-left: calc(-1 * var(--ck-spacing-small));
				margin-right: var(--ck-spacing-small);
			}

			@mixin ck-dir rtl {
				margin-right: calc(-1 * var(--ck-spacing-small));
				margin-left: var(--ck-spacing-small);
			}
		}
	}

	&.ck-button_with-keystroke {
		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__label {
			flex-grow: 1;
		}
	}

	/* A style of the button which is currently on, e.g. its feature is active. */
	&.ck-on {
		@mixin ck-button-colors --ck-color-button-on;

		color: var(--ck-color-button-on-color);
	}

	&.ck-button-save {
		color: var(--ck-color-button-save);
	}

	&.ck-button-cancel {
		color: var(--ck-color-button-cancel);
	}
}

/* A style of the button which handles the primary action. */
.ck.ck-button-action,
a.ck.ck-button-action {
	@mixin ck-button-colors --ck-color-button-action;

	color: var(--ck-color-button-action-text);
}

.ck.ck-button-bold,
a.ck.ck-button-bold {
	font-weight: bold;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements a button of given background color.
 *
 * @param {String} $background - Background color of the button.
 * @param {String} $border - Border color of the button.
 */
@define-mixin ck-button-colors $prefix {
	background: var($(prefix)-background);

	&:not(.ck-disabled) {
		&:hover {
			background: var($(prefix)-hover-background);
		}

		&:active {
			background: var($(prefix)-active-background);
		}
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
	&.ck-disabled {
		background: var($(prefix)-disabled-background);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 6758: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-button.ck-switchbutton {
	& .ck-button__toggle {
		display: block;

		& .ck-button__toggle__inner {
			display: block;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature
of the component, floating–point numbers have been used which, for the default font size
(see: --ck-font-size-base), will generate simple integers. */
:root {
	/* 34px at 13px font-size */
	--ck-switch-button-toggle-width: 2.6153846154em;
	/* 14px at 13px font-size */
	--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);
	--ck-switch-button-translation: calc(
		var(--ck-switch-button-toggle-width) -
		var(--ck-switch-button-toggle-inner-size) -
		2px /* Border */
	);
	--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);
}

.ck.ck-button.ck-switchbutton {
	/* Unlike a regular button, the switch button text color and background should never change.
	 * Changing toggle switch (background, outline) is enough to carry the information about the
	 * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)
	 */
	&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {
		color: inherit;
		background: transparent;
	}

	& .ck-button__label {
		@mixin ck-dir ltr {
			/* Separate the label from the switch */
			margin-right: calc(2 * var(--ck-spacing-large));
		}

		@mixin ck-dir rtl {
			/* Separate the label from the switch */
			margin-left: calc(2 * var(--ck-spacing-large));
		}
	}

	& .ck-button__toggle {
		@mixin ck-rounded-corners;

		@mixin ck-dir ltr {
			/* Make sure the toggle is always to the right as far as possible. */
			margin-left: auto;
		}

		@mixin ck-dir rtl {
			/* Make sure the toggle is always to the left as far as possible. */
			margin-right: auto;
		}

		/* Apply some smooth transition to the box-shadow and border. */
		/* Gently animate the background color of the toggle switch */
		transition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;
		border: 1px solid transparent;
		width: var(--ck-switch-button-toggle-width);
		background: var(--ck-color-switch-button-off-background);

		& .ck-button__toggle__inner {
			@mixin ck-rounded-corners {
				border-radius: calc(.5 * var(--ck-border-radius));
			}

			width: var(--ck-switch-button-toggle-inner-size);
			height: var(--ck-switch-button-toggle-inner-size);
			background: var(--ck-color-switch-button-inner-background);

			/* Gently animate the inner part of the toggle switch */
			transition: all 300ms ease;
		}

		&:hover {
			background: var(--ck-color-switch-button-off-hover-background);

			& .ck-button__toggle__inner {
				box-shadow: var(--ck-switch-button-inner-hover-shadow);
			}
		}
	}

	&.ck-disabled .ck-button__toggle {
		@mixin ck-disabled;
	}

	/* Overriding default .ck-button:focus styles + an outline around the toogle */
	&:focus {
		border-color: transparent;
		outline: none;
		box-shadow: none;

		& .ck-button__toggle {
			box-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);
			outline-offset: 1px;
			outline: var(--ck-focus-ring);
		}
	}

	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-on {
		& .ck-button__toggle {
			background: var(--ck-color-switch-button-on-background);

			&:hover {
				background: var(--ck-color-switch-button-on-hover-background);
			}

			& .ck-button__toggle__inner {
				/*
				* Move the toggle switch to the right. It will be animated.
				*/
				@mixin ck-dir ltr {
					transform: translateX( var( --ck-switch-button-translation ) );
				}

				@mixin ck-dir rtl {
					transform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );
				}
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 6781: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"], names: [], mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-color-grid {
	display: grid;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-grid-tile-size: 24px;

	/* Not using global colors here because these may change but some colors in a pallette
	 * require special treatment. For instance, this ensures no matter what the UI text color is,
	 * the check icon will look good on the black color tile. */
	--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);
}

.ck.ck-color-grid {
	grid-gap: 5px;
	padding: 8px;
}

.ck.ck-color-grid__tile {
	width: var(--ck-color-grid-tile-size);
	height: var(--ck-color-grid-tile-size);
	min-width: var(--ck-color-grid-tile-size);
	min-height: var(--ck-color-grid-tile-size);
	padding: 0;
	transition: .2s ease box-shadow;
	border: 0;

	&.ck-disabled {
		cursor: unset;
		transition: unset;
	}

	&.ck-color-table__color-tile_bordered {
		box-shadow: 0 0 0 1px var(--ck-color-base-border);
	}

	& .ck.ck-icon {
		display: none;
		color: var(--ck-color-color-grid-check-icon);
	}

	&.ck-on {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);

		& .ck.ck-icon {
			display: block;
		}
	}

	&.ck-on,
	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		/* Disable the default .ck-button's border ring. */
		border: 0;
	}

	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);
	}
}

.ck.ck-color-grid__label {
	padding: 0 var(--ck-spacing-standard);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 3398: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-input{min-width:unset}.color-picker-hex-input{width:max-content}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/colorpicker/colorpicker.css"], names: [], mappings: "AAKA,aACC,eACD,CAEA,wBACC,iBACD,CAEA,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAMD,CAJC,qDAEC,sCAAuC,CADvC,kCAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-input {
	min-width: unset;
}

.color-picker-hex-input {
	width: max-content;
}

.ck.ck-color-picker__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;

	& .ck-color-picker__hash-view {
		padding-top: var(--ck-spacing-tiny);
		padding-right: var(--ck-spacing-medium);
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 5485: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-dropdown-max-width: 75vw;
}

.ck.ck-dropdown {
	display: inline-block;
	position: relative;

	& .ck-dropdown__arrow {
		pointer-events: none;
		z-index: var(--ck-z-default);
	}

	/* Dropdown button should span horizontally, e.g. in vertical toolbars */
	& .ck-button.ck-dropdown__button {
		width: 100%;
	}

	& .ck-dropdown__panel {
		display: none;
		z-index: var(--ck-z-modal);
		max-width: var(--ck-dropdown-max-width);

		position: absolute;

		&.ck-dropdown__panel-visible {
			display: inline-block;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_n,
		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_nme {
			bottom: 100%;
		}

		&.ck-dropdown__panel_se,
		&.ck-dropdown__panel_sw,
		&.ck-dropdown__panel_smw,
		&.ck-dropdown__panel_sme,
		&.ck-dropdown__panel_s {
			/*
			 * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.
			 * See https://github.com/ckeditor/ckeditor5/issues/1053.
			 */
			top: 100%;
			bottom: auto;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_se {
			left: 0px;
		}

		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_sw {
			right: 0px;
		}

		&.ck-dropdown__panel_s,
		&.ck-dropdown__panel_n {
			/* Positioning panels relative to the center of the button */
			left: 50%;
			transform: translateX(-50%);
		}

		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_smw {
			/* Positioning panels relative to the middle-west of the button */
			left: 75%;
			transform: translateX(-75%);
		}

		&.ck-dropdown__panel_nme,
		&.ck-dropdown__panel_sme {
			/* Positioning panels relative to the middle-east of the button */
			left: 25%;
			transform: translateX(-25%);
		}
	}
}

/*
 * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.
 * See https://github.com/ckeditor/ckeditor5/issues/7874
 */
.ck.ck-toolbar .ck-dropdown__panel {
	z-index: calc( var(--ck-z-modal) + 1 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-dropdown {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-dropdown__arrow {
		width: var(--ck-dropdown-arrow-size);
	}

	@mixin ck-dir ltr {
		& .ck-dropdown__arrow {
			right: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-dropdown__arrow {
			left: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-right: var(--ck-spacing-small);
		}
	}

	&.ck-disabled .ck-dropdown__arrow {
		@mixin ck-disabled;
	}

	& .ck-button.ck-dropdown__button {
		@mixin ck-dir ltr {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-left: var(--ck-spacing-small);
			}
		}

		@mixin ck-dir rtl {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-right: var(--ck-spacing-small);
			}
		}

		/* #23 */
		& .ck-button__label {
			width: 7em;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
		&.ck-disabled .ck-button__label {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/816 */
		&.ck-on {
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
		}

		&.ck-dropdown__button_label-width_auto .ck-button__label {
			width: auto;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/8699 */
		&.ck-off:active,
		&.ck-on:active {
			box-shadow: none;
			
			&:focus {
				@mixin ck-box-shadow var(--ck-focus-outer-shadow);
			}
		}
	}
}

.ck.ck-dropdown__panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	background: var(--ck-color-dropdown-panel-background);
	border: 1px solid var(--ck-color-dropdown-panel-border);
	bottom: 0;

	/* Make sure the panel is at least as wide as the drop-down's button. */
	min-width: 100%;

	/* Disabled corner border radius to be consistent with the .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-dropdown__panel_se {
		border-top-left-radius: 0;
	}

	&.ck-dropdown__panel_sw {
		border-top-right-radius: 0;
	}

	&.ck-dropdown__panel_ne {
		border-bottom-left-radius: 0;
	}

	&.ck-dropdown__panel_nw {
		border-bottom-right-radius: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 3949: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

.ck.ck-dropdown .ck-dropdown__panel .ck-list {
	/* Disabled radius of top-left border to be consistent with .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
	}

	/* Make sure the button belonging to the first/last child of the list goes well with the
	border radius of the entire panel. */
	& .ck-list__item {
		&:first-child .ck-button {
			@mixin ck-rounded-corners {
				border-top-left-radius: 0;
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}
		}

		&:last-child .ck-button {
			@mixin ck-rounded-corners {
				border-top-left-radius: 0;
				border-top-right-radius: 0;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 7686: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-splitbutton {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-splitbutton__action:focus {
		z-index: calc(var(--ck-z-default) + 1);
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-split-button-hover-background: hsl(0, 0%, 92%);
	--ck-color-split-button-hover-border: hsl(0, 0%, 70%);
}

.ck.ck-splitbutton {
	/*
	 * Note: ck-rounded and ck-dir mixins don't go together (because they both use @nest).
	 */
	&:hover > .ck-splitbutton__action,
	&.ck-splitbutton_open > .ck-splitbutton__action {
		@nest [dir="ltr"] & {
			/* Don't round the action button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the action button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}
	}

	& > .ck-splitbutton__arrow {
		/* It's a text-less button and since the icon is positioned absolutely in such situation,
		it must get some arbitrary min-width. */
		min-width: unset;

		@nest [dir="ltr"] & {
			/* Don't round the arrow button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the arrow button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		& svg {
			width: var(--ck-dropdown-arrow-size);
		}
	}

	/* Make sure the divider stretches 100% height of the button
	https://github.com/ckeditor/ckeditor5/issues/10936 */
	& > .ck-splitbutton__arrow:not(:focus) {
		border-top-width: 0px;
		border-bottom-width: 0px;
	}

	/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling
	as a whole. The background of both buttons should stand out and there should be a visual
	separation between both buttons. */
	&.ck-splitbutton_open,
	&:hover {
		/* When the split button hovered as a whole, not as individual buttons. */
		& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {
			background: var(--ck-color-split-button-hover-background);
		}

		/* Splitbutton separator needs to be set with the ::after pseudoselector
		to display properly the borders on focus */
		& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
			content: '';
			position: absolute;
			width: 1px;
			height: 100%;
			background-color: var(--ck-color-split-button-hover-border);
		}

		/* Make sure the divider between the buttons looks fine when the button is focused */
		& > .ck-splitbutton__arrow:focus::after {
			--ck-color-split-button-hover-border: var(--ck-color-focus-border);
		}

		@nest [dir="ltr"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				left: -1px;
			}
		}

		@nest [dir="rtl"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				right: -1px;
			}
		}
	}

	/* Don't round the bottom left and right corners of the buttons when "open"
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-splitbutton_open {
		@mixin ck-rounded-corners {
			& > .ck-splitbutton__action {
				border-bottom-left-radius: 0;
			}

			& > .ck-splitbutton__arrow {
				border-bottom-right-radius: 0;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 7339: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"], names: [], mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-toolbar-dropdown-max-width: 60vw;
}

.ck.ck-toolbar-dropdown > .ck-dropdown__panel {
	/* https://github.com/ckeditor/ckeditor5/issues/5586 */
	width: max-content;
	max-width: var(--ck-toolbar-dropdown-max-width);

	& .ck-button {
		&:focus {
			z-index: calc(var(--ck-z-default) + 1);
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-toolbar-dropdown .ck-toolbar {
	border: 0;
}
`], sourceRoot: "" }]);
      const E = k;
    }, 9688: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_focus.css";
@import "../../mixins/_button.css";

:root {
	--ck-color-editable-blur-selection: hsl(0, 0%, 85%);
}

.ck.ck-editor__editable:not(.ck-editor__nested-editable) {
	@mixin ck-rounded-corners;

	&.ck-focused {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);
	}
}

.ck.ck-editor__editable_inline {
	overflow: auto;
	padding: 0 var(--ck-spacing-standard);
	border: 1px solid transparent;

	&[dir="ltr"] {
		text-align: left;
	}

	&[dir="rtl"] {
		text-align: right;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */
	& > *:first-child {
		margin-top: var(--ck-spacing-large);
	}

	/* https://github.com/ckeditor/ckeditor5/issues/847 */
	& > *:last-child {
		/*
		 * This value should match with the default margins of the block elements (like .media or .image)
		 * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).
		 */
		margin-bottom: var(--ck-spacing-large);
	}

	/* https://github.com/ckeditor/ckeditor5/issues/6517 */
	&.ck-blurred ::selection {
		background: var(--ck-color-editable-blur-selection);
	}
}

/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */
.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {
	&::after {
		border-bottom-color: var(--ck-color-base-foreground);
	}
}

.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {
	&::after {
		border-top-color: var(--ck-color-base-foreground);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 8847: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"], names: [], mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form__header {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	align-items: center;
	justify-content: space-between;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-form-header-height: 38px;
}

.ck.ck-form__header {
	padding: var(--ck-spacing-small) var(--ck-spacing-large);
	height: var(--ck-form-header-height);
	line-height: var(--ck-form-header-height);
	border-bottom: 1px solid var(--ck-color-base-border);

	& .ck-form__header__label {
		font-weight: bold;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 6574: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/icon/icon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"], names: [], mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-icon {
	vertical-align: middle;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));
}

.ck.ck-icon {
	width: var(--ck-icon-size);
	height: var(--ck-icon-size);

	/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */
	font-size: .8333350694em;

	/* Inherit cursor style (#5). */
	cursor: inherit;

	/* This will prevent blurry icons on Firefox. See #340. */
	will-change: transform;

	& * {
		/* Inherit cursor style (#5). */
		cursor: inherit;
	}

	/* Allows dynamic coloring of an icon by inheriting its color from the parent. */
	&.ck-icon_inherit-color {
		color: inherit;

		& * {
			color: inherit;

			&:not([fill]) {
				/* Needed by FF. */
				fill: currentColor;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 4879: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-input-width: 18em;

	/* Backward compatibility. */
	--ck-input-text-width: var(--ck-input-width);
}

.ck.ck-input {
	@mixin ck-rounded-corners;

	background: var(--ck-color-input-background);
	border: 1px solid var(--ck-color-input-border);
	padding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);
	min-width: var(--ck-input-width);

	/* This is important to stay of the same height as surrounding buttons */
	min-height: var(--ck-ui-component-min-height);

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .1s ease-in-out, border .1s ease-in-out;

	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	&[readonly] {
		border: 1px solid var(--ck-color-input-disabled-border);
		background: var(--ck-color-input-disabled-background);
		color: var(--ck-color-input-disabled-text);

		&:focus {
			/* The read-only input should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}
	}

	&.ck-error {
		border-color: var(--ck-color-input-error-border);
		animation: ck-input-shake .3s ease both;

		&:focus {
			@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);
		}
	}
}

@keyframes ck-input-shake {
	20% {
		transform: translateX(-2px);
	}

	40% {
		transform: translateX(2px);
	}

	60% {
		transform: translateX(-1px);
	}

	80% {
		transform: translateX(1px);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 3662: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/label/label.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"], names: [], mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-label {
	display: block;
}

.ck.ck-voice-label {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-label {
	font-weight: bold;
}
`], sourceRoot: "" }]);
      const E = k;
    }, 2577: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-labeled-field-view {
	& > .ck.ck-labeled-field-view__input-wrapper {
		display: flex;
		position: relative;
	}

	& .ck.ck-label {
		display: block;
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../../../mixins/_rounded.css";

:root {
	--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);
	--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));
	--ck-color-labeled-field-label-background: var(--ck-color-base-background);
}

.ck.ck-labeled-field-view {
	@mixin ck-rounded-corners;

	& > .ck.ck-labeled-field-view__input-wrapper {
		width: 100%;

		& > .ck.ck-label {
			top: 0px;

			@mixin ck-dir ltr {
				left: 0px;
			}

			@mixin ck-dir rtl {
				right: 0px;
			}

			pointer-events: none;
			transform-origin: 0 0;

			/* By default, display the label scaled down above the field. */
			transform: translate(var(--ck-spacing-medium), -6px) scale(.75);

			background: var(--ck-color-labeled-field-label-background);
			padding: 0 calc(.5 * var(--ck-font-size-tiny));
			line-height: initial;
			font-weight: normal;

			/* Prevent overflow when the label is longer than the input */
			text-overflow: ellipsis;
			overflow: hidden;

			max-width: 100%;

			transition:
				transform var(--ck-labeled-field-view-transition),
				padding var(--ck-labeled-field-view-transition),
				background var(--ck-labeled-field-view-transition);
		}
	}

	&.ck-error {
		& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
			color: var(--ck-color-base-error);
		}

		& .ck-input:not([readonly]) + .ck.ck-label {
			color: var(--ck-color-base-error);
		}
	}

	& .ck-labeled-field-view__status {
		font-size: var(--ck-font-size-small);
		margin-top: var(--ck-spacing-small);

		/* Let the info wrap to the next line to avoid stretching the layout horizontally.
		The status could be very long. */
		white-space: normal;

		&.ck-labeled-field-view__status_error {
			color: var(--ck-color-base-error);
		}
	}

	/* Disabled fields and fields that have no focus should fade out. */
	&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		color: var(--ck-color-input-disabled-text);
	}

	/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */
	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		@mixin ck-dir ltr {
			transform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		@mixin ck-dir rtl {
			transform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		/* Compensate for the default translate position. */
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));

		background: transparent;
		padding: 0;
	}

	/*------ DropdownView integration ----------------------------------------------------------------------------------- */

	/* Make sure dropdown' background color in any of dropdown's state does not collide with labeled field. */
	& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {
		background: transparent;
	}

	/* When the dropdown is "empty", the labeled field label replaces its label. */
	&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {
		opacity: 0;
	}

	/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 1046: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/list/list.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-list {
	@mixin ck-unselectable;

	display: flex;
	flex-direction: column;

	& .ck-list__item,
	& .ck-list__separator {
		display: block;
	}

	/* Make sure that whatever child of the list item gets focus, it remains on the
	top. Thanks to that, styles like box-shadow, outline, etc. are not masked by
	adjacent list items. */
	& .ck-list__item > *:focus {
		position: relative;
		z-index: var(--ck-z-default);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";

.ck.ck-list {
	@mixin ck-rounded-corners;

	list-style-type: none;
	background: var(--ck-color-list-background);
}

.ck.ck-list__item {
	cursor: default;
	min-width: 12em;

	& .ck-button {
		min-height: unset;
		width: 100%;
		text-align: left;
		border-radius: 0;

		/* List items should have the same height. Use absolute units to make sure it is so
		   because e.g. different heading styles may have different height
		   https://github.com/ckeditor/ckeditor5-heading/issues/63 */
		padding:
			calc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))
			calc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));

		& .ck-button__label {
			/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */
			line-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));
		}

		&:active {
			box-shadow: none;
		}

		&.ck-on {
			background: var(--ck-color-list-button-on-background);
			color: var(--ck-color-list-button-on-text);

			&:active {
				box-shadow: none;
			}

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-on-background-focus);
			}

			&:focus:not(.ck-switchbutton):not(.ck-disabled) {
				border-color: var(--ck-color-base-background);
			}
		}

		&:hover:not(.ck-disabled) {
			background: var(--ck-color-list-button-hover-background);
		}
	}

	/* It's unnecessary to change the background/text of a switch toggle; it has different ways
	of conveying its state (like the switcher) */
	& .ck-switchbutton {
		&.ck-on {
			background: var(--ck-color-list-background);
			color: inherit;

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-hover-background);
				color: inherit;
			}
		}
	}
}

.ck.ck-list__separator {
	height: 1px;
	width: 100%;
	background: var(--ck-color-base-border);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 8793: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Make sure the balloon arrow does not float over its children. */
	--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);
}

.ck.ck-balloon-panel {
	display: none;
	position: absolute;

	z-index: var(--ck-z-modal);

	&.ck-balloon-panel_with-arrow {
		&::before,
		&::after {
			content: "";
			position: absolute;
		}

		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&[class*="arrow_n"] {
		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&[class*="arrow_s"] {
		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&.ck-balloon-panel_visible {
		display: block;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-balloon-border-width: 1px;
	--ck-balloon-arrow-offset: 2px;
	--ck-balloon-arrow-height: 10px;
	--ck-balloon-arrow-half-width: 8px;
	--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);
}

.ck.ck-balloon-panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	min-height: 15px;

	background: var(--ck-color-panel-background);
	border: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);

	&.ck-balloon-panel_with-arrow {
		&::before,
		&::after {
			width: 0;
			height: 0;
			border-style: solid;
		}
	}

	&[class*="arrow_n"] {
		&::before,
		&::after {
			border-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);
		}

		&::before {
			border-color: transparent transparent var(--ck-color-panel-border) transparent;
			margin-top: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent transparent var(--ck-color-panel-background) transparent;
			margin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_s"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);
		}

		&::before {
			border-color: var(--ck-color-panel-border) transparent transparent;
			filter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));
			margin-bottom: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: var(--ck-color-panel-background) transparent transparent transparent;
			margin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_e"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);
		}

		&::before {
			border-color: transparent transparent transparent var(--ck-color-panel-border);
			margin-right: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent transparent transparent var(--ck-color-panel-background);
			margin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_w"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;
		}

		&::before {
			border-color: transparent var(--ck-color-panel-border) transparent transparent;
			margin-left: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent var(--ck-color-panel-background) transparent transparent;
			margin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&.ck-balloon-panel_arrow_n {
		&::before,
		&::after {
			left: 50%;
			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nw {
		&::before,
		&::after {
			left: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_ne {
		&::before,
		&::after {
			right: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_s {
		&::before,
		&::after {
			left: 50%;
			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_sw {
		&::before,
		&::after {
			left: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_se {
		&::before,
		&::after {
			right: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_sme {
		&::before,
		&::after {
			right: 25%;
			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_smw {
		&::before,
		&::after {
			left: 25%;
			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nme {
		&::before,
		&::after {
			right: 25%;
			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nmw {
		&::before,
		&::after {
			left: 25%;
			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_e {
		&::before,
		&::after {
			right: calc(-1 * var(--ck-balloon-arrow-height));
			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: 50%;
		}
	}

	&.ck-balloon-panel_arrow_w {
		&::before,
		&::after {
			left: calc(-1 * var(--ck-balloon-arrow-height));
			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 4650: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"], names: [], mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-balloon-rotator__navigation {
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Buttons inside a toolbar should be centered when rotator bar is wider.
 * See: https://github.com/ckeditor/ckeditor5-ui/issues/495
 */
.ck .ck-balloon-rotator__content .ck-toolbar {
	justify-content: center;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-balloon-rotator__navigation {
	background: var(--ck-color-toolbar-background);
	border-bottom: 1px solid var(--ck-color-toolbar-border);
	padding: 0 var(--ck-spacing-small);

	/* Let's keep similar appearance to \`ck-toolbar\`. */
	& > * {
		margin-right: var(--ck-spacing-small);
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	/* Gives counter more breath than buttons. */
	& .ck-balloon-rotator__counter {
		margin-right: var(--ck-spacing-standard);

		/* We need to use smaller margin because of previous button's right margin. */
		margin-left: var(--ck-spacing-small);
	}
}

.ck .ck-balloon-rotator__content {

	/* Disable default annotation shadow inside rotator with fake panels. */
	& .ck.ck-annotation-wrapper {
		box-shadow: none;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 7676: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-fake-panel {
	position: absolute;

	/* Fake panels should be placed under main balloon content. */
	z-index: calc(var(--ck-z-modal) - 1);
}

.ck .ck-fake-panel div {
	position: absolute;
}

.ck .ck-fake-panel div:nth-child( 1 ) {
	z-index: 2;
}

.ck .ck-fake-panel div:nth-child( 2 ) {
	z-index: 1;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_shadow.css";

:root {
	--ck-balloon-fake-panel-offset-horizontal: 6px;
	--ck-balloon-fake-panel-offset-vertical: 6px;
}

/* Let's use \`.ck-balloon-panel\` appearance. See: balloonpanel.css. */
.ck .ck-fake-panel div {
	@mixin ck-drop-shadow;

	min-height: 15px;

	background: var(--ck-color-panel-background);
	border: 1px solid var(--ck-color-panel-border);
	border-radius: var(--ck-border-radius);

	width: 100%;
	height: 100%;
}

.ck .ck-fake-panel div:nth-child( 1 ) {
	margin-left: var(--ck-balloon-fake-panel-offset-horizontal);
	margin-top: var(--ck-balloon-fake-panel-offset-vertical);
}

.ck .ck-fake-panel div:nth-child( 2 ) {
	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);
	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);
}
.ck .ck-fake-panel div:nth-child( 3 ) {
	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);
	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);
}

/* If balloon is positioned above element, we need to move fake panel to the top. */
.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,
.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,
.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {
	--ck-balloon-fake-panel-offset-vertical: -6px;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 5868: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-sticky-panel {
	& .ck-sticky-panel__content_sticky {
		z-index: var(--ck-z-modal); /* #315 */
		position: fixed;
		top: 0;
	}

	& .ck-sticky-panel__content_sticky_bottom-limit {
		top: auto;
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_shadow.css";

.ck.ck-sticky-panel {
	& .ck-sticky-panel__content_sticky {
		@mixin ck-drop-shadow;

		border-width: 0 1px 1px;
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 6764: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"], names: [], mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck-vertical-form .ck-button {
	&::after {
		content: "";
		width: 0;
		position: absolute;
		right: -1px;
		top: -1px;
		bottom: -1px;
		z-index: 1;
	}

	&:focus::after {
		display: none;
	}
}

.ck.ck-responsive-form {
	@mixin ck-media-phone {
		& .ck-button {
			&::after {
				content: "";
				width: 0;
				position: absolute;
				right: -1px;
				top: -1px;
				bottom: -1px;
				z-index: 1;
			}

			&:focus::after {
				display: none;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck-vertical-form > .ck-button:nth-last-child(2)::after {
	border-right: 1px solid var(--ck-color-base-border);
}

.ck.ck-responsive-form {
	padding: var(--ck-spacing-large);

	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}

	@mixin ck-dir ltr {
		& > :not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& > :not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		padding: 0;
		width: calc(.8 * var(--ck-input-width));

		& .ck-labeled-field-view {
			margin: var(--ck-spacing-large) var(--ck-spacing-large) 0;

			& .ck-input-text {
				min-width: 0;
				width: 100%;
			}

			/* Let the long error messages wrap in the narrow form. */
			& .ck-labeled-field-view__error {
				white-space: normal;
			}
		}

		/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */
		& > .ck-button:nth-last-child(2) {
			&::after {
				border-right: 1px solid var(--ck-color-base-border);
			}
		}

		& > .ck-button:nth-last-child(1),
		& > .ck-button:nth-last-child(2) {
			padding: var(--ck-spacing-standard);
			margin-top: var(--ck-spacing-large);
			border-radius: 0;

			&:not(:focus) {
				border-top: 1px solid var(--ck-color-base-border);
			}

			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;

				&:last-of-type {
					border-right: 1px solid var(--ck-color-base-border);
				}
			}
		}
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 9695: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"], names: [], mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-block-toolbar-button {
	position: absolute;
	z-index: var(--ck-z-default);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-block-toolbar-button: var(--ck-color-text);
	--ck-block-toolbar-button-size: var(--ck-font-size-normal);
}

.ck.ck-block-toolbar-button {
	color: var(--ck-color-block-toolbar-button);
	font-size: var(--ck-block-toolbar-size);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 5542: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-toolbar {
	@mixin ck-unselectable;

	display: flex;
	flex-flow: row nowrap;
	align-items: center;

	& > .ck-toolbar__items {
		display: flex;
		flex-flow: row wrap;
		align-items: center;
		flex-grow: 1;

	}

	& .ck.ck-toolbar__separator {
		display: inline-block;

		/*
		 * A leading or trailing separator makes no sense (separates from nothing on one side).
		 * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and
		 * moved to another toolbar in the dropdown.
		 */
		&:first-child,
		&:last-child {
			display: none;
		}
	}

	& .ck-toolbar__line-break {
		flex-basis: 100%;
	}

	&.ck-toolbar_grouping > .ck-toolbar__items {
		flex-wrap: nowrap;
	}

	&.ck-toolbar_vertical > .ck-toolbar__items {
		flex-direction: column;
	}

	&.ck-toolbar_floating > .ck-toolbar__items {
		flex-wrap: nowrap;
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		& > .ck-dropdown__button .ck-dropdown__arrow {
			display: none;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-toolbar {
	@mixin ck-rounded-corners;

	background: var(--ck-color-toolbar-background);
	padding: 0 var(--ck-spacing-small);
	border: 1px solid var(--ck-color-toolbar-border);

	& .ck.ck-toolbar__separator {
		align-self: stretch;
		width: 1px;
		min-width: 1px;
		background: var(--ck-color-toolbar-border);

		/*
		 * These margins make the separators look better in balloon toolbars (when aligned with the "tip").
		 * See https://github.com/ckeditor/ckeditor5/issues/7493.
		 */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	& .ck-toolbar__line-break {
		height: 0;
	}

	& > .ck-toolbar__items {
		& > *:not(.ck-toolbar__line-break) {
			/* (#11) Separate toolbar items. */
			margin-right: var(--ck-spacing-small);
		}

		/* Don't display a separator after an empty items container, for instance,
		when all items were grouped */
		&:empty + .ck.ck-toolbar__separator {
			display: none;
		}
	}

	& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),
	& > .ck.ck-toolbar__grouped-dropdown {
		/* Make sure items wrapped to the next line have v-spacing */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	&.ck-toolbar_vertical {
		/* Items in a vertical toolbar span the entire width. */
		padding: 0;

		/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */
		& > .ck-toolbar__items > .ck {
			/* Items in a vertical toolbar should span the horizontal space. */
			width: 100%;

			/* Items in a vertical toolbar should have no margin. */
			margin: 0;

			/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */
			border-radius: 0;
		}
	}

	&.ck-toolbar_compact {
		/* No spacing around items. */
		padding: 0;

		& > .ck-toolbar__items > * {
			/* Compact toolbar items have no spacing between them. */
			margin: 0;

			/* "Middle" children should have no rounded corners. */
			&:not(:first-child):not(:last-child) {
				border-radius: 0;
			}
		}
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		/*
		 * Dropdown button has asymmetric padding to fit the arrow.
		 * This button has no arrow so let's revert that padding back to normal.
		 */
		& > .ck.ck-button.ck-dropdown__button {
			padding-left: var(--ck-spacing-tiny);
		}
	}

	/* A drop-down containing the nested toolbar with configured items. */
	& .ck-toolbar__nested-toolbar-dropdown {
		/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */
		& > .ck-dropdown__panel {
			min-width: auto;
		}

		& > .ck-button > .ck-button__label {
			max-width: 7em;
			width: auto;
		}
	}

	&:focus {
		outline: none;
	}

	@nest .ck-toolbar-container & {
		border: 0;
	}
}

/* stylelint-disable */

/*
 * Styles for RTL toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="rtl"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="rtl"] {
	& > .ck-toolbar__items > .ck {
		margin-right: 0;
	}

	&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {
		/* (#11) Separate toolbar items. */
		margin-left: var(--ck-spacing-small);
	}

	& > .ck-toolbar__items > .ck:last-child {
		margin-left: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-left: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-left: var(--ck-spacing-small);
	}
}

/*
 * Styles for LTR toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="ltr"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="ltr"] {
	& > .ck-toolbar__items > .ck:last-child {
		margin-right: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-right: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-right: var(--ck-spacing-small);
	}
}

/* stylelint-enable */
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 3332: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"], names: [], mappings: "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-balloon-panel.ck-tooltip {
	/* Keep tooltips transparent for any interactions. */
	pointer-events: none;

	z-index: calc( var(--ck-z-modal) + 100 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

.ck.ck-balloon-panel.ck-tooltip {
	--ck-balloon-border-width: 0px;
	--ck-balloon-arrow-offset: 0px;
	--ck-balloon-arrow-half-width: 4px;
	--ck-balloon-arrow-height: 4px;
	--ck-color-panel-background: var(--ck-color-tooltip-background);

	padding: 0 var(--ck-spacing-medium);

	& .ck-tooltip__text {
		font-size: .9em;
		line-height: 1.5;
		color: var(--ck-color-tooltip-text);
	}

	/* Reset balloon panel styles */
	box-shadow: none;

	/* Hide the default shadow of the .ck-balloon-panel tip */
	&::before {
		display: none;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 4793: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);border:0;box-shadow:none;min-height:unset}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/globals/_hidden.css", "webpack://./../ckeditor5-ui/theme/globals/_reset.css", "webpack://./../ckeditor5-ui/theme/globals/_zindex.css", "webpack://./../ckeditor5-ui/theme/globals/_transition.css", "webpack://./../ckeditor5-ui/theme/globals/_poweredby.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"], names: [], mappings: "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAItD,0CAA2C,CAF3C,QAAS,CACT,eAAgB,CAEhB,gBA6CD,CA3CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,2BAA4B,CAC5B,8CACD,CC5DD,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which hides an element in DOM.
 */
.ck-hidden {
	/* Override selector specificity. Otherwise, all elements with some display
	style defined will override this one, which is not a desired result. */
	display: none !important;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-reset,
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	box-sizing: border-box;
	width: auto;
	height: auto;
	position: static;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-z-default: 1;
	--ck-z-modal: calc( var(--ck-z-default) + 999 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class that disables all transitions of the element and its children.
 */
.ck-transitions-disabled,
.ck-transitions-disabled * {
	transition: none !important;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-powered-by-line-height: 10px;
	--ck-powered-by-padding-vertical: 2px;
	--ck-powered-by-padding-horizontal: 4px;
	--ck-powered-by-text-color: hsl(0, 0%, 31%);
	--ck-powered-by-border-radius: var(--ck-border-radius);
	--ck-powered-by-background: hsl(0, 0%, 100%);
	--ck-powered-by-border-color: var(--ck-color-focus-border);
}

.ck.ck-balloon-panel.ck-powered-by-balloon {
	--ck-border-radius: var(--ck-powered-by-border-radius);

	border: 0;
	box-shadow: none;
	background: var(--ck-powered-by-background);
	min-height: unset;

	& .ck.ck-powered-by {
		line-height: var(--ck-powered-by-line-height);

		& a {
			cursor: pointer;
			display: flex;
			align-items: center;
			opacity: .66;
			filter: grayscale(80%);
			line-height: var(--ck-powered-by-line-height);
			padding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);
		}

		& .ck-powered-by__label {
			font-size: 7.5px;
			letter-spacing: -.2px;
			padding-left: 2px;
			text-transform: uppercase;
			font-weight: bold;
			margin-right: 4px;
			cursor: pointer;
			line-height: normal;
			color: var(--ck-powered-by-text-color);

		}

		& .ck-icon {
			display: block;
			cursor: pointer;
		}

		&:hover {
			& a {
				filter: grayscale(0%);
				opacity: 1;
			}
		}
	}

	&[class*="position_border"] {
		border: var(--ck-focus-ring);
		border-color: var(--ck-powered-by-border-color);
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-base-foreground: 								hsl(0, 0%, 98%);
	--ck-color-base-background: 								hsl(0, 0%, 100%);
	--ck-color-base-border: 									hsl(220, 6%, 81%);
	--ck-color-base-action: 									hsl(104, 50.2%, 42.5%);
	--ck-color-base-focus: 										hsl(209, 92%, 70%);
	--ck-color-base-text: 										hsl(0, 0%, 20%);
	--ck-color-base-active: 									hsl(218.1, 100%, 58%);
	--ck-color-base-active-focus:								hsl(218.2, 100%, 52.5%);
	--ck-color-base-error:										hsl(15, 100%, 43%);

	/* -- Generic colors ------------------------------------------------------------------------ */

	--ck-color-focus-border-coordinates: 						218, 81.8%, 56.9%;
	--ck-color-focus-border: 									hsl(var(--ck-color-focus-border-coordinates));
	--ck-color-focus-outer-shadow:								hsl(212.4, 89.3%, 89%);
	--ck-color-focus-disabled-shadow:							hsla(209, 90%, 72%,.3);
	--ck-color-focus-error-shadow:								hsla(9,100%,56%,.3);
	--ck-color-text: 											var(--ck-color-base-text);
	--ck-color-shadow-drop: 									hsla(0, 0%, 0%, 0.15);
	--ck-color-shadow-drop-active:								hsla(0, 0%, 0%, 0.2);
	--ck-color-shadow-inner: 									hsla(0, 0%, 0%, 0.1);

	/* -- Buttons ------------------------------------------------------------------------------- */

	--ck-color-button-default-background: 						transparent;
	--ck-color-button-default-hover-background: 				hsl(0, 0%, 94.1%);
	--ck-color-button-default-active-background: 				hsl(0, 0%, 94.1%);
	--ck-color-button-default-disabled-background: 				transparent;

	--ck-color-button-on-background: 							hsl(212, 100%, 97.1%);
	--ck-color-button-on-hover-background: 						hsl(211.7, 100%, 92.9%);
	--ck-color-button-on-active-background: 					hsl(211.7, 100%, 92.9%);
	--ck-color-button-on-disabled-background: 					hsl(211, 15%, 95%);
	--ck-color-button-on-color:									hsl(218.1, 100%, 58%);


	--ck-color-button-action-background: 						var(--ck-color-base-action);
	--ck-color-button-action-hover-background: 					hsl(104, 53.2%, 40.2%);
	--ck-color-button-action-active-background: 				hsl(104, 53.2%, 40.2%);
	--ck-color-button-action-disabled-background: 				hsl(104, 44%, 58%);
	--ck-color-button-action-text: 								var(--ck-color-base-background);

	--ck-color-button-save: 									hsl(120, 100%, 27%);
	--ck-color-button-cancel: 									hsl(15, 100%, 43%);

	--ck-color-switch-button-off-background:					hsl(0, 0%, 57.6%);
	--ck-color-switch-button-off-hover-background:				hsl(0, 0%, 49%);
	--ck-color-switch-button-on-background:						var(--ck-color-button-action-background);
	--ck-color-switch-button-on-hover-background:				hsl(104, 53.2%, 40.2%);
	--ck-color-switch-button-inner-background:					var(--ck-color-base-background);
	--ck-color-switch-button-inner-shadow:						hsla(0, 0%, 0%, 0.1);

	/* -- Dropdown ------------------------------------------------------------------------------ */

	--ck-color-dropdown-panel-background: 						var(--ck-color-base-background);
	--ck-color-dropdown-panel-border: 							var(--ck-color-base-border);

	/* -- Input --------------------------------------------------------------------------------- */

	--ck-color-input-background: 								var(--ck-color-base-background);
	--ck-color-input-border: 									var(--ck-color-base-border);
	--ck-color-input-error-border:								var(--ck-color-base-error);
	--ck-color-input-text: 										var(--ck-color-base-text);
	--ck-color-input-disabled-background: 						hsl(0, 0%, 95%);
	--ck-color-input-disabled-border: 							var(--ck-color-base-border);
	--ck-color-input-disabled-text: 							hsl(0, 0%, 46%);

	/* -- List ---------------------------------------------------------------------------------- */

	--ck-color-list-background: 								var(--ck-color-base-background);
	--ck-color-list-button-hover-background: 					var(--ck-color-button-default-hover-background);
	--ck-color-list-button-on-background: 						var(--ck-color-button-on-color);
	--ck-color-list-button-on-background-focus: 				var(--ck-color-button-on-color);
	--ck-color-list-button-on-text:								var(--ck-color-base-background);

	/* -- Panel --------------------------------------------------------------------------------- */

	--ck-color-panel-background: 								var(--ck-color-base-background);
	--ck-color-panel-border: 									var(--ck-color-base-border);

	/* -- Toolbar ------------------------------------------------------------------------------- */

	--ck-color-toolbar-background: 								var(--ck-color-base-background);
	--ck-color-toolbar-border: 									var(--ck-color-base-border);

	/* -- Tooltip ------------------------------------------------------------------------------- */

	--ck-color-tooltip-background: 								var(--ck-color-base-text);
	--ck-color-tooltip-text: 									var(--ck-color-base-background);

	/* -- Engine -------------------------------------------------------------------------------- */

	--ck-color-engine-placeholder-text: 						hsl(0, 0%, 44%);

	/* -- Upload -------------------------------------------------------------------------------- */

	--ck-color-upload-bar-background:		 					hsl(209, 92%, 70%);

	/* -- Link -------------------------------------------------------------------------------- */

	--ck-color-link-default:									hsl(240, 100%, 47%);
	--ck-color-link-selected-background:						hsla(201, 100%, 56%, 0.1);
	--ck-color-link-fake-selection:								hsla(201, 100%, 56%, 0.3);

	/* -- Search result highlight ---------------------------------------------------------------- */

	--ck-color-highlight-background:							hsl(60, 100%, 50%)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * An opacity value of disabled UI item.
	 */
	--ck-disabled-opacity: .5;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * The geometry of the of focused element's outer shadow.
	 */
	--ck-focus-outer-shadow-geometry: 0 0 0 3px;

	/**
	 * A visual style of focused element's outer shadow.
	 */
	--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);

	/**
	 * A visual style of focused element's outer shadow (when disabled).
	 */
	--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);

	/**
	 * A visual style of focused element's outer shadow (when has errors).
	 */
	--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);

	/**
	 * A visual style of focused element's border or outline.
	 */
	--ck-focus-ring: 1px solid var(--ck-color-focus-border);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-font-size-base: 13px;
	--ck-line-height-base: 1.84615;
	--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;

	--ck-font-size-tiny: 0.7em;
	--ck-font-size-small: 0.75em;
	--ck-font-size-normal: 1em;
	--ck-font-size-big: 1.4em;
	--ck-font-size-large: 1.8em;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* This is super-important. This is **manually** adjusted so a button without an icon
	is never smaller than a button with icon, additionally making sure that text-less buttons
	are perfect squares. The value is also shared by other components which should stay "in-line"
	with buttons. */
	--ck-ui-component-min-height: 2.3em;
}

/**
 * Resets an element, ignoring its children.
 */
.ck.ck-reset,
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	/* Do not include inheritable rules here. */
	margin: 0;
	padding: 0;
	border: 0;
	background: transparent;
	text-decoration: none;
	vertical-align: middle;
	transition: none;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */
	word-wrap: break-word;
}

/**
 * Resets an element AND its children.
 */
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	/* These are rule inherited by all children elements. */
	border-collapse: collapse;
	font: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);
	color: var(--ck-color-text);
	text-align: left;
	white-space: nowrap;
	cursor: auto;
	float: none;
}

.ck-reset_all {
	& .ck-rtl *:not(.ck-reset_all-excluded *) {
		text-align: right;
	}

	& iframe:not(.ck-reset_all-excluded *) {
		/* For IE */
		vertical-align: inherit;
	}

	& textarea:not(.ck-reset_all-excluded *) {
		white-space: pre-wrap;
	}

	& textarea:not(.ck-reset_all-excluded *),
	& input[type="text"]:not(.ck-reset_all-excluded *),
	& input[type="password"]:not(.ck-reset_all-excluded *) {
		cursor: text;
	}

	& textarea[disabled]:not(.ck-reset_all-excluded *),
	& input[type="text"][disabled]:not(.ck-reset_all-excluded *),
	& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {
		cursor: default;
	}

	& fieldset:not(.ck-reset_all-excluded *) {
		padding: 10px;
		border: 2px groove hsl(255, 7%, 88%);
	}

	& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {
		/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */
		padding: 0;
		border: 0
	}
}

/**
 * Default UI rules for RTL languages.
 */
.ck[dir="rtl"],
.ck[dir="rtl"] .ck {
	text-align: right;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Default border-radius value.
 */
:root{
	--ck-border-radius: 2px;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * A visual style of element's inner shadow (i.e. input).
	 */
	--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;

	/**
	 * A visual style of element's drop shadow (i.e. panel).
	 */
	--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);

	/**
	 * A visual style of element's active shadow (i.e. comment or suggestion).
	 */
	--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-spacing-unit: 						0.6em;
	--ck-spacing-large: 					calc(var(--ck-spacing-unit) * 1.5);
	--ck-spacing-standard: 					var(--ck-spacing-unit);
	--ck-spacing-medium: 					calc(var(--ck-spacing-unit) * 0.8);
	--ck-spacing-small: 					calc(var(--ck-spacing-unit) * 0.5);
	--ck-spacing-tiny: 						calc(var(--ck-spacing-unit) * 0.3);
	--ck-spacing-extra-tiny: 				calc(var(--ck-spacing-unit) * 0.16);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 3488: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widget.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-resizer: var(--ck-color-focus-border);
	--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);
	--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);

	--ck-resizer-border-radius: var(--ck-border-radius);
	--ck-resizer-tooltip-offset: 10px;
	--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);
}

.ck .ck-widget {
	/* This is neccessary for type around UI to be positioned properly. */
	position: relative;
}

.ck .ck-widget.ck-widget_with-selection-handle {
	/* Make the widget wrapper a relative positioning container for the drag handle. */
	position: relative;

	& .ck-widget__selection-handle {
		position: absolute;

		& .ck-icon {
			/* Make sure the icon in not a subject to font-size or line-height to avoid
			unnecessary spacing around it. */
			display: block;
		}
	}

	/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */
	&:hover > .ck-widget__selection-handle {
		visibility: visible;
	}

	/* Show the selection handle when the widget is selected, but not for nested widgets. */
	&.ck-widget_selected > .ck-widget__selection-handle {
		visibility: visible;
	}
}

.ck .ck-size-view {
	background: var(--ck-color-resizer-tooltip-background);
	color: var(--ck-color-resizer-tooltip-text);
	border: 1px solid var(--ck-color-resizer-tooltip-text);
	border-radius: var(--ck-resizer-border-radius);
	font-size: var(--ck-font-size-tiny);
	display: block;
	padding: 0 var(--ck-spacing-small);
	height: var(--ck-resizer-tooltip-height);
	line-height: var(--ck-resizer-tooltip-height);

	&.ck-orientation-top-left,
	&.ck-orientation-top-right,
	&.ck-orientation-bottom-right,
	&.ck-orientation-bottom-left,
	&.ck-orientation-above-center {
		position: absolute;
	}

	&.ck-orientation-top-left {
		top: var(--ck-resizer-tooltip-offset);
		left: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-top-right {
		top: var(--ck-resizer-tooltip-offset);
		right: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-bottom-right {
		bottom: var(--ck-resizer-tooltip-offset);
		right: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-bottom-left {
		bottom: var(--ck-resizer-tooltip-offset);
		left: var(--ck-resizer-tooltip-offset);
	}

	/* Class applied if the widget is too small to contain the size label */
	&.ck-orientation-above-center {
		top: calc(var(--ck-resizer-tooltip-height) * -1);
		left: 50%;
		transform: translate(-50%);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";

:root {
	--ck-widget-outline-thickness: 3px;
	--ck-widget-handler-icon-size: 16px;
	--ck-widget-handler-animation-duration: 200ms;
	--ck-widget-handler-animation-curve: ease;

	--ck-color-widget-blurred-border: hsl(0, 0%, 87%);
	--ck-color-widget-hover-border: hsl(43, 100%, 62%);
	--ck-color-widget-editable-focus-background: var(--ck-color-base-background);
	--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);
}

.ck .ck-widget {
	outline-width: var(--ck-widget-outline-thickness);
	outline-style: solid;
	outline-color: transparent;
	transition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);
	}

	&:hover {
		outline-color: var(--ck-color-widget-hover-border);
	}
}

.ck .ck-editor__nested-editable {
	border: 1px solid transparent;

	/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.
	These styles show a different border for a blink of an eye, so \`:focus\` need to have same styles applied. */
	&.ck-editor__nested-editable_focused,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);

		background-color: var(--ck-color-widget-editable-focus-background);
	}
}

.ck .ck-widget.ck-widget_with-selection-handle {
	& .ck-widget__selection-handle {
		padding: 4px;
		box-sizing: border-box;

		/* Background and opacity will be animated as the handler shows up or the widget gets selected. */
		background-color: transparent;
		opacity: 0;

		/* Transition:
		   * background-color for the .ck-widget_selected state change,
		   * visibility for hiding the handler,
		   * opacity for the proper look of the icon when the handler disappears. */
		transition:
			background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),
			visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),
			opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		/* Make only top corners round. */
		border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;

		/* Place the drag handler outside the widget wrapper. */
		transform: translateY(-100%);
		left: calc(0px - var(--ck-widget-outline-thickness));
		top: 0;

		& .ck-icon {
			/* Make sure the dimensions of the icon are independent of the fon-size of the content. */
			width: var(--ck-widget-handler-icon-size);
			height: var(--ck-widget-handler-icon-size);
			color: var(--ck-color-widget-drag-handler-icon-color);

			/* The "selected" part of the icon is invisible by default */
			& .ck-icon__selected-indicator {
				opacity: 0;

				/* Note: The animation is longer on purpose. Simply feels better. */
				transition: opacity 300ms var(--ck-widget-handler-animation-curve);
			}
		}

		/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */
		&:hover .ck-icon .ck-icon__selected-indicator {
			opacity: 1;
		}
	}

	/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */
	&:hover > .ck-widget__selection-handle {
		opacity: 1;
		background-color: var(--ck-color-widget-hover-border);
	}

	/* Show the selection handler when the widget is selected, but not for nested widgets. */
	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		& > .ck-widget__selection-handle {
			opacity: 1;
			background-color: var(--ck-color-focus-border);

			/* When the widget is selected, notify the user using the proper look of the icon. */
			& .ck-icon .ck-icon__selected-indicator {
				opacity: 1;
			}
		}
	}
}

/* In a RTL environment, align the selection handler to the right side of the widget */
/* stylelint-disable-next-line no-descending-specificity */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {
	left: auto;
	right: calc(0px - var(--ck-widget-outline-thickness));
}

/* https://github.com/ckeditor/ckeditor5/issues/6415 */
.ck.ck-editor__editable.ck-read-only .ck-widget {
	/* Prevent the :hover outline from showing up because of the used outline-color transition. */
	transition: none;

	&:not(.ck-widget_selected) {
		/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.
		 * See: https://github.com/ckeditor/ckeditor5/issues/1261
		 *
		 * Leave the unit because this custom property is used in calc() by other features.
		 * See: https://github.com/ckeditor/ckeditor5/issues/6775
		 */
		--ck-widget-outline-thickness: 0px;
	}

	&.ck-widget_with-selection-handle {
		& .ck-widget__selection-handle,
		& .ck-widget__selection-handle:hover {
			background: var(--ck-color-widget-blurred-border);
		}
	}
}

/* Style the widget when it's selected but the editable it belongs to lost focus. */
/* stylelint-disable-next-line no-descending-specificity */
.ck.ck-editor__editable.ck-blurred .ck-widget {
	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		outline-color: var(--ck-color-widget-blurred-border);

		&.ck-widget_with-selection-handle {
			& > .ck-widget__selection-handle,
			& > .ck-widget__selection-handle:hover {
				background: var(--ck-color-widget-blurred-border);
			}
		}
	}
}

.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,
.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {
	/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.
	In fact, anything with overflow: hidden.
	https://github.com/ckeditor/ckeditor5-block-quote/issues/28
	https://github.com/ckeditor/ckeditor5-widget/issues/44
	https://github.com/ckeditor/ckeditor5-widget/issues/66 */
	margin-top: calc(1em + var(--ck-widget-handler-icon-size));
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const E = k;
    }, 8506: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widgetresize.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"], names: [], mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget_with-resizer {
	/* Make the widget wrapper a relative positioning container for the drag handle. */
	position: relative;
}

.ck .ck-widget__resizer {
	display: none;
	position: absolute;

	/* The wrapper itself should not interfere with the pointer device, only the handles should. */
	pointer-events: none;

	left: 0;
	top: 0;
}

.ck-focused .ck-widget_with-resizer.ck-widget_selected {
	& > .ck-widget__resizer {
		display: block;
	}
}

.ck .ck-widget__resizer__handle {
	position: absolute;

	/* Resizers are the only UI elements that should interfere with a pointer device. */
	pointer-events: all;

	&.ck-widget__resizer__handle-top-left,
	&.ck-widget__resizer__handle-bottom-right {
		cursor: nwse-resize;
	}

	&.ck-widget__resizer__handle-top-right,
	&.ck-widget__resizer__handle-bottom-left {
		cursor: nesw-resize;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-resizer-size: 10px;

	/* Set the resizer with a 50% offset. */
	--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);
	--ck-resizer-border-width: 1px;
}

.ck .ck-widget__resizer {
	outline: 1px solid var(--ck-color-resizer);
}

.ck .ck-widget__resizer__handle {
	width: var(--ck-resizer-size);
	height: var(--ck-resizer-size);
	background: var(--ck-color-focus-border);
	border: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);
	border-radius: var(--ck-resizer-border-radius);

	&.ck-widget__resizer__handle-top-left {
		top: var(--ck-resizer-offset);
		left: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-top-right {
		top: var(--ck-resizer-offset);
		right: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-bottom-right {
		bottom: var(--ck-resizer-offset);
		right: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-bottom-left {
		bottom: var(--ck-resizer-offset);
		left: var(--ck-resizer-offset);
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 4921: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widgettypearound.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"], names: [], mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		display: block;
		position: absolute;
		overflow: hidden;
		z-index: var(--ck-z-default);

		& svg {
			position: absolute;
			top: 50%;
			left: 50%;
			z-index: calc(var(--ck-z-default) + 2);
		}

		&.ck-widget__type-around__button_before {
			/* Place it in the middle of the outline */
			top: calc(-0.5 * var(--ck-widget-outline-thickness));
			left: min(10%, 30px);

			transform: translateY(-50%);
		}

		&.ck-widget__type-around__button_after {
			/* Place it in the middle of the outline */
			bottom: calc(-0.5 * var(--ck-widget-outline-thickness));
			right: min(10%, 30px);

			transform: translateY(50%);
		}
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		&::after {
			content: "";
			display: block;
			position: absolute;
			top: 1px;
			left: 1px;
			z-index: calc(var(--ck-z-default) + 1);
		}
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		display: none;
		position: absolute;
		left: 0;
		right: 0;
	}

	/*
	 * When the widget is hovered the "fake caret" would normally be narrower than the
	 * extra outline displayed around the widget. Let's extend the "fake caret" to match
	 * the full width of the widget.
	 */
	&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		left: calc( -1 * var(--ck-widget-outline-thickness) );
		right: calc( -1 * var(--ck-widget-outline-thickness) );
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		top: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		bottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}
}

/*
 * Integration with the read-only mode of the editor.
 */
.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the restricted editing mode (feature) of the editor.
 */
.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the #isEnabled property of the WidgetTypeAround plugin.
 */
.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-widget-type-around-button-size: 20px;
	--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);
	--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);
	--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);
	--ck-color-widget-type-around-button-radar-start-alpha: 0;
	--ck-color-widget-type-around-button-radar-end-alpha: .3;
	--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);
}

@define-mixin ck-widget-type-around-button-visible {
	opacity: 1;
	pointer-events: auto;
}

@define-mixin ck-widget-type-around-button-hidden {
	opacity: 0;
	pointer-events: none;
}

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		width: var(--ck-widget-type-around-button-size);
		height: var(--ck-widget-type-around-button-size);
		background: var(--ck-color-widget-type-around-button);
		border-radius: 100px;
		transition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		@mixin ck-widget-type-around-button-hidden;

		& svg {
			width: 10px;
			height: 8px;
			transform: translate(-50%,-50%);
			transition: transform .5s ease;
			margin-top: 1px;

			& * {
				stroke-dasharray: 10;
				stroke-dashoffset: 0;

				fill: none;
				stroke: var(--ck-color-widget-type-around-button-icon);
				stroke-width: 1.5px;
				stroke-linecap: round;
				stroke-linejoin: round;
			}

			& line {
				stroke-dasharray: 7;
			}
		}

		&:hover {
			/*
			 * Display the "sonar" around the button when hovered.
			 */
			animation: ck-widget-type-around-button-sonar 1s ease infinite;

			/*
			 * Animate active button's icon.
			 */
			& svg {
				& polyline {
					animation: ck-widget-type-around-arrow-dash 2s linear;
				}

				& line {
					animation: ck-widget-type-around-arrow-tip-dash 2s linear;
				}
			}
		}
	}

	/*
	 * Show type around buttons when the widget gets selected or being hovered.
	 */
	&.ck-widget_selected,
	&:hover {
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-visible;
		}
	}

	/*
	 * Styles for the buttons when the widget is NOT selected (but the buttons are visible
	 * and still can be hovered).
	 */
	&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {
		background: var(--ck-color-widget-type-around-button-hover);
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		background: var(--ck-color-widget-type-around-button-active);

		&::after {
			width: calc(var(--ck-widget-type-around-button-size) - 2px);
			height: calc(var(--ck-widget-type-around-button-size) - 2px);
			border-radius: 100px;
			background: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);
		}
	}

	/*
	 * Styles for the "before" button when the widget has a selection handle. Because some space
	 * is consumed by the handle, the button must be moved slightly to the right to let it breathe.
	 */
	&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {
		margin-left: 20px;
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& .ck-widget__type-around__fake-caret {
		pointer-events: none;
		height: 1px;
		animation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;

		/*
		 * The semi-transparent-outline+background combo improves the contrast
		 * when the background underneath the fake caret is dark.
		 */
		outline: solid 1px hsla(0, 0%, 100%, .5);
		background: var(--ck-color-base-text);
	}

	/*
	 * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).
	 * Despite the widget being physically selected in the model, its outline should disappear.
	 */
	&.ck-widget_selected {
		&.ck-widget_type-around_show-fake-caret_before,
		&.ck-widget_type-around_show-fake-caret_after {
			outline-color: transparent;
		}
	}

	&.ck-widget_type-around_show-fake-caret_before,
	&.ck-widget_type-around_show-fake-caret_after {
		/*
		 * When the "fake caret" is visible we simulate that the widget is not selected
		 * (despite being physically selected), so the outline color should be for the
		 * unselected widget.
		 */
		&.ck-widget_selected:hover {
			outline-color: var(--ck-color-widget-hover-border);
		}

		/*
		 * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).
		 * In this state, the type around buttons would collide with the fake carets so they should disappear.
		 */
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-hidden;
		}

		/*
		 * Fake horizontal caret integration with the selection handle. When the caret is visible, simply
		 * hide the handle because it intersects with the caret (and does not make much sense anyway).
		 */
		&.ck-widget_with-selection-handle {
			&.ck-widget_selected,
			&.ck-widget_selected:hover {
				& > .ck-widget__selection-handle {
					opacity: 0
				}
			}
		}

		/*
		 * Fake horizontal caret integration with the resize UI. When the caret is visible, simply
		 * hide the resize UI because it creates too much noise. It can be visible when the user
		 * hovers the widget, though.
		 */
		&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {
			opacity: 0
		}
	}
}

/*
 * Styles for the "before" button when the widget has a selection handle in an RTL environment.
 * The selection handler is aligned to the right side of the widget so there is no need to create
 * additional space for it next to the "before" button.
 */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {
	margin-left: 0;
	margin-right: 20px;
}

/*
 * Hide type around buttons when the widget is selected as a child of a selected
 * nested editable (e.g. mulit-cell table selection).
 *
 * See https://github.com/ckeditor/ckeditor5/issues/7263.
 */
.ck-editor__nested-editable.ck-editor__editable_selected {
	& .ck-widget {
		&.ck-widget_selected,
		&:hover {
			& > .ck-widget__type-around > .ck-widget__type-around__button {
				@mixin ck-widget-type-around-button-hidden;
			}
		}
	}
}

/*
 * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).
 */
.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {
	background: var(--ck-color-widget-type-around-button-blurred-editable);

	& svg * {
		stroke: hsl(0,0%,60%);
	}
}

@keyframes ck-widget-type-around-arrow-dash {
	0% {
		stroke-dashoffset: 10;
	}
	20%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-arrow-tip-dash {
	0%, 20% {
		stroke-dashoffset: 7;
	}
	40%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-button-sonar {
	0% {
		box-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
	50% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));
	}
	100% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
}

@keyframes ck-widget-type-around-fake-caret-pulse {
	0% {
		opacity: 1;
	}
	49% {
		opacity: 1;
	}
	50% {
		opacity: 0;
	}
	99% {
		opacity: 0;
	}
	100% {
		opacity: 1;
	}
}
`], sourceRoot: "" }]);
      const E = k;
    }, 2245: (v, C, p) => {
      p.d(C, { Z: () => E });
      var D = p(1799), y = p.n(D), A = p(2609), k = p.n(A)()(y());
      k.push([v.id, ".viur-txt-align--left{text-align:left}.viur-txt-align--right{text-align:right}.viur-txt-align--center{text-align:center}.viur-txt-align--justify{text-align:justify}.viur-txt-indent--1{margin-left:1em}.viur-txt-indent--2{margin-left:2em}.viur-txt-indent--3{margin-left:3em}.viur-txt-indent--4{margin-left:4em}.viur-txt-indent--5{margin-left:5em}.viur-txt-indent--6{margin-left:6em}.viur-txt-indent--7{margin-left:7em}.viur-txt-indent--8{margin-left:8em}.viur-txt-indent--9{margin-left:9em}.viur-txt-indent--10{margin-left:10em}", "", { version: 3, sources: ["webpack://./../viur/theme.css"], names: [], mappings: "AAKA,sBACC,eACD,CACA,uBACC,gBACD,CACA,wBACC,iBACD,CACA,yBACC,kBACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,qBACC,gBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.viur-txt-align--left{
	text-align: left;
}
.viur-txt-align--right{
	text-align: right;
}
.viur-txt-align--center{
	text-align: center;
}
.viur-txt-align--justify{
	text-align: justify;
}
.viur-txt-indent--1{
	margin-left: 1em;
}
.viur-txt-indent--2{
	margin-left: 2em;
}
.viur-txt-indent--3{
	margin-left: 3em;
}
.viur-txt-indent--4{
	margin-left: 4em;
}
.viur-txt-indent--5{
	margin-left: 5em;
}
.viur-txt-indent--6{
	margin-left: 6em;
}
.viur-txt-indent--7{
	margin-left: 7em;
}
.viur-txt-indent--8{
	margin-left: 8em;
}
.viur-txt-indent--9{
	margin-left: 9em;
}
.viur-txt-indent--10{
	margin-left: 10em;
}

`], sourceRoot: "" }]);
      const E = k;
    }, 2609: (v) => {
      v.exports = function(C) {
        var p = [];
        return p.toString = function() {
          return this.map(function(D) {
            var y = C(D);
            return D[2] ? "@media ".concat(D[2], " {").concat(y, "}") : y;
          }).join("");
        }, p.i = function(D, y, A) {
          typeof D == "string" && (D = [[null, D, ""]]);
          var k = {};
          if (A)
            for (var E = 0; E < this.length; E++) {
              var P = this[E][0];
              P != null && (k[P] = !0);
            }
          for (var z = 0; z < D.length; z++) {
            var M = [].concat(D[z]);
            A && k[M[0]] || (y && (M[2] ? M[2] = "".concat(y, " and ").concat(M[2]) : M[2] = y), p.push(M));
          }
        }, p;
      };
    }, 1799: (v) => {
      function C(D, y) {
        return function(A) {
          if (Array.isArray(A))
            return A;
        }(D) || function(A, k) {
          var E = A && (typeof Symbol < "u" && A[Symbol.iterator] || A["@@iterator"]);
          if (E != null) {
            var P, z, M = [], F = !0, V = !1;
            try {
              for (E = E.call(A); !(F = (P = E.next()).done) && (M.push(P.value), !k || M.length !== k); F = !0)
                ;
            } catch (j) {
              V = !0, z = j;
            } finally {
              try {
                F || E.return == null || E.return();
              } finally {
                if (V)
                  throw z;
              }
            }
            return M;
          }
        }(D, y) || function(A, k) {
          if (A) {
            if (typeof A == "string")
              return p(A, k);
            var E = Object.prototype.toString.call(A).slice(8, -1);
            if (E === "Object" && A.constructor && (E = A.constructor.name), E === "Map" || E === "Set")
              return Array.from(A);
            if (E === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(E))
              return p(A, k);
          }
        }(D, y) || function() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }();
      }
      function p(D, y) {
        (y == null || y > D.length) && (y = D.length);
        for (var A = 0, k = new Array(y); A < y; A++)
          k[A] = D[A];
        return k;
      }
      v.exports = function(D) {
        var y = C(D, 4), A = y[1], k = y[3];
        if (!k)
          return A;
        if (typeof btoa == "function") {
          var E = btoa(unescape(encodeURIComponent(JSON.stringify(k)))), P = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(E), z = "/*# ".concat(P, " */"), M = k.sources.map(function(F) {
            return "/*# sourceURL=".concat(k.sourceRoot || "").concat(F, " */");
          });
          return [A].concat(M).concat([z]).join(`
`);
        }
        return [A].join(`
`);
      };
    }, 6062: (v, C, p) => {
      var D, y = function() {
        return D === void 0 && (D = !!(window && document && document.all && !window.atob)), D;
      }, A = /* @__PURE__ */ function() {
        var X = {};
        return function(de) {
          if (X[de] === void 0) {
            var O = document.querySelector(de);
            if (window.HTMLIFrameElement && O instanceof window.HTMLIFrameElement)
              try {
                O = O.contentDocument.head;
              } catch {
                O = null;
              }
            X[de] = O;
          }
          return X[de];
        };
      }(), k = [];
      function E(X) {
        for (var de = -1, O = 0; O < k.length; O++)
          if (k[O].identifier === X) {
            de = O;
            break;
          }
        return de;
      }
      function P(X, de) {
        for (var O = {}, oe = [], He = 0; He < X.length; He++) {
          var Ke = X[He], ze = de.base ? Ke[0] + de.base : Ke[0], nn = O[ze] || 0, Et = "".concat(ze, " ").concat(nn);
          O[ze] = nn + 1;
          var Ot = E(Et), Gt = { css: Ke[1], media: Ke[2], sourceMap: Ke[3] };
          Ot !== -1 ? (k[Ot].references++, k[Ot].updater(Gt)) : k.push({ identifier: Et, updater: se(Gt, de), references: 1 }), oe.push(Et);
        }
        return oe;
      }
      function z(X) {
        var de = document.createElement("style"), O = X.attributes || {};
        if (O.nonce === void 0) {
          var oe = p.nc;
          oe && (O.nonce = oe);
        }
        if (Object.keys(O).forEach(function(Ke) {
          de.setAttribute(Ke, O[Ke]);
        }), typeof X.insert == "function")
          X.insert(de);
        else {
          var He = A(X.insert || "head");
          if (!He)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          He.appendChild(de);
        }
        return de;
      }
      var M, F = (M = [], function(X, de) {
        return M[X] = de, M.filter(Boolean).join(`
`);
      });
      function V(X, de, O, oe) {
        var He = O ? "" : oe.media ? "@media ".concat(oe.media, " {").concat(oe.css, "}") : oe.css;
        if (X.styleSheet)
          X.styleSheet.cssText = F(de, He);
        else {
          var Ke = document.createTextNode(He), ze = X.childNodes;
          ze[de] && X.removeChild(ze[de]), ze.length ? X.insertBefore(Ke, ze[de]) : X.appendChild(Ke);
        }
      }
      function j(X, de, O) {
        var oe = O.css, He = O.media, Ke = O.sourceMap;
        if (He ? X.setAttribute("media", He) : X.removeAttribute("media"), Ke && typeof btoa < "u" && (oe += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(Ke)))), " */")), X.styleSheet)
          X.styleSheet.cssText = oe;
        else {
          for (; X.firstChild; )
            X.removeChild(X.firstChild);
          X.appendChild(document.createTextNode(oe));
        }
      }
      var Z = null, ne = 0;
      function se(X, de) {
        var O, oe, He;
        if (de.singleton) {
          var Ke = ne++;
          O = Z || (Z = z(de)), oe = V.bind(null, O, Ke, !1), He = V.bind(null, O, Ke, !0);
        } else
          O = z(de), oe = j.bind(null, O, de), He = function() {
            (function(ze) {
              if (ze.parentNode === null)
                return !1;
              ze.parentNode.removeChild(ze);
            })(O);
          };
        return oe(X), function(ze) {
          if (ze) {
            if (ze.css === X.css && ze.media === X.media && ze.sourceMap === X.sourceMap)
              return;
            oe(X = ze);
          } else
            He();
        };
      }
      v.exports = function(X, de) {
        (de = de || {}).singleton || typeof de.singleton == "boolean" || (de.singleton = y());
        var O = P(X = X || [], de);
        return function(oe) {
          if (oe = oe || [], Object.prototype.toString.call(oe) === "[object Array]") {
            for (var He = 0; He < O.length; He++) {
              var Ke = E(O[He]);
              k[Ke].references--;
            }
            for (var ze = P(oe, de), nn = 0; nn < O.length; nn++) {
              var Et = E(O[nn]);
              k[Et].references === 0 && (k[Et].updater(), k.splice(Et, 1));
            }
            O = ze;
          }
        };
      };
    } }, w = {};
    function b(v) {
      var C = w[v];
      if (C !== void 0)
        return C.exports;
      var p = w[v] = { id: v, exports: {} };
      return g[v](p, p.exports, b), p.exports;
    }
    b.n = (v) => {
      var C = v && v.__esModule ? () => v.default : () => v;
      return b.d(C, { a: C }), C;
    }, b.d = (v, C) => {
      for (var p in C)
        b.o(C, p) && !b.o(v, p) && Object.defineProperty(v, p, { enumerable: !0, get: C[p] });
    }, b.g = function() {
      if (typeof globalThis == "object")
        return globalThis;
      try {
        return this || new Function("return this")();
      } catch {
        if (typeof window == "object")
          return window;
      }
    }(), b.o = (v, C) => Object.prototype.hasOwnProperty.call(v, C), b.nc = void 0;
    var x = {};
    return (() => {
      function v({ emitter: o, activator: e, callback: t, contextElements: n }) {
        o.listenTo(document, "mousedown", (i, r) => {
          if (!e())
            return;
          const s = typeof r.composedPath == "function" ? r.composedPath() : [], a = typeof n == "function" ? n() : n;
          for (const l of a)
            if (l.contains(r.target) || s.includes(l))
              return;
          t();
        });
      }
      function C(o) {
        return class extends o {
          disableCssTransitions() {
            this._isCssTransitionsDisabled = !0;
          }
          enableCssTransitions() {
            this._isCssTransitionsDisabled = !1;
          }
          constructor(...e) {
            super(...e), this.set("_isCssTransitionsDisabled", !1), this.initializeCssTransitionDisablerMixin();
          }
          initializeCssTransitionDisablerMixin() {
            this.extendTemplate({ attributes: { class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")] } });
          }
        };
      }
      function p({ view: o }) {
        o.listenTo(o.element, "submit", (e, t) => {
          t.preventDefault(), o.fire("submit");
        }, { useCapture: !0 });
      }
      b.d(x, { default: () => uc });
      const D = function() {
        try {
          return navigator.userAgent.toLowerCase();
        } catch {
          return "";
        }
      }(), y = { isMac: E(D), isWindows: (A = D, A.indexOf("windows") > -1), isGecko: function(o) {
        return !!o.match(/gecko\/\d+/);
      }(D), isSafari: function(o) {
        return o.indexOf(" applewebkit/") > -1 && o.indexOf("chrome") === -1;
      }(D), isiOS: function(o) {
        return !!o.match(/iphone|ipad/i) || E(o) && navigator.maxTouchPoints > 0;
      }(D), isAndroid: function(o) {
        return o.indexOf("android") > -1;
      }(D), isBlink: function(o) {
        return o.indexOf("chrome/") > -1 && o.indexOf("edge/") < 0;
      }(D), features: { isRegExpUnicodePropertySupported: function() {
        let o = !1;
        try {
          o = "ć".search(new RegExp("[\\p{L}]", "u")) === 0;
        } catch {
        }
        return o;
      }() } };
      var A;
      const k = y;
      function E(o) {
        return o.indexOf("macintosh") > -1;
      }
      function P(o, e, t, n) {
        t = t || function(l, d) {
          return l === d;
        };
        const i = Array.isArray(o) ? o : Array.prototype.slice.call(o), r = Array.isArray(e) ? e : Array.prototype.slice.call(e), s = function(l, d, h) {
          const m = z(l, d, h);
          if (m === -1)
            return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
          const f = M(l, m), _ = M(d, m), S = z(f, _, h), B = l.length - S, T = d.length - S;
          return { firstIndex: m, lastIndexOld: B, lastIndexNew: T };
        }(i, r, t);
        return n ? function(l, d) {
          const { firstIndex: h, lastIndexOld: m, lastIndexNew: f } = l;
          if (h === -1)
            return Array(d).fill("equal");
          let _ = [];
          return h > 0 && (_ = _.concat(Array(h).fill("equal"))), f - h > 0 && (_ = _.concat(Array(f - h).fill("insert"))), m - h > 0 && (_ = _.concat(Array(m - h).fill("delete"))), f < d && (_ = _.concat(Array(d - f).fill("equal"))), _;
        }(s, r.length) : function(l, d) {
          const h = [], { firstIndex: m, lastIndexOld: f, lastIndexNew: _ } = d;
          return _ - m > 0 && h.push({ index: m, type: "insert", values: l.slice(m, _) }), f - m > 0 && h.push({ index: m + (_ - m), type: "delete", howMany: f - m }), h;
        }(r, s);
      }
      function z(o, e, t) {
        for (let n = 0; n < Math.max(o.length, e.length); n++)
          if (o[n] === void 0 || e[n] === void 0 || !t(o[n], e[n]))
            return n;
        return -1;
      }
      function M(o, e) {
        return o.slice(e).reverse();
      }
      function F(o, e, t) {
        t = t || function(B, T) {
          return B === T;
        };
        const n = o.length, i = e.length;
        if (n > 200 || i > 200 || n + i > 300)
          return F.fastDiff(o, e, t, !0);
        let r, s;
        if (i < n) {
          const B = o;
          o = e, e = B, r = "delete", s = "insert";
        } else
          r = "insert", s = "delete";
        const a = o.length, l = e.length, d = l - a, h = {}, m = {};
        function f(B) {
          const T = (m[B - 1] !== void 0 ? m[B - 1] : -1) + 1, R = m[B + 1] !== void 0 ? m[B + 1] : -1, N = T > R ? -1 : 1;
          h[B + N] && (h[B] = h[B + N].slice(0)), h[B] || (h[B] = []), h[B].push(T > R ? r : s);
          let U = Math.max(T, R), ee = U - B;
          for (; ee < a && U < l && t(o[ee], e[U]); )
            ee++, U++, h[B].push("equal");
          return U;
        }
        let _, S = 0;
        do {
          for (_ = -S; _ < d; _++)
            m[_] = f(_);
          for (_ = d + S; _ > d; _--)
            m[_] = f(_);
          m[d] = f(d), S++;
        } while (m[d] !== l);
        return h[d].slice(1);
      }
      F.fastDiff = P;
      const V = function() {
        return function o() {
          o.called = !0;
        };
      };
      class j {
        constructor(e, t) {
          this.source = e, this.name = t, this.path = [], this.stop = V(), this.off = V();
        }
      }
      const Z = new Array(256).fill("").map((o, e) => ("0" + e.toString(16)).slice(-2));
      function ne() {
        const o = 4294967296 * Math.random() >>> 0, e = 4294967296 * Math.random() >>> 0, t = 4294967296 * Math.random() >>> 0, n = 4294967296 * Math.random() >>> 0;
        return "e" + Z[o >> 0 & 255] + Z[o >> 8 & 255] + Z[o >> 16 & 255] + Z[o >> 24 & 255] + Z[e >> 0 & 255] + Z[e >> 8 & 255] + Z[e >> 16 & 255] + Z[e >> 24 & 255] + Z[t >> 0 & 255] + Z[t >> 8 & 255] + Z[t >> 16 & 255] + Z[t >> 24 & 255] + Z[n >> 0 & 255] + Z[n >> 8 & 255] + Z[n >> 16 & 255] + Z[n >> 24 & 255];
      }
      const se = { get(o = "normal") {
        return typeof o != "number" ? this[o] || this.normal : o;
      }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5 };
      function X(o, e) {
        const t = se.get(e.priority);
        for (let n = 0; n < o.length; n++)
          if (se.get(o[n].priority) < t)
            return void o.splice(n, 0, e);
        o.push(e);
      }
      const de = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
      class O extends Error {
        constructor(e, t, n) {
          super(function(i, r) {
            const s = /* @__PURE__ */ new WeakSet(), a = (h, m) => {
              if (typeof m == "object" && m !== null) {
                if (s.has(m))
                  return `[object ${m.constructor.name}]`;
                s.add(m);
              }
              return m;
            }, l = r ? ` ${JSON.stringify(r, a)}` : "", d = He(i);
            return i + l + d;
          }(e, n)), this.name = "CKEditorError", this.context = t, this.data = n;
        }
        is(e) {
          return e === "CKEditorError";
        }
        static rethrowUnexpectedError(e, t) {
          if (e.is && e.is("CKEditorError"))
            throw e;
          const n = new O(e.message, t);
          throw n.stack = e.stack, n;
        }
      }
      function oe(o, e) {
        console.warn(...Ke(o, e));
      }
      function He(o) {
        return `
Read more: ${de}#error-${o}`;
      }
      function Ke(o, e) {
        const t = He(o);
        return e ? [o, e, t] : [o, t];
      }
      const ze = "38.0.1", nn = new Date(2023, 4, 23), Et = typeof window == "object" ? window : b.g;
      if (Et.CKEDITOR_VERSION)
        throw new O("ckeditor-duplicated-modules", null);
      Et.CKEDITOR_VERSION = ze;
      const Ot = Symbol("listeningTo"), Gt = Symbol("emitterId"), Rt = Symbol("delegations"), pr = Se(Object);
      function Se(o) {
        return o ? class extends o {
          on(e, t, n) {
            this.listenTo(this, e, t, n);
          }
          once(e, t, n) {
            let i = !1;
            this.listenTo(this, e, (r, ...s) => {
              i || (i = !0, r.off(), t.call(this, r, ...s));
            }, n);
          }
          off(e, t) {
            this.stopListening(this, e, t);
          }
          listenTo(e, t, n, i = {}) {
            let r, s;
            this[Ot] || (this[Ot] = {});
            const a = this[Ot];
            qn(e) || pi(e);
            const l = qn(e);
            (r = a[l]) || (r = a[l] = { emitter: e, callbacks: {} }), (s = r.callbacks[t]) || (s = r.callbacks[t] = []), s.push(n), function(d, h, m, f, _) {
              h._addEventListener ? h._addEventListener(m, f, _) : d._addEventListener.call(h, m, f, _);
            }(this, e, t, n, i);
          }
          stopListening(e, t, n) {
            const i = this[Ot];
            let r = e && qn(e);
            const s = i && r ? i[r] : void 0, a = s && t ? s.callbacks[t] : void 0;
            if (!(!i || e && !s || t && !a))
              if (n)
                L(this, e, t, n), a.indexOf(n) !== -1 && (a.length === 1 ? delete s.callbacks[t] : L(this, e, t, n));
              else if (a) {
                for (; n = a.pop(); )
                  L(this, e, t, n);
                delete s.callbacks[t];
              } else if (s) {
                for (t in s.callbacks)
                  this.stopListening(e, t);
                delete i[r];
              } else {
                for (r in i)
                  this.stopListening(i[r].emitter);
                delete this[Ot];
              }
          }
          fire(e, ...t) {
            try {
              const n = e instanceof j ? e : new j(this, e), i = n.name;
              let r = fi(this, i);
              if (n.path.push(this), r) {
                const a = [n, ...t];
                r = Array.from(r);
                for (let l = 0; l < r.length && (r[l].callback.apply(this, a), n.off.called && (delete n.off.called, this._removeEventListener(i, r[l].callback)), !n.stop.called); l++)
                  ;
              }
              const s = this[Rt];
              if (s) {
                const a = s.get(i), l = s.get("*");
                a && gn(a, n, t), l && gn(l, n, t);
              }
              return n.return;
            } catch (n) {
              O.rethrowUnexpectedError(n, this);
            }
          }
          delegate(...e) {
            return { to: (t, n) => {
              this[Rt] || (this[Rt] = /* @__PURE__ */ new Map()), e.forEach((i) => {
                const r = this[Rt].get(i);
                r ? r.set(t, n) : this[Rt].set(i, /* @__PURE__ */ new Map([[t, n]]));
              });
            } };
          }
          stopDelegating(e, t) {
            if (this[Rt])
              if (e)
                if (t) {
                  const n = this[Rt].get(e);
                  n && n.delete(t);
                } else
                  this[Rt].delete(e);
              else
                this[Rt].clear();
          }
          _addEventListener(e, t, n) {
            (function(s, a) {
              const l = Eo(s);
              if (l[a])
                return;
              let d = a, h = null;
              const m = [];
              for (; d !== "" && !l[d]; )
                l[d] = { callbacks: [], childEvents: [] }, m.push(l[d]), h && l[d].childEvents.push(h), h = d, d = d.substr(0, d.lastIndexOf(":"));
              if (d !== "") {
                for (const f of m)
                  f.callbacks = l[d].callbacks.slice();
                l[d].childEvents.push(h);
              }
            })(this, e);
            const i = Dn(this, e), r = { callback: t, priority: se.get(n.priority) };
            for (const s of i)
              X(s, r);
          }
          _removeEventListener(e, t) {
            const n = Dn(this, e);
            for (const i of n)
              for (let r = 0; r < i.length; r++)
                i[r].callback == t && (i.splice(r, 1), r--);
          }
        } : pr;
      }
      function pi(o, e) {
        o[Gt] || (o[Gt] = e || ne());
      }
      function qn(o) {
        return o[Gt];
      }
      function Eo(o) {
        return o._events || Object.defineProperty(o, "_events", { value: {} }), o._events;
      }
      function Dn(o, e) {
        const t = Eo(o)[e];
        if (!t)
          return [];
        let n = [t.callbacks];
        for (let i = 0; i < t.childEvents.length; i++) {
          const r = Dn(o, t.childEvents[i]);
          n = n.concat(r);
        }
        return n;
      }
      function fi(o, e) {
        let t;
        return o._events && (t = o._events[e]) && t.callbacks.length ? t.callbacks : e.indexOf(":") > -1 ? fi(o, e.substr(0, e.lastIndexOf(":"))) : null;
      }
      function gn(o, e, t) {
        for (let [n, i] of o) {
          i ? typeof i == "function" && (i = i(e.name)) : i = e.name;
          const r = new j(e.source, i);
          r.path = [...e.path], n.fire(r, ...t);
        }
      }
      function L(o, e, t, n) {
        e._removeEventListener ? e._removeEventListener(t, n) : o._removeEventListener.call(e, t, n);
      }
      ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
        Se[o] = pr.prototype[o];
      });
      const K = function(o) {
        var e = typeof o;
        return o != null && (e == "object" || e == "function");
      }, Y = Symbol("observableProperties"), te = Symbol("boundObservables"), ve = Symbol("boundProperties"), Le = Symbol("decoratedMethods"), pe = Symbol("decoratedOriginal"), ue = re(Se());
      function re(o) {
        return o ? class extends o {
          set(e, t) {
            if (K(e))
              return void Object.keys(e).forEach((i) => {
                this.set(i, e[i]);
              }, this);
            Kt(this);
            const n = this[Y];
            if (e in this && !n.has(e))
              throw new O("observable-set-cannot-override", this);
            Object.defineProperty(this, e, { enumerable: !0, configurable: !0, get: () => n.get(e), set(i) {
              const r = n.get(e);
              let s = this.fire(`set:${e}`, e, i, r);
              s === void 0 && (s = i), r === s && n.has(e) || (n.set(e, s), this.fire(`change:${e}`, e, s, r));
            } }), this[e] = t;
          }
          bind(...e) {
            if (!e.length || !Zc(e))
              throw new O("observable-bind-wrong-properties", this);
            if (new Set(e).size !== e.length)
              throw new O("observable-bind-duplicate-properties", this);
            Kt(this);
            const t = this[ve];
            e.forEach((i) => {
              if (t.has(i))
                throw new O("observable-bind-rebind", this);
            });
            const n = /* @__PURE__ */ new Map();
            return e.forEach((i) => {
              const r = { property: i, to: [] };
              t.set(i, r), n.set(i, r);
            }), { to: ft, toMany: x0, _observable: this, _bindProperties: e, _to: [], _bindings: n };
          }
          unbind(...e) {
            if (!this[Y])
              return;
            const t = this[ve], n = this[te];
            if (e.length) {
              if (!Zc(e))
                throw new O("observable-unbind-wrong-properties", this);
              e.forEach((i) => {
                const r = t.get(i);
                r && (r.to.forEach(([s, a]) => {
                  const l = n.get(s), d = l[a];
                  d.delete(r), d.size || delete l[a], Object.keys(l).length || (n.delete(s), this.stopListening(s, "change"));
                }), t.delete(i));
              });
            } else
              n.forEach((i, r) => {
                this.stopListening(r, "change");
              }), n.clear(), t.clear();
          }
          decorate(e) {
            Kt(this);
            const t = this[e];
            if (!t)
              throw new O("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: e });
            this.on(e, (n, i) => {
              n.return = t.apply(this, i);
            }), this[e] = function(...n) {
              return this.fire(e, n);
            }, this[e][pe] = t, this[Le] || (this[Le] = []), this[Le].push(e);
          }
          stopListening(e, t, n) {
            if (!e && this[Le]) {
              for (const i of this[Le])
                this[i] = this[i][pe];
              delete this[Le];
            }
            super.stopListening(e, t, n);
          }
        } : ue;
      }
      function Kt(o) {
        o[Y] || (Object.defineProperty(o, Y, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(o, te, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(o, ve, { value: /* @__PURE__ */ new Map() }));
      }
      function ft(...o) {
        const e = function(...r) {
          if (!r.length)
            throw new O("observable-bind-to-parse-error", null);
          const s = { to: [] };
          let a;
          return typeof r[r.length - 1] == "function" && (s.callback = r.pop()), r.forEach((l) => {
            if (typeof l == "string")
              a.properties.push(l);
            else {
              if (typeof l != "object")
                throw new O("observable-bind-to-parse-error", null);
              a = { observable: l, properties: [] }, s.to.push(a);
            }
          }), s;
        }(...o), t = Array.from(this._bindings.keys()), n = t.length;
        if (!e.callback && e.to.length > 1)
          throw new O("observable-bind-to-no-callback", this);
        if (n > 1 && e.callback)
          throw new O("observable-bind-to-extra-callback", this);
        var i;
        e.to.forEach((r) => {
          if (r.properties.length && r.properties.length !== n)
            throw new O("observable-bind-to-properties-length", this);
          r.properties.length || (r.properties = this._bindProperties);
        }), this._to = e.to, e.callback && (this._bindings.get(t[0]).callback = e.callback), i = this._observable, this._to.forEach((r) => {
          const s = i[te];
          let a;
          s.get(r.observable) || i.listenTo(r.observable, "change", (l, d) => {
            a = s.get(r.observable)[d], a && a.forEach((h) => {
              Jc(i, h.property);
            });
          });
        }), function(r) {
          let s;
          r._bindings.forEach((a, l) => {
            r._to.forEach((d) => {
              s = d.properties[a.callback ? 0 : r._bindProperties.indexOf(l)], a.to.push([d.observable, s]), function(h, m, f, _) {
                const S = h[te], B = S.get(f), T = B || {};
                T[_] || (T[_] = /* @__PURE__ */ new Set()), T[_].add(m), B || S.set(f, T);
              }(r._observable, a, d.observable, s);
            });
          });
        }(this), this._bindProperties.forEach((r) => {
          Jc(this._observable, r);
        });
      }
      function x0(o, e, t) {
        if (this._bindings.size > 1)
          throw new O("observable-bind-to-many-not-one-binding", this);
        this.to(...function(n, i) {
          const r = n.map((s) => [s, i]);
          return Array.prototype.concat.apply([], r);
        }(o, e), t);
      }
      function Zc(o) {
        return o.every((e) => typeof e == "string");
      }
      function Jc(o, e) {
        const t = o[ve].get(e);
        let n;
        t.callback ? n = t.callback.apply(o, t.to.map((i) => i[0][i[1]])) : (n = t.to[0], n = n[0][n[1]]), Object.prototype.hasOwnProperty.call(o, e) ? o[e] = n : o.set(e, n);
      }
      ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
        re[o] = ue.prototype[o];
      });
      class Yc {
        constructor() {
          this._replacedElements = [];
        }
        replace(e, t) {
          this._replacedElements.push({ element: e, newElement: t }), e.style.display = "none", t && e.parentNode.insertBefore(t, e.nextSibling);
        }
        restore() {
          this._replacedElements.forEach(({ element: e, newElement: t }) => {
            e.style.display = "", t && t.remove();
          }), this._replacedElements = [];
        }
      }
      function Ls(o) {
        let e = 0;
        for (const t of o)
          e++;
        return e;
      }
      function _t(o, e) {
        const t = Math.min(o.length, e.length);
        for (let n = 0; n < t; n++)
          if (o[n] != e[n])
            return n;
        return o.length == e.length ? "same" : o.length < e.length ? "prefix" : "extension";
      }
      function zt(o) {
        return !(!o || !o[Symbol.iterator]);
      }
      const Qc = typeof Ds == "object" && Ds && Ds.Object === Object && Ds;
      var S0 = typeof self == "object" && self && self.Object === Object && self;
      const Zt = Qc || S0 || Function("return this")(), on = Zt.Symbol;
      var Xc = Object.prototype, D0 = Xc.hasOwnProperty, B0 = Xc.toString, bi = on ? on.toStringTag : void 0;
      const T0 = function(o) {
        var e = D0.call(o, bi), t = o[bi];
        try {
          o[bi] = void 0;
          var n = !0;
        } catch {
        }
        var i = B0.call(o);
        return n && (e ? o[bi] = t : delete o[bi]), i;
      };
      var I0 = Object.prototype.toString;
      const P0 = function(o) {
        return I0.call(o);
      };
      var ed = on ? on.toStringTag : void 0;
      const Bn = function(o) {
        return o == null ? o === void 0 ? "[object Undefined]" : "[object Null]" : ed && ed in Object(o) ? T0(o) : P0(o);
      }, At = Array.isArray, jt = function(o) {
        return o != null && typeof o == "object";
      }, td = function(o) {
        return typeof o == "string" || !At(o) && jt(o) && Bn(o) == "[object String]";
      };
      function js(o, e, t = {}, n = []) {
        const i = t && t.xmlns, r = i ? o.createElementNS(i, e) : o.createElement(e);
        for (const s in t)
          r.setAttribute(s, t[s]);
        !td(n) && zt(n) || (n = [n]);
        for (let s of n)
          td(s) && (s = o.createTextNode(s)), r.appendChild(s);
        return r;
      }
      const nd = function(o, e) {
        return function(t) {
          return o(e(t));
        };
      }, Hs = nd(Object.getPrototypeOf, Object);
      var O0 = Function.prototype, R0 = Object.prototype, od = O0.toString, z0 = R0.hasOwnProperty, M0 = od.call(Object);
      const xt = function(o) {
        if (!jt(o) || Bn(o) != "[object Object]")
          return !1;
        var e = Hs(o);
        if (e === null)
          return !0;
        var t = z0.call(e, "constructor") && e.constructor;
        return typeof t == "function" && t instanceof t && od.call(t) == M0;
      }, N0 = function() {
        this.__data__ = [], this.size = 0;
      }, ki = function(o, e) {
        return o === e || o != o && e != e;
      }, fr = function(o, e) {
        for (var t = o.length; t--; )
          if (ki(o[t][0], e))
            return t;
        return -1;
      };
      var F0 = Array.prototype.splice;
      const $0 = function(o) {
        var e = this.__data__, t = fr(e, o);
        return !(t < 0) && (t == e.length - 1 ? e.pop() : F0.call(e, t, 1), --this.size, !0);
      }, V0 = function(o) {
        var e = this.__data__, t = fr(e, o);
        return t < 0 ? void 0 : e[t][1];
      }, L0 = function(o) {
        return fr(this.__data__, o) > -1;
      }, j0 = function(o, e) {
        var t = this.__data__, n = fr(t, o);
        return n < 0 ? (++this.size, t.push([o, e])) : t[n][1] = e, this;
      };
      function xo(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.clear(); ++e < t; ) {
          var n = o[e];
          this.set(n[0], n[1]);
        }
      }
      xo.prototype.clear = N0, xo.prototype.delete = $0, xo.prototype.get = V0, xo.prototype.has = L0, xo.prototype.set = j0;
      const br = xo, H0 = function() {
        this.__data__ = new br(), this.size = 0;
      }, U0 = function(o) {
        var e = this.__data__, t = e.delete(o);
        return this.size = e.size, t;
      }, q0 = function(o) {
        return this.__data__.get(o);
      }, W0 = function(o) {
        return this.__data__.has(o);
      }, Wn = function(o) {
        if (!K(o))
          return !1;
        var e = Bn(o);
        return e == "[object Function]" || e == "[object GeneratorFunction]" || e == "[object AsyncFunction]" || e == "[object Proxy]";
      }, Us = Zt["__core-js_shared__"];
      var id = function() {
        var o = /[^.]+$/.exec(Us && Us.keys && Us.keys.IE_PROTO || "");
        return o ? "Symbol(src)_1." + o : "";
      }();
      const G0 = function(o) {
        return !!id && id in o;
      };
      var K0 = Function.prototype.toString;
      const Gn = function(o) {
        if (o != null) {
          try {
            return K0.call(o);
          } catch {
          }
          try {
            return o + "";
          } catch {
          }
        }
        return "";
      };
      var Z0 = /^\[object .+?Constructor\]$/, J0 = Function.prototype, Y0 = Object.prototype, Q0 = J0.toString, X0 = Y0.hasOwnProperty, ev = RegExp("^" + Q0.call(X0).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      const tv = function(o) {
        return !(!K(o) || G0(o)) && (Wn(o) ? ev : Z0).test(Gn(o));
      }, nv = function(o, e) {
        return o == null ? void 0 : o[e];
      }, Kn = function(o, e) {
        var t = nv(o, e);
        return tv(t) ? t : void 0;
      }, wi = Kn(Zt, "Map"), vi = Kn(Object, "create"), ov = function() {
        this.__data__ = vi ? vi(null) : {}, this.size = 0;
      }, iv = function(o) {
        var e = this.has(o) && delete this.__data__[o];
        return this.size -= e ? 1 : 0, e;
      };
      var rv = Object.prototype.hasOwnProperty;
      const sv = function(o) {
        var e = this.__data__;
        if (vi) {
          var t = e[o];
          return t === "__lodash_hash_undefined__" ? void 0 : t;
        }
        return rv.call(e, o) ? e[o] : void 0;
      };
      var av = Object.prototype.hasOwnProperty;
      const lv = function(o) {
        var e = this.__data__;
        return vi ? e[o] !== void 0 : av.call(e, o);
      }, cv = function(o, e) {
        var t = this.__data__;
        return this.size += this.has(o) ? 0 : 1, t[o] = vi && e === void 0 ? "__lodash_hash_undefined__" : e, this;
      };
      function So(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.clear(); ++e < t; ) {
          var n = o[e];
          this.set(n[0], n[1]);
        }
      }
      So.prototype.clear = ov, So.prototype.delete = iv, So.prototype.get = sv, So.prototype.has = lv, So.prototype.set = cv;
      const rd = So, dv = function() {
        this.size = 0, this.__data__ = { hash: new rd(), map: new (wi || br)(), string: new rd() };
      }, uv = function(o) {
        var e = typeof o;
        return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? o !== "__proto__" : o === null;
      }, kr = function(o, e) {
        var t = o.__data__;
        return uv(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
      }, hv = function(o) {
        var e = kr(this, o).delete(o);
        return this.size -= e ? 1 : 0, e;
      }, gv = function(o) {
        return kr(this, o).get(o);
      }, mv = function(o) {
        return kr(this, o).has(o);
      }, pv = function(o, e) {
        var t = kr(this, o), n = t.size;
        return t.set(o, e), this.size += t.size == n ? 0 : 1, this;
      };
      function Do(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.clear(); ++e < t; ) {
          var n = o[e];
          this.set(n[0], n[1]);
        }
      }
      Do.prototype.clear = dv, Do.prototype.delete = hv, Do.prototype.get = gv, Do.prototype.has = mv, Do.prototype.set = pv;
      const wr = Do, fv = function(o, e) {
        var t = this.__data__;
        if (t instanceof br) {
          var n = t.__data__;
          if (!wi || n.length < 199)
            return n.push([o, e]), this.size = ++t.size, this;
          t = this.__data__ = new wr(n);
        }
        return t.set(o, e), this.size = t.size, this;
      };
      function Bo(o) {
        var e = this.__data__ = new br(o);
        this.size = e.size;
      }
      Bo.prototype.clear = H0, Bo.prototype.delete = U0, Bo.prototype.get = q0, Bo.prototype.has = W0, Bo.prototype.set = fv;
      const _i = Bo, bv = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length; ++t < n && e(o[t], t, o) !== !1; )
          ;
        return o;
      }, vr = function() {
        try {
          var o = Kn(Object, "defineProperty");
          return o({}, "", {}), o;
        } catch {
        }
      }(), qs = function(o, e, t) {
        e == "__proto__" && vr ? vr(o, e, { configurable: !0, enumerable: !0, value: t, writable: !0 }) : o[e] = t;
      };
      var kv = Object.prototype.hasOwnProperty;
      const Ws = function(o, e, t) {
        var n = o[e];
        kv.call(o, e) && ki(n, t) && (t !== void 0 || e in o) || qs(o, e, t);
      }, To = function(o, e, t, n) {
        var i = !t;
        t || (t = {});
        for (var r = -1, s = e.length; ++r < s; ) {
          var a = e[r], l = n ? n(t[a], o[a], a, t, o) : void 0;
          l === void 0 && (l = o[a]), i ? qs(t, a, l) : Ws(t, a, l);
        }
        return t;
      }, wv = function(o, e) {
        for (var t = -1, n = Array(o); ++t < o; )
          n[t] = e(t);
        return n;
      }, sd = function(o) {
        return jt(o) && Bn(o) == "[object Arguments]";
      };
      var ad = Object.prototype, vv = ad.hasOwnProperty, _v = ad.propertyIsEnumerable;
      const Gs = sd(/* @__PURE__ */ function() {
        return arguments;
      }()) ? sd : function(o) {
        return jt(o) && vv.call(o, "callee") && !_v.call(o, "callee");
      }, Av = function() {
        return !1;
      };
      var ld = u && !u.nodeType && u, cd = ld && !0 && c && !c.nodeType && c, dd = cd && cd.exports === ld ? Zt.Buffer : void 0;
      const Ai = (dd ? dd.isBuffer : void 0) || Av;
      var Cv = /^(?:0|[1-9]\d*)$/;
      const Ks = function(o, e) {
        var t = typeof o;
        return !!(e = e ?? 9007199254740991) && (t == "number" || t != "symbol" && Cv.test(o)) && o > -1 && o % 1 == 0 && o < e;
      }, ud = function(o) {
        return typeof o == "number" && o > -1 && o % 1 == 0 && o <= 9007199254740991;
      };
      var We = {};
      We["[object Float32Array]"] = We["[object Float64Array]"] = We["[object Int8Array]"] = We["[object Int16Array]"] = We["[object Int32Array]"] = We["[object Uint8Array]"] = We["[object Uint8ClampedArray]"] = We["[object Uint16Array]"] = We["[object Uint32Array]"] = !0, We["[object Arguments]"] = We["[object Array]"] = We["[object ArrayBuffer]"] = We["[object Boolean]"] = We["[object DataView]"] = We["[object Date]"] = We["[object Error]"] = We["[object Function]"] = We["[object Map]"] = We["[object Number]"] = We["[object Object]"] = We["[object RegExp]"] = We["[object Set]"] = We["[object String]"] = We["[object WeakMap]"] = !1;
      const yv = function(o) {
        return jt(o) && ud(o.length) && !!We[Bn(o)];
      }, _r = function(o) {
        return function(e) {
          return o(e);
        };
      };
      var hd = u && !u.nodeType && u, Ci = hd && !0 && c && !c.nodeType && c, Zs = Ci && Ci.exports === hd && Qc.process;
      const Io = function() {
        try {
          var o = Ci && Ci.require && Ci.require("util").types;
          return o || Zs && Zs.binding && Zs.binding("util");
        } catch {
        }
      }();
      var gd = Io && Io.isTypedArray;
      const Js = gd ? _r(gd) : yv;
      var Ev = Object.prototype.hasOwnProperty;
      const md = function(o, e) {
        var t = At(o), n = !t && Gs(o), i = !t && !n && Ai(o), r = !t && !n && !i && Js(o), s = t || n || i || r, a = s ? wv(o.length, String) : [], l = a.length;
        for (var d in o)
          !e && !Ev.call(o, d) || s && (d == "length" || i && (d == "offset" || d == "parent") || r && (d == "buffer" || d == "byteLength" || d == "byteOffset") || Ks(d, l)) || a.push(d);
        return a;
      };
      var xv = Object.prototype;
      const Ys = function(o) {
        var e = o && o.constructor;
        return o === (typeof e == "function" && e.prototype || xv);
      }, Sv = nd(Object.keys, Object);
      var Dv = Object.prototype.hasOwnProperty;
      const Bv = function(o) {
        if (!Ys(o))
          return Sv(o);
        var e = [];
        for (var t in Object(o))
          Dv.call(o, t) && t != "constructor" && e.push(t);
        return e;
      }, Ar = function(o) {
        return o != null && ud(o.length) && !Wn(o);
      }, Qs = function(o) {
        return Ar(o) ? md(o) : Bv(o);
      }, Tv = function(o, e) {
        return o && To(e, Qs(e), o);
      }, Iv = function(o) {
        var e = [];
        if (o != null)
          for (var t in Object(o))
            e.push(t);
        return e;
      };
      var Pv = Object.prototype.hasOwnProperty;
      const Ov = function(o) {
        if (!K(o))
          return Iv(o);
        var e = Ys(o), t = [];
        for (var n in o)
          (n != "constructor" || !e && Pv.call(o, n)) && t.push(n);
        return t;
      }, Po = function(o) {
        return Ar(o) ? md(o, !0) : Ov(o);
      }, Rv = function(o, e) {
        return o && To(e, Po(e), o);
      };
      var pd = u && !u.nodeType && u, fd = pd && !0 && c && !c.nodeType && c, bd = fd && fd.exports === pd ? Zt.Buffer : void 0, kd = bd ? bd.allocUnsafe : void 0;
      const wd = function(o, e) {
        if (e)
          return o.slice();
        var t = o.length, n = kd ? kd(t) : new o.constructor(t);
        return o.copy(n), n;
      }, Xs = function(o, e) {
        var t = -1, n = o.length;
        for (e || (e = Array(n)); ++t < n; )
          e[t] = o[t];
        return e;
      }, zv = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length, i = 0, r = []; ++t < n; ) {
          var s = o[t];
          e(s, t, o) && (r[i++] = s);
        }
        return r;
      }, vd = function() {
        return [];
      };
      var Mv = Object.prototype.propertyIsEnumerable, _d = Object.getOwnPropertySymbols;
      const ea = _d ? function(o) {
        return o == null ? [] : (o = Object(o), zv(_d(o), function(e) {
          return Mv.call(o, e);
        }));
      } : vd, Nv = function(o, e) {
        return To(o, ea(o), e);
      }, Ad = function(o, e) {
        for (var t = -1, n = e.length, i = o.length; ++t < n; )
          o[i + t] = e[t];
        return o;
      }, Cd = Object.getOwnPropertySymbols ? function(o) {
        for (var e = []; o; )
          Ad(e, ea(o)), o = Hs(o);
        return e;
      } : vd, Fv = function(o, e) {
        return To(o, Cd(o), e);
      }, yd = function(o, e, t) {
        var n = e(o);
        return At(o) ? n : Ad(n, t(o));
      }, ta = function(o) {
        return yd(o, Qs, ea);
      }, $v = function(o) {
        return yd(o, Po, Cd);
      }, na = Kn(Zt, "DataView"), oa = Kn(Zt, "Promise"), ia = Kn(Zt, "Set"), ra = Kn(Zt, "WeakMap");
      var Ed = "[object Map]", xd = "[object Promise]", Sd = "[object Set]", Dd = "[object WeakMap]", Bd = "[object DataView]", Vv = Gn(na), Lv = Gn(wi), jv = Gn(oa), Hv = Gn(ia), Uv = Gn(ra), Zn = Bn;
      (na && Zn(new na(new ArrayBuffer(1))) != Bd || wi && Zn(new wi()) != Ed || oa && Zn(oa.resolve()) != xd || ia && Zn(new ia()) != Sd || ra && Zn(new ra()) != Dd) && (Zn = function(o) {
        var e = Bn(o), t = e == "[object Object]" ? o.constructor : void 0, n = t ? Gn(t) : "";
        if (n)
          switch (n) {
            case Vv:
              return Bd;
            case Lv:
              return Ed;
            case jv:
              return xd;
            case Hv:
              return Sd;
            case Uv:
              return Dd;
          }
        return e;
      });
      const yi = Zn;
      var qv = Object.prototype.hasOwnProperty;
      const Wv = function(o) {
        var e = o.length, t = new o.constructor(e);
        return e && typeof o[0] == "string" && qv.call(o, "index") && (t.index = o.index, t.input = o.input), t;
      }, Cr = Zt.Uint8Array, sa = function(o) {
        var e = new o.constructor(o.byteLength);
        return new Cr(e).set(new Cr(o)), e;
      }, Gv = function(o, e) {
        var t = e ? sa(o.buffer) : o.buffer;
        return new o.constructor(t, o.byteOffset, o.byteLength);
      };
      var Kv = /\w*$/;
      const Zv = function(o) {
        var e = new o.constructor(o.source, Kv.exec(o));
        return e.lastIndex = o.lastIndex, e;
      };
      var Td = on ? on.prototype : void 0, Id = Td ? Td.valueOf : void 0;
      const Jv = function(o) {
        return Id ? Object(Id.call(o)) : {};
      }, Pd = function(o, e) {
        var t = e ? sa(o.buffer) : o.buffer;
        return new o.constructor(t, o.byteOffset, o.length);
      }, Yv = function(o, e, t) {
        var n = o.constructor;
        switch (e) {
          case "[object ArrayBuffer]":
            return sa(o);
          case "[object Boolean]":
          case "[object Date]":
            return new n(+o);
          case "[object DataView]":
            return Gv(o, t);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return Pd(o, t);
          case "[object Map]":
          case "[object Set]":
            return new n();
          case "[object Number]":
          case "[object String]":
            return new n(o);
          case "[object RegExp]":
            return Zv(o);
          case "[object Symbol]":
            return Jv(o);
        }
      };
      var Od = Object.create;
      const Qv = /* @__PURE__ */ function() {
        function o() {
        }
        return function(e) {
          if (!K(e))
            return {};
          if (Od)
            return Od(e);
          o.prototype = e;
          var t = new o();
          return o.prototype = void 0, t;
        };
      }(), Rd = function(o) {
        return typeof o.constructor != "function" || Ys(o) ? {} : Qv(Hs(o));
      }, Xv = function(o) {
        return jt(o) && yi(o) == "[object Map]";
      };
      var zd = Io && Io.isMap;
      const e_ = zd ? _r(zd) : Xv, t_ = function(o) {
        return jt(o) && yi(o) == "[object Set]";
      };
      var Md = Io && Io.isSet;
      const n_ = Md ? _r(Md) : t_;
      var Nd = "[object Arguments]", Fd = "[object Function]", $d = "[object Object]", Ue = {};
      Ue[Nd] = Ue["[object Array]"] = Ue["[object ArrayBuffer]"] = Ue["[object DataView]"] = Ue["[object Boolean]"] = Ue["[object Date]"] = Ue["[object Float32Array]"] = Ue["[object Float64Array]"] = Ue["[object Int8Array]"] = Ue["[object Int16Array]"] = Ue["[object Int32Array]"] = Ue["[object Map]"] = Ue["[object Number]"] = Ue[$d] = Ue["[object RegExp]"] = Ue["[object Set]"] = Ue["[object String]"] = Ue["[object Symbol]"] = Ue["[object Uint8Array]"] = Ue["[object Uint8ClampedArray]"] = Ue["[object Uint16Array]"] = Ue["[object Uint32Array]"] = !0, Ue["[object Error]"] = Ue[Fd] = Ue["[object WeakMap]"] = !1;
      const aa = function o(e, t, n, i, r, s) {
        var a, l = 1 & t, d = 2 & t, h = 4 & t;
        if (n && (a = r ? n(e, i, r, s) : n(e)), a !== void 0)
          return a;
        if (!K(e))
          return e;
        var m = At(e);
        if (m) {
          if (a = Wv(e), !l)
            return Xs(e, a);
        } else {
          var f = yi(e), _ = f == Fd || f == "[object GeneratorFunction]";
          if (Ai(e))
            return wd(e, l);
          if (f == $d || f == Nd || _ && !r) {
            if (a = d || _ ? {} : Rd(e), !l)
              return d ? Fv(e, Rv(a, e)) : Nv(e, Tv(a, e));
          } else {
            if (!Ue[f])
              return r ? e : {};
            a = Yv(e, f, l);
          }
        }
        s || (s = new _i());
        var S = s.get(e);
        if (S)
          return S;
        s.set(e, a), n_(e) ? e.forEach(function(T) {
          a.add(o(T, t, n, T, e, s));
        }) : e_(e) && e.forEach(function(T, R) {
          a.set(R, o(T, t, n, R, e, s));
        });
        var B = m ? void 0 : (h ? d ? $v : ta : d ? Po : Qs)(e);
        return bv(B || e, function(T, R) {
          B && (T = e[R = T]), Ws(a, R, o(T, t, n, R, e, s));
        }), a;
      }, la = function(o, e) {
        return aa(o, 5, e = typeof e == "function" ? e : void 0);
      }, Oo = function(o) {
        return jt(o) && o.nodeType === 1 && !xt(o);
      };
      class Vd {
        constructor(e, t) {
          this._config = {}, t && this.define(Ld(t)), e && this._setObjectToTarget(this._config, e);
        }
        set(e, t) {
          this._setToTarget(this._config, e, t);
        }
        define(e, t) {
          this._setToTarget(this._config, e, t, !0);
        }
        get(e) {
          return this._getFromSource(this._config, e);
        }
        *names() {
          for (const e of Object.keys(this._config))
            yield e;
        }
        _setToTarget(e, t, n, i = !1) {
          if (xt(t))
            return void this._setObjectToTarget(e, t, i);
          const r = t.split(".");
          t = r.pop();
          for (const s of r)
            xt(e[s]) || (e[s] = {}), e = e[s];
          if (xt(n))
            return xt(e[t]) || (e[t] = {}), e = e[t], void this._setObjectToTarget(e, n, i);
          i && e[t] !== void 0 || (e[t] = n);
        }
        _getFromSource(e, t) {
          const n = t.split(".");
          t = n.pop();
          for (const i of n) {
            if (!xt(e[i])) {
              e = null;
              break;
            }
            e = e[i];
          }
          return e ? Ld(e[t]) : void 0;
        }
        _setObjectToTarget(e, t, n) {
          Object.keys(t).forEach((i) => {
            this._setToTarget(e, i, t[i], n);
          });
        }
      }
      function Ld(o) {
        return la(o, o_);
      }
      function o_(o) {
        return Oo(o) ? o : void 0;
      }
      function Tn(o) {
        if (o) {
          if (o.defaultView)
            return o instanceof o.defaultView.Document;
          if (o.ownerDocument && o.ownerDocument.defaultView)
            return o instanceof o.ownerDocument.defaultView.Node;
        }
        return !1;
      }
      function yr(o) {
        const e = Object.prototype.toString.apply(o);
        return e == "[object Window]" || e == "[object global]";
      }
      const jd = In(Se());
      function In(o) {
        return o ? class extends o {
          listenTo(e, t, n, i = {}) {
            if (Tn(e) || yr(e)) {
              const r = { capture: !!i.useCapture, passive: !!i.usePassive }, s = this._getProxyEmitter(e, r) || new i_(e, r);
              this.listenTo(s, t, n, i);
            } else
              super.listenTo(e, t, n, i);
          }
          stopListening(e, t, n) {
            if (Tn(e) || yr(e)) {
              const i = this._getAllProxyEmitters(e);
              for (const r of i)
                this.stopListening(r, t, n);
            } else
              super.stopListening(e, t, n);
          }
          _getProxyEmitter(e, t) {
            return function(n, i) {
              const r = n[Ot];
              return r && r[i] ? r[i].emitter : null;
            }(this, Hd(e, t));
          }
          _getAllProxyEmitters(e) {
            return [{ capture: !1, passive: !1 }, { capture: !1, passive: !0 }, { capture: !0, passive: !1 }, { capture: !0, passive: !0 }].map((t) => this._getProxyEmitter(e, t)).filter((t) => !!t);
          }
        } : jd;
      }
      ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
        In[o] = jd.prototype[o];
      });
      class i_ extends Se() {
        constructor(e, t) {
          super(), pi(this, Hd(e, t)), this._domNode = e, this._options = t;
        }
        attach(e) {
          if (this._domListeners && this._domListeners[e])
            return;
          const t = this._createDomListener(e);
          this._domNode.addEventListener(e, t, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[e] = t;
        }
        detach(e) {
          let t;
          !this._domListeners[e] || (t = this._events[e]) && t.callbacks.length || this._domListeners[e].removeListener();
        }
        _addEventListener(e, t, n) {
          this.attach(e), Se().prototype._addEventListener.call(this, e, t, n);
        }
        _removeEventListener(e, t) {
          Se().prototype._removeEventListener.call(this, e, t), this.detach(e);
        }
        _createDomListener(e) {
          const t = (n) => {
            this.fire(e, n);
          };
          return t.removeListener = () => {
            this._domNode.removeEventListener(e, t, this._options), delete this._domListeners[e];
          }, t;
        }
      }
      function Hd(o, e) {
        let t = function(n) {
          return n["data-ck-expando"] || (n["data-ck-expando"] = ne());
        }(o);
        for (const n of Object.keys(e).sort())
          e[n] && (t += "-" + n);
        return t;
      }
      let ca;
      try {
        ca = { window, document };
      } catch {
        ca = { window: {}, document: {} };
      }
      const ke = ca;
      function Ud(o) {
        const e = [];
        let t = o;
        for (; t && t.nodeType != Node.DOCUMENT_NODE; )
          e.unshift(t), t = t.parentNode;
        return e;
      }
      function Qe(o) {
        return Object.prototype.toString.call(o) == "[object Text]";
      }
      function Er(o) {
        return Object.prototype.toString.apply(o) == "[object Range]";
      }
      function qd(o) {
        const e = o.ownerDocument.defaultView.getComputedStyle(o);
        return { top: parseInt(e.borderTopWidth, 10), right: parseInt(e.borderRightWidth, 10), bottom: parseInt(e.borderBottomWidth, 10), left: parseInt(e.borderLeftWidth, 10) };
      }
      const Wd = ["top", "right", "bottom", "left", "width", "height"];
      class Ze {
        constructor(e) {
          const t = Er(e);
          if (Object.defineProperty(this, "_source", { value: e._source || e, writable: !0, enumerable: !1 }), Kd(e) || t)
            if (t) {
              const n = Ze.getDomRangeRects(e);
              xr(this, Ze.getBoundingRect(n));
            } else
              xr(this, e.getBoundingClientRect());
          else if (yr(e)) {
            const { innerWidth: n, innerHeight: i } = e;
            xr(this, { top: 0, right: n, bottom: i, left: 0, width: n, height: i });
          } else
            xr(this, e);
        }
        clone() {
          return new Ze(this);
        }
        moveTo(e, t) {
          return this.top = t, this.right = e + this.width, this.bottom = t + this.height, this.left = e, this;
        }
        moveBy(e, t) {
          return this.top += t, this.right += e, this.left += e, this.bottom += t, this;
        }
        getIntersection(e) {
          const t = { top: Math.max(this.top, e.top), right: Math.min(this.right, e.right), bottom: Math.min(this.bottom, e.bottom), left: Math.max(this.left, e.left), width: 0, height: 0 };
          return t.width = t.right - t.left, t.height = t.bottom - t.top, t.width < 0 || t.height < 0 ? null : new Ze(t);
        }
        getIntersectionArea(e) {
          const t = this.getIntersection(e);
          return t ? t.getArea() : 0;
        }
        getArea() {
          return this.width * this.height;
        }
        getVisible() {
          const e = this._source;
          let t = this.clone();
          if (!Gd(e)) {
            let n = e.parentNode || e.commonAncestorContainer;
            for (; n && !Gd(n); ) {
              const i = new Ze(n), r = t.getIntersection(i);
              if (!r)
                return null;
              r.getArea() < t.getArea() && (t = r), n = n.parentNode;
            }
          }
          return t;
        }
        isEqual(e) {
          for (const t of Wd)
            if (this[t] !== e[t])
              return !1;
          return !0;
        }
        contains(e) {
          const t = this.getIntersection(e);
          return !(!t || !t.isEqual(e));
        }
        excludeScrollbarsAndBorders() {
          const e = this._source;
          let t, n, i;
          if (yr(e))
            t = e.innerWidth - e.document.documentElement.clientWidth, n = e.innerHeight - e.document.documentElement.clientHeight, i = e.getComputedStyle(e.document.documentElement).direction;
          else {
            const r = qd(e);
            t = e.offsetWidth - e.clientWidth - r.left - r.right, n = e.offsetHeight - e.clientHeight - r.top - r.bottom, i = e.ownerDocument.defaultView.getComputedStyle(e).direction, this.left += r.left, this.top += r.top, this.right -= r.right, this.bottom -= r.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
          }
          return this.width -= t, i === "ltr" ? this.right -= t : this.left += t, this.height -= n, this.bottom -= n, this;
        }
        static getDomRangeRects(e) {
          const t = [], n = Array.from(e.getClientRects());
          if (n.length)
            for (const i of n)
              t.push(new Ze(i));
          else {
            let i = e.startContainer;
            Qe(i) && (i = i.parentNode);
            const r = new Ze(i.getBoundingClientRect());
            r.right = r.left, r.width = 0, t.push(r);
          }
          return t;
        }
        static getBoundingRect(e) {
          const t = { left: Number.POSITIVE_INFINITY, top: Number.POSITIVE_INFINITY, right: Number.NEGATIVE_INFINITY, bottom: Number.NEGATIVE_INFINITY, width: 0, height: 0 };
          let n = 0;
          for (const i of e)
            n++, t.left = Math.min(t.left, i.left), t.top = Math.min(t.top, i.top), t.right = Math.max(t.right, i.right), t.bottom = Math.max(t.bottom, i.bottom);
          return n == 0 ? null : (t.width = t.right - t.left, t.height = t.bottom - t.top, new Ze(t));
        }
      }
      function xr(o, e) {
        for (const t of Wd)
          o[t] = e[t];
      }
      function Gd(o) {
        return !!Kd(o) && o === o.ownerDocument.body;
      }
      function Kd(o) {
        return o !== null && typeof o == "object" && o.nodeType === 1 && typeof o.getBoundingClientRect == "function";
      }
      const ot = class {
        constructor(o, e) {
          ot._observerInstance || ot._createObserver(), this._element = o, this._callback = e, ot._addElementCallback(o, e), ot._observerInstance.observe(o);
        }
        destroy() {
          ot._deleteElementCallback(this._element, this._callback);
        }
        static _addElementCallback(o, e) {
          ot._elementCallbacks || (ot._elementCallbacks = /* @__PURE__ */ new Map());
          let t = ot._elementCallbacks.get(o);
          t || (t = /* @__PURE__ */ new Set(), ot._elementCallbacks.set(o, t)), t.add(e);
        }
        static _deleteElementCallback(o, e) {
          const t = ot._getElementCallbacks(o);
          t && (t.delete(e), t.size || (ot._elementCallbacks.delete(o), ot._observerInstance.unobserve(o))), ot._elementCallbacks && !ot._elementCallbacks.size && (ot._observerInstance = null, ot._elementCallbacks = null);
        }
        static _getElementCallbacks(o) {
          return ot._elementCallbacks ? ot._elementCallbacks.get(o) : null;
        }
        static _createObserver() {
          ot._observerInstance = new ke.window.ResizeObserver((o) => {
            for (const e of o) {
              const t = ot._getElementCallbacks(e.target);
              if (t)
                for (const n of t)
                  n(e);
            }
          });
        }
      };
      let Sr = ot;
      function r_(o, e) {
        o instanceof HTMLTextAreaElement && (o.value = e), o.innerHTML = e;
      }
      function da(o) {
        return (e) => e + o;
      }
      function Dr(o) {
        let e = 0;
        for (; o.previousSibling; )
          o = o.previousSibling, e++;
        return e;
      }
      function Zd(o, e, t) {
        o.insertBefore(t, o.childNodes[e] || null);
      }
      function Ro(o) {
        return o && o.nodeType === Node.COMMENT_NODE;
      }
      function Jd(o) {
        try {
          ke.document.createAttribute(o);
        } catch {
          return !1;
        }
        return !0;
      }
      function Jn(o) {
        return !!(o && o.getClientRects && o.getClientRects().length);
      }
      Sr._observerInstance = null, Sr._elementCallbacks = null;
      var Yd = Math.pow;
      function Qd({ element: o, target: e, positions: t, limiter: n, fitInViewport: i, viewportOffsetConfig: r }) {
        Wn(e) && (e = e()), Wn(n) && (n = n());
        const s = function(f) {
          return f && f.parentNode ? f.offsetParent === ke.document.body ? null : f.offsetParent : null;
        }(o), a = new Ze(o), l = new Ze(e);
        let d;
        const h = i && function(f) {
          f = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, f);
          const _ = new Ze(ke.window);
          return _.top += f.top, _.height -= f.top, _.bottom -= f.bottom, _.height -= f.bottom, _;
        }(r) || null, m = { targetRect: l, elementRect: a, positionedElementAncestor: s, viewportRect: h };
        if (n || i) {
          const f = n && new Ze(n).getVisible();
          Object.assign(m, { limiterRect: f, viewportRect: h }), d = function(_, S) {
            const { elementRect: B } = S, T = B.getArea(), R = _.map((ee) => new ua(ee, S)).filter((ee) => !!ee.name);
            let N = 0, U = null;
            for (const ee of R) {
              const { limiterIntersectionArea: we, viewportIntersectionArea: Ge } = ee;
              if (we === T)
                return ee;
              const Te = Yd(Ge, 2) + Yd(we, 2);
              Te > N && (N = Te, U = ee);
            }
            return U;
          }(t, m) || new ua(t[0], m);
        } else
          d = new ua(t[0], m);
        return d;
      }
      function Xd(o) {
        const { scrollX: e, scrollY: t } = ke.window;
        return o.clone().moveBy(e, t);
      }
      class ua {
        constructor(e, t) {
          const n = e(t.targetRect, t.elementRect, t.viewportRect);
          if (!n)
            return;
          const { left: i, top: r, name: s, config: a } = n;
          this.name = s, this.config = a, this._positioningFunctionCorrdinates = { left: i, top: r }, this._options = t;
        }
        get left() {
          return this._absoluteRect.left;
        }
        get top() {
          return this._absoluteRect.top;
        }
        get limiterIntersectionArea() {
          const e = this._options.limiterRect;
          if (e) {
            const t = this._options.viewportRect;
            if (!t)
              return e.getIntersectionArea(this._rect);
            {
              const n = e.getIntersection(t);
              if (n)
                return n.getIntersectionArea(this._rect);
            }
          }
          return 0;
        }
        get viewportIntersectionArea() {
          const e = this._options.viewportRect;
          return e ? e.getIntersectionArea(this._rect) : 0;
        }
        get _rect() {
          return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top)), this._cachedRect;
        }
        get _absoluteRect() {
          return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = Xd(this._rect), this._options.positionedElementAncestor && function(e, t) {
            const n = Xd(new Ze(t)), i = qd(t);
            let r = 0, s = 0;
            r -= n.left, s -= n.top, r += t.scrollLeft, s += t.scrollTop, r -= i.left, s -= i.top, e.moveBy(r, s);
          }(this._cachedAbsoluteRect, this._options.positionedElementAncestor)), this._cachedAbsoluteRect;
        }
      }
      function eu(o) {
        const e = o.parentNode;
        e && e.removeChild(o);
      }
      function s_({ window: o, rect: e, alignToTop: t, forceScroll: n, viewportOffset: i }) {
        const r = e.clone().moveBy(0, i), s = e.clone().moveBy(0, -i), a = new Ze(o).excludeScrollbarsAndBorders(), l = t && n, d = [s, r].every((S) => a.contains(S));
        let { scrollX: h, scrollY: m } = o;
        const f = h, _ = m;
        l ? m -= a.top - e.top + i : d || (nu(s, a) ? m -= a.top - e.top + i : tu(r, a) && (m += t ? e.top - a.top - i : e.bottom - a.bottom + i)), d || (ou(e, a) ? h -= a.left - e.left + i : iu(e, a) && (h += e.right - a.right + i)), h == f && m === _ || o.scrollTo(h, m);
      }
      function a_({ parent: o, getRect: e, alignToTop: t, forceScroll: n, ancestorOffset: i = 0 }) {
        const r = ha(o), s = t && n;
        let a, l, d;
        for (; o != r.document.body; )
          l = e(), a = new Ze(o).excludeScrollbarsAndBorders(), d = a.contains(l), s ? o.scrollTop -= a.top - l.top + i : d || (nu(l, a) ? o.scrollTop -= a.top - l.top + i : tu(l, a) && (o.scrollTop += t ? l.top - a.top - i : l.bottom - a.bottom + i)), d || (ou(l, a) ? o.scrollLeft -= a.left - l.left + i : iu(l, a) && (o.scrollLeft += l.right - a.right + i)), o = o.parentNode;
      }
      function tu(o, e) {
        return o.bottom > e.bottom;
      }
      function nu(o, e) {
        return o.top < e.top;
      }
      function ou(o, e) {
        return o.left < e.left;
      }
      function iu(o, e) {
        return o.right > e.right;
      }
      function ha(o) {
        return Er(o) ? o.startContainer.ownerDocument.defaultView : o.ownerDocument.defaultView;
      }
      function l_(o) {
        if (Er(o)) {
          let e = o.commonAncestorContainer;
          return Qe(e) && (e = e.parentNode), e;
        }
        return o.parentNode;
      }
      function ru(o, e) {
        const t = ha(o), n = new Ze(o);
        if (t === e)
          return n;
        {
          let i = t;
          for (; i != e; ) {
            const r = i.frameElement, s = new Ze(r).excludeScrollbarsAndBorders();
            n.moveBy(s.left, s.top), i = i.parent;
          }
        }
        return n;
      }
      const c_ = { ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧" }, d_ = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" }, Ce = function() {
        const o = { arrowleft: 37, arrowup: 38, arrowright: 39, arrowdown: 40, backspace: 8, delete: 46, enter: 13, space: 32, esc: 27, tab: 9, ctrl: 1114112, shift: 2228224, alt: 4456448, cmd: 8912896 };
        for (let e = 65; e <= 90; e++)
          o[String.fromCharCode(e).toLowerCase()] = e;
        for (let e = 48; e <= 57; e++)
          o[e - 48] = e;
        for (let e = 112; e <= 123; e++)
          o["f" + (e - 111)] = e;
        for (const e of "`-=[];',./\\")
          o[e] = e.charCodeAt(0);
        return o;
      }(), u_ = Object.fromEntries(Object.entries(Ce).map(([o, e]) => [e, o.charAt(0).toUpperCase() + o.slice(1)]));
      function zo(o) {
        let e;
        if (typeof o == "string") {
          if (e = Ce[o.toLowerCase()], !e)
            throw new O("keyboard-unknown-key", null, { key: o });
        } else
          e = o.keyCode + (o.altKey ? Ce.alt : 0) + (o.ctrlKey ? Ce.ctrl : 0) + (o.shiftKey ? Ce.shift : 0) + (o.metaKey ? Ce.cmd : 0);
        return e;
      }
      function Br(o) {
        return typeof o == "string" && (o = function(e) {
          return e.split("+").map((t) => t.trim());
        }(o)), o.map((e) => typeof e == "string" ? function(t) {
          if (t.endsWith("!"))
            return zo(t.slice(0, -1));
          const n = zo(t);
          return k.isMac && n == Ce.ctrl ? Ce.cmd : n;
        }(e) : e).reduce((e, t) => t + e, 0);
      }
      function su(o) {
        let e = Br(o);
        return Object.entries(k.isMac ? c_ : d_).reduce((t, [n, i]) => (e & Ce[n] && (e &= ~Ce[n], t += i), t), "") + (e ? u_[e] : "");
      }
      function ga(o, e) {
        const t = e === "ltr";
        switch (o) {
          case Ce.arrowleft:
            return t ? "left" : "right";
          case Ce.arrowright:
            return t ? "right" : "left";
          case Ce.arrowup:
            return "up";
          case Ce.arrowdown:
            return "down";
        }
      }
      function Xe(o) {
        return Array.isArray(o) ? o : [o];
      }
      function h_(o, e, t = 1) {
        if (typeof t != "number")
          throw new O("translation-service-quantity-not-a-number", null, { quantity: t });
        const n = Object.keys(ke.window.CKEDITOR_TRANSLATIONS).length;
        n === 1 && (o = Object.keys(ke.window.CKEDITOR_TRANSLATIONS)[0]);
        const i = e.id || e.string;
        if (n === 0 || !function(l, d) {
          return !!ke.window.CKEDITOR_TRANSLATIONS[l] && !!ke.window.CKEDITOR_TRANSLATIONS[l].dictionary[d];
        }(o, i))
          return t !== 1 ? e.plural : e.string;
        const r = ke.window.CKEDITOR_TRANSLATIONS[o].dictionary, s = ke.window.CKEDITOR_TRANSLATIONS[o].getPluralForm || ((l) => l === 1 ? 0 : 1), a = r[i];
        return typeof a == "string" ? a : a[Number(s(t))];
      }
      ke.window.CKEDITOR_TRANSLATIONS || (ke.window.CKEDITOR_TRANSLATIONS = {});
      const g_ = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];
      function au(o) {
        return g_.includes(o) ? "rtl" : "ltr";
      }
      class m_ {
        constructor({ uiLanguage: e = "en", contentLanguage: t } = {}) {
          this.uiLanguage = e, this.contentLanguage = t || this.uiLanguage, this.uiLanguageDirection = au(this.uiLanguage), this.contentLanguageDirection = au(this.contentLanguage), this.t = (n, i) => this._t(n, i);
        }
        get language() {
          return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
        }
        _t(e, t = []) {
          t = Xe(t), typeof e == "string" && (e = { string: e });
          const n = e.plural ? t[0] : 1;
          return function(i, r) {
            return i.replace(/%(\d+)/g, (s, a) => a < r.length ? r[a] : s);
          }(h_(this.uiLanguage, e, n), t);
        }
      }
      class Ht extends Se() {
        constructor(e = {}, t = {}) {
          super();
          const n = zt(e);
          if (n || (t = e), this._items = [], this._itemMap = /* @__PURE__ */ new Map(), this._idProperty = t.idProperty || "id", this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap(), this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap(), this._skippedIndexesFromExternal = [], n)
            for (const i of e)
              this._items.push(i), this._itemMap.set(this._getItemIdBeforeAdding(i), i);
        }
        get length() {
          return this._items.length;
        }
        get first() {
          return this._items[0] || null;
        }
        get last() {
          return this._items[this.length - 1] || null;
        }
        add(e, t) {
          return this.addMany([e], t);
        }
        addMany(e, t) {
          if (t === void 0)
            t = this._items.length;
          else if (t > this._items.length || t < 0)
            throw new O("collection-add-item-invalid-index", this);
          let n = 0;
          for (const i of e) {
            const r = this._getItemIdBeforeAdding(i), s = t + n;
            this._items.splice(s, 0, i), this._itemMap.set(r, i), this.fire("add", i, s), n++;
          }
          return this.fire("change", { added: e, removed: [], index: t }), this;
        }
        get(e) {
          let t;
          if (typeof e == "string")
            t = this._itemMap.get(e);
          else {
            if (typeof e != "number")
              throw new O("collection-get-invalid-arg", this);
            t = this._items[e];
          }
          return t || null;
        }
        has(e) {
          if (typeof e == "string")
            return this._itemMap.has(e);
          {
            const t = e[this._idProperty];
            return t && this._itemMap.has(t);
          }
        }
        getIndex(e) {
          let t;
          return t = typeof e == "string" ? this._itemMap.get(e) : e, t ? this._items.indexOf(t) : -1;
        }
        remove(e) {
          const [t, n] = this._remove(e);
          return this.fire("change", { added: [], removed: [t], index: n }), t;
        }
        map(e, t) {
          return this._items.map(e, t);
        }
        find(e, t) {
          return this._items.find(e, t);
        }
        filter(e, t) {
          return this._items.filter(e, t);
        }
        clear() {
          this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
          const e = Array.from(this._items);
          for (; this.length; )
            this._remove(0);
          this.fire("change", { added: [], removed: e, index: 0 });
        }
        bindTo(e) {
          if (this._bindToCollection)
            throw new O("collection-bind-to-rebind", this);
          return this._bindToCollection = e, { as: (t) => {
            this._setUpBindToBinding((n) => new t(n));
          }, using: (t) => {
            typeof t == "function" ? this._setUpBindToBinding(t) : this._setUpBindToBinding((n) => n[t]);
          } };
        }
        _setUpBindToBinding(e) {
          const t = this._bindToCollection, n = (i, r, s) => {
            const a = t._bindToCollection == this, l = t._bindToInternalToExternalMap.get(r);
            if (a && l)
              this._bindToExternalToInternalMap.set(r, l), this._bindToInternalToExternalMap.set(l, r);
            else {
              const d = e(r);
              if (!d)
                return void this._skippedIndexesFromExternal.push(s);
              let h = s;
              for (const m of this._skippedIndexesFromExternal)
                s > m && h--;
              for (const m of t._skippedIndexesFromExternal)
                h >= m && h++;
              this._bindToExternalToInternalMap.set(r, d), this._bindToInternalToExternalMap.set(d, r), this.add(d, h);
              for (let m = 0; m < t._skippedIndexesFromExternal.length; m++)
                h <= t._skippedIndexesFromExternal[m] && t._skippedIndexesFromExternal[m]++;
            }
          };
          for (const i of t)
            n(0, i, t.getIndex(i));
          this.listenTo(t, "add", n), this.listenTo(t, "remove", (i, r, s) => {
            const a = this._bindToExternalToInternalMap.get(r);
            a && this.remove(a), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((l, d) => (s < d && l.push(d - 1), s > d && l.push(d), l), []);
          });
        }
        _getItemIdBeforeAdding(e) {
          const t = this._idProperty;
          let n;
          if (t in e) {
            if (n = e[t], typeof n != "string")
              throw new O("collection-add-invalid-id", this);
            if (this.get(n))
              throw new O("collection-add-item-already-exists", this);
          } else
            e[t] = n = ne();
          return n;
        }
        _remove(e) {
          let t, n, i, r = !1;
          const s = this._idProperty;
          if (typeof e == "string" ? (n = e, i = this._itemMap.get(n), r = !i, i && (t = this._items.indexOf(i))) : typeof e == "number" ? (t = e, i = this._items[t], r = !i, i && (n = i[s])) : (i = e, n = i[s], t = this._items.indexOf(i), r = t == -1 || !this._itemMap.get(n)), r)
            throw new O("collection-remove-404", this);
          this._items.splice(t, 1), this._itemMap.delete(n);
          const a = this._bindToInternalToExternalMap.get(i);
          return this._bindToInternalToExternalMap.delete(i), this._bindToExternalToInternalMap.delete(a), this.fire("remove", i, t), [i, t];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
      }
      function it(o) {
        const e = o.next();
        return e.done ? null : e.value;
      }
      class Jt extends In(re()) {
        constructor() {
          super(), this._elements = /* @__PURE__ */ new Set(), this._nextEventLoopTimeout = null, this.set("isFocused", !1), this.set("focusedElement", null);
        }
        add(e) {
          if (this._elements.has(e))
            throw new O("focustracker-add-element-already-exist", this);
          this.listenTo(e, "focus", () => this._focus(e), { useCapture: !0 }), this.listenTo(e, "blur", () => this._blur(), { useCapture: !0 }), this._elements.add(e);
        }
        remove(e) {
          e === this.focusedElement && this._blur(), this._elements.has(e) && (this.stopListening(e), this._elements.delete(e));
        }
        destroy() {
          this.stopListening();
        }
        _focus(e) {
          clearTimeout(this._nextEventLoopTimeout), this.focusedElement = e, this.isFocused = !0;
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null, this.isFocused = !1;
          }, 0);
        }
      }
      class mn {
        constructor() {
          this._listener = new (In())();
        }
        listenTo(e) {
          this._listener.listenTo(e, "keydown", (t, n) => {
            this._listener.fire("_keydown:" + zo(n), n);
          });
        }
        set(e, t, n = {}) {
          const i = Br(e), r = n.priority;
          this._listener.listenTo(this._listener, "_keydown:" + i, (s, a) => {
            t(a, () => {
              a.preventDefault(), a.stopPropagation(), s.stop();
            }), s.return = !0;
          }, { priority: r });
        }
        press(e) {
          return !!this._listener.fire("_keydown:" + zo(e), e);
        }
        stopListening(e) {
          this._listener.stopListening(e);
        }
        destroy() {
          this.stopListening();
        }
      }
      function pn(o) {
        return zt(o) ? new Map(o) : function(e) {
          const t = /* @__PURE__ */ new Map();
          for (const n in e)
            t.set(n, e[n]);
          return t;
        }(o);
      }
      function ma(o, e) {
        let t;
        function n(...i) {
          n.cancel(), t = setTimeout(() => o(...i), e);
        }
        return n.cancel = () => {
          clearTimeout(t);
        }, n;
      }
      function pa(o, e) {
        return !!(t = o.charAt(e - 1)) && t.length == 1 && /[\ud800-\udbff]/.test(t) && function(n) {
          return !!n && n.length == 1 && /[\udc00-\udfff]/.test(n);
        }(o.charAt(e));
        var t;
      }
      function fa(o, e) {
        return !!(t = o.charAt(e)) && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t);
        var t;
      }
      const p_ = function() {
        const o = [new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}", "u"), new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")], e = new RegExp("\\p{Regional_Indicator}{2}", "u").source, t = "(?:" + o.map((n) => n.source).join("|") + ")";
        return new RegExp(`${e}|${t}(?:‍${t})*`, "ug");
      }();
      function lu(o, e) {
        const t = String(o).matchAll(p_);
        return Array.from(t).some((n) => n.index < e && e < n.index + n[0].length);
      }
      class Yn extends Ht {
        constructor(e = []) {
          super(e, { idProperty: "viewUid" }), this.on("add", (t, n, i) => {
            this._renderViewIntoCollectionParent(n, i);
          }), this.on("remove", (t, n) => {
            n.element && this._parentElement && n.element.remove();
          }), this._parentElement = null;
        }
        destroy() {
          this.map((e) => e.destroy());
        }
        setParent(e) {
          this._parentElement = e;
          for (const t of this)
            this._renderViewIntoCollectionParent(t);
        }
        delegate(...e) {
          if (!e.length || !e.every((t) => typeof t == "string"))
            throw new O("ui-viewcollection-delegate-wrong-events", this);
          return { to: (t) => {
            for (const n of this)
              for (const i of e)
                n.delegate(i).to(t);
            this.on("add", (n, i) => {
              for (const r of e)
                i.delegate(r).to(t);
            }), this.on("remove", (n, i) => {
              for (const r of e)
                i.stopDelegating(r, t);
            });
          } };
        }
        _renderViewIntoCollectionParent(e, t) {
          e.isRendered || e.render(), e.element && this._parentElement && this._parentElement.insertBefore(e.element, this._parentElement.children[t]);
        }
        remove(e) {
          return super.remove(e);
        }
      }
      var f_ = b(6062), Q = b.n(f_), cu = b(4793), b_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(cu.Z, b_), cu.Z.locals;
      class _e extends In(re()) {
        constructor(e) {
          super(), this.element = null, this.isRendered = !1, this.locale = e, this.t = e && e.t, this._viewCollections = new Ht(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (t, n) => {
            n.locale = e, n.t = e && e.t;
          }), this.decorate("render");
        }
        get bindTemplate() {
          return this._bindTemplate ? this._bindTemplate : this._bindTemplate = rn.bind(this, this);
        }
        createCollection(e) {
          const t = new Yn(e);
          return this._viewCollections.add(t), t;
        }
        registerChild(e) {
          zt(e) || (e = [e]);
          for (const t of e)
            this._unboundChildren.add(t);
        }
        deregisterChild(e) {
          zt(e) || (e = [e]);
          for (const t of e)
            this._unboundChildren.remove(t);
        }
        setTemplate(e) {
          this.template = new rn(e);
        }
        extendTemplate(e) {
          rn.extend(this.template, e);
        }
        render() {
          if (this.isRendered)
            throw new O("ui-view-render-already-rendered", this);
          this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = !0;
        }
        destroy() {
          this.stopListening(), this._viewCollections.map((e) => e.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
        }
      }
      class rn extends Se() {
        constructor(e) {
          super(), Object.assign(this, gu(hu(e))), this._isRendered = !1, this._revertData = null;
        }
        render() {
          const e = this._renderNode({ intoFragment: !0 });
          return this._isRendered = !0, e;
        }
        apply(e) {
          return this._revertData = { children: [], bindings: [], attributes: {} }, this._renderNode({ node: e, intoFragment: !1, isApplying: !0, revertData: this._revertData }), e;
        }
        revert(e) {
          if (!this._revertData)
            throw new O("ui-template-revert-not-applied", [this, e]);
          this._revertTemplateFromNode(e, this._revertData);
        }
        *getViews() {
          yield* function* e(t) {
            if (t.children)
              for (const n of t.children)
                Ir(n) ? yield n : ba(n) && (yield* e(n));
          }(this);
        }
        static bind(e, t) {
          return { to: (n, i) => new k_({ eventNameOrFunction: n, attribute: n, observable: e, emitter: t, callback: i }), if: (n, i, r) => new du({ observable: e, emitter: t, attribute: n, valueIfTrue: i, callback: r }) };
        }
        static extend(e, t) {
          if (e._isRendered)
            throw new O("template-extend-render", [this, e]);
          bu(e, gu(hu(t)));
        }
        _renderNode(e) {
          let t;
          if (t = e.node ? this.tag && this.text : this.tag ? this.text : !this.text, t)
            throw new O("ui-template-wrong-syntax", this);
          return this.text ? this._renderText(e) : this._renderElement(e);
        }
        _renderElement(e) {
          let t = e.node;
          return t || (t = e.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(e), this._renderElementChildren(e), this._setUpListeners(e), t;
        }
        _renderText(e) {
          let t = e.node;
          return t ? e.revertData.text = t.textContent : t = e.node = document.createTextNode(""), Tr(this.text) ? this._bindToObservable({ schema: this.text, updater: w_(t), data: e }) : t.textContent = this.text.join(""), t;
        }
        _renderAttributes(e) {
          if (!this.attributes)
            return;
          const t = e.node, n = e.revertData;
          for (const i in this.attributes) {
            const r = t.getAttribute(i), s = this.attributes[i];
            n && (n.attributes[i] = r);
            const a = ku(s) ? s[0].ns : null;
            if (Tr(s)) {
              const l = ku(s) ? s[0].value : s;
              n && wu(i) && l.unshift(r), this._bindToObservable({ schema: l, updater: v_(t, i, a), data: e });
            } else if (i == "style" && typeof s[0] != "string")
              this._renderStyleAttribute(s[0], e);
            else {
              n && r && wu(i) && s.unshift(r);
              const l = s.map((d) => d && d.value || d).reduce((d, h) => d.concat(h), []).reduce(pu, "");
              Mo(l) || t.setAttributeNS(a, i, l);
            }
          }
        }
        _renderStyleAttribute(e, t) {
          const n = t.node;
          for (const i in e) {
            const r = e[i];
            Tr(r) ? this._bindToObservable({ schema: [r], updater: __(n, i), data: t }) : n.style[i] = r;
          }
        }
        _renderElementChildren(e) {
          const t = e.node, n = e.intoFragment ? document.createDocumentFragment() : t, i = e.isApplying;
          let r = 0;
          for (const s of this.children)
            if (ka(s)) {
              if (!i) {
                s.setParent(t);
                for (const a of s)
                  n.appendChild(a.element);
              }
            } else if (Ir(s))
              i || (s.isRendered || s.render(), n.appendChild(s.element));
            else if (Tn(s))
              n.appendChild(s);
            else if (i) {
              const a = { children: [], bindings: [], attributes: {} };
              e.revertData.children.push(a), s._renderNode({ intoFragment: !1, node: n.childNodes[r++], isApplying: !0, revertData: a });
            } else
              n.appendChild(s.render());
          e.intoFragment && t.appendChild(n);
        }
        _setUpListeners(e) {
          if (this.eventListeners)
            for (const t in this.eventListeners) {
              const n = this.eventListeners[t].map((i) => {
                const [r, s] = t.split("@");
                return i.activateDomEventListener(r, s, e);
              });
              e.revertData && e.revertData.bindings.push(n);
            }
        }
        _bindToObservable({ schema: e, updater: t, data: n }) {
          const i = n.revertData;
          uu(e, t, n);
          const r = e.filter((s) => !Mo(s)).filter((s) => s.observable).map((s) => s.activateAttributeListener(e, t, n));
          i && i.bindings.push(r);
        }
        _revertTemplateFromNode(e, t) {
          for (const i of t.bindings)
            for (const r of i)
              r();
          if (t.text)
            return void (e.textContent = t.text);
          const n = e;
          for (const i in t.attributes) {
            const r = t.attributes[i];
            r === null ? n.removeAttribute(i) : n.setAttribute(i, r);
          }
          for (let i = 0; i < t.children.length; ++i)
            this._revertTemplateFromNode(n.childNodes[i], t.children[i]);
        }
      }
      class Ei {
        constructor(e) {
          this.attribute = e.attribute, this.observable = e.observable, this.emitter = e.emitter, this.callback = e.callback;
        }
        getValue(e) {
          const t = this.observable[this.attribute];
          return this.callback ? this.callback(t, e) : t;
        }
        activateAttributeListener(e, t, n) {
          const i = () => uu(e, t, n);
          return this.emitter.listenTo(this.observable, `change:${this.attribute}`, i), () => {
            this.emitter.stopListening(this.observable, `change:${this.attribute}`, i);
          };
        }
      }
      class k_ extends Ei {
        constructor(e) {
          super(e), this.eventNameOrFunction = e.eventNameOrFunction;
        }
        activateDomEventListener(e, t, n) {
          const i = (r, s) => {
            t && !s.target.matches(t) || (typeof this.eventNameOrFunction == "function" ? this.eventNameOrFunction(s) : this.observable.fire(this.eventNameOrFunction, s));
          };
          return this.emitter.listenTo(n.node, e, i), () => {
            this.emitter.stopListening(n.node, e, i);
          };
        }
      }
      class du extends Ei {
        constructor(e) {
          super(e), this.valueIfTrue = e.valueIfTrue;
        }
        getValue(e) {
          return !Mo(super.getValue(e)) && (this.valueIfTrue || !0);
        }
      }
      function Tr(o) {
        return !!o && (o.value && (o = o.value), Array.isArray(o) ? o.some(Tr) : o instanceof Ei);
      }
      function uu(o, e, { node: t }) {
        const n = function(r, s) {
          return r.map((a) => a instanceof Ei ? a.getValue(s) : a);
        }(o, t);
        let i;
        i = o.length == 1 && o[0] instanceof du ? n[0] : n.reduce(pu, ""), Mo(i) ? e.remove() : e.set(i);
      }
      function w_(o) {
        return { set(e) {
          o.textContent = e;
        }, remove() {
          o.textContent = "";
        } };
      }
      function v_(o, e, t) {
        return { set(n) {
          o.setAttributeNS(t, e, n);
        }, remove() {
          o.removeAttributeNS(t, e);
        } };
      }
      function __(o, e) {
        return { set(t) {
          o.style[e] = t;
        }, remove() {
          o.style[e] = null;
        } };
      }
      function hu(o) {
        return la(o, (e) => {
          if (e && (e instanceof Ei || ba(e) || Ir(e) || ka(e)))
            return e;
        });
      }
      function gu(o) {
        if (typeof o == "string" ? o = /* @__PURE__ */ function(e) {
          return { text: [e] };
        }(o) : o.text && function(e) {
          e.text = Xe(e.text);
        }(o), o.on && (o.eventListeners = function(e) {
          for (const t in e)
            mu(e, t);
          return e;
        }(o.on), delete o.on), !o.text) {
          o.attributes && function(t) {
            for (const n in t)
              t[n].value && (t[n].value = Xe(t[n].value)), mu(t, n);
          }(o.attributes);
          const e = [];
          if (o.children)
            if (ka(o.children))
              e.push(o.children);
            else
              for (const t of o.children)
                ba(t) || Ir(t) || Tn(t) ? e.push(t) : e.push(new rn(t));
          o.children = e;
        }
        return o;
      }
      function mu(o, e) {
        o[e] = Xe(o[e]);
      }
      function pu(o, e) {
        return Mo(e) ? o : Mo(o) ? e : `${o} ${e}`;
      }
      function fu(o, e) {
        for (const t in e)
          o[t] ? o[t].push(...e[t]) : o[t] = e[t];
      }
      function bu(o, e) {
        if (e.attributes && (o.attributes || (o.attributes = {}), fu(o.attributes, e.attributes)), e.eventListeners && (o.eventListeners || (o.eventListeners = {}), fu(o.eventListeners, e.eventListeners)), e.text && o.text.push(...e.text), e.children && e.children.length) {
          if (o.children.length != e.children.length)
            throw new O("ui-template-extend-children-mismatch", o);
          let t = 0;
          for (const n of e.children)
            bu(o.children[t++], n);
        }
      }
      function Mo(o) {
        return !o && o !== 0;
      }
      function Ir(o) {
        return o instanceof _e;
      }
      function ba(o) {
        return o instanceof rn;
      }
      function ka(o) {
        return o instanceof Yn;
      }
      function ku(o) {
        return K(o[0]) && o[0].ns;
      }
      function wu(o) {
        return o == "class" || o == "style";
      }
      class A_ extends Yn {
        constructor(e, t = []) {
          super(t), this.locale = e;
        }
        attachToDom() {
          this._bodyCollectionContainer = new rn({ tag: "div", attributes: { class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"], dir: this.locale.uiLanguageDirection }, children: this }).render();
          let e = document.querySelector(".ck-body-wrapper");
          e || (e = js(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(e)), e.appendChild(this._bodyCollectionContainer);
        }
        detachFromDom() {
          super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
          const e = document.querySelector(".ck-body-wrapper");
          e && e.childElementCount == 0 && e.remove();
        }
      }
      var vu = b(6574), C_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(vu.Z, C_), vu.Z.locals;
      const _u = class extends _e {
        constructor() {
          super();
          const o = this.bindTemplate;
          this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", !0), this.setTemplate({ tag: "svg", ns: "http://www.w3.org/2000/svg", attributes: { class: ["ck", "ck-icon", "ck-reset_all-excluded", o.if("isColorInherited", "ck-icon_inherit-color")], viewBox: o.to("viewBox") } });
        }
        render() {
          super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
            this._updateXMLContent(), this._colorFillPaths();
          }), this.on("change:fillColor", () => {
            this._colorFillPaths();
          });
        }
        _updateXMLContent() {
          if (this.content) {
            const o = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"), e = o.getAttribute("viewBox");
            e && (this.viewBox = e);
            for (const { name: t, value: n } of Array.from(o.attributes))
              _u.presentationalAttributeNames.includes(t) && this.element.setAttribute(t, n);
            for (; this.element.firstChild; )
              this.element.removeChild(this.element.firstChild);
            for (; o.childNodes.length > 0; )
              this.element.appendChild(o.childNodes[0]);
          }
        }
        _colorFillPaths() {
          this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((o) => {
            o.style.fill = this.fillColor;
          });
        }
      };
      let xi = _u;
      xi.presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"];
      var Au = b(4906), y_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Au.Z, y_), Au.Z.locals;
      class je extends _e {
        constructor(e) {
          super(e), this._focusDelayed = null;
          const t = this.bindTemplate, n = ne();
          this.set("ariaChecked", void 0), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", `ck-editor__aria-label_${n}`), this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isVisible", !0), this.set("isToggleable", !1), this.set("keystroke", void 0), this.set("label", void 0), this.set("role", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.set("withKeystroke", !1), this.children = this.createCollection(), this.labelView = this._createLabelView(), this.iconView = new xi(), this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
          const i = { tag: "button", attributes: { class: ["ck", "ck-button", t.to("class"), t.if("isEnabled", "ck-disabled", (r) => !r), t.if("isVisible", "ck-hidden", (r) => !r), t.to("isOn", (r) => r ? "ck-on" : "ck-off"), t.if("withText", "ck-button_with-text"), t.if("withKeystroke", "ck-button_with-keystroke")], role: t.to("role"), type: t.to("type", (r) => r || "button"), tabindex: t.to("tabindex"), "aria-label": t.to("ariaLabel"), "aria-labelledby": t.to("ariaLabelledBy"), "aria-disabled": t.if("isEnabled", !0, (r) => !r), "aria-checked": t.to("isOn"), "aria-pressed": t.to("isOn", (r) => !!this.isToggleable && String(!!r)), "data-cke-tooltip-text": t.to("_tooltipString"), "data-cke-tooltip-position": t.to("tooltipPosition") }, children: this.children, on: { click: t.to((r) => {
            this.isEnabled ? this.fire("execute") : r.preventDefault();
          }) } };
          k.isSafari && (this._focusDelayed || (this._focusDelayed = ma(() => this.focus(), 0)), i.on.mousedown = t.to(() => {
            this._focusDelayed();
          }), i.on.mouseup = t.to(() => {
            this._focusDelayed.cancel();
          })), this.setTemplate(i);
        }
        render() {
          super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView);
        }
        focus() {
          this.element.focus();
        }
        destroy() {
          this._focusDelayed && this._focusDelayed.cancel(), super.destroy();
        }
        _createLabelView() {
          const e = new _e(), t = this.bindTemplate;
          return e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__label"], style: t.to("labelStyle"), id: this.ariaLabelledBy }, children: [{ text: t.to("label") }] }), e;
        }
        _createKeystrokeView() {
          const e = new _e();
          return e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__keystroke"] }, children: [{ text: this.bindTemplate.to("keystroke", (t) => su(t)) }] }), e;
        }
        _getTooltipString(e, t, n) {
          return e ? typeof e == "string" ? e : (n && (n = su(n)), e instanceof Function ? e(t, n) : `${t}${n ? ` (${n})` : ""}`) : "";
        }
      }
      var Cu = b(6758), E_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Cu.Z, E_), Cu.Z.locals;
      class Pr extends je {
        constructor(e) {
          super(e), this.isToggleable = !0, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
        }
        render() {
          super.render(), this.children.add(this.toggleSwitchView);
        }
        _createToggleView() {
          const e = new _e();
          return e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__toggle"] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }] }), e;
        }
      }
      var yu = b(6781), x_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(yu.Z, x_), yu.Z.locals, b(1103), b(841);
      var Eu = b(3662), S_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Eu.Z, S_), Eu.Z.locals;
      class xu extends _e {
        constructor(e) {
          super(e), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${ne()}`;
          const t = this.bindTemplate;
          this.setTemplate({ tag: "label", attributes: { class: ["ck", "ck-label"], id: this.id, for: t.to("for") }, children: [{ text: t.to("text") }] });
        }
      }
      var Su = b(2577), D_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Su.Z, D_), Su.Z.locals;
      class Du extends _e {
        constructor(e, t) {
          super(e);
          const n = `ck-labeled-field-view-${ne()}`, i = `ck-labeled-field-view-status-${ne()}`;
          this.fieldView = t(this, n, i), this.set("label", void 0), this.set("isEnabled", !0), this.set("isEmpty", !0), this.set("isFocused", !1), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(n), this.statusView = this._createStatusView(i), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", (s, a) => s || a);
          const r = this.bindTemplate;
          this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view", r.to("class"), r.if("isEnabled", "ck-disabled", (s) => !s), r.if("isEmpty", "ck-labeled-field-view_empty"), r.if("isFocused", "ck-labeled-field-view_focused"), r.if("placeholder", "ck-labeled-field-view_placeholder"), r.if("errorText", "ck-error")] }, children: [{ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] }, children: this.fieldWrapperChildren }, this.statusView] });
        }
        _createLabelView(e) {
          const t = new xu(this.locale);
          return t.for = e, t.bind("text").to(this, "label"), t;
        }
        _createStatusView(e) {
          const t = new _e(this.locale), n = this.bindTemplate;
          return t.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__status", n.if("errorText", "ck-labeled-field-view__status_error"), n.if("_statusText", "ck-hidden", (i) => !i)], id: e, role: n.if("errorText", "alert") }, children: [{ text: n.to("_statusText") }] }), t;
        }
        focus() {
          this.fieldView.focus();
        }
      }
      var Bu = b(4879), B_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Bu.Z, B_), Bu.Z.locals;
      class T_ extends _e {
        constructor(e) {
          super(e), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("isReadOnly", !1), this.set("hasError", !1), this.set("ariaDescribedById", void 0), this.focusTracker = new Jt(), this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", !0), this.set("inputMode", "text");
          const t = this.bindTemplate;
          this.setTemplate({ tag: "input", attributes: { class: ["ck", "ck-input", t.if("isFocused", "ck-input_focused"), t.if("isEmpty", "ck-input-text_empty"), t.if("hasError", "ck-error")], id: t.to("id"), placeholder: t.to("placeholder"), readonly: t.to("isReadOnly"), inputmode: t.to("inputMode"), "aria-invalid": t.if("hasError", !0), "aria-describedby": t.to("ariaDescribedById") }, on: { input: t.to((...n) => {
            this.fire("input", ...n), this._updateIsEmpty();
          }), change: t.to(this._updateIsEmpty.bind(this)) } });
        }
        render() {
          super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (e, t, n) => {
            this._setDomElementValue(n), this._updateIsEmpty();
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy();
        }
        select() {
          this.element.select();
        }
        focus() {
          this.element.focus();
        }
        _updateIsEmpty() {
          this.isEmpty = !this.element.value;
        }
        _setDomElementValue(e) {
          this.element.value = e || e === 0 ? e : "";
        }
      }
      class I_ extends T_ {
        constructor(e) {
          super(e), this.extendTemplate({ attributes: { type: "text", class: ["ck-input-text"] } });
        }
      }
      class P_ extends _e {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-dropdown__panel", t.to("position", (n) => `ck-dropdown__panel_${n}`), t.if("isVisible", "ck-dropdown__panel-visible")] }, children: this.children, on: { selectstart: t.to((n) => {
            n.target.tagName.toLocaleLowerCase() !== "input" && n.preventDefault();
          }) } });
        }
        focus() {
          if (this.children.length) {
            const e = this.children.first;
            typeof e.focus == "function" ? e.focus() : oe("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this });
          }
        }
        focusLast() {
          if (this.children.length) {
            const e = this.children.last;
            typeof e.focusLast == "function" ? e.focusLast() : e.focus();
          }
        }
      }
      var Tu = b(5485), O_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Tu.Z, O_), Tu.Z.locals;
      const wa = class extends _e {
        constructor(o, e, t) {
          super(o);
          const n = this.bindTemplate;
          this.buttonView = e, this.panelView = t, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.keystrokes = new mn(), this.focusTracker = new Jt(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dropdown", n.to("class"), n.if("isEnabled", "ck-disabled", (i) => !i)], id: n.to("id"), "aria-describedby": n.to("ariaDescribedById") }, children: [e, t] }), e.extendTemplate({ attributes: { class: ["ck-dropdown__button"], "data-cke-tooltip-disabled": n.to("isOpen") } });
        }
        render() {
          super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", () => {
            this.isOpen = !this.isOpen;
          }), this.panelView.bind("isVisible").to(this, "isOpen"), this.on("change:isOpen", (e, t, n) => {
            n && (this.panelPosition === "auto" ? this.panelView.position = wa._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: !0, positions: this._panelPositions }).name : this.panelView.position = this.panelPosition);
          }), this.keystrokes.listenTo(this.element);
          const o = (e, t) => {
            this.isOpen && (this.isOpen = !1, t());
          };
          this.keystrokes.set("arrowdown", (e, t) => {
            this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0, t());
          }), this.keystrokes.set("arrowright", (e, t) => {
            this.isOpen && t();
          }), this.keystrokes.set("arrowleft", o), this.keystrokes.set("esc", o);
        }
        focus() {
          this.buttonView.focus();
        }
        get _panelPositions() {
          const { south: o, north: e, southEast: t, southWest: n, northEast: i, northWest: r, southMiddleEast: s, southMiddleWest: a, northMiddleEast: l, northMiddleWest: d } = wa.defaultPanelPositions;
          return this.locale.uiLanguageDirection !== "rtl" ? [t, n, s, a, o, i, r, l, d, e] : [n, t, a, s, o, r, i, d, l, e];
        }
      };
      let va = wa;
      va.defaultPanelPositions = { south: (o, e) => ({ top: o.bottom, left: o.left - (e.width - o.width) / 2, name: "s" }), southEast: (o) => ({ top: o.bottom, left: o.left, name: "se" }), southWest: (o, e) => ({ top: o.bottom, left: o.left - e.width + o.width, name: "sw" }), southMiddleEast: (o, e) => ({ top: o.bottom, left: o.left - (e.width - o.width) / 4, name: "sme" }), southMiddleWest: (o, e) => ({ top: o.bottom, left: o.left - 3 * (e.width - o.width) / 4, name: "smw" }), north: (o, e) => ({ top: o.top - e.height, left: o.left - (e.width - o.width) / 2, name: "n" }), northEast: (o, e) => ({ top: o.top - e.height, left: o.left, name: "ne" }), northWest: (o, e) => ({ top: o.top - e.height, left: o.left - e.width + o.width, name: "nw" }), northMiddleEast: (o, e) => ({ top: o.top - e.height, left: o.left - (e.width - o.width) / 4, name: "nme" }), northMiddleWest: (o, e) => ({ top: o.top - e.height, left: o.left - 3 * (e.width - o.width) / 4, name: "nmw" }) }, va._getOptimalPosition = Qd;
      const Iu = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
      class Pu extends je {
        constructor(e) {
          super(e), this.arrowView = this._createArrowView(), this.extendTemplate({ attributes: { "aria-haspopup": !0, "aria-expanded": this.bindTemplate.to("isOn", (t) => String(t)) } }), this.delegate("execute").to(this, "open");
        }
        render() {
          super.render(), this.children.add(this.arrowView);
        }
        _createArrowView() {
          const e = new xi();
          return e.content = Iu, e.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }), e;
        }
      }
      class Si {
        constructor(e) {
          if (this.focusables = e.focusables, this.focusTracker = e.focusTracker, this.keystrokeHandler = e.keystrokeHandler, this.actions = e.actions, e.actions && e.keystrokeHandler)
            for (const t in e.actions) {
              let n = e.actions[t];
              typeof n == "string" && (n = [n]);
              for (const i of n)
                e.keystrokeHandler.set(i, (r, s) => {
                  this[t](), s();
                });
            }
        }
        get first() {
          return this.focusables.find(_a) || null;
        }
        get last() {
          return this.focusables.filter(_a).slice(-1)[0] || null;
        }
        get next() {
          return this._getFocusableItem(1);
        }
        get previous() {
          return this._getFocusableItem(-1);
        }
        get current() {
          let e = null;
          return this.focusTracker.focusedElement === null ? null : (this.focusables.find((t, n) => {
            const i = t.element === this.focusTracker.focusedElement;
            return i && (e = n), i;
          }), e);
        }
        focusFirst() {
          this._focus(this.first);
        }
        focusLast() {
          this._focus(this.last);
        }
        focusNext() {
          this._focus(this.next);
        }
        focusPrevious() {
          this._focus(this.previous);
        }
        _focus(e) {
          e && e.focus();
        }
        _getFocusableItem(e) {
          const t = this.current, n = this.focusables.length;
          if (!n)
            return null;
          if (t === null)
            return this[e === 1 ? "first" : "last"];
          let i = (t + n + e) % n;
          do {
            const r = this.focusables.get(i);
            if (_a(r))
              return r;
            i = (i + n + e) % n;
          } while (i !== t);
          return null;
        }
      }
      function _a(o) {
        return !(!o.focus || !Jn(o.element));
      }
      class Ou extends _e {
        constructor(e) {
          super(e), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } });
        }
      }
      class R_ extends _e {
        constructor(e) {
          super(e), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__line-break"] } });
        }
      }
      function Ru(o) {
        return Array.isArray(o) ? { items: o, removeItems: [] } : o ? Object.assign({ items: [], removeItems: [] }, o) : { items: [], removeItems: [] };
      }
      class W extends re() {
        constructor(e) {
          super(), this._disableStack = /* @__PURE__ */ new Set(), this.editor = e, this.set("isEnabled", !0);
        }
        forceDisabled(e) {
          this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", zu, { priority: "highest" }), this.isEnabled = !1);
        }
        clearForceDisabled(e) {
          this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", zu), this.isEnabled = !0);
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return !1;
        }
      }
      function zu(o) {
        o.return = !1, o.stop();
      }
      class be extends re() {
        constructor(e) {
          super(), this.editor = e, this.set("value", void 0), this.set("isEnabled", !1), this._affectsData = !0, this._isEnabledBasedOnSelection = !0, this._disableStack = /* @__PURE__ */ new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
            this.refresh();
          }), this.listenTo(e, "change:isReadOnly", () => {
            this.refresh();
          }), this.on("set:isEnabled", (t) => {
            this.affectsData && (e.isReadOnly || this._isEnabledBasedOnSelection && !e.model.canEditAt(e.model.document.selection)) && (t.return = !1, t.stop());
          }, { priority: "highest" }), this.on("execute", (t) => {
            this.isEnabled || t.stop();
          }, { priority: "high" });
        }
        get affectsData() {
          return this._affectsData;
        }
        set affectsData(e) {
          this._affectsData = e;
        }
        refresh() {
          this.isEnabled = !0;
        }
        forceDisabled(e) {
          this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", Mu, { priority: "highest" }), this.isEnabled = !1);
        }
        clearForceDisabled(e) {
          this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", Mu), this.refresh());
        }
        execute(...e) {
        }
        destroy() {
          this.stopListening();
        }
      }
      function Mu(o) {
        o.return = !1, o.stop();
      }
      class Nu extends be {
        constructor() {
          super(...arguments), this._childCommandsDefinitions = [];
        }
        refresh() {
        }
        execute(...e) {
          const t = this._getFirstEnabledCommand();
          return !!t && t.execute(e);
        }
        registerChildCommand(e, t = {}) {
          X(this._childCommandsDefinitions, { command: e, priority: t.priority || "normal" }), e.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled();
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand();
        }
        _getFirstEnabledCommand() {
          const e = this._childCommandsDefinitions.find(({ command: t }) => t.isEnabled);
          return e && e.command;
        }
      }
      class Fu extends Se() {
        constructor(e, t = [], n = []) {
          super(), this._plugins = /* @__PURE__ */ new Map(), this._context = e, this._availablePlugins = /* @__PURE__ */ new Map();
          for (const i of t)
            i.pluginName && this._availablePlugins.set(i.pluginName, i);
          this._contextPlugins = /* @__PURE__ */ new Map();
          for (const [i, r] of n)
            this._contextPlugins.set(i, r), this._contextPlugins.set(r, i), i.pluginName && this._availablePlugins.set(i.pluginName, i);
        }
        *[Symbol.iterator]() {
          for (const e of this._plugins)
            typeof e[0] == "function" && (yield e);
        }
        get(e) {
          const t = this._plugins.get(e);
          if (!t) {
            let n = e;
            throw typeof e == "function" && (n = e.pluginName || e.name), new O("plugincollection-plugin-not-loaded", this._context, { plugin: n });
          }
          return t;
        }
        has(e) {
          return this._plugins.has(e);
        }
        init(e, t = [], n = []) {
          const i = this, r = this._context;
          (function S(B, T = /* @__PURE__ */ new Set()) {
            B.forEach((R) => {
              l(R) && (T.has(R) || (T.add(R), R.pluginName && !i._availablePlugins.has(R.pluginName) && i._availablePlugins.set(R.pluginName, R), R.requires && S(R.requires, T)));
            });
          })(e), f(e);
          const s = [...function S(B, T = /* @__PURE__ */ new Set()) {
            return B.map((R) => l(R) ? R : i._availablePlugins.get(R)).reduce((R, N) => T.has(N) ? R : (T.add(N), N.requires && (f(N.requires, N), S(N.requires, T).forEach((U) => R.add(U))), R.add(N)), /* @__PURE__ */ new Set());
          }(e.filter((S) => !h(S, t)))];
          (function(S, B) {
            for (const T of B) {
              if (typeof T != "function")
                throw new O("plugincollection-replace-plugin-invalid-type", null, { pluginItem: T });
              const R = T.pluginName;
              if (!R)
                throw new O("plugincollection-replace-plugin-missing-name", null, { pluginItem: T });
              if (T.requires && T.requires.length)
                throw new O("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: R });
              const N = i._availablePlugins.get(R);
              if (!N)
                throw new O("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: R });
              const U = S.indexOf(N);
              if (U === -1) {
                if (i._contextPlugins.has(N))
                  return;
                throw new O("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: R });
              }
              if (N.requires && N.requires.length)
                throw new O("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: R });
              S.splice(U, 1, T), i._availablePlugins.set(R, T);
            }
          })(s, n);
          const a = s.map((S) => {
            let B = i._contextPlugins.get(S);
            return B = B || new S(r), i._add(S, B), B;
          });
          return _(a, "init").then(() => _(a, "afterInit")).then(() => a);
          function l(S) {
            return typeof S == "function";
          }
          function d(S) {
            return l(S) && !!S.isContextPlugin;
          }
          function h(S, B) {
            return B.some((T) => T === S || m(S) === T || m(T) === S);
          }
          function m(S) {
            return l(S) ? S.pluginName || S.name : S;
          }
          function f(S, B = null) {
            S.map((T) => l(T) ? T : i._availablePlugins.get(T) || T).forEach((T) => {
              (function(R, N) {
                if (!l(R))
                  throw N ? new O("plugincollection-soft-required", r, { missingPlugin: R, requiredBy: m(N) }) : new O("plugincollection-plugin-not-found", r, { plugin: R });
              })(T, B), function(R, N) {
                if (d(N) && !d(R))
                  throw new O("plugincollection-context-required", r, { plugin: m(R), requiredBy: m(N) });
              }(T, B), function(R, N) {
                if (N && h(R, t))
                  throw new O("plugincollection-required", r, { plugin: m(R), requiredBy: m(N) });
              }(T, B);
            });
          }
          function _(S, B) {
            return S.reduce((T, R) => R[B] ? i._contextPlugins.has(R) ? T : T.then(R[B].bind(R)) : T, Promise.resolve());
          }
        }
        destroy() {
          const e = [];
          for (const [, t] of this)
            typeof t.destroy != "function" || this._contextPlugins.has(t) || e.push(t.destroy());
          return Promise.all(e);
        }
        _add(e, t) {
          this._plugins.set(e, t);
          const n = e.pluginName;
          if (n) {
            if (this._plugins.has(n))
              throw new O("plugincollection-plugin-name-conflict", null, { pluginName: n, plugin1: this._plugins.get(n).constructor, plugin2: e });
            this._plugins.set(n, t);
          }
        }
      }
      class $u {
        constructor(e) {
          this._contextOwner = null, this.config = new Vd(e, this.constructor.defaultConfig);
          const t = this.constructor.builtinPlugins;
          this.config.define("plugins", t), this.plugins = new Fu(this, t);
          const n = this.config.get("language") || {};
          this.locale = new m_({ uiLanguage: typeof n == "string" ? n : n.ui, contentLanguage: this.config.get("language.content") }), this.t = this.locale.t, this.editors = new Ht();
        }
        initPlugins() {
          const e = this.config.get("plugins") || [], t = this.config.get("substitutePlugins") || [];
          for (const n of e.concat(t)) {
            if (typeof n != "function")
              throw new O("context-initplugins-constructor-only", null, { Plugin: n });
            if (n.isContextPlugin !== !0)
              throw new O("context-initplugins-invalid-plugin", null, { Plugin: n });
          }
          return this.plugins.init(e, [], t);
        }
        destroy() {
          return Promise.all(Array.from(this.editors, (e) => e.destroy())).then(() => this.plugins.destroy());
        }
        _addEditor(e, t) {
          if (this._contextOwner)
            throw new O("context-addeditor-private-context");
          this.editors.add(e), t && (this._contextOwner = e);
        }
        _removeEditor(e) {
          return this.editors.has(e) && this.editors.remove(e), this._contextOwner === e ? this.destroy() : Promise.resolve();
        }
        _getEditorConfig() {
          const e = {};
          for (const t of this.config.names())
            ["plugins", "removePlugins", "extraPlugins"].includes(t) || (e[t] = this.config.get(t));
          return e;
        }
        static create(e) {
          return new Promise((t) => {
            const n = new this(e);
            t(n.initPlugins().then(() => n));
          });
        }
      }
      class Or extends re() {
        constructor(e) {
          super(), this.context = e;
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return !0;
        }
      }
      class z_ extends mn {
        constructor(e) {
          super(), this.editor = e;
        }
        set(e, t, n = {}) {
          if (typeof t == "string") {
            const i = t;
            t = (r, s) => {
              this.editor.execute(i), s();
            };
          }
          super.set(e, t, n);
        }
      }
      var Vu = b(4717), M_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Vu.Z, M_), Vu.Z.locals;
      const Rr = /* @__PURE__ */ new WeakMap();
      function N_(o, e) {
        return !!e.hasClass("ck-placeholder") && (o.removeClass("ck-placeholder", e), !0);
      }
      function Aa(o, e) {
        const t = Rr.get(o), n = [];
        let i = !1;
        for (const [r, s] of t)
          s.isDirectHost && (n.push(r), Lu(e, r, s) && (i = !0));
        for (const [r, s] of t) {
          if (s.isDirectHost)
            continue;
          const a = F_(r);
          a && (n.includes(a) || (s.hostElement = a, Lu(e, r, s) && (i = !0)));
        }
        return i;
      }
      function Lu(o, e, t) {
        const { text: n, isDirectHost: i, hostElement: r } = t;
        let s = !1;
        return r.getAttribute("data-placeholder") !== n && (o.setAttribute("data-placeholder", n, r), s = !0), (i || e.childCount == 1) && function(a, l) {
          if (!a.isAttached() || Array.from(a.getChildren()).some((m) => !m.is("uiElement")))
            return !1;
          const d = a.document, h = d.selection.anchor;
          return !(d.isComposing && h && h.parent === a || !l && d.isFocused && (!h || h.parent === a));
        }(r, t.keepOnFocus) ? function(a, l) {
          return !l.hasClass("ck-placeholder") && (a.addClass("ck-placeholder", l), !0);
        }(o, r) && (s = !0) : N_(o, r) && (s = !0), s;
      }
      function F_(o) {
        if (o.childCount) {
          const e = o.getChild(0);
          if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement"))
            return e;
        }
        return null;
      }
      class Qn {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      const ju = function(o) {
        return aa(o, 4);
      };
      class Xn extends Se(Qn) {
        constructor(e) {
          super(), this.document = e, this.parent = null;
        }
        get index() {
          let e;
          if (!this.parent)
            return null;
          if ((e = this.parent.getChildIndex(this)) == -1)
            throw new O("view-node-not-found-in-parent", this);
          return e;
        }
        get nextSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e + 1) || null;
        }
        get previousSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e - 1) || null;
        }
        get root() {
          let e = this;
          for (; e.parent; )
            e = e.parent;
          return e;
        }
        isAttached() {
          return this.root.is("rootElement");
        }
        getPath() {
          const e = [];
          let t = this;
          for (; t.parent; )
            e.unshift(t.index), t = t.parent;
          return e;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this : this.parent;
          for (; n; )
            t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
        getCommonAncestor(e, t = {}) {
          const n = this.getAncestors(t), i = e.getAncestors(t);
          let r = 0;
          for (; n[r] == i[r] && n[r]; )
            r++;
          return r === 0 ? null : n[r - 1];
        }
        isBefore(e) {
          if (this == e || this.root !== e.root)
            return !1;
          const t = this.getPath(), n = e.getPath(), i = _t(t, n);
          switch (i) {
            case "prefix":
              return !0;
            case "extension":
              return !1;
            default:
              return t[i] < n[i];
          }
        }
        isAfter(e) {
          return this != e && this.root === e.root && !this.isBefore(e);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _fireChange(e, t) {
          this.fire(`change:${e}`, t), this.parent && this.parent._fireChange(e, t);
        }
        toJSON() {
          const e = ju(this);
          return delete e.parent, e;
        }
      }
      Xn.prototype.is = function(o) {
        return o === "node" || o === "view:node";
      };
      class Me extends Xn {
        constructor(e, t) {
          super(e), this._textData = t;
        }
        get data() {
          return this._textData;
        }
        get _data() {
          return this.data;
        }
        set _data(e) {
          this._fireChange("text", this), this._textData = e;
        }
        isSimilar(e) {
          return e instanceof Me && (this === e || this.data === e.data);
        }
        _clone() {
          return new Me(this.document, this.data);
        }
      }
      Me.prototype.is = function(o) {
        return o === "$text" || o === "view:$text" || o === "text" || o === "view:text" || o === "node" || o === "view:node";
      };
      class sn extends Qn {
        constructor(e, t, n) {
          if (super(), this.textNode = e, t < 0 || t > e.data.length)
            throw new O("view-textproxy-wrong-offsetintext", this);
          if (n < 0 || t + n > e.data.length)
            throw new O("view-textproxy-wrong-length", this);
          this.data = e.data.substring(t, t + n), this.offsetInText = t;
        }
        get offsetSize() {
          return this.data.length;
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        get document() {
          return this.textNode.document;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this.textNode : this.parent;
          for (; n !== null; )
            t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
      }
      sn.prototype.is = function(o) {
        return o === "$textProxy" || o === "view:$textProxy" || o === "textProxy" || o === "view:textProxy";
      };
      class No {
        constructor(...e) {
          this._patterns = [], this.add(...e);
        }
        add(...e) {
          for (let t of e)
            (typeof t == "string" || t instanceof RegExp) && (t = { name: t }), this._patterns.push(t);
        }
        match(...e) {
          for (const t of e)
            for (const n of this._patterns) {
              const i = Hu(t, n);
              if (i)
                return { element: t, pattern: n, match: i };
            }
          return null;
        }
        matchAll(...e) {
          const t = [];
          for (const n of e)
            for (const i of this._patterns) {
              const r = Hu(n, i);
              r && t.push({ element: n, pattern: i, match: r });
            }
          return t.length > 0 ? t : null;
        }
        getElementName() {
          if (this._patterns.length !== 1)
            return null;
          const e = this._patterns[0], t = e.name;
          return typeof e == "function" || !t || t instanceof RegExp ? null : t;
        }
      }
      function Hu(o, e) {
        if (typeof e == "function")
          return e(o);
        const t = {};
        return e.name && (t.name = function(n, i) {
          return n instanceof RegExp ? !!i.match(n) : n === i;
        }(e.name, o.name), !t.name) || e.attributes && (t.attributes = function(n, i) {
          const r = new Set(i.getAttributeKeys());
          return xt(n) ? (n.style !== void 0 && oe("matcher-pattern-deprecated-attributes-style-key", n), n.class !== void 0 && oe("matcher-pattern-deprecated-attributes-class-key", n)) : (r.delete("style"), r.delete("class")), Ca(n, r, (s) => i.getAttribute(s));
        }(e.attributes, o), !t.attributes) || e.classes && (t.classes = function(n, i) {
          return Ca(n, i.getClassNames(), () => {
          });
        }(e.classes, o), !t.classes) || e.styles && (t.styles = function(n, i) {
          return Ca(n, i.getStyleNames(!0), (r) => i.getStyle(r));
        }(e.styles, o), !t.styles) ? null : t;
      }
      function Ca(o, e, t) {
        const n = function(s) {
          return Array.isArray(s) ? s.map((a) => xt(a) ? (a.key !== void 0 && a.value !== void 0 || oe("matcher-pattern-missing-key-or-value", a), [a.key, a.value]) : [a, !0]) : xt(s) ? Object.entries(s) : [[s, !0]];
        }(o), i = Array.from(e), r = [];
        if (n.forEach(([s, a]) => {
          i.forEach((l) => {
            (function(d, h) {
              return d === !0 || d === h || d instanceof RegExp && h.match(d);
            })(s, l) && function(d, h, m) {
              if (d === !0)
                return !0;
              const f = m(h);
              return d === f || d instanceof RegExp && !!String(f).match(d);
            }(a, l, t) && r.push(l);
          });
        }), n.length && !(r.length < n.length))
          return r;
      }
      const zr = function(o) {
        return typeof o == "symbol" || jt(o) && Bn(o) == "[object Symbol]";
      };
      var $_ = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, V_ = /^\w*$/;
      const L_ = function(o, e) {
        if (At(o))
          return !1;
        var t = typeof o;
        return !(t != "number" && t != "symbol" && t != "boolean" && o != null && !zr(o)) || V_.test(o) || !$_.test(o) || e != null && o in Object(e);
      };
      function ya(o, e) {
        if (typeof o != "function" || e != null && typeof e != "function")
          throw new TypeError("Expected a function");
        var t = function() {
          var n = arguments, i = e ? e.apply(this, n) : n[0], r = t.cache;
          if (r.has(i))
            return r.get(i);
          var s = o.apply(this, n);
          return t.cache = r.set(i, s) || r, s;
        };
        return t.cache = new (ya.Cache || wr)(), t;
      }
      ya.Cache = wr;
      const j_ = ya, H_ = function(o) {
        var e = j_(o, function(n) {
          return t.size === 500 && t.clear(), n;
        }), t = e.cache;
        return e;
      };
      var U_ = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, q_ = /\\(\\)?/g, W_ = H_(function(o) {
        var e = [];
        return o.charCodeAt(0) === 46 && e.push(""), o.replace(U_, function(t, n, i, r) {
          e.push(i ? r.replace(q_, "$1") : n || t);
        }), e;
      });
      const G_ = W_, Uu = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length, i = Array(n); ++t < n; )
          i[t] = e(o[t], t, o);
        return i;
      };
      var qu = on ? on.prototype : void 0, Wu = qu ? qu.toString : void 0;
      const K_ = function o(e) {
        if (typeof e == "string")
          return e;
        if (At(e))
          return Uu(e, o) + "";
        if (zr(e))
          return Wu ? Wu.call(e) : "";
        var t = e + "";
        return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
      }, Ea = function(o) {
        return o == null ? "" : K_(o);
      }, xa = function(o, e) {
        return At(o) ? o : L_(o, e) ? [o] : G_(Ea(o));
      }, Z_ = function(o) {
        var e = o == null ? 0 : o.length;
        return e ? o[e - 1] : void 0;
      }, Sa = function(o) {
        if (typeof o == "string" || zr(o))
          return o;
        var e = o + "";
        return e == "0" && 1 / o == -1 / 0 ? "-0" : e;
      }, Gu = function(o, e) {
        for (var t = 0, n = (e = xa(e, o)).length; o != null && t < n; )
          o = o[Sa(e[t++])];
        return t && t == n ? o : void 0;
      }, Ku = function(o, e, t) {
        var n = -1, i = o.length;
        e < 0 && (e = -e > i ? 0 : i + e), (t = t > i ? i : t) < 0 && (t += i), i = e > t ? 0 : t - e >>> 0, e >>>= 0;
        for (var r = Array(i); ++n < i; )
          r[n] = o[n + e];
        return r;
      }, J_ = function(o, e) {
        return e.length < 2 ? o : Gu(o, Ku(e, 0, -1));
      }, Y_ = function(o, e) {
        return e = xa(e, o), (o = J_(o, e)) == null || delete o[Sa(Z_(e))];
      }, Q_ = function(o, e) {
        return o == null || Y_(o, e);
      }, Mr = function(o, e, t) {
        var n = o == null ? void 0 : Gu(o, e);
        return n === void 0 ? t : n;
      }, Da = function(o, e, t) {
        (t !== void 0 && !ki(o[e], t) || t === void 0 && !(e in o)) && qs(o, e, t);
      }, X_ = /* @__PURE__ */ function(o) {
        return function(e, t, n) {
          for (var i = -1, r = Object(e), s = n(e), a = s.length; a--; ) {
            var l = s[o ? a : ++i];
            if (t(r[l], l, r) === !1)
              break;
          }
          return e;
        };
      }(), eA = function(o) {
        return jt(o) && Ar(o);
      }, Ba = function(o, e) {
        if ((e !== "constructor" || typeof o[e] != "function") && e != "__proto__")
          return o[e];
      }, tA = function(o) {
        return To(o, Po(o));
      }, nA = function(o, e, t, n, i, r, s) {
        var a = Ba(o, t), l = Ba(e, t), d = s.get(l);
        if (d)
          Da(o, t, d);
        else {
          var h = r ? r(a, l, t + "", o, e, s) : void 0, m = h === void 0;
          if (m) {
            var f = At(l), _ = !f && Ai(l), S = !f && !_ && Js(l);
            h = l, f || _ || S ? At(a) ? h = a : eA(a) ? h = Xs(a) : _ ? (m = !1, h = wd(l, !0)) : S ? (m = !1, h = Pd(l, !0)) : h = [] : xt(l) || Gs(l) ? (h = a, Gs(a) ? h = tA(a) : K(a) && !Wn(a) || (h = Rd(l))) : m = !1;
          }
          m && (s.set(l, h), i(h, l, n, r, s), s.delete(l)), Da(o, t, h);
        }
      }, Zu = function o(e, t, n, i, r) {
        e !== t && X_(t, function(s, a) {
          if (r || (r = new _i()), K(s))
            nA(e, t, a, n, o, i, r);
          else {
            var l = i ? i(Ba(e, a), s, a + "", e, t, r) : void 0;
            l === void 0 && (l = s), Da(e, a, l);
          }
        }, Po);
      }, eo = function(o) {
        return o;
      }, oA = function(o, e, t) {
        switch (t.length) {
          case 0:
            return o.call(e);
          case 1:
            return o.call(e, t[0]);
          case 2:
            return o.call(e, t[0], t[1]);
          case 3:
            return o.call(e, t[0], t[1], t[2]);
        }
        return o.apply(e, t);
      };
      var Ju = Math.max;
      const iA = function(o, e, t) {
        return e = Ju(e === void 0 ? o.length - 1 : e, 0), function() {
          for (var n = arguments, i = -1, r = Ju(n.length - e, 0), s = Array(r); ++i < r; )
            s[i] = n[e + i];
          i = -1;
          for (var a = Array(e + 1); ++i < e; )
            a[i] = n[i];
          return a[e] = t(s), oA(o, this, a);
        };
      }, rA = function(o) {
        return function() {
          return o;
        };
      }, sA = vr ? function(o, e) {
        return vr(o, "toString", { configurable: !0, enumerable: !1, value: rA(e), writable: !0 });
      } : eo;
      var aA = Date.now;
      const lA = function(o) {
        var e = 0, t = 0;
        return function() {
          var n = aA(), i = 16 - (n - t);
          if (t = n, i > 0) {
            if (++e >= 800)
              return arguments[0];
          } else
            e = 0;
          return o.apply(void 0, arguments);
        };
      }(sA), Yu = function(o, e) {
        return lA(iA(o, e, eo), o + "");
      }, cA = function(o, e, t) {
        if (!K(t))
          return !1;
        var n = typeof e;
        return !!(n == "number" ? Ar(t) && Ks(e, t.length) : n == "string" && e in t) && ki(t[e], o);
      }, Ta = function(o) {
        return Yu(function(e, t) {
          var n = -1, i = t.length, r = i > 1 ? t[i - 1] : void 0, s = i > 2 ? t[2] : void 0;
          for (r = o.length > 3 && typeof r == "function" ? (i--, r) : void 0, s && cA(t[0], t[1], s) && (r = i < 3 ? void 0 : r, i = 1), e = Object(e); ++n < i; ) {
            var a = t[n];
            a && o(e, a, n, r);
          }
          return e;
        });
      }, Qu = Ta(function(o, e, t) {
        Zu(o, e, t);
      }), dA = function(o, e, t, n) {
        if (!K(o))
          return o;
        for (var i = -1, r = (e = xa(e, o)).length, s = r - 1, a = o; a != null && ++i < r; ) {
          var l = Sa(e[i]), d = t;
          if (l === "__proto__" || l === "constructor" || l === "prototype")
            return o;
          if (i != s) {
            var h = a[l];
            (d = n ? n(h, l, a) : void 0) === void 0 && (d = K(h) ? h : Ks(e[i + 1]) ? [] : {});
          }
          Ws(a, l, d), a = a[l];
        }
        return o;
      }, uA = function(o, e, t) {
        return o == null ? o : dA(o, e, t);
      };
      class hA {
        constructor(e) {
          this._styles = {}, this._styleProcessor = e;
        }
        get isEmpty() {
          const e = Object.entries(this._styles);
          return !Array.from(e).length;
        }
        get size() {
          return this.isEmpty ? 0 : this.getStyleNames().length;
        }
        setTo(e) {
          this.clear();
          const t = Array.from(function(n) {
            let i = null, r = 0, s = 0, a = null;
            const l = /* @__PURE__ */ new Map();
            if (n === "")
              return l;
            n.charAt(n.length - 1) != ";" && (n += ";");
            for (let d = 0; d < n.length; d++) {
              const h = n.charAt(d);
              if (i === null)
                switch (h) {
                  case ":":
                    a || (a = n.substr(r, d - r), s = d + 1);
                    break;
                  case '"':
                  case "'":
                    i = h;
                    break;
                  case ";": {
                    const m = n.substr(s, d - s);
                    a && l.set(a.trim(), m.trim()), a = null, r = d + 1;
                    break;
                  }
                }
              else
                h === i && (i = null);
            }
            return l;
          }(e).entries());
          for (const [n, i] of t)
            this._styleProcessor.toNormalizedForm(n, i, this._styles);
        }
        has(e) {
          if (this.isEmpty)
            return !1;
          const t = this._styleProcessor.getReducedForm(e, this._styles).find(([n]) => n === e);
          return Array.isArray(t);
        }
        set(e, t) {
          if (K(e))
            for (const [n, i] of Object.entries(e))
              this._styleProcessor.toNormalizedForm(n, i, this._styles);
          else
            this._styleProcessor.toNormalizedForm(e, t, this._styles);
        }
        remove(e) {
          const t = Ia(e);
          Q_(this._styles, t), delete this._styles[e], this._cleanEmptyObjectsOnPath(t);
        }
        getNormalized(e) {
          return this._styleProcessor.getNormalized(e, this._styles);
        }
        toString() {
          return this.isEmpty ? "" : this._getStylesEntries().map((e) => e.join(":")).sort().join(";") + ";";
        }
        getAsString(e) {
          if (this.isEmpty)
            return;
          if (this._styles[e] && !K(this._styles[e]))
            return this._styles[e];
          const t = this._styleProcessor.getReducedForm(e, this._styles).find(([n]) => n === e);
          return Array.isArray(t) ? t[1] : void 0;
        }
        getStyleNames(e = !1) {
          return this.isEmpty ? [] : e ? this._styleProcessor.getStyleNames(this._styles) : this._getStylesEntries().map(([t]) => t);
        }
        clear() {
          this._styles = {};
        }
        _getStylesEntries() {
          const e = [], t = Object.keys(this._styles);
          for (const n of t)
            e.push(...this._styleProcessor.getReducedForm(n, this._styles));
          return e;
        }
        _cleanEmptyObjectsOnPath(e) {
          const t = e.split(".");
          if (!(t.length > 1))
            return;
          const n = t.splice(0, t.length - 1).join("."), i = Mr(this._styles, n);
          i && !Array.from(Object.keys(i)).length && this.remove(n);
        }
      }
      class gA {
        constructor() {
          this._normalizers = /* @__PURE__ */ new Map(), this._extractors = /* @__PURE__ */ new Map(), this._reducers = /* @__PURE__ */ new Map(), this._consumables = /* @__PURE__ */ new Map();
        }
        toNormalizedForm(e, t, n) {
          if (K(t))
            Pa(n, Ia(e), t);
          else if (this._normalizers.has(e)) {
            const i = this._normalizers.get(e), { path: r, value: s } = i(t);
            Pa(n, r, s);
          } else
            Pa(n, e, t);
        }
        getNormalized(e, t) {
          if (!e)
            return Qu({}, t);
          if (t[e] !== void 0)
            return t[e];
          if (this._extractors.has(e)) {
            const n = this._extractors.get(e);
            if (typeof n == "string")
              return Mr(t, n);
            const i = n(e, t);
            if (i)
              return i;
          }
          return Mr(t, Ia(e));
        }
        getReducedForm(e, t) {
          const n = this.getNormalized(e, t);
          return n === void 0 ? [] : this._reducers.has(e) ? this._reducers.get(e)(n) : [[e, n]];
        }
        getStyleNames(e) {
          const t = Array.from(this._consumables.keys()).filter((i) => {
            const r = this.getNormalized(i, e);
            return r && typeof r == "object" ? Object.keys(r).length : r;
          }), n = /* @__PURE__ */ new Set([...t, ...Object.keys(e)]);
          return Array.from(n.values());
        }
        getRelatedStyles(e) {
          return this._consumables.get(e) || [];
        }
        setNormalizer(e, t) {
          this._normalizers.set(e, t);
        }
        setExtractor(e, t) {
          this._extractors.set(e, t);
        }
        setReducer(e, t) {
          this._reducers.set(e, t);
        }
        setStyleRelation(e, t) {
          this._mapStyleNames(e, t);
          for (const n of t)
            this._mapStyleNames(n, [e]);
        }
        _mapStyleNames(e, t) {
          this._consumables.has(e) || this._consumables.set(e, []), this._consumables.get(e).push(...t);
        }
      }
      function Ia(o) {
        return o.replace("-", ".");
      }
      function Pa(o, e, t) {
        let n = t;
        K(t) && (n = Qu({}, Mr(o, e), t)), uA(o, e, n);
      }
      class Mt extends Xn {
        constructor(e, t, n, i) {
          if (super(e), this._unsafeAttributesToRender = [], this._customProperties = /* @__PURE__ */ new Map(), this.name = t, this._attrs = function(r) {
            const s = pn(r);
            for (const [a, l] of s)
              l === null ? s.delete(a) : typeof l != "string" && s.set(a, String(l));
            return s;
          }(n), this._children = [], i && this._insertChild(0, i), this._classes = /* @__PURE__ */ new Set(), this._attrs.has("class")) {
            const r = this._attrs.get("class");
            Xu(this._classes, r), this._attrs.delete("class");
          }
          this._styles = new hA(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style"));
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this._children.length === 0;
        }
        getChild(e) {
          return this._children[e];
        }
        getChildIndex(e) {
          return this._children.indexOf(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        *getAttributeKeys() {
          this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys();
        }
        *getAttributes() {
          yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
        }
        getAttribute(e) {
          if (e == "class")
            return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
          if (e == "style") {
            const t = this._styles.toString();
            return t == "" ? void 0 : t;
          }
          return this._attrs.get(e);
        }
        hasAttribute(e) {
          return e == "class" ? this._classes.size > 0 : e == "style" ? !this._styles.isEmpty : this._attrs.has(e);
        }
        isSimilar(e) {
          if (!(e instanceof Mt))
            return !1;
          if (this === e)
            return !0;
          if (this.name != e.name || this._attrs.size !== e._attrs.size || this._classes.size !== e._classes.size || this._styles.size !== e._styles.size)
            return !1;
          for (const [t, n] of this._attrs)
            if (!e._attrs.has(t) || e._attrs.get(t) !== n)
              return !1;
          for (const t of this._classes)
            if (!e._classes.has(t))
              return !1;
          for (const t of this._styles.getStyleNames())
            if (!e._styles.has(t) || e._styles.getAsString(t) !== this._styles.getAsString(t))
              return !1;
          return !0;
        }
        hasClass(...e) {
          for (const t of e)
            if (!this._classes.has(t))
              return !1;
          return !0;
        }
        getClassNames() {
          return this._classes.keys();
        }
        getStyle(e) {
          return this._styles.getAsString(e);
        }
        getNormalizedStyle(e) {
          return this._styles.getNormalized(e);
        }
        getStyleNames(e) {
          return this._styles.getStyleNames(e);
        }
        hasStyle(...e) {
          for (const t of e)
            if (!this._styles.has(t))
              return !1;
          return !0;
        }
        findAncestor(...e) {
          const t = new No(...e);
          let n = this.parent;
          for (; n && !n.is("documentFragment"); ) {
            if (t.match(n))
              return n;
            n = n.parent;
          }
          return null;
        }
        getCustomProperty(e) {
          return this._customProperties.get(e);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        getIdentity() {
          const e = Array.from(this._classes).sort().join(","), t = this._styles.toString(), n = Array.from(this._attrs).map((i) => `${i[0]}="${i[1]}"`).sort().join(" ");
          return this.name + (e == "" ? "" : ` class="${e}"`) + (t ? ` style="${t}"` : "") + (n == "" ? "" : ` ${n}`);
        }
        shouldRenderUnsafeAttribute(e) {
          return this._unsafeAttributesToRender.includes(e);
        }
        _clone(e = !1) {
          const t = [];
          if (e)
            for (const i of this.getChildren())
              t.push(i._clone(e));
          const n = new this.constructor(this.document, this.name, this._attrs, t);
          return n._classes = new Set(this._classes), n._styles.set(this._styles.getNormalized()), n._customProperties = new Map(this._customProperties), n.getFillerOffset = this.getFillerOffset, n._unsafeAttributesToRender = this._unsafeAttributesToRender, n;
        }
        _appendChild(e) {
          return this._insertChild(this.childCount, e);
        }
        _insertChild(e, t) {
          this._fireChange("children", this);
          let n = 0;
          const i = function(r, s) {
            return typeof s == "string" ? [new Me(r, s)] : (zt(s) || (s = [s]), Array.from(s).map((a) => typeof a == "string" ? new Me(r, a) : a instanceof sn ? new Me(r, a.data) : a));
          }(this.document, t);
          for (const r of i)
            r.parent !== null && r._remove(), r.parent = this, r.document = this.document, this._children.splice(e, 0, r), e++, n++;
          return n;
        }
        _removeChildren(e, t = 1) {
          this._fireChange("children", this);
          for (let n = e; n < e + t; n++)
            this._children[n].parent = null;
          return this._children.splice(e, t);
        }
        _setAttribute(e, t) {
          const n = String(t);
          this._fireChange("attributes", this), e == "class" ? Xu(this._classes, n) : e == "style" ? this._styles.setTo(n) : this._attrs.set(e, n);
        }
        _removeAttribute(e) {
          return this._fireChange("attributes", this), e == "class" ? this._classes.size > 0 && (this._classes.clear(), !0) : e == "style" ? !this._styles.isEmpty && (this._styles.clear(), !0) : this._attrs.delete(e);
        }
        _addClass(e) {
          this._fireChange("attributes", this);
          for (const t of Xe(e))
            this._classes.add(t);
        }
        _removeClass(e) {
          this._fireChange("attributes", this);
          for (const t of Xe(e))
            this._classes.delete(t);
        }
        _setStyle(e, t) {
          this._fireChange("attributes", this), typeof e != "string" ? this._styles.set(e) : this._styles.set(e, t);
        }
        _removeStyle(e) {
          this._fireChange("attributes", this);
          for (const t of Xe(e))
            this._styles.remove(t);
        }
        _setCustomProperty(e, t) {
          this._customProperties.set(e, t);
        }
        _removeCustomProperty(e) {
          return this._customProperties.delete(e);
        }
      }
      function Xu(o, e) {
        const t = e.split(/\s+/);
        o.clear(), t.forEach((n) => o.add(n));
      }
      Mt.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "element" || o === "view:element") : o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Di extends Mt {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = eh;
        }
      }
      function eh() {
        const o = [...this.getChildren()], e = o[this.childCount - 1];
        if (e && e.is("element", "br"))
          return this.childCount;
        for (const t of o)
          if (!t.is("uiElement"))
            return null;
        return this.childCount;
      }
      Di.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Nr extends re(Di) {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.set("isReadOnly", !1), this.set("isFocused", !1), this.bind("isReadOnly").to(e), this.bind("isFocused").to(e, "isFocused", (r) => r && e.selection.editableElement == this), this.listenTo(e.selection, "change", () => {
            this.isFocused = e.isFocused && e.selection.editableElement == this;
          });
        }
        destroy() {
          this.stopListening();
        }
      }
      Nr.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      const th = Symbol("rootName");
      class nh extends Nr {
        constructor(e, t) {
          super(e, t), this.rootName = "main";
        }
        get rootName() {
          return this.getCustomProperty(th);
        }
        set rootName(e) {
          this._setCustomProperty(th, e);
        }
        set _name(e) {
          this.name = e;
        }
      }
      nh.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "rootElement" || o === "view:rootElement" || o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "rootElement" || o === "view:rootElement" || o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class to {
        constructor(e = {}) {
          if (!e.boundaries && !e.startPosition)
            throw new O("view-tree-walker-no-start-position", null);
          if (e.direction && e.direction != "forward" && e.direction != "backward")
            throw new O("view-tree-walker-unknown-direction", e.startPosition, { direction: e.direction });
          this.boundaries = e.boundaries || null, e.startPosition ? this._position = J._createAt(e.startPosition) : this._position = J._createAt(e.boundaries[e.direction == "backward" ? "end" : "start"]), this.direction = e.direction || "forward", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(e) {
          let t, n;
          do
            n = this.position, t = this.next();
          while (!t.done && e(t.value));
          t.done || (this._position = n);
        }
        next() {
          return this.direction == "forward" ? this._next() : this._previous();
        }
        _next() {
          let e = this.position.clone();
          const t = this.position, n = e.parent;
          if (n.parent === null && e.offset === n.childCount)
            return { done: !0, value: void 0 };
          if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset)
            return { done: !0, value: void 0 };
          let i;
          if (n instanceof Me) {
            if (e.isAtEnd)
              return this._position = J._createAfter(n), this._next();
            i = n.data[e.offset];
          } else
            i = n.getChild(e.offset);
          if (i instanceof Mt)
            return this.shallow ? e.offset++ : e = new J(i, 0), this._position = e, this._formatReturnValue("elementStart", i, t, e, 1);
          if (i instanceof Me) {
            if (this.singleCharacters)
              return e = new J(i, 0), this._position = e, this._next();
            {
              let r, s = i.data.length;
              return i == this._boundaryEndParent ? (s = this.boundaries.end.offset, r = new sn(i, 0, s), e = J._createAfter(r)) : (r = new sn(i, 0, i.data.length), e.offset++), this._position = e, this._formatReturnValue("text", r, t, e, s);
            }
          }
          if (typeof i == "string") {
            let r;
            this.singleCharacters ? r = 1 : r = (n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length) - e.offset;
            const s = new sn(n, e.offset, r);
            return e.offset += r, this._position = e, this._formatReturnValue("text", s, t, e, r);
          }
          return e = J._createAfter(n), this._position = e, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n, t, e);
        }
        _previous() {
          let e = this.position.clone();
          const t = this.position, n = e.parent;
          if (n.parent === null && e.offset === 0)
            return { done: !0, value: void 0 };
          if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset)
            return { done: !0, value: void 0 };
          let i;
          if (n instanceof Me) {
            if (e.isAtStart)
              return this._position = J._createBefore(n), this._previous();
            i = n.data[e.offset - 1];
          } else
            i = n.getChild(e.offset - 1);
          if (i instanceof Mt)
            return this.shallow ? (e.offset--, this._position = e, this._formatReturnValue("elementStart", i, t, e, 1)) : (e = new J(i, i.childCount), this._position = e, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", i, t, e));
          if (i instanceof Me) {
            if (this.singleCharacters)
              return e = new J(i, i.data.length), this._position = e, this._previous();
            {
              let r, s = i.data.length;
              if (i == this._boundaryStartParent) {
                const a = this.boundaries.start.offset;
                r = new sn(i, a, i.data.length - a), s = r.data.length, e = J._createBefore(r);
              } else
                r = new sn(i, 0, i.data.length), e.offset--;
              return this._position = e, this._formatReturnValue("text", r, t, e, s);
            }
          }
          if (typeof i == "string") {
            let r;
            if (this.singleCharacters)
              r = 1;
            else {
              const a = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
              r = e.offset - a;
            }
            e.offset -= r;
            const s = new sn(n, e.offset, r);
            return this._position = e, this._formatReturnValue("text", s, t, e, r);
          }
          return e = J._createBefore(n), this._position = e, this._formatReturnValue("elementStart", n, t, e, 1);
        }
        _formatReturnValue(e, t, n, i, r) {
          return t instanceof sn && (t.offsetInText + t.data.length == t.textNode.data.length && (this.direction != "forward" || this.boundaries && this.boundaries.end.isEqual(this.position) ? n = J._createAfter(t.textNode) : (i = J._createAfter(t.textNode), this._position = i)), t.offsetInText === 0 && (this.direction != "backward" || this.boundaries && this.boundaries.start.isEqual(this.position) ? n = J._createBefore(t.textNode) : (i = J._createBefore(t.textNode), this._position = i))), { done: !1, value: { type: e, item: t, previousPosition: n, nextPosition: i, length: r } };
        }
      }
      class J extends Qn {
        constructor(e, t) {
          super(), this.parent = e, this.offset = t;
        }
        get nodeAfter() {
          return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null;
        }
        get nodeBefore() {
          return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null;
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          const e = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
          return this.offset === e;
        }
        get root() {
          return this.parent.root;
        }
        get editableElement() {
          let e = this.parent;
          for (; !(e instanceof Nr); ) {
            if (!e.parent)
              return null;
            e = e.parent;
          }
          return e;
        }
        getShiftedBy(e) {
          const t = J._createAt(this), n = t.offset + e;
          return t.offset = n < 0 ? 0 : n, t;
        }
        getLastMatchingPosition(e, t = {}) {
          t.startPosition = this;
          const n = new to(t);
          return n.skip(e), n.position;
        }
        getAncestors() {
          return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: !0 });
        }
        getCommonAncestor(e) {
          const t = this.getAncestors(), n = e.getAncestors();
          let i = 0;
          for (; t[i] == n[i] && t[i]; )
            i++;
          return i === 0 ? null : t[i - 1];
        }
        isEqual(e) {
          return this.parent == e.parent && this.offset == e.offset;
        }
        isBefore(e) {
          return this.compareWith(e) == "before";
        }
        isAfter(e) {
          return this.compareWith(e) == "after";
        }
        compareWith(e) {
          if (this.root !== e.root)
            return "different";
          if (this.isEqual(e))
            return "same";
          const t = this.parent.is("node") ? this.parent.getPath() : [], n = e.parent.is("node") ? e.parent.getPath() : [];
          t.push(this.offset), n.push(e.offset);
          const i = _t(t, n);
          switch (i) {
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return t[i] < n[i] ? "before" : "after";
          }
        }
        getWalker(e = {}) {
          return e.startPosition = this, new to(e);
        }
        clone() {
          return new J(this.parent, this.offset);
        }
        static _createAt(e, t) {
          if (e instanceof J)
            return new this(e.parent, e.offset);
          {
            const n = e;
            if (t == "end")
              t = n.is("$text") ? n.data.length : n.childCount;
            else {
              if (t == "before")
                return this._createBefore(n);
              if (t == "after")
                return this._createAfter(n);
              if (t !== 0 && !t)
                throw new O("view-createpositionat-offset-required", n);
            }
            return new J(n, t);
          }
        }
        static _createAfter(e) {
          if (e.is("$textProxy"))
            return new J(e.textNode, e.offsetInText + e.data.length);
          if (!e.parent)
            throw new O("view-position-after-root", e, { root: e });
          return new J(e.parent, e.index + 1);
        }
        static _createBefore(e) {
          if (e.is("$textProxy"))
            return new J(e.textNode, e.offsetInText);
          if (!e.parent)
            throw new O("view-position-before-root", e, { root: e });
          return new J(e.parent, e.index);
        }
      }
      J.prototype.is = function(o) {
        return o === "position" || o === "view:position";
      };
      class ae extends Qn {
        constructor(e, t = null) {
          super(), this.start = e.clone(), this.end = t ? t.clone() : e.clone();
        }
        *[Symbol.iterator]() {
          yield* new to({ boundaries: this, ignoreElementEnd: !0 });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return this.start.parent === this.end.parent;
        }
        get root() {
          return this.start.root;
        }
        getEnlarged() {
          let e = this.start.getLastMatchingPosition(Fr, { direction: "backward" }), t = this.end.getLastMatchingPosition(Fr);
          return e.parent.is("$text") && e.isAtStart && (e = J._createBefore(e.parent)), t.parent.is("$text") && t.isAtEnd && (t = J._createAfter(t.parent)), new ae(e, t);
        }
        getTrimmed() {
          let e = this.start.getLastMatchingPosition(Fr);
          if (e.isAfter(this.end) || e.isEqual(this.end))
            return new ae(e, e);
          let t = this.end.getLastMatchingPosition(Fr, { direction: "backward" });
          const n = e.nodeAfter, i = t.nodeBefore;
          return n && n.is("$text") && (e = new J(n, 0)), i && i.is("$text") && (t = new J(i, i.data.length)), new ae(e, t);
        }
        isEqual(e) {
          return this == e || this.start.isEqual(e.start) && this.end.isEqual(e.end);
        }
        containsPosition(e) {
          return e.isAfter(this.start) && e.isBefore(this.end);
        }
        containsRange(e, t = !1) {
          e.isCollapsed && (t = !1);
          const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start), i = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
          return n && i;
        }
        getDifference(e) {
          const t = [];
          return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new ae(this.start, e.start)), this.containsPosition(e.end) && t.push(new ae(e.end, this.end))) : t.push(this.clone()), t;
        }
        getIntersection(e) {
          if (this.isIntersecting(e)) {
            let t = this.start, n = this.end;
            return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new ae(t, n);
          }
          return null;
        }
        getWalker(e = {}) {
          return e.boundaries = this, new to(e);
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed)
            return null;
          let e = this.start.nodeAfter, t = this.end.nodeBefore;
          return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (e = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (t = this.end.parent.previousSibling), e && e.is("element") && e === t ? e : null;
        }
        clone() {
          return new ae(this.start, this.end);
        }
        *getItems(e = {}) {
          e.boundaries = this, e.ignoreElementEnd = !0;
          const t = new to(e);
          for (const n of t)
            yield n.item;
        }
        *getPositions(e = {}) {
          e.boundaries = this;
          const t = new to(e);
          yield t.position;
          for (const n of t)
            yield n.nextPosition;
        }
        isIntersecting(e) {
          return this.start.isBefore(e.end) && this.end.isAfter(e.start);
        }
        static _createFromParentsAndOffsets(e, t, n, i) {
          return new this(new J(e, t), new J(n, i));
        }
        static _createFromPositionAndShift(e, t) {
          const n = e, i = e.getShiftedBy(t);
          return t > 0 ? new this(n, i) : new this(i, n);
        }
        static _createIn(e) {
          return this._createFromParentsAndOffsets(e, 0, e, e.childCount);
        }
        static _createOn(e) {
          const t = e.is("$textProxy") ? e.offsetSize : 1;
          return this._createFromPositionAndShift(J._createBefore(e), t);
        }
      }
      function Fr(o) {
        return !(!o.item.is("attributeElement") && !o.item.is("uiElement"));
      }
      ae.prototype.is = function(o) {
        return o === "range" || o === "view:range";
      };
      class an extends Se(Qn) {
        constructor(...e) {
          super(), this._ranges = [], this._lastRangeBackward = !1, this._isFake = !1, this._fakeSelectionLabel = "", e.length && this.setTo(...e);
        }
        get isFake() {
          return this._isFake;
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel;
        }
        get anchor() {
          if (!this._ranges.length)
            return null;
          const e = this._ranges[this._ranges.length - 1];
          return (this._lastRangeBackward ? e.end : e.start).clone();
        }
        get focus() {
          if (!this._ranges.length)
            return null;
          const e = this._ranges[this._ranges.length - 1];
          return (this._lastRangeBackward ? e.start : e.end).clone();
        }
        get isCollapsed() {
          return this.rangeCount === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        get editableElement() {
          return this.anchor ? this.anchor.editableElement : null;
        }
        *getRanges() {
          for (const e of this._ranges)
            yield e.clone();
        }
        getFirstRange() {
          let e = null;
          for (const t of this._ranges)
            e && !t.start.isBefore(e.start) || (e = t);
          return e ? e.clone() : null;
        }
        getLastRange() {
          let e = null;
          for (const t of this._ranges)
            e && !t.end.isAfter(e.end) || (e = t);
          return e ? e.clone() : null;
        }
        getFirstPosition() {
          const e = this.getFirstRange();
          return e ? e.start.clone() : null;
        }
        getLastPosition() {
          const e = this.getLastRange();
          return e ? e.end.clone() : null;
        }
        isEqual(e) {
          if (this.isFake != e.isFake || this.isFake && this.fakeSelectionLabel != e.fakeSelectionLabel || this.rangeCount != e.rangeCount)
            return !1;
          if (this.rangeCount === 0)
            return !0;
          if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
            return !1;
          for (const t of this._ranges) {
            let n = !1;
            for (const i of e._ranges)
              if (t.isEqual(i)) {
                n = !0;
                break;
              }
            if (!n)
              return !1;
          }
          return !0;
        }
        isSimilar(e) {
          if (this.isBackward != e.isBackward)
            return !1;
          const t = Ls(this.getRanges());
          if (t != Ls(e.getRanges()))
            return !1;
          if (t == 0)
            return !0;
          for (let n of this.getRanges()) {
            n = n.getTrimmed();
            let i = !1;
            for (let r of e.getRanges())
              if (r = r.getTrimmed(), n.start.isEqual(r.start) && n.end.isEqual(r.end)) {
                i = !0;
                break;
              }
            if (!i)
              return !1;
          }
          return !0;
        }
        getSelectedElement() {
          return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
        }
        setTo(...e) {
          let [t, n, i] = e;
          if (typeof n == "object" && (i = n, n = void 0), t === null)
            this._setRanges([]), this._setFakeOptions(i);
          else if (t instanceof an || t instanceof Oa)
            this._setRanges(t.getRanges(), t.isBackward), this._setFakeOptions({ fake: t.isFake, label: t.fakeSelectionLabel });
          else if (t instanceof ae)
            this._setRanges([t], i && i.backward), this._setFakeOptions(i);
          else if (t instanceof J)
            this._setRanges([new ae(t)]), this._setFakeOptions(i);
          else if (t instanceof Xn) {
            const r = !!i && !!i.backward;
            let s;
            if (n === void 0)
              throw new O("view-selection-setto-required-second-parameter", this);
            s = n == "in" ? ae._createIn(t) : n == "on" ? ae._createOn(t) : new ae(J._createAt(t, n)), this._setRanges([s], r), this._setFakeOptions(i);
          } else {
            if (!zt(t))
              throw new O("view-selection-setto-not-selectable", this);
            this._setRanges(t, i && i.backward), this._setFakeOptions(i);
          }
          this.fire("change");
        }
        setFocus(e, t) {
          if (this.anchor === null)
            throw new O("view-selection-setfocus-no-ranges", this);
          const n = J._createAt(e, t);
          if (n.compareWith(this.focus) == "same")
            return;
          const i = this.anchor;
          this._ranges.pop(), n.compareWith(i) == "before" ? this._addRange(new ae(n, i), !0) : this._addRange(new ae(i, n)), this.fire("change");
        }
        _setRanges(e, t = !1) {
          e = Array.from(e), this._ranges = [];
          for (const n of e)
            this._addRange(n);
          this._lastRangeBackward = !!t;
        }
        _setFakeOptions(e = {}) {
          this._isFake = !!e.fake, this._fakeSelectionLabel = e.fake && e.label || "";
        }
        _addRange(e, t = !1) {
          if (!(e instanceof ae))
            throw new O("view-selection-add-range-not-range", this);
          this._pushRange(e), this._lastRangeBackward = !!t;
        }
        _pushRange(e) {
          for (const t of this._ranges)
            if (e.isIntersecting(t))
              throw new O("view-selection-range-intersects", this, { addedRange: e, intersectingRange: t });
          this._ranges.push(new ae(e.start, e.end));
        }
      }
      an.prototype.is = function(o) {
        return o === "selection" || o === "view:selection";
      };
      class Oa extends Se(Qn) {
        constructor(...e) {
          super(), this._selection = new an(), this._selection.delegate("change").to(this), e.length && this._selection.setTo(...e);
        }
        get isFake() {
          return this._selection.isFake;
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get editableElement() {
          return this._selection.editableElement;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        *getRanges() {
          yield* this._selection.getRanges();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        isEqual(e) {
          return this._selection.isEqual(e);
        }
        isSimilar(e) {
          return this._selection.isSimilar(e);
        }
        _setTo(...e) {
          this._selection.setTo(...e);
        }
        _setFocus(e, t) {
          this._selection.setFocus(e, t);
        }
      }
      Oa.prototype.is = function(o) {
        return o === "selection" || o == "documentSelection" || o == "view:selection" || o == "view:documentSelection";
      };
      class Fo extends j {
        constructor(e, t, n) {
          super(e, t), this.startRange = n, this._eventPhase = "none", this._currentTarget = null;
        }
        get eventPhase() {
          return this._eventPhase;
        }
        get currentTarget() {
          return this._currentTarget;
        }
      }
      const Ra = Symbol("bubbling contexts");
      function za(o) {
        return class extends o {
          fire(e, ...t) {
            try {
              const n = e instanceof j ? e : new j(this, e), i = Ma(this);
              if (!i.size)
                return;
              if (Bi(n, "capturing", this), $o(i, "$capture", n, ...t))
                return n.return;
              const r = n.startRange || this.selection.getFirstRange(), s = r ? r.getContainedElement() : null, a = !!s && !!oh(i, s);
              let l = s || function(d) {
                if (!d)
                  return null;
                const h = d.start.parent, m = d.end.parent, f = h.getPath(), _ = m.getPath();
                return f.length > _.length ? h : m;
              }(r);
              if (Bi(n, "atTarget", l), !a) {
                if ($o(i, "$text", n, ...t))
                  return n.return;
                Bi(n, "bubbling", l);
              }
              for (; l; ) {
                if (l.is("rootElement")) {
                  if ($o(i, "$root", n, ...t))
                    return n.return;
                } else if (l.is("element") && $o(i, l.name, n, ...t))
                  return n.return;
                if ($o(i, l, n, ...t))
                  return n.return;
                l = l.parent, Bi(n, "bubbling", l);
              }
              return Bi(n, "bubbling", this), $o(i, "$document", n, ...t), n.return;
            } catch (n) {
              O.rethrowUnexpectedError(n, this);
            }
          }
          _addEventListener(e, t, n) {
            const i = Xe(n.context || "$document"), r = Ma(this);
            for (const s of i) {
              let a = r.get(s);
              a || (a = new (Se())(), r.set(s, a)), this.listenTo(a, e, t, n);
            }
          }
          _removeEventListener(e, t) {
            const n = Ma(this);
            for (const i of n.values())
              this.stopListening(i, e, t);
          }
        };
      }
      {
        const o = za(Object);
        ["fire", "_addEventListener", "_removeEventListener"].forEach((e) => {
          za[e] = o.prototype[e];
        });
      }
      function Bi(o, e, t) {
        o instanceof Fo && (o._eventPhase = e, o._currentTarget = t);
      }
      function $o(o, e, t, ...n) {
        const i = typeof e == "string" ? o.get(e) : oh(o, e);
        return !!i && (i.fire(t, ...n), t.stop.called);
      }
      function oh(o, e) {
        for (const [t, n] of o)
          if (typeof t == "function" && t(e))
            return n;
        return null;
      }
      function Ma(o) {
        return o[Ra] || (o[Ra] = /* @__PURE__ */ new Map()), o[Ra];
      }
      class ih extends za(re()) {
        constructor(e) {
          super(), this._postFixers = /* @__PURE__ */ new Set(), this.selection = new Oa(), this.roots = new Ht({ idProperty: "rootName" }), this.stylesProcessor = e, this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1);
        }
        getRoot(e = "main") {
          return this.roots.get(e);
        }
        registerPostFixer(e) {
          this._postFixers.add(e);
        }
        destroy() {
          this.roots.map((e) => e.destroy()), this.stopListening();
        }
        _callPostFixers(e) {
          let t = !1;
          do
            for (const n of this._postFixers)
              if (t = n(e), t)
                break;
          while (t);
        }
      }
      class no extends Mt {
        constructor(e, t, n, i) {
          super(e, t, n, i), this._priority = 10, this._id = null, this._clonesGroup = null, this.getFillerOffset = mA;
        }
        get priority() {
          return this._priority;
        }
        get id() {
          return this._id;
        }
        getElementsWithSameId() {
          if (this.id === null)
            throw new O("attribute-element-get-elements-with-same-id-no-id", this);
          return new Set(this._clonesGroup);
        }
        isSimilar(e) {
          return this.id !== null || e.id !== null ? this.id === e.id : super.isSimilar(e) && this.priority == e.priority;
        }
        _clone(e = !1) {
          const t = super._clone(e);
          return t._priority = this._priority, t._id = this._id, t;
        }
      }
      function mA() {
        if (Na(this))
          return null;
        let o = this.parent;
        for (; o && o.is("attributeElement"); ) {
          if (Na(o) > 1)
            return null;
          o = o.parent;
        }
        return !o || Na(o) > 1 ? null : this.childCount;
      }
      function Na(o) {
        return Array.from(o.getChildren()).filter((e) => !e.is("uiElement")).length;
      }
      no.DEFAULT_PRIORITY = 10, no.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "attributeElement" || o === "view:attributeElement" || o === "element" || o === "view:element") : o === "attributeElement" || o === "view:attributeElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Fa extends Mt {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = pA;
        }
        _insertChild(e, t) {
          if (t && (t instanceof Xn || Array.from(t).length > 0))
            throw new O("view-emptyelement-cannot-add", [this, t]);
          return 0;
        }
      }
      function pA() {
        return null;
      }
      Fa.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "emptyElement" || o === "view:emptyElement" || o === "element" || o === "view:element") : o === "emptyElement" || o === "view:emptyElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class $r extends Mt {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = bA;
        }
        _insertChild(e, t) {
          if (t && (t instanceof Xn || Array.from(t).length > 0))
            throw new O("view-uielement-cannot-add", [this, t]);
          return 0;
        }
        render(e, t) {
          return this.toDomElement(e);
        }
        toDomElement(e) {
          const t = e.createElement(this.name);
          for (const n of this.getAttributeKeys())
            t.setAttribute(n, this.getAttribute(n));
          return t;
        }
      }
      function fA(o) {
        o.document.on("arrowKey", (e, t) => function(n, i, r) {
          if (i.keyCode == Ce.arrowright) {
            const s = i.domTarget.ownerDocument.defaultView.getSelection(), a = s.rangeCount == 1 && s.getRangeAt(0).collapsed;
            if (a || i.shiftKey) {
              const l = s.focusNode, d = s.focusOffset, h = r.domPositionToView(l, d);
              if (h === null)
                return;
              let m = !1;
              const f = h.getLastMatchingPosition((_) => (_.item.is("uiElement") && (m = !0), !(!_.item.is("uiElement") && !_.item.is("attributeElement"))));
              if (m) {
                const _ = r.viewPositionToDom(f);
                a ? s.collapse(_.parent, _.offset) : s.extend(_.parent, _.offset);
              }
            }
          }
        }(0, t, o.domConverter), { priority: "low" });
      }
      function bA() {
        return null;
      }
      $r.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "uiElement" || o === "view:uiElement" || o === "element" || o === "view:element") : o === "uiElement" || o === "view:uiElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class $a extends Mt {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = kA;
        }
        _insertChild(e, t) {
          if (t && (t instanceof Xn || Array.from(t).length > 0))
            throw new O("view-rawelement-cannot-add", [this, t]);
          return 0;
        }
        render(e, t) {
        }
      }
      function kA() {
        return null;
      }
      $a.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "rawElement" || o === "view:rawElement" || o === "element" || o === "view:element") : o === "rawElement" || o === "view:rawElement" || o === this.name || o === "view:" + this.name || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class oo extends Se(Qn) {
        constructor(e, t) {
          super(), this._children = [], this._customProperties = /* @__PURE__ */ new Map(), this.document = e, t && this._insertChild(0, t);
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]();
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get name() {
        }
        getCustomProperty(e) {
          return this._customProperties.get(e);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        _appendChild(e) {
          return this._insertChild(this.childCount, e);
        }
        getChild(e) {
          return this._children[e];
        }
        getChildIndex(e) {
          return this._children.indexOf(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        _insertChild(e, t) {
          this._fireChange("children", this);
          let n = 0;
          const i = function(r, s) {
            return typeof s == "string" ? [new Me(r, s)] : (zt(s) || (s = [s]), Array.from(s).map((a) => typeof a == "string" ? new Me(r, a) : a instanceof sn ? new Me(r, a.data) : a));
          }(this.document, t);
          for (const r of i)
            r.parent !== null && r._remove(), r.parent = this, this._children.splice(e, 0, r), e++, n++;
          return n;
        }
        _removeChildren(e, t = 1) {
          this._fireChange("children", this);
          for (let n = e; n < e + t; n++)
            this._children[n].parent = null;
          return this._children.splice(e, t);
        }
        _fireChange(e, t) {
          this.fire("change:" + e, t);
        }
        _setCustomProperty(e, t) {
          this._customProperties.set(e, t);
        }
        _removeCustomProperty(e) {
          return this._customProperties.delete(e);
        }
      }
      oo.prototype.is = function(o) {
        return o === "documentFragment" || o === "view:documentFragment";
      };
      class rh {
        constructor(e) {
          this._cloneGroups = /* @__PURE__ */ new Map(), this._slotFactory = null, this.document = e;
        }
        setSelection(...e) {
          this.document.selection._setTo(...e);
        }
        setSelectionFocus(e, t) {
          this.document.selection._setFocus(e, t);
        }
        createDocumentFragment(e) {
          return new oo(this.document, e);
        }
        createText(e) {
          return new Me(this.document, e);
        }
        createAttributeElement(e, t, n = {}) {
          const i = new no(this.document, e, t);
          return typeof n.priority == "number" && (i._priority = n.priority), n.id && (i._id = n.id), n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i;
        }
        createContainerElement(e, t, n = {}, i = {}) {
          let r = null;
          xt(n) ? i = n : r = n;
          const s = new Di(this.document, e, t, r);
          return i.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), s;
        }
        createEditableElement(e, t, n = {}) {
          const i = new Nr(this.document, e, t);
          return n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i;
        }
        createEmptyElement(e, t, n = {}) {
          const i = new Fa(this.document, e, t);
          return n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i;
        }
        createUIElement(e, t, n) {
          const i = new $r(this.document, e, t);
          return n && (i.render = n), i;
        }
        createRawElement(e, t, n, i = {}) {
          const r = new $a(this.document, e, t);
          return n && (r.render = n), i.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), r;
        }
        setAttribute(e, t, n) {
          n._setAttribute(e, t);
        }
        removeAttribute(e, t) {
          t._removeAttribute(e);
        }
        addClass(e, t) {
          t._addClass(e);
        }
        removeClass(e, t) {
          t._removeClass(e);
        }
        setStyle(e, t, n) {
          xt(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t);
        }
        removeStyle(e, t) {
          t._removeStyle(e);
        }
        setCustomProperty(e, t, n) {
          n._setCustomProperty(e, t);
        }
        removeCustomProperty(e, t) {
          return t._removeCustomProperty(e);
        }
        breakAttributes(e) {
          return e instanceof J ? this._breakAttributes(e) : this._breakAttributesRange(e);
        }
        breakContainer(e) {
          const t = e.parent;
          if (!t.is("containerElement"))
            throw new O("view-writer-break-non-container-element", this.document);
          if (!t.parent)
            throw new O("view-writer-break-root", this.document);
          if (e.isAtStart)
            return J._createBefore(t);
          if (!e.isAtEnd) {
            const n = t._clone(!1);
            this.insert(J._createAfter(t), n);
            const i = new ae(e, J._createAt(t, "end")), r = new J(n, 0);
            this.move(i, r);
          }
          return J._createAfter(t);
        }
        mergeAttributes(e) {
          const t = e.offset, n = e.parent;
          if (n.is("$text"))
            return e;
          if (n.is("attributeElement") && n.childCount === 0) {
            const s = n.parent, a = n.index;
            return n._remove(), this._removeFromClonedElementsGroup(n), this.mergeAttributes(new J(s, a));
          }
          const i = n.getChild(t - 1), r = n.getChild(t);
          if (!i || !r)
            return e;
          if (i.is("$text") && r.is("$text"))
            return ah(i, r);
          if (i.is("attributeElement") && r.is("attributeElement") && i.isSimilar(r)) {
            const s = i.childCount;
            return i._appendChild(r.getChildren()), r._remove(), this._removeFromClonedElementsGroup(r), this.mergeAttributes(new J(i, s));
          }
          return e;
        }
        mergeContainers(e) {
          const t = e.nodeBefore, n = e.nodeAfter;
          if (!(t && n && t.is("containerElement") && n.is("containerElement")))
            throw new O("view-writer-merge-containers-invalid-position", this.document);
          const i = t.getChild(t.childCount - 1), r = i instanceof Me ? J._createAt(i, "end") : J._createAt(t, "end");
          return this.move(ae._createIn(n), J._createAt(t, "end")), this.remove(ae._createOn(n)), r;
        }
        insert(e, t) {
          lh(t = zt(t) ? [...t] : [t], this.document);
          const n = t.reduce((s, a) => {
            const l = s[s.length - 1], d = !a.is("uiElement");
            return l && l.breakAttributes == d ? l.nodes.push(a) : s.push({ breakAttributes: d, nodes: [a] }), s;
          }, []);
          let i = null, r = e;
          for (const { nodes: s, breakAttributes: a } of n) {
            const l = this._insertNodes(r, s, a);
            i || (i = l.start), r = l.end;
          }
          return i ? new ae(i, r) : new ae(e);
        }
        remove(e) {
          const t = e instanceof ae ? e : ae._createOn(e);
          if (Ti(t, this.document), t.isCollapsed)
            return new oo(this.document);
          const { start: n, end: i } = this._breakAttributesRange(t, !0), r = n.parent, s = i.offset - n.offset, a = r._removeChildren(n.offset, s);
          for (const d of a)
            this._removeFromClonedElementsGroup(d);
          const l = this.mergeAttributes(n);
          return t.start = l, t.end = l.clone(), new oo(this.document, a);
        }
        clear(e, t) {
          Ti(e, this.document);
          const n = e.getWalker({ direction: "backward", ignoreElementEnd: !0 });
          for (const i of n) {
            const r = i.item;
            let s;
            if (r.is("element") && t.isSimilar(r))
              s = ae._createOn(r);
            else if (!i.nextPosition.isAfter(e.start) && r.is("$textProxy")) {
              const a = r.getAncestors().find((l) => l.is("element") && t.isSimilar(l));
              a && (s = ae._createIn(a));
            }
            s && (s.end.isAfter(e.end) && (s.end = e.end), s.start.isBefore(e.start) && (s.start = e.start), this.remove(s));
          }
        }
        move(e, t) {
          let n;
          if (t.isAfter(e.end)) {
            const i = (t = this._breakAttributes(t, !0)).parent, r = i.childCount;
            e = this._breakAttributesRange(e, !0), n = this.remove(e), t.offset += i.childCount - r;
          } else
            n = this.remove(e);
          return this.insert(t, n);
        }
        wrap(e, t) {
          if (!(t instanceof no))
            throw new O("view-writer-wrap-invalid-attribute", this.document);
          if (Ti(e, this.document), e.isCollapsed) {
            let i = e.start;
            i.parent.is("element") && (n = i.parent, !Array.from(n.getChildren()).some((s) => !s.is("uiElement"))) && (i = i.getLastMatchingPosition((s) => s.item.is("uiElement"))), i = this._wrapPosition(i, t);
            const r = this.document.selection;
            return r.isCollapsed && r.getFirstPosition().isEqual(e.start) && this.setSelection(i), new ae(i);
          }
          return this._wrapRange(e, t);
          var n;
        }
        unwrap(e, t) {
          if (!(t instanceof no))
            throw new O("view-writer-unwrap-invalid-attribute", this.document);
          if (Ti(e, this.document), e.isCollapsed)
            return e;
          const { start: n, end: i } = this._breakAttributesRange(e, !0), r = n.parent, s = this._unwrapChildren(r, n.offset, i.offset, t), a = this.mergeAttributes(s.start);
          a.isEqual(s.start) || s.end.offset--;
          const l = this.mergeAttributes(s.end);
          return new ae(a, l);
        }
        rename(e, t) {
          const n = new Di(this.document, e, t.getAttributes());
          return this.insert(J._createAfter(t), n), this.move(ae._createIn(t), J._createAt(n, 0)), this.remove(ae._createOn(t)), n;
        }
        clearClonedElementsGroup(e) {
          this._cloneGroups.delete(e);
        }
        createPositionAt(e, t) {
          return J._createAt(e, t);
        }
        createPositionAfter(e) {
          return J._createAfter(e);
        }
        createPositionBefore(e) {
          return J._createBefore(e);
        }
        createRange(e, t) {
          return new ae(e, t);
        }
        createRangeOn(e) {
          return ae._createOn(e);
        }
        createRangeIn(e) {
          return ae._createIn(e);
        }
        createSelection(...e) {
          return new an(...e);
        }
        createSlot(e = "children") {
          if (!this._slotFactory)
            throw new O("view-writer-invalid-create-slot-context", this.document);
          return this._slotFactory(this, e);
        }
        _registerSlotFactory(e) {
          this._slotFactory = e;
        }
        _clearSlotFactory() {
          this._slotFactory = null;
        }
        _insertNodes(e, t, n) {
          let i, r;
          if (i = n ? Va(e) : e.parent.is("$text") ? e.parent.parent : e.parent, !i)
            throw new O("view-writer-invalid-position-container", this.document);
          r = n ? this._breakAttributes(e, !0) : e.parent.is("$text") ? La(e) : e;
          const s = i._insertChild(r.offset, t);
          for (const h of t)
            this._addToClonedElementsGroup(h);
          const a = r.getShiftedBy(s), l = this.mergeAttributes(r);
          l.isEqual(r) || a.offset--;
          const d = this.mergeAttributes(a);
          return new ae(l, d);
        }
        _wrapChildren(e, t, n, i) {
          let r = t;
          const s = [];
          for (; r < n; ) {
            const l = e.getChild(r), d = l.is("$text"), h = l.is("attributeElement");
            if (h && this._wrapAttributeElement(i, l))
              s.push(new J(e, r));
            else if (d || !h || wA(i, l)) {
              const m = i._clone();
              l._remove(), m._appendChild(l), e._insertChild(r, m), this._addToClonedElementsGroup(m), s.push(new J(e, r));
            } else
              this._wrapChildren(l, 0, l.childCount, i);
            r++;
          }
          let a = 0;
          for (const l of s)
            l.offset -= a, l.offset != t && (this.mergeAttributes(l).isEqual(l) || (a++, n--));
          return ae._createFromParentsAndOffsets(e, t, e, n);
        }
        _unwrapChildren(e, t, n, i) {
          let r = t;
          const s = [];
          for (; r < n; ) {
            const l = e.getChild(r);
            if (l.is("attributeElement"))
              if (l.isSimilar(i)) {
                const d = l.getChildren(), h = l.childCount;
                l._remove(), e._insertChild(r, d), this._removeFromClonedElementsGroup(l), s.push(new J(e, r), new J(e, r + h)), r += h, n += h - 1;
              } else
                this._unwrapAttributeElement(i, l) ? (s.push(new J(e, r), new J(e, r + 1)), r++) : (this._unwrapChildren(l, 0, l.childCount, i), r++);
            else
              r++;
          }
          let a = 0;
          for (const l of s)
            l.offset -= a, !(l.offset == t || l.offset == n) && (this.mergeAttributes(l).isEqual(l) || (a++, n--));
          return ae._createFromParentsAndOffsets(e, t, e, n);
        }
        _wrapRange(e, t) {
          const { start: n, end: i } = this._breakAttributesRange(e, !0), r = n.parent, s = this._wrapChildren(r, n.offset, i.offset, t), a = this.mergeAttributes(s.start);
          a.isEqual(s.start) || s.end.offset--;
          const l = this.mergeAttributes(s.end);
          return new ae(a, l);
        }
        _wrapPosition(e, t) {
          if (t.isSimilar(e.parent))
            return sh(e.clone());
          e.parent.is("$text") && (e = La(e));
          const n = this.createAttributeElement("_wrapPosition-fake-element");
          n._priority = Number.POSITIVE_INFINITY, n.isSimilar = () => !1, e.parent._insertChild(e.offset, n);
          const i = new ae(e, e.getShiftedBy(1));
          this.wrap(i, t);
          const r = new J(n.parent, n.index);
          n._remove();
          const s = r.nodeBefore, a = r.nodeAfter;
          return s instanceof Me && a instanceof Me ? ah(s, a) : sh(r);
        }
        _wrapAttributeElement(e, t) {
          if (!ch(e, t) || e.name !== t.name || e.priority !== t.priority)
            return !1;
          for (const n of e.getAttributeKeys())
            if (n !== "class" && n !== "style" && t.hasAttribute(n) && t.getAttribute(n) !== e.getAttribute(n))
              return !1;
          for (const n of e.getStyleNames())
            if (t.hasStyle(n) && t.getStyle(n) !== e.getStyle(n))
              return !1;
          for (const n of e.getAttributeKeys())
            n !== "class" && n !== "style" && (t.hasAttribute(n) || this.setAttribute(n, e.getAttribute(n), t));
          for (const n of e.getStyleNames())
            t.hasStyle(n) || this.setStyle(n, e.getStyle(n), t);
          for (const n of e.getClassNames())
            t.hasClass(n) || this.addClass(n, t);
          return !0;
        }
        _unwrapAttributeElement(e, t) {
          if (!ch(e, t) || e.name !== t.name || e.priority !== t.priority)
            return !1;
          for (const n of e.getAttributeKeys())
            if (n !== "class" && n !== "style" && (!t.hasAttribute(n) || t.getAttribute(n) !== e.getAttribute(n)))
              return !1;
          if (!t.hasClass(...e.getClassNames()))
            return !1;
          for (const n of e.getStyleNames())
            if (!t.hasStyle(n) || t.getStyle(n) !== e.getStyle(n))
              return !1;
          for (const n of e.getAttributeKeys())
            n !== "class" && n !== "style" && this.removeAttribute(n, t);
          return this.removeClass(Array.from(e.getClassNames()), t), this.removeStyle(Array.from(e.getStyleNames()), t), !0;
        }
        _breakAttributesRange(e, t = !1) {
          const n = e.start, i = e.end;
          if (Ti(e, this.document), e.isCollapsed) {
            const l = this._breakAttributes(e.start, t);
            return new ae(l, l);
          }
          const r = this._breakAttributes(i, t), s = r.parent.childCount, a = this._breakAttributes(n, t);
          return r.offset += r.parent.childCount - s, new ae(a, r);
        }
        _breakAttributes(e, t = !1) {
          const n = e.offset, i = e.parent;
          if (e.parent.is("emptyElement"))
            throw new O("view-writer-cannot-break-empty-element", this.document);
          if (e.parent.is("uiElement"))
            throw new O("view-writer-cannot-break-ui-element", this.document);
          if (e.parent.is("rawElement"))
            throw new O("view-writer-cannot-break-raw-element", this.document);
          if (!t && i.is("$text") && ja(i.parent) || ja(i))
            return e.clone();
          if (i.is("$text"))
            return this._breakAttributes(La(e), t);
          if (n == i.childCount) {
            const r = new J(i.parent, i.index + 1);
            return this._breakAttributes(r, t);
          }
          if (n === 0) {
            const r = new J(i.parent, i.index);
            return this._breakAttributes(r, t);
          }
          {
            const r = i.index + 1, s = i._clone();
            i.parent._insertChild(r, s), this._addToClonedElementsGroup(s);
            const a = i.childCount - n, l = i._removeChildren(n, a);
            s._appendChild(l);
            const d = new J(i.parent, r);
            return this._breakAttributes(d, t);
          }
        }
        _addToClonedElementsGroup(e) {
          if (!e.root.is("rootElement"))
            return;
          if (e.is("element"))
            for (const i of e.getChildren())
              this._addToClonedElementsGroup(i);
          const t = e.id;
          if (!t)
            return;
          let n = this._cloneGroups.get(t);
          n || (n = /* @__PURE__ */ new Set(), this._cloneGroups.set(t, n)), n.add(e), e._clonesGroup = n;
        }
        _removeFromClonedElementsGroup(e) {
          if (e.is("element"))
            for (const i of e.getChildren())
              this._removeFromClonedElementsGroup(i);
          const t = e.id;
          if (!t)
            return;
          const n = this._cloneGroups.get(t);
          n && n.delete(e);
        }
      }
      function Va(o) {
        let e = o.parent;
        for (; !ja(e); ) {
          if (!e)
            return;
          e = e.parent;
        }
        return e;
      }
      function wA(o, e) {
        return o.priority < e.priority || !(o.priority > e.priority) && o.getIdentity() < e.getIdentity();
      }
      function sh(o) {
        const e = o.nodeBefore;
        if (e && e.is("$text"))
          return new J(e, e.data.length);
        const t = o.nodeAfter;
        return t && t.is("$text") ? new J(t, 0) : o;
      }
      function La(o) {
        if (o.offset == o.parent.data.length)
          return new J(o.parent.parent, o.parent.index + 1);
        if (o.offset === 0)
          return new J(o.parent.parent, o.parent.index);
        const e = o.parent.data.slice(o.offset);
        return o.parent._data = o.parent.data.slice(0, o.offset), o.parent.parent._insertChild(o.parent.index + 1, new Me(o.root.document, e)), new J(o.parent.parent, o.parent.index + 1);
      }
      function ah(o, e) {
        const t = o.data.length;
        return o._data += e.data, e._remove(), new J(o, t);
      }
      const vA = [Me, no, Di, Fa, $a, $r];
      function lh(o, e) {
        for (const t of o) {
          if (!vA.some((n) => t instanceof n))
            throw new O("view-writer-insert-invalid-node-type", e);
          t.is("$text") || lh(t.getChildren(), e);
        }
      }
      function ja(o) {
        return o && (o.is("containerElement") || o.is("documentFragment"));
      }
      function Ti(o, e) {
        const t = Va(o.start), n = Va(o.end);
        if (!t || !n || t !== n)
          throw new O("view-writer-invalid-range-container", e);
      }
      function ch(o, e) {
        return o.id === null && e.id === null;
      }
      const dh = (o) => o.createTextNode(" "), uh = (o) => {
        const e = o.createElement("span");
        return e.dataset.ckeFiller = "true", e.innerText = " ", e;
      }, hh = (o) => {
        const e = o.createElement("br");
        return e.dataset.ckeFiller = "true", e;
      }, ln = 7, Vr = "⁠".repeat(ln);
      function Nt(o) {
        return Qe(o) && o.data.substr(0, ln) === Vr;
      }
      function Ii(o) {
        return o.data.length == ln && Nt(o);
      }
      function gh(o) {
        return Nt(o) ? o.data.slice(ln) : o.data;
      }
      function _A(o, e) {
        if (e.keyCode == Ce.arrowleft) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection();
          if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
            const n = t.getRangeAt(0).startContainer, i = t.getRangeAt(0).startOffset;
            Nt(n) && i <= ln && t.collapse(n, 0);
          }
        }
      }
      var mh = b(9315), AA = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(mh.Z, AA), mh.Z.locals;
      class CA extends re() {
        constructor(e, t) {
          super(), this.domDocuments = /* @__PURE__ */ new Set(), this.markedAttributes = /* @__PURE__ */ new Set(), this.markedChildren = /* @__PURE__ */ new Set(), this.markedTexts = /* @__PURE__ */ new Set(), this._inlineFiller = null, this._fakeSelectionContainer = null, this.domConverter = e, this.selection = t, this.set("isFocused", !1), this.set("isSelecting", !1), k.isBlink && !k.isAndroid && this.on("change:isSelecting", () => {
            this.isSelecting || this.render();
          }), this.set("isComposing", !1), this.on("change:isComposing", () => {
            this.isComposing || this.render();
          });
        }
        markToSync(e, t) {
          if (e === "text")
            this.domConverter.mapViewToDom(t.parent) && this.markedTexts.add(t);
          else {
            if (!this.domConverter.mapViewToDom(t))
              return;
            if (e === "attributes")
              this.markedAttributes.add(t);
            else {
              if (e !== "children")
                throw new O("view-renderer-unknown-type", this);
              this.markedChildren.add(t);
            }
          }
        }
        render() {
          if (this.isComposing && !k.isAndroid)
            return;
          let e = null;
          const t = !(k.isBlink && !k.isAndroid) || !this.isSelecting;
          for (const n of this.markedChildren)
            this._updateChildrenMappings(n);
          t ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? e = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (e = this.selection.getFirstPosition(), this.markedChildren.add(e.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (e = this.domConverter.domPositionToView(this._inlineFiller), e && e.parent.is("$text") && (e = J._createBefore(e.parent)));
          for (const n of this.markedAttributes)
            this._updateAttrs(n);
          for (const n of this.markedChildren)
            this._updateChildren(n, { inlineFillerPosition: e });
          for (const n of this.markedTexts)
            !this.markedChildren.has(n.parent) && this.domConverter.mapViewToDom(n.parent) && this._updateText(n, { inlineFillerPosition: e });
          if (t)
            if (e) {
              const n = this.domConverter.viewPositionToDom(e), i = n.parent.ownerDocument;
              Nt(n.parent) ? this._inlineFiller = n.parent : this._inlineFiller = ph(i, n.parent, n.offset);
            } else
              this._inlineFiller = null;
          this._updateFocus(), this._updateSelection(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
        }
        _updateChildrenMappings(e) {
          if (!this.domConverter.mapViewToDom(e))
            return;
          const t = Array.from(this.domConverter.mapViewToDom(e).childNodes), n = Array.from(this.domConverter.viewChildrenToDom(e, { withChildren: !1 })), i = this._diffNodeLists(t, n), r = this._findUpdateActions(i, t, n, yA);
          if (r.indexOf("update") !== -1) {
            const s = { equal: 0, insert: 0, delete: 0 };
            for (const a of r)
              if (a === "update") {
                const l = s.equal + s.insert, d = s.equal + s.delete, h = e.getChild(l);
                !h || h.is("uiElement") || h.is("rawElement") || this._updateElementMappings(h, t[d]), eu(n[l]), s.equal++;
              } else
                s[a]++;
          }
        }
        _updateElementMappings(e, t) {
          this.domConverter.unbindDomElement(t), this.domConverter.bindElements(t, e), this.markedChildren.add(e), this.markedAttributes.add(e);
        }
        _getInlineFillerPosition() {
          const e = this.selection.getFirstPosition();
          return e.parent.is("$text") ? J._createBefore(e.parent) : e;
        }
        _isSelectionInInlineFiller() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
            return !1;
          const e = this.selection.getFirstPosition(), t = this.domConverter.viewPositionToDom(e);
          return !!(t && Qe(t.parent) && Nt(t.parent));
        }
        _removeInlineFiller() {
          const e = this._inlineFiller;
          if (!Nt(e))
            throw new O("view-renderer-filler-was-lost", this);
          Ii(e) ? e.remove() : e.data = e.data.substr(ln), this._inlineFiller = null;
        }
        _needsInlineFillerAtSelection() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
            return !1;
          const e = this.selection.getFirstPosition(), t = e.parent, n = e.offset;
          if (!this.domConverter.mapViewToDom(t.root) || !t.is("element") || !function(s) {
            if (s.getAttribute("contenteditable") == "false")
              return !1;
            const a = s.findAncestor((l) => l.hasAttribute("contenteditable"));
            return !a || a.getAttribute("contenteditable") == "true";
          }(t) || n === t.getFillerOffset())
            return !1;
          const i = e.nodeBefore, r = e.nodeAfter;
          return !(i instanceof Me || r instanceof Me) && (!k.isAndroid || !i && !r);
        }
        _updateText(e, t) {
          const n = this.domConverter.findCorrespondingDomText(e);
          let i = this.domConverter.viewToDom(e).data;
          const r = t.inlineFillerPosition;
          r && r.parent == e.parent && r.offset == e.index && (i = Vr + i), fh(n, i);
        }
        _updateAttrs(e) {
          const t = this.domConverter.mapViewToDom(e);
          if (!t)
            return;
          const n = Array.from(t.attributes).map((r) => r.name), i = e.getAttributeKeys();
          for (const r of i)
            this.domConverter.setDomElementAttribute(t, r, e.getAttribute(r), e);
          for (const r of n)
            e.hasAttribute(r) || this.domConverter.removeDomElementAttribute(t, r);
        }
        _updateChildren(e, t) {
          const n = this.domConverter.mapViewToDom(e);
          if (!n)
            return;
          if (k.isAndroid) {
            let m = null;
            for (const f of Array.from(n.childNodes)) {
              if (m && Qe(m) && Qe(f)) {
                n.normalize();
                break;
              }
              m = f;
            }
          }
          const i = t.inlineFillerPosition, r = n.childNodes, s = Array.from(this.domConverter.viewChildrenToDom(e, { bind: !0 }));
          i && i.parent === e && ph(n.ownerDocument, s, i.offset);
          const a = this._diffNodeLists(r, s), l = this._findUpdateActions(a, r, s, EA);
          let d = 0;
          const h = /* @__PURE__ */ new Set();
          for (const m of l)
            m === "delete" ? (h.add(r[d]), eu(r[d])) : m !== "equal" && m !== "update" || d++;
          d = 0;
          for (const m of l)
            m === "insert" ? (Zd(n, d, s[d]), d++) : m === "update" ? (fh(r[d], s[d].data), d++) : m === "equal" && (this._markDescendantTextToSync(this.domConverter.domToView(s[d])), d++);
          for (const m of h)
            m.parentNode || this.domConverter.unbindDomElement(m);
        }
        _diffNodeLists(e, t) {
          return e = function(n, i) {
            const r = Array.from(n);
            return r.length == 0 || !i || r[r.length - 1] == i && r.pop(), r;
          }(e, this._fakeSelectionContainer), F(e, t, xA.bind(null, this.domConverter));
        }
        _findUpdateActions(e, t, n, i) {
          if (e.indexOf("insert") === -1 || e.indexOf("delete") === -1)
            return e;
          let r = [], s = [], a = [];
          const l = { equal: 0, insert: 0, delete: 0 };
          for (const d of e)
            d === "insert" ? a.push(n[l.equal + l.insert]) : d === "delete" ? s.push(t[l.equal + l.delete]) : (r = r.concat(F(s, a, i).map((h) => h === "equal" ? "update" : h)), r.push("equal"), s = [], a = []), l[d]++;
          return r.concat(F(s, a, i).map((d) => d === "equal" ? "update" : d));
        }
        _markDescendantTextToSync(e) {
          if (e) {
            if (e.is("$text"))
              this.markedTexts.add(e);
            else if (e.is("element"))
              for (const t of e.getChildren())
                this._markDescendantTextToSync(t);
          }
        }
        _updateSelection() {
          if (k.isBlink && !k.isAndroid && this.isSelecting && !this.markedChildren.size)
            return;
          if (this.selection.rangeCount === 0)
            return this._removeDomSelection(), void this._removeFakeSelection();
          const e = this.domConverter.mapViewToDom(this.selection.editableElement);
          this.isFocused && e && (this.selection.isFake ? this._updateFakeSelection(e) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(e)) : this.isComposing && k.isAndroid || this._updateDomSelection(e));
        }
        _updateFakeSelection(e) {
          const t = e.ownerDocument;
          this._fakeSelectionContainer || (this._fakeSelectionContainer = function(s) {
            const a = s.createElement("div");
            return a.className = "ck-fake-selection-container", Object.assign(a.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" }), a.textContent = " ", a;
          }(t));
          const n = this._fakeSelectionContainer;
          if (this.domConverter.bindFakeSelection(n, this.selection), !this._fakeSelectionNeedsUpdate(e))
            return;
          n.parentElement && n.parentElement == e || e.appendChild(n), n.textContent = this.selection.fakeSelectionLabel || " ";
          const i = t.getSelection(), r = t.createRange();
          i.removeAllRanges(), r.selectNodeContents(n), i.addRange(r);
        }
        _updateDomSelection(e) {
          const t = e.ownerDocument.defaultView.getSelection();
          if (!this._domSelectionNeedsUpdate(t))
            return;
          const n = this.domConverter.viewPositionToDom(this.selection.anchor), i = this.domConverter.viewPositionToDom(this.selection.focus);
          t.collapse(n.parent, n.offset), t.extend(i.parent, i.offset), k.isGecko && function(r, s) {
            const a = r.parent;
            if (a.nodeType != Node.ELEMENT_NODE || r.offset != a.childNodes.length - 1)
              return;
            const l = a.childNodes[r.offset];
            l && l.tagName == "BR" && s.addRange(s.getRangeAt(0));
          }(i, t);
        }
        _domSelectionNeedsUpdate(e) {
          if (!this.domConverter.isDomSelectionCorrect(e))
            return !0;
          const t = e && this.domConverter.domSelectionToView(e);
          return (!t || !this.selection.isEqual(t)) && !(!this.selection.isCollapsed && this.selection.isSimilar(t));
        }
        _fakeSelectionNeedsUpdate(e) {
          const t = this._fakeSelectionContainer, n = e.ownerDocument.getSelection();
          return !t || t.parentElement !== e || n.anchorNode !== t && !t.contains(n.anchorNode) || t.textContent !== this.selection.fakeSelectionLabel;
        }
        _removeDomSelection() {
          for (const e of this.domDocuments) {
            const t = e.getSelection();
            if (t.rangeCount) {
              const n = e.activeElement, i = this.domConverter.mapDomToView(n);
              n && i && t.removeAllRanges();
            }
          }
        }
        _removeFakeSelection() {
          const e = this._fakeSelectionContainer;
          e && e.remove();
        }
        _updateFocus() {
          if (this.isFocused) {
            const e = this.selection.editableElement;
            e && this.domConverter.focus(e);
          }
        }
      }
      function ph(o, e, t) {
        const n = e instanceof Array ? e : e.childNodes, i = n[t];
        if (Qe(i))
          return i.data = Vr + i.data, i;
        {
          const r = o.createTextNode(Vr);
          return Array.isArray(e) ? n.splice(t, 0, r) : Zd(e, t, r), r;
        }
      }
      function yA(o, e) {
        return Tn(o) && Tn(e) && !Qe(o) && !Qe(e) && !Ro(o) && !Ro(e) && o.tagName.toLowerCase() === e.tagName.toLowerCase();
      }
      function EA(o, e) {
        return Tn(o) && Tn(e) && Qe(o) && Qe(e);
      }
      function xA(o, e, t) {
        return e === t || (Qe(e) && Qe(t) ? e.data === t.data : !(!o.isBlockFiller(e) || !o.isBlockFiller(t)));
      }
      function fh(o, e) {
        const t = o.data;
        if (t == e)
          return;
        const n = P(t, e);
        for (const i of n)
          i.type === "insert" ? o.insertData(i.index, i.values.join("")) : o.deleteData(i.index, i.howMany);
      }
      const SA = hh(ke.document), DA = dh(ke.document), BA = uh(ke.document), Lr = "data-ck-unsafe-attribute-", bh = "data-ck-unsafe-element";
      class kh {
        constructor(e, { blockFillerMode: t, renderingMode: n = "editing" } = {}) {
          this._domToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToDomMapping = /* @__PURE__ */ new WeakMap(), this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap(), this._rawContentElementMatcher = new No(), this._encounteredRawContentDomNodes = /* @__PURE__ */ new WeakSet(), this.document = e, this.renderingMode = n, this.blockFillerMode = t || (n === "editing" ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this.unsafeElements = ["script", "style"], this._domDocument = this.renderingMode === "editing" ? ke.document : ke.document.implementation.createHTMLDocument("");
        }
        bindFakeSelection(e, t) {
          this._fakeSelectionMapping.set(e, new an(t));
        }
        fakeSelectionToView(e) {
          return this._fakeSelectionMapping.get(e);
        }
        bindElements(e, t) {
          this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
        }
        unbindDomElement(e) {
          const t = this._domToViewMapping.get(e);
          if (t) {
            this._domToViewMapping.delete(e), this._viewToDomMapping.delete(t);
            for (const n of Array.from(e.children))
              this.unbindDomElement(n);
          }
        }
        bindDocumentFragments(e, t) {
          this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
        }
        shouldRenderAttribute(e, t, n) {
          return this.renderingMode === "data" || !(e = e.toLowerCase()).startsWith("on") && (e !== "srcdoc" || !t.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) && (n === "img" && (e === "src" || e === "srcset") || n === "source" && e === "srcset" || !t.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i));
        }
        setContentOf(e, t) {
          if (this.renderingMode === "data")
            return void (e.innerHTML = t);
          const n = new DOMParser().parseFromString(t, "text/html"), i = n.createDocumentFragment(), r = n.body.childNodes;
          for (; r.length > 0; )
            i.appendChild(r[0]);
          const s = n.createTreeWalker(i, NodeFilter.SHOW_ELEMENT), a = [];
          let l;
          for (; l = s.nextNode(); )
            a.push(l);
          for (const d of a) {
            for (const m of d.getAttributeNames())
              this.setDomElementAttribute(d, m, d.getAttribute(m));
            const h = d.tagName.toLowerCase();
            this._shouldRenameElement(h) && (_h(h), d.replaceWith(this._createReplacementDomElement(h, d)));
          }
          for (; e.firstChild; )
            e.firstChild.remove();
          e.append(i);
        }
        viewToDom(e, t = {}) {
          if (e.is("$text")) {
            const n = this._processDataFromViewText(e);
            return this._domDocument.createTextNode(n);
          }
          {
            if (this.mapViewToDom(e))
              return this.mapViewToDom(e);
            let n;
            if (e.is("documentFragment"))
              n = this._domDocument.createDocumentFragment(), t.bind && this.bindDocumentFragments(n, e);
            else {
              if (e.is("uiElement"))
                return n = e.name === "$comment" ? this._domDocument.createComment(e.getCustomProperty("$rawContent")) : e.render(this._domDocument, this), t.bind && this.bindElements(n, e), n;
              this._shouldRenameElement(e.name) ? (_h(e.name), n = this._createReplacementDomElement(e.name)) : n = e.hasAttribute("xmlns") ? this._domDocument.createElementNS(e.getAttribute("xmlns"), e.name) : this._domDocument.createElement(e.name), e.is("rawElement") && e.render(n, this), t.bind && this.bindElements(n, e);
              for (const i of e.getAttributeKeys())
                this.setDomElementAttribute(n, i, e.getAttribute(i), e);
            }
            if (t.withChildren !== !1)
              for (const i of this.viewChildrenToDom(e, t))
                n.appendChild(i);
            return n;
          }
        }
        setDomElementAttribute(e, t, n, i) {
          const r = this.shouldRenderAttribute(t, n, e.tagName.toLowerCase()) || i && i.shouldRenderUnsafeAttribute(t);
          r || oe("domconverter-unsafe-attribute-detected", { domElement: e, key: t, value: n }), Jd(t) ? (e.hasAttribute(t) && !r ? e.removeAttribute(t) : e.hasAttribute(Lr + t) && r && e.removeAttribute(Lr + t), e.setAttribute(r ? t : Lr + t, n)) : oe("domconverter-invalid-attribute-detected", { domElement: e, key: t, value: n });
        }
        removeDomElementAttribute(e, t) {
          t != bh && (e.removeAttribute(t), e.removeAttribute(Lr + t));
        }
        *viewChildrenToDom(e, t = {}) {
          const n = e.getFillerOffset && e.getFillerOffset();
          let i = 0;
          for (const r of e.getChildren()) {
            n === i && (yield this._getBlockFiller());
            const s = r.is("element") && !!r.getCustomProperty("dataPipeline:transparentRendering") && !it(r.getAttributes());
            s && this.renderingMode == "data" ? yield* this.viewChildrenToDom(r, t) : (s && oe("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: r }), yield this.viewToDom(r, t)), i++;
          }
          n === i && (yield this._getBlockFiller());
        }
        viewRangeToDom(e) {
          const t = this.viewPositionToDom(e.start), n = this.viewPositionToDom(e.end), i = this._domDocument.createRange();
          return i.setStart(t.parent, t.offset), i.setEnd(n.parent, n.offset), i;
        }
        viewPositionToDom(e) {
          const t = e.parent;
          if (t.is("$text")) {
            const n = this.findCorrespondingDomText(t);
            if (!n)
              return null;
            let i = e.offset;
            return Nt(n) && (i += ln), { parent: n, offset: i };
          }
          {
            let n, i, r;
            if (e.offset === 0) {
              if (n = this.mapViewToDom(t), !n)
                return null;
              r = n.childNodes[0];
            } else {
              const s = e.nodeBefore;
              if (i = s.is("$text") ? this.findCorrespondingDomText(s) : this.mapViewToDom(s), !i)
                return null;
              n = i.parentNode, r = i.nextSibling;
            }
            return Qe(r) && Nt(r) ? { parent: r, offset: ln } : { parent: n, offset: i ? Dr(i) + 1 : 0 };
          }
        }
        domToView(e, t = {}) {
          if (this.isBlockFiller(e))
            return null;
          const n = this.getHostViewElement(e);
          if (n)
            return n;
          if (Ro(e) && t.skipComments)
            return null;
          if (Qe(e)) {
            if (Ii(e))
              return null;
            {
              const i = this._processDataFromDomText(e);
              return i === "" ? null : new Me(this.document, i);
            }
          }
          {
            if (this.mapDomToView(e))
              return this.mapDomToView(e);
            let i;
            if (this.isDocumentFragment(e))
              i = new oo(this.document), t.bind && this.bindDocumentFragments(e, i);
            else {
              i = this._createViewElement(e, t), t.bind && this.bindElements(e, i);
              const r = e.attributes;
              if (r)
                for (let s = r.length, a = 0; a < s; a++)
                  i._setAttribute(r[a].name, r[a].value);
              if (this._isViewElementWithRawContent(i, t) || Ro(e)) {
                const s = Ro(e) ? e.data : e.innerHTML;
                return i._setCustomProperty("$rawContent", s), this._encounteredRawContentDomNodes.add(e), i;
              }
            }
            if (t.withChildren !== !1)
              for (const r of this.domChildrenToView(e, t))
                i._appendChild(r);
            return i;
          }
        }
        *domChildrenToView(e, t) {
          for (let n = 0; n < e.childNodes.length; n++) {
            const i = e.childNodes[n], r = this.domToView(i, t);
            r !== null && (yield r);
          }
        }
        domSelectionToView(e) {
          if (e.rangeCount === 1) {
            let i = e.getRangeAt(0).startContainer;
            Qe(i) && (i = i.parentNode);
            const r = this.fakeSelectionToView(i);
            if (r)
              return r;
          }
          const t = this.isDomSelectionBackward(e), n = [];
          for (let i = 0; i < e.rangeCount; i++) {
            const r = e.getRangeAt(i), s = this.domRangeToView(r);
            s && n.push(s);
          }
          return new an(n, { backward: t });
        }
        domRangeToView(e) {
          const t = this.domPositionToView(e.startContainer, e.startOffset), n = this.domPositionToView(e.endContainer, e.endOffset);
          return t && n ? new ae(t, n) : null;
        }
        domPositionToView(e, t = 0) {
          if (this.isBlockFiller(e))
            return this.domPositionToView(e.parentNode, Dr(e));
          const n = this.mapDomToView(e);
          if (n && (n.is("uiElement") || n.is("rawElement")))
            return J._createBefore(n);
          if (Qe(e)) {
            if (Ii(e))
              return this.domPositionToView(e.parentNode, Dr(e));
            const i = this.findCorrespondingViewText(e);
            let r = t;
            return i ? (Nt(e) && (r -= ln, r = r < 0 ? 0 : r), new J(i, r)) : null;
          }
          if (t === 0) {
            const i = this.mapDomToView(e);
            if (i)
              return new J(i, 0);
          } else {
            const i = e.childNodes[t - 1];
            if (Qe(i) && Ii(i) || i && this.isBlockFiller(i))
              return this.domPositionToView(i.parentNode, Dr(i));
            const r = Qe(i) ? this.findCorrespondingViewText(i) : this.mapDomToView(i);
            if (r && r.parent)
              return new J(r.parent, r.index + 1);
          }
          return null;
        }
        mapDomToView(e) {
          return this.getHostViewElement(e) || this._domToViewMapping.get(e);
        }
        findCorrespondingViewText(e) {
          if (Ii(e))
            return null;
          const t = this.getHostViewElement(e);
          if (t)
            return t;
          const n = e.previousSibling;
          if (n) {
            if (!this.isElement(n))
              return null;
            const i = this.mapDomToView(n);
            if (i) {
              const r = i.nextSibling;
              return r instanceof Me ? r : null;
            }
          } else {
            const i = this.mapDomToView(e.parentNode);
            if (i) {
              const r = i.getChild(0);
              return r instanceof Me ? r : null;
            }
          }
          return null;
        }
        mapViewToDom(e) {
          return this._viewToDomMapping.get(e);
        }
        findCorrespondingDomText(e) {
          const t = e.previousSibling;
          return t && this.mapViewToDom(t) ? this.mapViewToDom(t).nextSibling : !t && e.parent && this.mapViewToDom(e.parent) ? this.mapViewToDom(e.parent).childNodes[0] : null;
        }
        focus(e) {
          const t = this.mapViewToDom(e);
          if (t && t.ownerDocument.activeElement !== t) {
            const { scrollX: n, scrollY: i } = ke.window, r = [];
            wh(t, (s) => {
              const { scrollLeft: a, scrollTop: l } = s;
              r.push([a, l]);
            }), t.focus(), wh(t, (s) => {
              const [a, l] = r.shift();
              s.scrollLeft = a, s.scrollTop = l;
            }), ke.window.scrollTo(n, i);
          }
        }
        isElement(e) {
          return e && e.nodeType == Node.ELEMENT_NODE;
        }
        isDocumentFragment(e) {
          return e && e.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
        }
        isBlockFiller(e) {
          return this.blockFillerMode == "br" ? e.isEqualNode(SA) : !(e.tagName !== "BR" || !vh(e, this.blockElements) || e.parentNode.childNodes.length !== 1) || e.isEqualNode(BA) || function(t, n) {
            return t.isEqualNode(DA) && vh(t, n) && t.parentNode.childNodes.length === 1;
          }(e, this.blockElements);
        }
        isDomSelectionBackward(e) {
          if (e.isCollapsed)
            return !1;
          const t = this._domDocument.createRange();
          try {
            t.setStart(e.anchorNode, e.anchorOffset), t.setEnd(e.focusNode, e.focusOffset);
          } catch {
            return !1;
          }
          const n = t.collapsed;
          return t.detach(), n;
        }
        getHostViewElement(e) {
          const t = Ud(e);
          for (t.pop(); t.length; ) {
            const n = t.pop(), i = this._domToViewMapping.get(n);
            if (i && (i.is("uiElement") || i.is("rawElement")))
              return i;
          }
          return null;
        }
        isDomSelectionCorrect(e) {
          return this._isDomSelectionPositionCorrect(e.anchorNode, e.anchorOffset) && this._isDomSelectionPositionCorrect(e.focusNode, e.focusOffset);
        }
        registerRawContentMatcher(e) {
          this._rawContentElementMatcher.add(e);
        }
        _getBlockFiller() {
          switch (this.blockFillerMode) {
            case "nbsp":
              return dh(this._domDocument);
            case "markedNbsp":
              return uh(this._domDocument);
            case "br":
              return hh(this._domDocument);
          }
        }
        _isDomSelectionPositionCorrect(e, t) {
          if (Qe(e) && Nt(e) && t < ln || this.isElement(e) && Nt(e.childNodes[t]))
            return !1;
          const n = this.mapDomToView(e);
          return !n || !n.is("uiElement") && !n.is("rawElement");
        }
        _processDataFromViewText(e) {
          let t = e.data;
          if (e.getAncestors().some((n) => this.preElements.includes(n.name)))
            return t;
          if (t.charAt(0) == " ") {
            const n = this._getTouchingInlineViewNode(e, !1);
            !(n && n.is("$textProxy") && this._nodeEndsWithSpace(n)) && n || (t = " " + t.substr(1));
          }
          if (t.charAt(t.length - 1) == " ") {
            const n = this._getTouchingInlineViewNode(e, !0), i = n && n.is("$textProxy") && n.data.charAt(0) == " ";
            t.charAt(t.length - 2) != " " && n && !i || (t = t.substr(0, t.length - 1) + " ");
          }
          return t.replace(/ {2}/g, "  ");
        }
        _nodeEndsWithSpace(e) {
          if (e.getAncestors().some((n) => this.preElements.includes(n.name)))
            return !1;
          const t = this._processDataFromViewText(e);
          return t.charAt(t.length - 1) == " ";
        }
        _processDataFromDomText(e) {
          let t = e.data;
          if (function(d, h) {
            return Ud(d).some((f) => f.tagName && h.includes(f.tagName.toLowerCase()));
          }(e, this.preElements))
            return gh(e);
          t = t.replace(/[ \n\t\r]{1,}/g, " ");
          const n = this._getTouchingInlineDomNode(e, !1), i = this._getTouchingInlineDomNode(e, !0), r = this._checkShouldLeftTrimDomText(e, n), s = this._checkShouldRightTrimDomText(e, i);
          r && (t = t.replace(/^ /, "")), s && (t = t.replace(/ $/, "")), t = gh(new Text(t)), t = t.replace(/ \u00A0/g, "  ");
          const a = i && this.isElement(i) && i.tagName != "BR", l = i && Qe(i) && i.data.charAt(0) == " ";
          return (/( |\u00A0)\u00A0$/.test(t) || !i || a || l) && (t = t.replace(/\u00A0$/, " ")), (r || n && this.isElement(n) && n.tagName != "BR") && (t = t.replace(/^\u00A0/, " ")), t;
        }
        _checkShouldLeftTrimDomText(e, t) {
          return !t || (this.isElement(t) ? t.tagName === "BR" : !this._encounteredRawContentDomNodes.has(e.previousSibling) && /[^\S\u00A0]/.test(t.data.charAt(t.data.length - 1)));
        }
        _checkShouldRightTrimDomText(e, t) {
          return !t && !Nt(e);
        }
        _getTouchingInlineViewNode(e, t) {
          const n = new to({ startPosition: t ? J._createAfter(e) : J._createBefore(e), direction: t ? "forward" : "backward" });
          for (const i of n) {
            if (i.item.is("element") && this.inlineObjectElements.includes(i.item.name))
              return i.item;
            if (i.item.is("containerElement") || i.item.is("element", "br"))
              return null;
            if (i.item.is("$textProxy"))
              return i.item;
          }
          return null;
        }
        _getTouchingInlineDomNode(e, t) {
          if (!e.parentNode)
            return null;
          const n = t ? "firstChild" : "lastChild", i = t ? "nextSibling" : "previousSibling";
          let r = !0, s = e;
          do
            if (!r && s[n] ? s = s[n] : s[i] ? (s = s[i], r = !1) : (s = s.parentNode, r = !0), !s || this._isBlockElement(s))
              return null;
          while (!Qe(s) && s.tagName != "BR" && !this._isInlineObjectElement(s));
          return s;
        }
        _isBlockElement(e) {
          return this.isElement(e) && this.blockElements.includes(e.tagName.toLowerCase());
        }
        _isInlineObjectElement(e) {
          return this.isElement(e) && this.inlineObjectElements.includes(e.tagName.toLowerCase());
        }
        _createViewElement(e, t) {
          if (Ro(e))
            return new $r(this.document, "$comment");
          const n = t.keepOriginalCase ? e.tagName : e.tagName.toLowerCase();
          return new Mt(this.document, n);
        }
        _isViewElementWithRawContent(e, t) {
          return t.withChildren !== !1 && !!this._rawContentElementMatcher.match(e);
        }
        _shouldRenameElement(e) {
          const t = e.toLowerCase();
          return this.renderingMode === "editing" && this.unsafeElements.includes(t);
        }
        _createReplacementDomElement(e, t) {
          const n = this._domDocument.createElement("span");
          if (n.setAttribute(bh, e), t) {
            for (; t.firstChild; )
              n.appendChild(t.firstChild);
            for (const i of t.getAttributeNames())
              n.setAttribute(i, t.getAttribute(i));
          }
          return n;
        }
      }
      function wh(o, e) {
        let t = o;
        for (; t; )
          e(t), t = t.parentElement;
      }
      function vh(o, e) {
        const t = o.parentNode;
        return !!t && !!t.tagName && e.includes(t.tagName.toLowerCase());
      }
      function _h(o) {
        o === "script" && oe("domconverter-unsafe-script-element-detected"), o === "style" && oe("domconverter-unsafe-style-element-detected");
      }
      class cn extends In() {
        constructor(e) {
          super(), this._isEnabled = !1, this.view = e, this.document = e.document;
        }
        get isEnabled() {
          return this._isEnabled;
        }
        enable() {
          this._isEnabled = !0;
        }
        disable() {
          this._isEnabled = !1;
        }
        destroy() {
          this.disable(), this.stopListening();
        }
        checkShouldIgnoreEventFromTarget(e) {
          return e && e.nodeType === 3 && (e = e.parentNode), !(!e || e.nodeType !== 1) && e.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
        }
      }
      const Ah = Ta(function(o, e) {
        To(e, Po(e), o);
      });
      class Vo {
        constructor(e, t, n) {
          this.view = e, this.document = e.document, this.domEvent = t, this.domTarget = t.target, Ah(this, n);
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget);
        }
        preventDefault() {
          this.domEvent.preventDefault();
        }
        stopPropagation() {
          this.domEvent.stopPropagation();
        }
      }
      class Pn extends cn {
        constructor() {
          super(...arguments), this.useCapture = !1;
        }
        observe(e) {
          (typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType).forEach((t) => {
            this.listenTo(e, t, (n, i) => {
              this.isEnabled && !this.checkShouldIgnoreEventFromTarget(i.target) && this.onDomEvent(i);
            }, { useCapture: this.useCapture });
          });
        }
        stopObserving(e) {
          this.stopListening(e);
        }
        fire(e, t, n) {
          this.isEnabled && this.document.fire(e, new Vo(this.view, t, n));
        }
      }
      class TA extends Pn {
        constructor() {
          super(...arguments), this.domEventType = ["keydown", "keyup"];
        }
        onDomEvent(e) {
          const t = { keyCode: e.keyCode, altKey: e.altKey, ctrlKey: e.ctrlKey, shiftKey: e.shiftKey, metaKey: e.metaKey, get keystroke() {
            return zo(this);
          } };
          this.fire(e.type, e, t);
        }
      }
      const Ha = function() {
        return Zt.Date.now();
      };
      var IA = /\s/;
      const PA = function(o) {
        for (var e = o.length; e-- && IA.test(o.charAt(e)); )
          ;
        return e;
      };
      var OA = /^\s+/;
      const RA = function(o) {
        return o && o.slice(0, PA(o) + 1).replace(OA, "");
      };
      var zA = /^[-+]0x[0-9a-f]+$/i, MA = /^0b[01]+$/i, NA = /^0o[0-7]+$/i, FA = parseInt;
      const Ch = function(o) {
        if (typeof o == "number")
          return o;
        if (zr(o))
          return NaN;
        if (K(o)) {
          var e = typeof o.valueOf == "function" ? o.valueOf() : o;
          o = K(e) ? e + "" : e;
        }
        if (typeof o != "string")
          return o === 0 ? o : +o;
        o = RA(o);
        var t = MA.test(o);
        return t || NA.test(o) ? FA(o.slice(2), t ? 2 : 8) : zA.test(o) ? NaN : +o;
      };
      var $A = Math.max, VA = Math.min;
      const Pi = function(o, e, t) {
        var n, i, r, s, a, l, d = 0, h = !1, m = !1, f = !0;
        if (typeof o != "function")
          throw new TypeError("Expected a function");
        function _(N) {
          var U = n, ee = i;
          return n = i = void 0, d = N, s = o.apply(ee, U);
        }
        function S(N) {
          var U = N - l;
          return l === void 0 || U >= e || U < 0 || m && N - d >= r;
        }
        function B() {
          var N = Ha();
          if (S(N))
            return T(N);
          a = setTimeout(B, function(U) {
            var ee = e - (U - l);
            return m ? VA(ee, r - (U - d)) : ee;
          }(N));
        }
        function T(N) {
          return a = void 0, f && n ? _(N) : (n = i = void 0, s);
        }
        function R() {
          var N = Ha(), U = S(N);
          if (n = arguments, i = this, l = N, U) {
            if (a === void 0)
              return function(ee) {
                return d = ee, a = setTimeout(B, e), h ? _(ee) : s;
              }(l);
            if (m)
              return clearTimeout(a), a = setTimeout(B, e), _(l);
          }
          return a === void 0 && (a = setTimeout(B, e)), s;
        }
        return e = Ch(e) || 0, K(t) && (h = !!t.leading, r = (m = "maxWait" in t) ? $A(Ch(t.maxWait) || 0, e) : r, f = "trailing" in t ? !!t.trailing : f), R.cancel = function() {
          a !== void 0 && clearTimeout(a), d = 0, n = l = i = a = void 0;
        }, R.flush = function() {
          return a === void 0 ? s : T(Ha());
        }, R;
      };
      class LA extends cn {
        constructor(e) {
          super(e), this._fireSelectionChangeDoneDebounced = Pi((t) => {
            this.document.fire("selectionChangeDone", t);
          }, 200);
        }
        observe() {
          const e = this.document;
          e.on("arrowKey", (t, n) => {
            e.selection.isFake && this.isEnabled && n.preventDefault();
          }, { context: "$capture" }), e.on("arrowKey", (t, n) => {
            e.selection.isFake && this.isEnabled && this._handleSelectionMove(n.keyCode);
          }, { priority: "lowest" });
        }
        stopObserving() {
        }
        destroy() {
          super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionMove(e) {
          const t = this.document.selection, n = new an(t.getRanges(), { backward: t.isBackward, fake: !1 });
          e != Ce.arrowleft && e != Ce.arrowup || n.setTo(n.getFirstPosition()), e != Ce.arrowright && e != Ce.arrowdown || n.setTo(n.getLastPosition());
          const i = { oldSelection: t, newSelection: n, domSelection: null };
          this.document.fire("selectionChange", i), this._fireSelectionChangeDoneDebounced(i);
        }
      }
      const jA = function(o) {
        return this.__data__.set(o, "__lodash_hash_undefined__"), this;
      }, HA = function(o) {
        return this.__data__.has(o);
      };
      function jr(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.__data__ = new wr(); ++e < t; )
          this.add(o[e]);
      }
      jr.prototype.add = jr.prototype.push = jA, jr.prototype.has = HA;
      const UA = jr, qA = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length; ++t < n; )
          if (e(o[t], t, o))
            return !0;
        return !1;
      }, WA = function(o, e) {
        return o.has(e);
      }, yh = function(o, e, t, n, i, r) {
        var s = 1 & t, a = o.length, l = e.length;
        if (a != l && !(s && l > a))
          return !1;
        var d = r.get(o), h = r.get(e);
        if (d && h)
          return d == e && h == o;
        var m = -1, f = !0, _ = 2 & t ? new UA() : void 0;
        for (r.set(o, e), r.set(e, o); ++m < a; ) {
          var S = o[m], B = e[m];
          if (n)
            var T = s ? n(B, S, m, e, o, r) : n(S, B, m, o, e, r);
          if (T !== void 0) {
            if (T)
              continue;
            f = !1;
            break;
          }
          if (_) {
            if (!qA(e, function(R, N) {
              if (!WA(_, N) && (S === R || i(S, R, t, n, r)))
                return _.push(N);
            })) {
              f = !1;
              break;
            }
          } else if (S !== B && !i(S, B, t, n, r)) {
            f = !1;
            break;
          }
        }
        return r.delete(o), r.delete(e), f;
      }, GA = function(o) {
        var e = -1, t = Array(o.size);
        return o.forEach(function(n, i) {
          t[++e] = [i, n];
        }), t;
      }, KA = function(o) {
        var e = -1, t = Array(o.size);
        return o.forEach(function(n) {
          t[++e] = n;
        }), t;
      };
      var Eh = on ? on.prototype : void 0, Ua = Eh ? Eh.valueOf : void 0;
      const ZA = function(o, e, t, n, i, r, s) {
        switch (t) {
          case "[object DataView]":
            if (o.byteLength != e.byteLength || o.byteOffset != e.byteOffset)
              return !1;
            o = o.buffer, e = e.buffer;
          case "[object ArrayBuffer]":
            return !(o.byteLength != e.byteLength || !r(new Cr(o), new Cr(e)));
          case "[object Boolean]":
          case "[object Date]":
          case "[object Number]":
            return ki(+o, +e);
          case "[object Error]":
            return o.name == e.name && o.message == e.message;
          case "[object RegExp]":
          case "[object String]":
            return o == e + "";
          case "[object Map]":
            var a = GA;
          case "[object Set]":
            var l = 1 & n;
            if (a || (a = KA), o.size != e.size && !l)
              return !1;
            var d = s.get(o);
            if (d)
              return d == e;
            n |= 2, s.set(o, e);
            var h = yh(a(o), a(e), n, i, r, s);
            return s.delete(o), h;
          case "[object Symbol]":
            if (Ua)
              return Ua.call(o) == Ua.call(e);
        }
        return !1;
      };
      var JA = Object.prototype.hasOwnProperty;
      const YA = function(o, e, t, n, i, r) {
        var s = 1 & t, a = ta(o), l = a.length;
        if (l != ta(e).length && !s)
          return !1;
        for (var d = l; d--; ) {
          var h = a[d];
          if (!(s ? h in e : JA.call(e, h)))
            return !1;
        }
        var m = r.get(o), f = r.get(e);
        if (m && f)
          return m == e && f == o;
        var _ = !0;
        r.set(o, e), r.set(e, o);
        for (var S = s; ++d < l; ) {
          var B = o[h = a[d]], T = e[h];
          if (n)
            var R = s ? n(T, B, h, e, o, r) : n(B, T, h, o, e, r);
          if (!(R === void 0 ? B === T || i(B, T, t, n, r) : R)) {
            _ = !1;
            break;
          }
          S || (S = h == "constructor");
        }
        if (_ && !S) {
          var N = o.constructor, U = e.constructor;
          N == U || !("constructor" in o) || !("constructor" in e) || typeof N == "function" && N instanceof N && typeof U == "function" && U instanceof U || (_ = !1);
        }
        return r.delete(o), r.delete(e), _;
      };
      var xh = "[object Arguments]", Sh = "[object Array]", Hr = "[object Object]", Dh = Object.prototype.hasOwnProperty;
      const QA = function(o, e, t, n, i, r) {
        var s = At(o), a = At(e), l = s ? Sh : yi(o), d = a ? Sh : yi(e), h = (l = l == xh ? Hr : l) == Hr, m = (d = d == xh ? Hr : d) == Hr, f = l == d;
        if (f && Ai(o)) {
          if (!Ai(e))
            return !1;
          s = !0, h = !1;
        }
        if (f && !h)
          return r || (r = new _i()), s || Js(o) ? yh(o, e, t, n, i, r) : ZA(o, e, l, t, n, i, r);
        if (!(1 & t)) {
          var _ = h && Dh.call(o, "__wrapped__"), S = m && Dh.call(e, "__wrapped__");
          if (_ || S) {
            var B = _ ? o.value() : o, T = S ? e.value() : e;
            return r || (r = new _i()), i(B, T, t, n, r);
          }
        }
        return !!f && (r || (r = new _i()), YA(o, e, t, n, i, r));
      }, Bh = function o(e, t, n, i, r) {
        return e === t || (e == null || t == null || !jt(e) && !jt(t) ? e != e && t != t : QA(e, t, n, i, o, r));
      }, XA = function(o, e, t) {
        var n = (t = typeof t == "function" ? t : void 0) ? t(o, e) : void 0;
        return n === void 0 ? Bh(o, e, void 0, t) : !!n;
      };
      class Th extends cn {
        constructor(e) {
          super(e), this._config = { childList: !0, characterData: !0, subtree: !0 }, this.domConverter = e.domConverter, this.renderer = e._renderer, this._domElements = /* @__PURE__ */ new Set(), this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords());
        }
        observe(e) {
          this._domElements.add(e), this.isEnabled && this._mutationObserver.observe(e, this._config);
        }
        stopObserving(e) {
          if (this._domElements.delete(e), this.isEnabled) {
            this._mutationObserver.disconnect();
            for (const t of this._domElements)
              this._mutationObserver.observe(t, this._config);
          }
        }
        enable() {
          super.enable();
          for (const e of this._domElements)
            this._mutationObserver.observe(e, this._config);
        }
        disable() {
          super.disable(), this._mutationObserver.disconnect();
        }
        destroy() {
          super.destroy(), this._mutationObserver.disconnect();
        }
        _onMutations(e) {
          if (e.length === 0)
            return;
          const t = this.domConverter, n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
          for (const s of e) {
            const a = t.mapDomToView(s.target);
            a && (a.is("uiElement") || a.is("rawElement") || s.type !== "childList" || this._isBogusBrMutation(s) || i.add(a));
          }
          for (const s of e) {
            const a = t.mapDomToView(s.target);
            if ((!a || !a.is("uiElement") && !a.is("rawElement")) && s.type === "characterData") {
              const l = t.findCorrespondingViewText(s.target);
              l && !i.has(l.parent) ? n.add(l) : !l && Nt(s.target) && i.add(t.mapDomToView(s.target.parentNode));
            }
          }
          let r = !1;
          for (const s of n)
            r = !0, this.renderer.markToSync("text", s);
          for (const s of i) {
            const a = t.mapViewToDom(s), l = Array.from(s.getChildren()), d = Array.from(t.domChildrenToView(a, { withChildren: !1 }));
            XA(l, d, eC) || (r = !0, this.renderer.markToSync("children", s));
          }
          r && this.view.forceRender();
        }
        _isBogusBrMutation(e) {
          let t = null;
          return e.nextSibling === null && e.removedNodes.length === 0 && e.addedNodes.length == 1 && (t = this.domConverter.domToView(e.addedNodes[0], { withChildren: !1 })), t && t.is("element", "br");
        }
      }
      function eC(o, e) {
        if (!Array.isArray(o))
          return o === e || !(!o.is("$text") || !e.is("$text")) && o.data === e.data;
      }
      class qa extends Pn {
        constructor(e) {
          super(e), this._isFocusChanging = !1, this.domEventType = ["focus", "blur"], this.useCapture = !0;
          const t = this.document;
          t.on("focus", () => {
            this._isFocusChanging = !0, this._renderTimeoutId = setTimeout(() => {
              this.flush(), e.change(() => {
              });
            }, 50);
          }), t.on("blur", (n, i) => {
            const r = t.selection.editableElement;
            r !== null && r !== i.target || (t.isFocused = !1, this._isFocusChanging = !1, e.change(() => {
            }));
          });
        }
        flush() {
          this._isFocusChanging && (this._isFocusChanging = !1, this.document.isFocused = !0);
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
        destroy() {
          this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
        }
      }
      class tC extends cn {
        constructor(e) {
          super(e), this.mutationObserver = e.getObserver(Th), this.focusObserver = e.getObserver(qa), this.selection = this.document.selection, this.domConverter = e.domConverter, this._documents = /* @__PURE__ */ new WeakSet(), this._fireSelectionChangeDoneDebounced = Pi((t) => {
            this.document.fire("selectionChangeDone", t);
          }, 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = Pi(() => this.document.isSelecting = !1, 5e3), this._loopbackCounter = 0;
        }
        observe(e) {
          const t = e.ownerDocument, n = () => {
            this.document.isSelecting && (this._handleSelectionChange(null, t), this.document.isSelecting = !1, this._documentIsSelectingInactivityTimeoutDebounced.cancel());
          };
          this.listenTo(e, "selectstart", () => {
            this.document.isSelecting = !0, this._documentIsSelectingInactivityTimeoutDebounced();
          }, { priority: "highest" }), this.listenTo(e, "keydown", n, { priority: "highest", useCapture: !0 }), this.listenTo(e, "keyup", n, { priority: "highest", useCapture: !0 }), this._documents.has(t) || (this.listenTo(t, "mouseup", n, { priority: "highest", useCapture: !0 }), this.listenTo(t, "selectionchange", (i, r) => {
            this.document.isComposing && !k.isAndroid || (this._handleSelectionChange(r, t), this._documentIsSelectingInactivityTimeoutDebounced());
          }), this._documents.add(t));
        }
        stopObserving(e) {
          this.stopListening(e);
        }
        destroy() {
          super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel();
        }
        _reportInfiniteLoop() {
        }
        _handleSelectionChange(e, t) {
          if (!this.isEnabled)
            return;
          const n = t.defaultView.getSelection();
          if (this.checkShouldIgnoreEventFromTarget(n.anchorNode))
            return;
          this.mutationObserver.flush();
          const i = this.domConverter.domSelectionToView(n);
          if (i.rangeCount != 0) {
            if (this.view.hasDomSelection = !0, !this.selection.isEqual(i) || !this.domConverter.isDomSelectionCorrect(n))
              if (++this._loopbackCounter > 60)
                this._reportInfiniteLoop();
              else if (this.focusObserver.flush(), this.selection.isSimilar(i))
                this.view.forceRender();
              else {
                const r = { oldSelection: this.selection, newSelection: i, domSelection: n };
                this.document.fire("selectionChange", r), this._fireSelectionChangeDoneDebounced(r);
              }
          } else
            this.view.hasDomSelection = !1;
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0;
        }
      }
      class nC extends Pn {
        constructor(e) {
          super(e), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
          const t = this.document;
          t.on("compositionstart", () => {
            t.isComposing = !0;
          }, { priority: "low" }), t.on("compositionend", () => {
            t.isComposing = !1;
          }, { priority: "low" });
        }
        onDomEvent(e) {
          this.fire(e.type, e, { data: e.data });
        }
      }
      class Ih {
        constructor(e, t = {}) {
          this._files = t.cacheFiles ? Ph(e) : null, this._native = e;
        }
        get files() {
          return this._files || (this._files = Ph(this._native)), this._files;
        }
        get types() {
          return this._native.types;
        }
        getData(e) {
          return this._native.getData(e);
        }
        setData(e, t) {
          this._native.setData(e, t);
        }
        set effectAllowed(e) {
          this._native.effectAllowed = e;
        }
        get effectAllowed() {
          return this._native.effectAllowed;
        }
        set dropEffect(e) {
          this._native.dropEffect = e;
        }
        get dropEffect() {
          return this._native.dropEffect;
        }
        setDragImage(e, t, n) {
          this._native.setDragImage(e, t, n);
        }
        get isCanceled() {
          return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
        }
      }
      function Ph(o) {
        const e = Array.from(o.files || []), t = Array.from(o.items || []);
        return e.length ? e : t.filter((n) => n.kind === "file").map((n) => n.getAsFile());
      }
      class oC extends Pn {
        constructor() {
          super(...arguments), this.domEventType = "beforeinput";
        }
        onDomEvent(e) {
          const t = e.getTargetRanges(), n = this.view, i = n.document;
          let r = null, s = null, a = [];
          if (e.dataTransfer && (r = new Ih(e.dataTransfer)), e.data !== null ? s = e.data : r && (s = r.getData("text/plain")), i.selection.isFake)
            a = Array.from(i.selection.getRanges());
          else if (t.length)
            a = t.map((l) => n.domConverter.domRangeToView(l));
          else if (k.isAndroid) {
            const l = e.target.ownerDocument.defaultView.getSelection();
            a = Array.from(n.domConverter.domSelectionToView(l).getRanges());
          }
          if (k.isAndroid && e.inputType == "insertCompositionText" && s && s.endsWith(`
`))
            this.fire(e.type, e, { inputType: "insertParagraph", targetRanges: [n.createRange(a[0].end)] });
          else if (e.inputType == "insertText" && s && s.includes(`
`)) {
            const l = s.split(/\n{1,2}/g);
            let d = a;
            for (let h = 0; h < l.length; h++) {
              const m = l[h];
              m != "" && (this.fire(e.type, e, { data: m, dataTransfer: r, targetRanges: d, inputType: e.inputType, isComposing: e.isComposing }), d = [i.selection.getFirstRange()]), h + 1 < l.length && (this.fire(e.type, e, { inputType: "insertParagraph", targetRanges: d }), d = [i.selection.getFirstRange()]);
            }
          } else
            this.fire(e.type, e, { data: s, dataTransfer: r, targetRanges: a, inputType: e.inputType, isComposing: e.isComposing });
        }
      }
      class iC extends cn {
        constructor(e) {
          super(e), this.document.on("keydown", (t, n) => {
            if (this.isEnabled && ((i = n.keyCode) == Ce.arrowright || i == Ce.arrowleft || i == Ce.arrowup || i == Ce.arrowdown)) {
              const r = new Fo(this.document, "arrowKey", this.document.selection.getFirstRange());
              this.document.fire(r, n), r.stop.called && t.stop();
            }
            var i;
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class rC extends cn {
        constructor(e) {
          super(e);
          const t = this.document;
          t.on("keydown", (n, i) => {
            if (!this.isEnabled || i.keyCode != Ce.tab || i.ctrlKey)
              return;
            const r = new Fo(t, "tab", t.selection.getFirstRange());
            t.fire(r, i), r.stop.called && n.stop();
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class sC extends re() {
        constructor(e) {
          super(), this.domRoots = /* @__PURE__ */ new Map(), this._initialDomRootAttributes = /* @__PURE__ */ new WeakMap(), this._observers = /* @__PURE__ */ new Map(), this._ongoingChange = !1, this._postFixersInProgress = !1, this._renderingDisabled = !1, this._hasChangedSinceTheLastRendering = !1, this.document = new ih(e), this.domConverter = new kh(this.document), this.set("isRenderingInProgress", !1), this.set("hasDomSelection", !1), this._renderer = new CA(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new rh(this.document), this.addObserver(Th), this.addObserver(qa), this.addObserver(tC), this.addObserver(TA), this.addObserver(LA), this.addObserver(nC), this.addObserver(iC), this.addObserver(oC), this.addObserver(rC), this.document.on("arrowKey", _A, { priority: "low" }), fA(this), this.on("render", () => {
            this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = !1;
          }), this.listenTo(this.document.selection, "change", () => {
            this._hasChangedSinceTheLastRendering = !0;
          }), this.listenTo(this.document, "change:isFocused", () => {
            this._hasChangedSinceTheLastRendering = !0;
          });
        }
        attachDomRoot(e, t = "main") {
          const n = this.document.getRoot(t);
          n._name = e.tagName.toLowerCase();
          const i = {};
          for (const { name: s, value: a } of Array.from(e.attributes))
            i[s] = a, s === "class" ? this._writer.addClass(a.split(" "), n) : this._writer.setAttribute(s, a, n);
          this._initialDomRootAttributes.set(e, i);
          const r = () => {
            this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n), n.isReadOnly ? this._writer.addClass("ck-read-only", n) : this._writer.removeClass("ck-read-only", n);
          };
          r(), this.domRoots.set(t, e), this.domConverter.bindElements(e, n), this._renderer.markToSync("children", n), this._renderer.markToSync("attributes", n), this._renderer.domDocuments.add(e.ownerDocument), n.on("change:children", (s, a) => this._renderer.markToSync("children", a)), n.on("change:attributes", (s, a) => this._renderer.markToSync("attributes", a)), n.on("change:text", (s, a) => this._renderer.markToSync("text", a)), n.on("change:isReadOnly", () => this.change(r)), n.on("change", () => {
            this._hasChangedSinceTheLastRendering = !0;
          });
          for (const s of this._observers.values())
            s.observe(e, t);
        }
        detachDomRoot(e) {
          const t = this.domRoots.get(e);
          Array.from(t.attributes).forEach(({ name: i }) => t.removeAttribute(i));
          const n = this._initialDomRootAttributes.get(t);
          for (const i in n)
            t.setAttribute(i, n[i]);
          this.domRoots.delete(e), this.domConverter.unbindDomElement(t);
          for (const i of this._observers.values())
            i.stopObserving(t);
        }
        getDomRoot(e = "main") {
          return this.domRoots.get(e);
        }
        addObserver(e) {
          let t = this._observers.get(e);
          if (t)
            return t;
          t = new e(this), this._observers.set(e, t);
          for (const [n, i] of this.domRoots)
            t.observe(i, n);
          return t.enable(), t;
        }
        getObserver(e) {
          return this._observers.get(e);
        }
        disableObservers() {
          for (const e of this._observers.values())
            e.disable();
        }
        enableObservers() {
          for (const e of this._observers.values())
            e.enable();
        }
        scrollToTheSelection({ alignToTop: e, forceScroll: t, viewportOffset: n = 20, ancestorOffset: i = 20 } = {}) {
          const r = this.document.selection.getFirstRange();
          r && function({ target: s, viewportOffset: a = 0, ancestorOffset: l = 0, alignToTop: d, forceScroll: h }) {
            const m = ha(s);
            let f = m, _ = null;
            for (; f; ) {
              let S;
              S = l_(f == m ? s : _), a_({ parent: S, getRect: () => ru(s, f), alignToTop: d, ancestorOffset: l, forceScroll: h });
              const B = ru(s, f);
              if (s_({ window: f, rect: B, viewportOffset: a, alignToTop: d, forceScroll: h }), f.parent != f) {
                if (_ = f.frameElement, f = f.parent, !_)
                  return;
              } else
                f = null;
            }
          }({ target: this.domConverter.viewRangeToDom(r), viewportOffset: n, ancestorOffset: i, alignToTop: e, forceScroll: t });
        }
        focus() {
          if (!this.document.isFocused) {
            const e = this.document.selection.editableElement;
            e && (this.domConverter.focus(e), this.forceRender());
          }
        }
        change(e) {
          if (this.isRenderingInProgress || this._postFixersInProgress)
            throw new O("cannot-change-view-tree", this);
          try {
            if (this._ongoingChange)
              return e(this._writer);
            this._ongoingChange = !0;
            const t = e(this._writer);
            return this._ongoingChange = !1, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0, this.document._callPostFixers(this._writer), this._postFixersInProgress = !1, this.fire("render")), t;
          } catch (t) {
            O.rethrowUnexpectedError(t, this);
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = !0, this.getObserver(qa).flush(), this.change(() => {
          });
        }
        destroy() {
          for (const e of this._observers.values())
            e.destroy();
          this.document.destroy(), this.stopListening();
        }
        createPositionAt(e, t) {
          return J._createAt(e, t);
        }
        createPositionAfter(e) {
          return J._createAfter(e);
        }
        createPositionBefore(e) {
          return J._createBefore(e);
        }
        createRange(e, t) {
          return new ae(e, t);
        }
        createRangeOn(e) {
          return ae._createOn(e);
        }
        createRangeIn(e) {
          return ae._createIn(e);
        }
        createSelection(...e) {
          return new an(...e);
        }
        _disableRendering(e) {
          this._renderingDisabled = e, e == 0 && this.change(() => {
          });
        }
        _render() {
          this.isRenderingInProgress = !0, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = !1;
        }
      }
      class On {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      class io extends On {
        constructor(e) {
          super(), this.parent = null, this._attrs = pn(e);
        }
        get document() {
          return null;
        }
        get index() {
          let e;
          if (!this.parent)
            return null;
          if ((e = this.parent.getChildIndex(this)) === null)
            throw new O("model-node-not-found-in-parent", this);
          return e;
        }
        get startOffset() {
          let e;
          if (!this.parent)
            return null;
          if ((e = this.parent.getChildStartOffset(this)) === null)
            throw new O("model-node-not-found-in-parent", this);
          return e;
        }
        get offsetSize() {
          return 1;
        }
        get endOffset() {
          return this.parent ? this.startOffset + this.offsetSize : null;
        }
        get nextSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e + 1) || null;
        }
        get previousSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e - 1) || null;
        }
        get root() {
          let e = this;
          for (; e.parent; )
            e = e.parent;
          return e;
        }
        isAttached() {
          return this.parent !== null && this.root.isAttached();
        }
        getPath() {
          const e = [];
          let t = this;
          for (; t.parent; )
            e.unshift(t.startOffset), t = t.parent;
          return e;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this : this.parent;
          for (; n; )
            t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
        getCommonAncestor(e, t = {}) {
          const n = this.getAncestors(t), i = e.getAncestors(t);
          let r = 0;
          for (; n[r] == i[r] && n[r]; )
            r++;
          return r === 0 ? null : n[r - 1];
        }
        isBefore(e) {
          if (this == e || this.root !== e.root)
            return !1;
          const t = this.getPath(), n = e.getPath(), i = _t(t, n);
          switch (i) {
            case "prefix":
              return !0;
            case "extension":
              return !1;
            default:
              return t[i] < n[i];
          }
        }
        isAfter(e) {
          return this != e && this.root === e.root && !this.isBefore(e);
        }
        hasAttribute(e) {
          return this._attrs.has(e);
        }
        getAttribute(e) {
          return this._attrs.get(e);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        toJSON() {
          const e = {};
          return this._attrs.size && (e.attributes = Array.from(this._attrs).reduce((t, n) => (t[n[0]] = n[1], t), {})), e;
        }
        _clone(e) {
          return new this.constructor(this._attrs);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _setAttribute(e, t) {
          this._attrs.set(e, t);
        }
        _setAttributesTo(e) {
          this._attrs = pn(e);
        }
        _removeAttribute(e) {
          return this._attrs.delete(e);
        }
        _clearAttributes() {
          this._attrs.clear();
        }
      }
      io.prototype.is = function(o) {
        return o === "node" || o === "model:node";
      };
      class Oi {
        constructor(e) {
          this._nodes = [], e && this._insertNodes(0, e);
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]();
        }
        get length() {
          return this._nodes.length;
        }
        get maxOffset() {
          return this._nodes.reduce((e, t) => e + t.offsetSize, 0);
        }
        getNode(e) {
          return this._nodes[e] || null;
        }
        getNodeIndex(e) {
          const t = this._nodes.indexOf(e);
          return t == -1 ? null : t;
        }
        getNodeStartOffset(e) {
          const t = this.getNodeIndex(e);
          return t === null ? null : this._nodes.slice(0, t).reduce((n, i) => n + i.offsetSize, 0);
        }
        indexToOffset(e) {
          if (e == this._nodes.length)
            return this.maxOffset;
          const t = this._nodes[e];
          if (!t)
            throw new O("model-nodelist-index-out-of-bounds", this);
          return this.getNodeStartOffset(t);
        }
        offsetToIndex(e) {
          let t = 0;
          for (const n of this._nodes) {
            if (e >= t && e < t + n.offsetSize)
              return this.getNodeIndex(n);
            t += n.offsetSize;
          }
          if (t != e)
            throw new O("model-nodelist-offset-out-of-bounds", this, { offset: e, nodeList: this });
          return this.length;
        }
        _insertNodes(e, t) {
          for (const n of t)
            if (!(n instanceof io))
              throw new O("model-nodelist-insertnodes-not-node", this);
          this._nodes = function(n, i, r, s) {
            if (Math.max(i.length, n.length) > 1e4)
              return n.slice(0, r).concat(i).concat(n.slice(r + s, n.length));
            {
              const a = Array.from(n);
              return a.splice(r, s, ...i), a;
            }
          }(this._nodes, Array.from(t), e, 0);
        }
        _removeNodes(e, t = 1) {
          return this._nodes.splice(e, t);
        }
        toJSON() {
          return this._nodes.map((e) => e.toJSON());
        }
      }
      class Ne extends io {
        constructor(e, t) {
          super(t), this._data = e || "";
        }
        get offsetSize() {
          return this.data.length;
        }
        get data() {
          return this._data;
        }
        toJSON() {
          const e = super.toJSON();
          return e.data = this.data, e;
        }
        _clone() {
          return new Ne(this.data, this.getAttributes());
        }
        static fromJSON(e) {
          return new Ne(e.data, e.attributes);
        }
      }
      Ne.prototype.is = function(o) {
        return o === "$text" || o === "model:$text" || o === "text" || o === "model:text" || o === "node" || o === "model:node";
      };
      class Yt extends On {
        constructor(e, t, n) {
          if (super(), this.textNode = e, t < 0 || t > e.offsetSize)
            throw new O("model-textproxy-wrong-offsetintext", this);
          if (n < 0 || t + n > e.offsetSize)
            throw new O("model-textproxy-wrong-length", this);
          this.data = e.data.substring(t, t + n), this.offsetInText = t;
        }
        get startOffset() {
          return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
        }
        get offsetSize() {
          return this.data.length;
        }
        get endOffset() {
          return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        getPath() {
          const e = this.textNode.getPath();
          return e.length > 0 && (e[e.length - 1] += this.offsetInText), e;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this : this.parent;
          for (; n; )
            t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
        hasAttribute(e) {
          return this.textNode.hasAttribute(e);
        }
        getAttribute(e) {
          return this.textNode.getAttribute(e);
        }
        getAttributes() {
          return this.textNode.getAttributes();
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys();
        }
      }
      Yt.prototype.is = function(o) {
        return o === "$textProxy" || o === "model:$textProxy" || o === "textProxy" || o === "model:textProxy";
      };
      class Fe extends io {
        constructor(e, t, n) {
          super(t), this._children = new Oi(), this.name = e, n && this._insertChild(0, n);
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        getChild(e) {
          return this._children.getNode(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(e) {
          return this._children.getNodeIndex(e);
        }
        getChildStartOffset(e) {
          return this._children.getNodeStartOffset(e);
        }
        offsetToIndex(e) {
          return this._children.offsetToIndex(e);
        }
        getNodeByPath(e) {
          let t = this;
          for (const n of e)
            t = t.getChild(t.offsetToIndex(n));
          return t;
        }
        findAncestor(e, t = {}) {
          let n = t.includeSelf ? this : this.parent;
          for (; n; ) {
            if (n.name === e)
              return n;
            n = n.parent;
          }
          return null;
        }
        toJSON() {
          const e = super.toJSON();
          if (e.name = this.name, this._children.length > 0) {
            e.children = [];
            for (const t of this._children)
              e.children.push(t.toJSON());
          }
          return e;
        }
        _clone(e = !1) {
          const t = e ? Array.from(this._children).map((n) => n._clone(!0)) : void 0;
          return new Fe(this.name, this.getAttributes(), t);
        }
        _appendChild(e) {
          this._insertChild(this.childCount, e);
        }
        _insertChild(e, t) {
          const n = function(i) {
            return typeof i == "string" ? [new Ne(i)] : (zt(i) || (i = [i]), Array.from(i).map((r) => typeof r == "string" ? new Ne(r) : r instanceof Yt ? new Ne(r.data, r.getAttributes()) : r));
          }(t);
          for (const i of n)
            i.parent !== null && i._remove(), i.parent = this;
          this._children._insertNodes(e, n);
        }
        _removeChildren(e, t = 1) {
          const n = this._children._removeNodes(e, t);
          for (const i of n)
            i.parent = null;
          return n;
        }
        static fromJSON(e) {
          let t;
          if (e.children) {
            t = [];
            for (const n of e.children)
              n.name ? t.push(Fe.fromJSON(n)) : t.push(Ne.fromJSON(n));
          }
          return new Fe(e.name, e.attributes, t);
        }
      }
      Fe.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "element" || o === "model:element") : o === "element" || o === "model:element" || o === "node" || o === "model:node";
      };
      class dn {
        constructor(e) {
          if (!e || !e.boundaries && !e.startPosition)
            throw new O("model-tree-walker-no-start-position", null);
          const t = e.direction || "forward";
          if (t != "forward" && t != "backward")
            throw new O("model-tree-walker-unknown-direction", e, { direction: t });
          this.direction = t, this.boundaries = e.boundaries || null, e.startPosition ? this._position = e.startPosition.clone() : this._position = q._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(e) {
          let t, n, i, r;
          do
            i = this.position, r = this._visitedParent, { done: t, value: n } = this.next();
          while (!t && e(n));
          t || (this._position = i, this._visitedParent = r);
        }
        next() {
          return this.direction == "forward" ? this._next() : this._previous();
        }
        _next() {
          const e = this.position, t = this.position.clone(), n = this._visitedParent;
          if (n.parent === null && t.offset === n.maxOffset)
            return { done: !0, value: void 0 };
          if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset)
            return { done: !0, value: void 0 };
          const i = Ri(t, n), r = i || Oh(t, n, i);
          if (r instanceof Fe)
            return this.shallow ? t.offset++ : (t.path.push(0), this._visitedParent = r), this._position = t, ro("elementStart", r, e, t, 1);
          if (r instanceof Ne) {
            let s;
            if (this.singleCharacters)
              s = 1;
            else {
              let d = r.endOffset;
              this._boundaryEndParent == n && this.boundaries.end.offset < d && (d = this.boundaries.end.offset), s = d - t.offset;
            }
            const a = t.offset - r.startOffset, l = new Yt(r, a, s);
            return t.offset += s, this._position = t, ro("text", l, e, t, s);
          }
          return t.path.pop(), t.offset++, this._position = t, this._visitedParent = n.parent, this.ignoreElementEnd ? this._next() : ro("elementEnd", n, e, t);
        }
        _previous() {
          const e = this.position, t = this.position.clone(), n = this._visitedParent;
          if (n.parent === null && t.offset === 0)
            return { done: !0, value: void 0 };
          if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset)
            return { done: !0, value: void 0 };
          const i = t.parent, r = Ri(t, i), s = r || Rh(t, i, r);
          if (s instanceof Fe)
            return t.offset--, this.shallow ? (this._position = t, ro("elementStart", s, e, t, 1)) : (t.path.push(s.maxOffset), this._position = t, this._visitedParent = s, this.ignoreElementEnd ? this._previous() : ro("elementEnd", s, e, t));
          if (s instanceof Ne) {
            let a;
            if (this.singleCharacters)
              a = 1;
            else {
              let h = s.startOffset;
              this._boundaryStartParent == n && this.boundaries.start.offset > h && (h = this.boundaries.start.offset), a = t.offset - h;
            }
            const l = t.offset - s.startOffset, d = new Yt(s, l - a, a);
            return t.offset -= a, this._position = t, ro("text", d, e, t, a);
          }
          return t.path.pop(), this._position = t, this._visitedParent = n.parent, ro("elementStart", n, e, t, 1);
        }
      }
      function ro(o, e, t, n, i) {
        return { done: !1, value: { type: o, item: e, previousPosition: t, nextPosition: n, length: i } };
      }
      class q extends On {
        constructor(e, t, n = "toNone") {
          if (super(), !e.is("element") && !e.is("documentFragment"))
            throw new O("model-position-root-invalid", e);
          if (!(t instanceof Array) || t.length === 0)
            throw new O("model-position-path-incorrect-format", e, { path: t });
          e.is("rootElement") ? t = t.slice() : (t = [...e.getPath(), ...t], e = e.root), this.root = e, this.path = t, this.stickiness = n;
        }
        get offset() {
          return this.path[this.path.length - 1];
        }
        set offset(e) {
          this.path[this.path.length - 1] = e;
        }
        get parent() {
          let e = this.root;
          for (let t = 0; t < this.path.length - 1; t++)
            if (e = e.getChild(e.offsetToIndex(this.path[t])), !e)
              throw new O("model-position-path-incorrect", this, { position: this });
          if (e.is("$text"))
            throw new O("model-position-path-incorrect", this, { position: this });
          return e;
        }
        get index() {
          return this.parent.offsetToIndex(this.offset);
        }
        get textNode() {
          return Ri(this, this.parent);
        }
        get nodeAfter() {
          const e = this.parent;
          return Oh(this, e, Ri(this, e));
        }
        get nodeBefore() {
          const e = this.parent;
          return Rh(this, e, Ri(this, e));
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset;
        }
        compareWith(e) {
          if (this.root != e.root)
            return "different";
          const t = _t(this.path, e.path);
          switch (t) {
            case "same":
              return "same";
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return this.path[t] < e.path[t] ? "before" : "after";
          }
        }
        getLastMatchingPosition(e, t = {}) {
          t.startPosition = this;
          const n = new dn(t);
          return n.skip(e), n.position;
        }
        getParentPath() {
          return this.path.slice(0, -1);
        }
        getAncestors() {
          const e = this.parent;
          return e.is("documentFragment") ? [e] : e.getAncestors({ includeSelf: !0 });
        }
        findAncestor(e) {
          const t = this.parent;
          return t.is("element") ? t.findAncestor(e, { includeSelf: !0 }) : null;
        }
        getCommonPath(e) {
          if (this.root != e.root)
            return [];
          const t = _t(this.path, e.path), n = typeof t == "string" ? Math.min(this.path.length, e.path.length) : t;
          return this.path.slice(0, n);
        }
        getCommonAncestor(e) {
          const t = this.getAncestors(), n = e.getAncestors();
          let i = 0;
          for (; t[i] == n[i] && t[i]; )
            i++;
          return i === 0 ? null : t[i - 1];
        }
        getShiftedBy(e) {
          const t = this.clone(), n = t.offset + e;
          return t.offset = n < 0 ? 0 : n, t;
        }
        isAfter(e) {
          return this.compareWith(e) == "after";
        }
        isBefore(e) {
          return this.compareWith(e) == "before";
        }
        isEqual(e) {
          return this.compareWith(e) == "same";
        }
        isTouching(e) {
          if (this.root !== e.root)
            return !1;
          const t = Math.min(this.path.length, e.path.length);
          for (let n = 0; n < t; n++) {
            const i = this.path[n] - e.path[n];
            if (i < -1 || i > 1)
              return !1;
            if (i === 1)
              return zh(e, this, n);
            if (i === -1)
              return zh(this, e, n);
          }
          return this.path.length === e.path.length || (this.path.length > e.path.length ? Wa(this.path, t) : Wa(e.path, t));
        }
        hasSameParentAs(e) {
          return this.root !== e.root ? !1 : _t(this.getParentPath(), e.getParentPath()) == "same";
        }
        getTransformedByOperation(e) {
          let t;
          switch (e.type) {
            case "insert":
              t = this._getTransformedByInsertOperation(e);
              break;
            case "move":
            case "remove":
            case "reinsert":
              t = this._getTransformedByMoveOperation(e);
              break;
            case "split":
              t = this._getTransformedBySplitOperation(e);
              break;
            case "merge":
              t = this._getTransformedByMergeOperation(e);
              break;
            default:
              t = q._createAt(this);
          }
          return t;
        }
        _getTransformedByInsertOperation(e) {
          return this._getTransformedByInsertion(e.position, e.howMany);
        }
        _getTransformedByMoveOperation(e) {
          return this._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
        }
        _getTransformedBySplitOperation(e) {
          const t = e.movedRange;
          return t.containsPosition(this) || t.start.isEqual(this) && this.stickiness == "toNext" ? this._getCombined(e.splitPosition, e.moveTargetPosition) : e.graveyardPosition ? this._getTransformedByMove(e.graveyardPosition, e.insertionPosition, 1) : this._getTransformedByInsertion(e.insertionPosition, 1);
        }
        _getTransformedByMergeOperation(e) {
          const t = e.movedRange;
          let n;
          return t.containsPosition(this) || t.start.isEqual(this) ? (n = this._getCombined(e.sourcePosition, e.targetPosition), e.sourcePosition.isBefore(e.targetPosition) && (n = n._getTransformedByDeletion(e.deletionPosition, 1))) : n = this.isEqual(e.deletionPosition) ? q._createAt(e.deletionPosition) : this._getTransformedByMove(e.deletionPosition, e.graveyardPosition, 1), n;
        }
        _getTransformedByDeletion(e, t) {
          const n = q._createAt(this);
          if (this.root != e.root)
            return n;
          if (_t(e.getParentPath(), this.getParentPath()) == "same") {
            if (e.offset < this.offset) {
              if (e.offset + t > this.offset)
                return null;
              n.offset -= t;
            }
          } else if (_t(e.getParentPath(), this.getParentPath()) == "prefix") {
            const i = e.path.length - 1;
            if (e.offset <= this.path[i]) {
              if (e.offset + t > this.path[i])
                return null;
              n.path[i] -= t;
            }
          }
          return n;
        }
        _getTransformedByInsertion(e, t) {
          const n = q._createAt(this);
          if (this.root != e.root)
            return n;
          if (_t(e.getParentPath(), this.getParentPath()) == "same")
            (e.offset < this.offset || e.offset == this.offset && this.stickiness != "toPrevious") && (n.offset += t);
          else if (_t(e.getParentPath(), this.getParentPath()) == "prefix") {
            const i = e.path.length - 1;
            e.offset <= this.path[i] && (n.path[i] += t);
          }
          return n;
        }
        _getTransformedByMove(e, t, n) {
          if (t = t._getTransformedByDeletion(e, n), e.isEqual(t))
            return q._createAt(this);
          const i = this._getTransformedByDeletion(e, n);
          return i === null || e.isEqual(this) && this.stickiness == "toNext" || e.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious" ? this._getCombined(e, t) : i._getTransformedByInsertion(t, n);
        }
        _getCombined(e, t) {
          const n = e.path.length - 1, i = q._createAt(t);
          return i.stickiness = this.stickiness, i.offset = i.offset + this.path[n] - e.offset, i.path = [...i.path, ...this.path.slice(n + 1)], i;
        }
        toJSON() {
          return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness };
        }
        clone() {
          return new this.constructor(this.root, this.path, this.stickiness);
        }
        static _createAt(e, t, n = "toNone") {
          if (e instanceof q)
            return new q(e.root, e.path, e.stickiness);
          {
            const i = e;
            if (t == "end")
              t = i.maxOffset;
            else {
              if (t == "before")
                return this._createBefore(i, n);
              if (t == "after")
                return this._createAfter(i, n);
              if (t !== 0 && !t)
                throw new O("model-createpositionat-offset-required", [this, e]);
            }
            if (!i.is("element") && !i.is("documentFragment"))
              throw new O("model-position-parent-incorrect", [this, e]);
            const r = i.getPath();
            return r.push(t), new this(i.root, r, n);
          }
        }
        static _createAfter(e, t) {
          if (!e.parent)
            throw new O("model-position-after-root", [this, e], { root: e });
          return this._createAt(e.parent, e.endOffset, t);
        }
        static _createBefore(e, t) {
          if (!e.parent)
            throw new O("model-position-before-root", e, { root: e });
          return this._createAt(e.parent, e.startOffset, t);
        }
        static fromJSON(e, t) {
          if (e.root === "$graveyard") {
            const n = new q(t.graveyard, e.path);
            return n.stickiness = e.stickiness, n;
          }
          if (!t.getRoot(e.root))
            throw new O("model-position-fromjson-no-root", t, { rootName: e.root });
          return new q(t.getRoot(e.root), e.path, e.stickiness);
        }
      }
      function Ri(o, e) {
        const t = e.getChild(e.offsetToIndex(o.offset));
        return t && t.is("$text") && t.startOffset < o.offset ? t : null;
      }
      function Oh(o, e, t) {
        return t !== null ? null : e.getChild(e.offsetToIndex(o.offset));
      }
      function Rh(o, e, t) {
        return t !== null ? null : e.getChild(e.offsetToIndex(o.offset) - 1);
      }
      function zh(o, e, t) {
        return t + 1 !== o.path.length && !!Wa(e.path, t + 1) && !!function(n, i) {
          let r = n.parent, s = n.path.length - 1, a = 0;
          for (; s >= i; ) {
            if (n.path[s] + a !== r.maxOffset)
              return !1;
            a = 1, s--, r = r.parent;
          }
          return !0;
        }(o, t + 1);
      }
      function Wa(o, e) {
        for (; e < o.length; ) {
          if (o[e] !== 0)
            return !1;
          e++;
        }
        return !0;
      }
      q.prototype.is = function(o) {
        return o === "position" || o === "model:position";
      };
      class $ extends On {
        constructor(e, t) {
          super(), this.start = q._createAt(e), this.end = t ? q._createAt(t) : q._createAt(e), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
        }
        *[Symbol.iterator]() {
          yield* new dn({ boundaries: this, ignoreElementEnd: !0 });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return _t(this.start.getParentPath(), this.end.getParentPath()) == "same";
        }
        get root() {
          return this.start.root;
        }
        containsPosition(e) {
          return e.isAfter(this.start) && e.isBefore(this.end);
        }
        containsRange(e, t = !1) {
          e.isCollapsed && (t = !1);
          const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start), i = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
          return n && i;
        }
        containsItem(e) {
          const t = q._createBefore(e);
          return this.containsPosition(t) || this.start.isEqual(t);
        }
        isEqual(e) {
          return this.start.isEqual(e.start) && this.end.isEqual(e.end);
        }
        isIntersecting(e) {
          return this.start.isBefore(e.end) && this.end.isAfter(e.start);
        }
        getDifference(e) {
          const t = [];
          return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new $(this.start, e.start)), this.containsPosition(e.end) && t.push(new $(e.end, this.end))) : t.push(new $(this.start, this.end)), t;
        }
        getIntersection(e) {
          if (this.isIntersecting(e)) {
            let t = this.start, n = this.end;
            return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new $(t, n);
          }
          return null;
        }
        getJoined(e, t = !1) {
          let n = this.isIntersecting(e);
          if (n || (n = this.start.isBefore(e.start) ? t ? this.end.isTouching(e.start) : this.end.isEqual(e.start) : t ? e.end.isTouching(this.start) : e.end.isEqual(this.start)), !n)
            return null;
          let i = this.start, r = this.end;
          return e.start.isBefore(i) && (i = e.start), e.end.isAfter(r) && (r = e.end), new $(i, r);
        }
        getMinimalFlatRanges() {
          const e = [], t = this.start.getCommonPath(this.end).length, n = q._createAt(this.start);
          let i = n.parent;
          for (; n.path.length > t + 1; ) {
            const r = i.maxOffset - n.offset;
            r !== 0 && e.push(new $(n, n.getShiftedBy(r))), n.path = n.path.slice(0, -1), n.offset++, i = i.parent;
          }
          for (; n.path.length <= this.end.path.length; ) {
            const r = this.end.path[n.path.length - 1], s = r - n.offset;
            s !== 0 && e.push(new $(n, n.getShiftedBy(s))), n.offset = r, n.path.push(0);
          }
          return e;
        }
        getWalker(e = {}) {
          return e.boundaries = this, new dn(e);
        }
        *getItems(e = {}) {
          e.boundaries = this, e.ignoreElementEnd = !0;
          const t = new dn(e);
          for (const n of t)
            yield n.item;
        }
        *getPositions(e = {}) {
          e.boundaries = this;
          const t = new dn(e);
          yield t.position;
          for (const n of t)
            yield n.nextPosition;
        }
        getTransformedByOperation(e) {
          switch (e.type) {
            case "insert":
              return this._getTransformedByInsertOperation(e);
            case "move":
            case "remove":
            case "reinsert":
              return this._getTransformedByMoveOperation(e);
            case "split":
              return [this._getTransformedBySplitOperation(e)];
            case "merge":
              return [this._getTransformedByMergeOperation(e)];
          }
          return [new $(this.start, this.end)];
        }
        getTransformedByOperations(e) {
          const t = [new $(this.start, this.end)];
          for (const n of e)
            for (let i = 0; i < t.length; i++) {
              const r = t[i].getTransformedByOperation(n);
              t.splice(i, 1, ...r), i += r.length - 1;
            }
          for (let n = 0; n < t.length; n++) {
            const i = t[n];
            for (let r = n + 1; r < t.length; r++) {
              const s = t[r];
              (i.containsRange(s) || s.containsRange(i) || i.isEqual(s)) && t.splice(r, 1);
            }
          }
          return t;
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed)
            return null;
          const e = this.start.nodeAfter, t = this.end.nodeBefore;
          return e && e.is("element") && e === t ? e : null;
        }
        toJSON() {
          return { start: this.start.toJSON(), end: this.end.toJSON() };
        }
        clone() {
          return new this.constructor(this.start, this.end);
        }
        _getTransformedByInsertOperation(e, t = !1) {
          return this._getTransformedByInsertion(e.position, e.howMany, t);
        }
        _getTransformedByMoveOperation(e, t = !1) {
          const n = e.sourcePosition, i = e.howMany, r = e.targetPosition;
          return this._getTransformedByMove(n, r, i, t);
        }
        _getTransformedBySplitOperation(e) {
          const t = this.start._getTransformedBySplitOperation(e);
          let n = this.end._getTransformedBySplitOperation(e);
          return this.end.isEqual(e.insertionPosition) && (n = this.end.getShiftedBy(1)), t.root != n.root && (n = this.end.getShiftedBy(-1)), new $(t, n);
        }
        _getTransformedByMergeOperation(e) {
          if (this.start.isEqual(e.targetPosition) && this.end.isEqual(e.deletionPosition))
            return new $(this.start);
          let t = this.start._getTransformedByMergeOperation(e), n = this.end._getTransformedByMergeOperation(e);
          return t.root != n.root && (n = this.end.getShiftedBy(-1)), t.isAfter(n) ? (e.sourcePosition.isBefore(e.targetPosition) ? (t = q._createAt(n), t.offset = 0) : (e.deletionPosition.isEqual(t) || (n = e.deletionPosition), t = e.targetPosition), new $(t, n)) : new $(t, n);
        }
        _getTransformedByInsertion(e, t, n = !1) {
          if (n && this.containsPosition(e))
            return [new $(this.start, e), new $(e.getShiftedBy(t), this.end._getTransformedByInsertion(e, t))];
          {
            const i = new $(this.start, this.end);
            return i.start = i.start._getTransformedByInsertion(e, t), i.end = i.end._getTransformedByInsertion(e, t), [i];
          }
        }
        _getTransformedByMove(e, t, n, i = !1) {
          if (this.isCollapsed) {
            const m = this.start._getTransformedByMove(e, t, n);
            return [new $(m)];
          }
          const r = $._createFromPositionAndShift(e, n), s = t._getTransformedByDeletion(e, n);
          if (this.containsPosition(t) && !i && (r.containsPosition(this.start) || r.containsPosition(this.end))) {
            const m = this.start._getTransformedByMove(e, t, n), f = this.end._getTransformedByMove(e, t, n);
            return [new $(m, f)];
          }
          let a;
          const l = this.getDifference(r);
          let d = null;
          const h = this.getIntersection(r);
          if (l.length == 1 ? d = new $(l[0].start._getTransformedByDeletion(e, n), l[0].end._getTransformedByDeletion(e, n)) : l.length == 2 && (d = new $(this.start, this.end._getTransformedByDeletion(e, n))), a = d ? d._getTransformedByInsertion(s, n, h !== null || i) : [], h) {
            const m = new $(h.start._getCombined(r.start, s), h.end._getCombined(r.start, s));
            a.length == 2 ? a.splice(1, 0, m) : a.push(m);
          }
          return a;
        }
        _getTransformedByDeletion(e, t) {
          let n = this.start._getTransformedByDeletion(e, t), i = this.end._getTransformedByDeletion(e, t);
          return n == null && i == null ? null : (n == null && (n = e), i == null && (i = e), new $(n, i));
        }
        static _createFromPositionAndShift(e, t) {
          const n = e, i = e.getShiftedBy(t);
          return t > 0 ? new this(n, i) : new this(i, n);
        }
        static _createIn(e) {
          return new this(q._createAt(e, 0), q._createAt(e, e.maxOffset));
        }
        static _createOn(e) {
          return this._createFromPositionAndShift(q._createBefore(e), e.offsetSize);
        }
        static _createFromRanges(e) {
          if (e.length === 0)
            throw new O("range-create-from-ranges-empty-array", null);
          if (e.length == 1)
            return e[0].clone();
          const t = e[0];
          e.sort((r, s) => r.start.isAfter(s.start) ? 1 : -1);
          const n = e.indexOf(t), i = new this(t.start, t.end);
          if (n > 0)
            for (let r = n - 1; e[r].end.isEqual(i.start); r++)
              i.start = q._createAt(e[r].start);
          for (let r = n + 1; r < e.length && e[r].start.isEqual(i.end); r++)
            i.end = q._createAt(e[r].end);
          return i;
        }
        static fromJSON(e, t) {
          return new this(q.fromJSON(e.start, t), q.fromJSON(e.end, t));
        }
      }
      $.prototype.is = function(o) {
        return o === "range" || o === "model:range";
      };
      class Mh extends Se() {
        constructor() {
          super(), this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelLengthCallbacks = /* @__PURE__ */ new Map(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._deferredBindingRemovals = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this.on("modelToViewPosition", (e, t) => {
            if (t.viewPosition)
              return;
            const n = this._modelToViewMapping.get(t.modelPosition.parent);
            if (!n)
              throw new O("mapping-model-position-view-parent-not-found", this, { modelPosition: t.modelPosition });
            t.viewPosition = this.findPositionIn(n, t.modelPosition.offset);
          }, { priority: "low" }), this.on("viewToModelPosition", (e, t) => {
            if (t.modelPosition)
              return;
            const n = this.findMappedViewAncestor(t.viewPosition), i = this._viewToModelMapping.get(n), r = this._toModelOffset(t.viewPosition.parent, t.viewPosition.offset, n);
            t.modelPosition = q._createAt(i, r);
          }, { priority: "low" });
        }
        bindElements(e, t) {
          this._modelToViewMapping.set(e, t), this._viewToModelMapping.set(t, e);
        }
        unbindViewElement(e, t = {}) {
          const n = this.toModelElement(e);
          if (this._elementToMarkerNames.has(e))
            for (const i of this._elementToMarkerNames.get(e))
              this._unboundMarkerNames.add(i);
          t.defer ? this._deferredBindingRemovals.set(e, e.root) : (this._viewToModelMapping.delete(e), this._modelToViewMapping.get(n) == e && this._modelToViewMapping.delete(n));
        }
        unbindModelElement(e) {
          const t = this.toViewElement(e);
          this._modelToViewMapping.delete(e), this._viewToModelMapping.get(t) == e && this._viewToModelMapping.delete(t);
        }
        bindElementToMarker(e, t) {
          const n = this._markerNameToElements.get(t) || /* @__PURE__ */ new Set();
          n.add(e);
          const i = this._elementToMarkerNames.get(e) || /* @__PURE__ */ new Set();
          i.add(t), this._markerNameToElements.set(t, n), this._elementToMarkerNames.set(e, i);
        }
        unbindElementFromMarkerName(e, t) {
          const n = this._markerNameToElements.get(t);
          n && (n.delete(e), n.size == 0 && this._markerNameToElements.delete(t));
          const i = this._elementToMarkerNames.get(e);
          i && (i.delete(t), i.size == 0 && this._elementToMarkerNames.delete(e));
        }
        flushUnboundMarkerNames() {
          const e = Array.from(this._unboundMarkerNames);
          return this._unboundMarkerNames.clear(), e;
        }
        flushDeferredBindings() {
          for (const [e, t] of this._deferredBindingRemovals)
            e.root == t && this.unbindViewElement(e);
          this._deferredBindingRemovals = /* @__PURE__ */ new Map();
        }
        clearBindings() {
          this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this._deferredBindingRemovals = /* @__PURE__ */ new Map();
        }
        toModelElement(e) {
          return this._viewToModelMapping.get(e);
        }
        toViewElement(e) {
          return this._modelToViewMapping.get(e);
        }
        toModelRange(e) {
          return new $(this.toModelPosition(e.start), this.toModelPosition(e.end));
        }
        toViewRange(e) {
          return new ae(this.toViewPosition(e.start), this.toViewPosition(e.end));
        }
        toModelPosition(e) {
          const t = { viewPosition: e, mapper: this };
          return this.fire("viewToModelPosition", t), t.modelPosition;
        }
        toViewPosition(e, t = {}) {
          const n = { modelPosition: e, mapper: this, isPhantom: t.isPhantom };
          return this.fire("modelToViewPosition", n), n.viewPosition;
        }
        markerNameToElements(e) {
          const t = this._markerNameToElements.get(e);
          if (!t)
            return null;
          const n = /* @__PURE__ */ new Set();
          for (const i of t)
            if (i.is("attributeElement"))
              for (const r of i.getElementsWithSameId())
                n.add(r);
            else
              n.add(i);
          return n;
        }
        registerViewToModelLength(e, t) {
          this._viewToModelLengthCallbacks.set(e, t);
        }
        findMappedViewAncestor(e) {
          let t = e.parent;
          for (; !this._viewToModelMapping.has(t); )
            t = t.parent;
          return t;
        }
        _toModelOffset(e, t, n) {
          if (n != e)
            return this._toModelOffset(e.parent, e.index, n) + this._toModelOffset(e, t, e);
          if (e.is("$text"))
            return t;
          let i = 0;
          for (let r = 0; r < t; r++)
            i += this.getModelLength(e.getChild(r));
          return i;
        }
        getModelLength(e) {
          if (this._viewToModelLengthCallbacks.get(e.name))
            return this._viewToModelLengthCallbacks.get(e.name)(e);
          if (this._viewToModelMapping.has(e))
            return 1;
          if (e.is("$text"))
            return e.data.length;
          if (e.is("uiElement"))
            return 0;
          {
            let t = 0;
            for (const n of e.getChildren())
              t += this.getModelLength(n);
            return t;
          }
        }
        findPositionIn(e, t) {
          let n, i = 0, r = 0, s = 0;
          if (e.is("$text"))
            return new J(e, t);
          for (; r < t; )
            n = e.getChild(s), i = this.getModelLength(n), r += i, s++;
          return r == t ? this._moveViewPositionToTextNode(new J(e, s)) : this.findPositionIn(n, t - (r - i));
        }
        _moveViewPositionToTextNode(e) {
          const t = e.nodeBefore, n = e.nodeAfter;
          return t instanceof Me ? new J(t, t.data.length) : n instanceof Me ? new J(n, 0) : e;
        }
      }
      class aC {
        constructor() {
          this._consumable = /* @__PURE__ */ new Map(), this._textProxyRegistry = /* @__PURE__ */ new Map();
        }
        add(e, t) {
          t = Ur(t), e instanceof Yt && (e = this._getSymbolForTextProxy(e)), this._consumable.has(e) || this._consumable.set(e, /* @__PURE__ */ new Map()), this._consumable.get(e).set(t, !0);
        }
        consume(e, t) {
          return t = Ur(t), e instanceof Yt && (e = this._getSymbolForTextProxy(e)), !!this.test(e, t) && (this._consumable.get(e).set(t, !1), !0);
        }
        test(e, t) {
          t = Ur(t), e instanceof Yt && (e = this._getSymbolForTextProxy(e));
          const n = this._consumable.get(e);
          if (n === void 0)
            return null;
          const i = n.get(t);
          return i === void 0 ? null : i;
        }
        revert(e, t) {
          t = Ur(t), e instanceof Yt && (e = this._getSymbolForTextProxy(e));
          const n = this.test(e, t);
          return n === !1 ? (this._consumable.get(e).set(t, !0), !0) : n !== !0 && null;
        }
        verifyAllConsumed(e) {
          const t = [];
          for (const [n, i] of this._consumable)
            for (const [r, s] of i) {
              const a = r.split(":")[0];
              s && e == a && t.push({ event: r, item: n.name || n.description });
            }
          if (t.length)
            throw new O("conversion-model-consumable-not-consumed", null, { items: t });
        }
        _getSymbolForTextProxy(e) {
          let t = null;
          const n = this._textProxyRegistry.get(e.startOffset);
          if (n) {
            const i = n.get(e.endOffset);
            i && (t = i.get(e.parent));
          }
          return t || (t = this._addSymbolForTextProxy(e)), t;
        }
        _addSymbolForTextProxy(e) {
          const t = e.startOffset, n = e.endOffset, i = e.parent, r = Symbol("$textProxy:" + e.data);
          let s, a;
          return s = this._textProxyRegistry.get(t), s || (s = /* @__PURE__ */ new Map(), this._textProxyRegistry.set(t, s)), a = s.get(n), a || (a = /* @__PURE__ */ new Map(), s.set(n, a)), a.set(i, r), r;
        }
      }
      function Ur(o) {
        const e = o.split(":");
        return e[0] == "insert" ? e[0] : e[0] == "addMarker" || e[0] == "removeMarker" ? o : e.length > 1 ? e[0] + ":" + e[1] : e[0];
      }
      var lC = Object.defineProperty, cC = Object.defineProperties, dC = Object.getOwnPropertyDescriptors, Nh = Object.getOwnPropertySymbols, uC = Object.prototype.hasOwnProperty, hC = Object.prototype.propertyIsEnumerable, Fh = (o, e, t) => e in o ? lC(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Ga = (o, e) => {
        for (var t in e || (e = {}))
          uC.call(e, t) && Fh(o, t, e[t]);
        if (Nh)
          for (var t of Nh(e))
            hC.call(e, t) && Fh(o, t, e[t]);
        return o;
      }, $h = (o, e) => cC(o, dC(e));
      class Vh extends Se() {
        constructor(e) {
          super(), this._conversionApi = Ga({ dispatcher: this }, e), this._firedEventsMap = /* @__PURE__ */ new WeakMap();
        }
        convertChanges(e, t, n) {
          const i = this._createConversionApi(n, e.getRefreshedItems());
          for (const s of e.getMarkersToRemove())
            this._convertMarkerRemove(s.name, s.range, i);
          const r = this._reduceChanges(e.getChanges());
          for (const s of r)
            s.type === "insert" ? this._convertInsert($._createFromPositionAndShift(s.position, s.length), i) : s.type === "reinsert" ? this._convertReinsert($._createFromPositionAndShift(s.position, s.length), i) : s.type === "remove" ? this._convertRemove(s.position, s.length, s.name, i) : this._convertAttribute(s.range, s.attributeKey, s.attributeOldValue, s.attributeNewValue, i);
          for (const s of i.mapper.flushUnboundMarkerNames()) {
            const a = t.get(s).getRange();
            this._convertMarkerRemove(s, a, i), this._convertMarkerAdd(s, a, i);
          }
          for (const s of e.getMarkersToAdd())
            this._convertMarkerAdd(s.name, s.range, i);
          i.mapper.flushDeferredBindings(), i.consumable.verifyAllConsumed("insert");
        }
        convert(e, t, n, i = {}) {
          const r = this._createConversionApi(n, void 0, i);
          this._convertInsert(e, r);
          for (const [s, a] of t)
            this._convertMarkerAdd(s, a, r);
          r.consumable.verifyAllConsumed("insert");
        }
        convertSelection(e, t, n) {
          const i = Array.from(t.getMarkersAtPosition(e.getFirstPosition())), r = this._createConversionApi(n);
          if (this._addConsumablesForSelection(r.consumable, e, i), this.fire("selection", { selection: e }, r), e.isCollapsed) {
            for (const s of i) {
              const a = s.getRange();
              if (!gC(e.getFirstPosition(), s, r.mapper))
                continue;
              const l = { item: e, markerName: s.name, markerRange: a };
              r.consumable.test(e, "addMarker:" + s.name) && this.fire(`addMarker:${s.name}`, l, r);
            }
            for (const s of e.getAttributeKeys()) {
              const a = { item: e, range: e.getFirstRange(), attributeKey: s, attributeOldValue: null, attributeNewValue: e.getAttribute(s) };
              r.consumable.test(e, "attribute:" + a.attributeKey) && this.fire(`attribute:${a.attributeKey}:$text`, a, r);
            }
          }
        }
        _convertInsert(e, t, n = {}) {
          n.doNotAddConsumables || this._addConsumablesForInsert(t.consumable, Array.from(e));
          for (const i of Array.from(e.getWalker({ shallow: !0 })).map(Lh))
            this._testAndFire("insert", i, t);
        }
        _convertRemove(e, t, n, i) {
          this.fire(`remove:${n}`, { position: e, length: t }, i);
        }
        _convertAttribute(e, t, n, i, r) {
          this._addConsumablesForRange(r.consumable, e, `attribute:${t}`);
          for (const s of e) {
            const a = { item: s.item, range: $._createFromPositionAndShift(s.previousPosition, s.length), attributeKey: t, attributeOldValue: n, attributeNewValue: i };
            this._testAndFire(`attribute:${t}`, a, r);
          }
        }
        _convertReinsert(e, t) {
          const n = Array.from(e.getWalker({ shallow: !0 }));
          this._addConsumablesForInsert(t.consumable, n);
          for (const i of n.map(Lh))
            this._testAndFire("insert", $h(Ga({}, i), { reconversion: !0 }), t);
        }
        _convertMarkerAdd(e, t, n) {
          if (t.root.rootName == "$graveyard")
            return;
          const i = `addMarker:${e}`;
          if (n.consumable.add(t, i), this.fire(i, { markerName: e, markerRange: t }, n), n.consumable.consume(t, i)) {
            this._addConsumablesForRange(n.consumable, t, i);
            for (const r of t.getItems()) {
              if (!n.consumable.test(r, i))
                continue;
              const s = { item: r, range: $._createOn(r), markerName: e, markerRange: t };
              this.fire(i, s, n);
            }
          }
        }
        _convertMarkerRemove(e, t, n) {
          t.root.rootName != "$graveyard" && this.fire(`removeMarker:${e}`, { markerName: e, markerRange: t }, n);
        }
        _reduceChanges(e) {
          const t = { changes: e };
          return this.fire("reduceChanges", t), t.changes;
        }
        _addConsumablesForInsert(e, t) {
          for (const n of t) {
            const i = n.item;
            if (e.test(i, "insert") === null) {
              e.add(i, "insert");
              for (const r of i.getAttributeKeys())
                e.add(i, "attribute:" + r);
            }
          }
          return e;
        }
        _addConsumablesForRange(e, t, n) {
          for (const i of t.getItems())
            e.add(i, n);
          return e;
        }
        _addConsumablesForSelection(e, t, n) {
          e.add(t, "selection");
          for (const i of n)
            e.add(t, "addMarker:" + i.name);
          for (const i of t.getAttributeKeys())
            e.add(t, "attribute:" + i);
          return e;
        }
        _testAndFire(e, t, n) {
          const i = function(l, d) {
            const h = d.item.is("element") ? d.item.name : "$text";
            return `${l}:${h}`;
          }(e, t), r = t.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(t.item) : t.item, s = this._firedEventsMap.get(n), a = s.get(r);
          if (a) {
            if (a.has(i))
              return;
            a.add(i);
          } else
            s.set(r, /* @__PURE__ */ new Set([i]));
          this.fire(i, t, n);
        }
        _testAndFireAddAttributes(e, t) {
          const n = { item: e, range: $._createOn(e) };
          for (const i of n.item.getAttributeKeys())
            n.attributeKey = i, n.attributeOldValue = null, n.attributeNewValue = n.item.getAttribute(i), this._testAndFire(`attribute:${i}`, n, t);
        }
        _createConversionApi(e, t = /* @__PURE__ */ new Set(), n = {}) {
          const i = $h(Ga({}, this._conversionApi), { consumable: new aC(), writer: e, options: n, convertItem: (r) => this._convertInsert($._createOn(r), i), convertChildren: (r) => this._convertInsert($._createIn(r), i, { doNotAddConsumables: !0 }), convertAttributes: (r) => this._testAndFireAddAttributes(r, i), canReuseView: (r) => !t.has(i.mapper.toModelElement(r)) });
          return this._firedEventsMap.set(i, /* @__PURE__ */ new Map()), i;
        }
      }
      function gC(o, e, t) {
        const n = e.getRange(), i = Array.from(o.getAncestors());
        return i.shift(), i.reverse(), !i.some((r) => {
          if (n.containsItem(r))
            return !!t.toViewElement(r).getCustomProperty("addHighlight");
        });
      }
      function Lh(o) {
        return { item: o.item, range: $._createFromPositionAndShift(o.previousPosition, o.length) };
      }
      class Ft extends Se(On) {
        constructor(...e) {
          super(), this._lastRangeBackward = !1, this._attrs = /* @__PURE__ */ new Map(), this._ranges = [], e.length && this.setTo(...e);
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const e = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? e.end : e.start;
          }
          return null;
        }
        get focus() {
          if (this._ranges.length > 0) {
            const e = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? e.start : e.end;
          }
          return null;
        }
        get isCollapsed() {
          return this._ranges.length === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        isEqual(e) {
          if (this.rangeCount != e.rangeCount)
            return !1;
          if (this.rangeCount === 0)
            return !0;
          if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
            return !1;
          for (const t of this._ranges) {
            let n = !1;
            for (const i of e._ranges)
              if (t.isEqual(i)) {
                n = !0;
                break;
              }
            if (!n)
              return !1;
          }
          return !0;
        }
        *getRanges() {
          for (const e of this._ranges)
            yield new $(e.start, e.end);
        }
        getFirstRange() {
          let e = null;
          for (const t of this._ranges)
            e && !t.start.isBefore(e.start) || (e = t);
          return e ? new $(e.start, e.end) : null;
        }
        getLastRange() {
          let e = null;
          for (const t of this._ranges)
            e && !t.end.isAfter(e.end) || (e = t);
          return e ? new $(e.start, e.end) : null;
        }
        getFirstPosition() {
          const e = this.getFirstRange();
          return e ? e.start.clone() : null;
        }
        getLastPosition() {
          const e = this.getLastRange();
          return e ? e.end.clone() : null;
        }
        setTo(...e) {
          let [t, n, i] = e;
          if (typeof n == "object" && (i = n, n = void 0), t === null)
            this._setRanges([]);
          else if (t instanceof Ft)
            this._setRanges(t.getRanges(), t.isBackward);
          else if (t && typeof t.getRanges == "function")
            this._setRanges(t.getRanges(), t.isBackward);
          else if (t instanceof $)
            this._setRanges([t], !!i && !!i.backward);
          else if (t instanceof q)
            this._setRanges([new $(t)]);
          else if (t instanceof io) {
            const r = !!i && !!i.backward;
            let s;
            if (n == "in")
              s = $._createIn(t);
            else if (n == "on")
              s = $._createOn(t);
            else {
              if (n === void 0)
                throw new O("model-selection-setto-required-second-parameter", [this, t]);
              s = new $(q._createAt(t, n));
            }
            this._setRanges([s], r);
          } else {
            if (!zt(t))
              throw new O("model-selection-setto-not-selectable", [this, t]);
            this._setRanges(t, i && !!i.backward);
          }
        }
        _setRanges(e, t = !1) {
          const n = Array.from(e), i = n.some((r) => {
            if (!(r instanceof $))
              throw new O("model-selection-set-ranges-not-range", [this, e]);
            return this._ranges.every((s) => !s.isEqual(r));
          });
          (n.length !== this._ranges.length || i) && (this._replaceAllRanges(n), this._lastRangeBackward = !!t, this.fire("change:range", { directChange: !0 }));
        }
        setFocus(e, t) {
          if (this.anchor === null)
            throw new O("model-selection-setfocus-no-ranges", [this, e]);
          const n = q._createAt(e, t);
          if (n.compareWith(this.focus) == "same")
            return;
          const i = this.anchor;
          this._ranges.length && this._popRange(), n.compareWith(i) == "before" ? (this._pushRange(new $(n, i)), this._lastRangeBackward = !0) : (this._pushRange(new $(i, n)), this._lastRangeBackward = !1), this.fire("change:range", { directChange: !0 });
        }
        getAttribute(e) {
          return this._attrs.get(e);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        hasAttribute(e) {
          return this._attrs.has(e);
        }
        removeAttribute(e) {
          this.hasAttribute(e) && (this._attrs.delete(e), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
        }
        setAttribute(e, t) {
          this.getAttribute(e) !== t && (this._attrs.set(e, t), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
        }
        getSelectedElement() {
          return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
        }
        *getSelectedBlocks() {
          const e = /* @__PURE__ */ new WeakSet();
          for (const t of this.getRanges()) {
            const n = Hh(t.start, e);
            pC(n, t) && (yield n);
            for (const r of t.getWalker()) {
              const s = r.item;
              r.type == "elementEnd" && mC(s, e, t) && (yield s);
            }
            const i = Hh(t.end, e);
            fC(i, t) && (yield i);
          }
        }
        containsEntireContent(e = this.anchor.root) {
          const t = q._createAt(e, 0), n = q._createAt(e, "end");
          return t.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition());
        }
        _pushRange(e) {
          this._checkRange(e), this._ranges.push(new $(e.start, e.end));
        }
        _checkRange(e) {
          for (let t = 0; t < this._ranges.length; t++)
            if (e.isIntersecting(this._ranges[t]))
              throw new O("model-selection-range-intersects", [this, e], { addedRange: e, intersectingRange: this._ranges[t] });
        }
        _replaceAllRanges(e) {
          this._removeAllRanges();
          for (const t of e)
            this._pushRange(t);
        }
        _removeAllRanges() {
          for (; this._ranges.length > 0; )
            this._popRange();
        }
        _popRange() {
          this._ranges.pop();
        }
      }
      function jh(o, e) {
        return !e.has(o) && (e.add(o), o.root.document.model.schema.isBlock(o) && !!o.parent);
      }
      function mC(o, e, t) {
        return jh(o, e) && Ka(o, t);
      }
      function Hh(o, e) {
        const t = o.parent.root.document.model.schema, n = o.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
        let i = !1;
        const r = n.find((s) => !i && (i = t.isLimit(s), !i && jh(s, e)));
        return n.forEach((s) => e.add(s)), r;
      }
      function Ka(o, e) {
        const t = function(n) {
          const i = n.root.document.model.schema;
          let r = n.parent;
          for (; r; ) {
            if (i.isBlock(r))
              return r;
            r = r.parent;
          }
        }(o);
        return t ? !e.containsRange($._createOn(t), !0) : !0;
      }
      function pC(o, e) {
        return !!o && (!(!e.isCollapsed && !o.isEmpty) || !e.start.isTouching(q._createAt(o, o.maxOffset)) && Ka(o, e));
      }
      function fC(o, e) {
        return !!o && (!(!e.isCollapsed && !o.isEmpty) || !e.end.isTouching(q._createAt(o, 0)) && Ka(o, e));
      }
      Ft.prototype.is = function(o) {
        return o === "selection" || o === "model:selection";
      };
      class fn extends Se($) {
        constructor(e, t) {
          super(e, t), bC.call(this);
        }
        detach() {
          this.stopListening();
        }
        toRange() {
          return new $(this.start, this.end);
        }
        static fromRange(e) {
          return new fn(e.start, e.end);
        }
      }
      function bC() {
        this.listenTo(this.root.document.model, "applyOperation", (o, e) => {
          const t = e[0];
          t.isDocumentOperation && kC.call(this, t);
        }, { priority: "low" });
      }
      function kC(o) {
        const e = this.getTransformedByOperation(o), t = $._createFromRanges(e), n = !t.isEqual(this), i = function(s, a) {
          switch (a.type) {
            case "insert":
              return s.containsPosition(a.position);
            case "move":
            case "remove":
            case "reinsert":
            case "merge":
              return s.containsPosition(a.sourcePosition) || s.start.isEqual(a.sourcePosition) || s.containsPosition(a.targetPosition);
            case "split":
              return s.containsPosition(a.splitPosition) || s.containsPosition(a.insertionPosition);
          }
          return !1;
        }(this, o);
        let r = null;
        if (n) {
          t.root.rootName == "$graveyard" && (r = o.type == "remove" ? o.sourcePosition : o.deletionPosition);
          const s = this.toRange();
          this.start = t.start, this.end = t.end, this.fire("change:range", s, { deletionPosition: r });
        } else
          i && this.fire("change:content", this.toRange(), { deletionPosition: r });
      }
      fn.prototype.is = function(o) {
        return o === "liveRange" || o === "model:liveRange" || o == "range" || o === "model:range";
      };
      const qr = "selection:";
      class Qt extends Se(On) {
        constructor(e) {
          super(), this._selection = new wC(e), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden;
        }
        get markers() {
          return this._selection.markers;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        getRanges() {
          return this._selection.getRanges();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        containsEntireContent(e) {
          return this._selection.containsEntireContent(e);
        }
        destroy() {
          this._selection.destroy();
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys();
        }
        getAttributes() {
          return this._selection.getAttributes();
        }
        getAttribute(e) {
          return this._selection.getAttribute(e);
        }
        hasAttribute(e) {
          return this._selection.hasAttribute(e);
        }
        refresh() {
          this._selection.updateMarkers(), this._selection._updateAttributes(!1);
        }
        observeMarkers(e) {
          this._selection.observeMarkers(e);
        }
        _setFocus(e, t) {
          this._selection.setFocus(e, t);
        }
        _setTo(...e) {
          this._selection.setTo(...e);
        }
        _setAttribute(e, t) {
          this._selection.setAttribute(e, t);
        }
        _removeAttribute(e) {
          this._selection.removeAttribute(e);
        }
        _getStoredAttributes() {
          return this._selection.getStoredAttributes();
        }
        _overrideGravity() {
          return this._selection.overrideGravity();
        }
        _restoreGravity(e) {
          this._selection.restoreGravity(e);
        }
        static _getStoreAttributeKey(e) {
          return qr + e;
        }
        static _isStoreAttributeKey(e) {
          return e.startsWith(qr);
        }
      }
      Qt.prototype.is = function(o) {
        return o === "selection" || o == "model:selection" || o == "documentSelection" || o == "model:documentSelection";
      };
      class wC extends Ft {
        constructor(e) {
          super(), this.markers = new Ht({ idProperty: "name" }), this._attributePriority = /* @__PURE__ */ new Map(), this._selectionRestorePosition = null, this._hasChangedRange = !1, this._overriddenGravityRegister = /* @__PURE__ */ new Set(), this._observedMarkers = /* @__PURE__ */ new Set(), this._model = e.model, this._document = e, this.listenTo(this._model, "applyOperation", (t, n) => {
            const i = n[0];
            i.isDocumentOperation && i.type != "marker" && i.type != "rename" && i.type != "noop" && (this._ranges.length == 0 && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = !1, this.fire("change:range", { directChange: !1 })));
          }, { priority: "lowest" }), this.on("change:range", () => {
            this._validateSelectionRanges(this.getRanges());
          }), this.listenTo(this._model.markers, "update", (t, n, i, r) => {
            this._updateMarker(n, r);
          }), this.listenTo(this._document, "change", (t, n) => {
            (function(i, r) {
              const s = i.document.differ;
              for (const a of s.getChanges()) {
                if (a.type != "insert")
                  continue;
                const l = a.position.parent;
                a.length === l.maxOffset && i.enqueueChange(r, (d) => {
                  const h = Array.from(l.getAttributeKeys()).filter((m) => m.startsWith(qr));
                  for (const m of h)
                    d.removeAttribute(m, l);
                });
              }
            })(this._model, n);
          });
        }
        get isCollapsed() {
          return this._ranges.length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
        }
        get anchor() {
          return super.anchor || this._document._getDefaultRange().start;
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end;
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1;
        }
        get hasOwnRange() {
          return this._ranges.length > 0;
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size;
        }
        destroy() {
          for (let e = 0; e < this._ranges.length; e++)
            this._ranges[e].detach();
          this.stopListening();
        }
        *getRanges() {
          this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
        }
        getFirstRange() {
          return super.getFirstRange() || this._document._getDefaultRange();
        }
        getLastRange() {
          return super.getLastRange() || this._document._getDefaultRange();
        }
        setTo(...e) {
          super.setTo(...e), this._updateAttributes(!0), this.updateMarkers();
        }
        setFocus(e, t) {
          super.setFocus(e, t), this._updateAttributes(!0), this.updateMarkers();
        }
        setAttribute(e, t) {
          if (this._setAttribute(e, t)) {
            const n = [e];
            this.fire("change:attribute", { attributeKeys: n, directChange: !0 });
          }
        }
        removeAttribute(e) {
          if (this._removeAttribute(e)) {
            const t = [e];
            this.fire("change:attribute", { attributeKeys: t, directChange: !0 });
          }
        }
        overrideGravity() {
          const e = ne();
          return this._overriddenGravityRegister.add(e), this._overriddenGravityRegister.size === 1 && this._updateAttributes(!0), e;
        }
        restoreGravity(e) {
          if (!this._overriddenGravityRegister.has(e))
            throw new O("document-selection-gravity-wrong-restore", this, { uid: e });
          this._overriddenGravityRegister.delete(e), this.isGravityOverridden || this._updateAttributes(!0);
        }
        observeMarkers(e) {
          this._observedMarkers.add(e), this.updateMarkers();
        }
        _replaceAllRanges(e) {
          this._validateSelectionRanges(e), super._replaceAllRanges(e);
        }
        _popRange() {
          this._ranges.pop().detach();
        }
        _pushRange(e) {
          const t = this._prepareRange(e);
          t && this._ranges.push(t);
        }
        _validateSelectionRanges(e) {
          for (const t of e)
            if (!this._document._validateSelectionRange(t))
              throw new O("document-selection-wrong-position", this, { range: t });
        }
        _prepareRange(e) {
          if (this._checkRange(e), e.root == this._document.graveyard)
            return;
          const t = fn.fromRange(e);
          return t.on("change:range", (n, i, r) => {
            if (this._hasChangedRange = !0, t.root == this._document.graveyard) {
              this._selectionRestorePosition = r.deletionPosition;
              const s = this._ranges.indexOf(t);
              this._ranges.splice(s, 1), t.detach();
            }
          }), t;
        }
        updateMarkers() {
          if (!this._observedMarkers.size)
            return;
          const e = [];
          let t = !1;
          for (const i of this._model.markers) {
            const r = i.name.split(":", 1)[0];
            if (!this._observedMarkers.has(r))
              continue;
            const s = i.getRange();
            for (const a of this.getRanges())
              s.containsRange(a, !a.isCollapsed) && e.push(i);
          }
          const n = Array.from(this.markers);
          for (const i of e)
            this.markers.has(i) || (this.markers.add(i), t = !0);
          for (const i of Array.from(this.markers))
            e.includes(i) || (this.markers.remove(i), t = !0);
          t && this.fire("change:marker", { oldMarkers: n, directChange: !1 });
        }
        _updateMarker(e, t) {
          const n = e.name.split(":", 1)[0];
          if (!this._observedMarkers.has(n))
            return;
          let i = !1;
          const r = Array.from(this.markers), s = this.markers.has(e);
          if (t) {
            let a = !1;
            for (const l of this.getRanges())
              if (t.containsRange(l, !l.isCollapsed)) {
                a = !0;
                break;
              }
            a && !s ? (this.markers.add(e), i = !0) : !a && s && (this.markers.remove(e), i = !0);
          } else
            s && (this.markers.remove(e), i = !0);
          i && this.fire("change:marker", { oldMarkers: r, directChange: !1 });
        }
        _updateAttributes(e) {
          const t = pn(this._getSurroundingAttributes()), n = pn(this.getAttributes());
          if (e)
            this._attributePriority = /* @__PURE__ */ new Map(), this._attrs = /* @__PURE__ */ new Map();
          else
            for (const [r, s] of this._attributePriority)
              s == "low" && (this._attrs.delete(r), this._attributePriority.delete(r));
          this._setAttributesTo(t);
          const i = [];
          for (const [r, s] of this.getAttributes())
            n.has(r) && n.get(r) === s || i.push(r);
          for (const [r] of n)
            this.hasAttribute(r) || i.push(r);
          i.length > 0 && this.fire("change:attribute", { attributeKeys: i, directChange: !1 });
        }
        _setAttribute(e, t, n = !0) {
          const i = n ? "normal" : "low";
          return i == "low" && this._attributePriority.get(e) == "normal" ? !1 : super.getAttribute(e) !== t && (this._attrs.set(e, t), this._attributePriority.set(e, i), !0);
        }
        _removeAttribute(e, t = !0) {
          const n = t ? "normal" : "low";
          return (n != "low" || this._attributePriority.get(e) != "normal") && (this._attributePriority.set(e, n), !!super.hasAttribute(e) && (this._attrs.delete(e), !0));
        }
        _setAttributesTo(e) {
          const t = /* @__PURE__ */ new Set();
          for (const [n, i] of this.getAttributes())
            e.get(n) !== i && this._removeAttribute(n, !1);
          for (const [n, i] of e)
            this._setAttribute(n, i, !1) && t.add(n);
          return t;
        }
        *getStoredAttributes() {
          const e = this.getFirstPosition().parent;
          if (this.isCollapsed && e.isEmpty)
            for (const t of e.getAttributeKeys())
              t.startsWith(qr) && (yield [t.substr(10), e.getAttribute(t)]);
        }
        _getSurroundingAttributes() {
          const e = this.getFirstPosition(), t = this._model.schema;
          let n = null;
          if (this.isCollapsed) {
            const i = e.textNode ? e.textNode : e.nodeBefore, r = e.textNode ? e.textNode : e.nodeAfter;
            if (this.isGravityOverridden || (n = Wr(i)), n || (n = Wr(r)), !this.isGravityOverridden && !n) {
              let s = i;
              for (; s && !t.isInline(s) && !n; )
                s = s.previousSibling, n = Wr(s);
            }
            if (!n) {
              let s = r;
              for (; s && !t.isInline(s) && !n; )
                s = s.nextSibling, n = Wr(s);
            }
            n || (n = this.getStoredAttributes());
          } else {
            const i = this.getFirstRange();
            for (const r of i) {
              if (r.item.is("element") && t.isObject(r.item))
                break;
              if (r.type == "text") {
                n = r.item.getAttributes();
                break;
              }
            }
          }
          return n;
        }
        _fixGraveyardSelection(e) {
          const t = this._model.schema.getNearestSelectionRange(e);
          t && this._pushRange(t);
        }
      }
      function Wr(o) {
        return o instanceof Yt || o instanceof Ne ? o.getAttributes() : null;
      }
      class Uh {
        constructor(e) {
          this._dispatchers = e;
        }
        add(e) {
          for (const t of this._dispatchers)
            e(t);
          return this;
        }
      }
      const Rn = function(o) {
        return aa(o, 5);
      };
      class vC extends Uh {
        elementToElement(e) {
          return this.add(function(t) {
            const n = Gh(t.model), i = zi(t.view, "container");
            return n.attributes.length && (n.children = !0), (r) => {
              r.on(`insert:${n.name}`, /* @__PURE__ */ function(s, a = AC) {
                return (l, d, h) => {
                  if (!a(d.item, h.consumable, { preflight: !0 }))
                    return;
                  const m = s(d.item, h, d);
                  if (!m)
                    return;
                  a(d.item, h.consumable);
                  const f = h.mapper.toViewPosition(d.range.start);
                  h.mapper.bindElements(d.item, m), h.writer.insert(f, m), h.convertAttributes(d.item), Qh(m, d.item.getChildren(), h, { reconversion: d.reconversion });
                };
              }(i, Yh(n)), { priority: t.converterPriority || "normal" }), (n.children || n.attributes.length) && r.on("reduceChanges", Jh(n), { priority: "low" });
            };
          }(e));
        }
        elementToStructure(e) {
          return this.add(function(t) {
            const n = Gh(t.model), i = zi(t.view, "container");
            return n.children = !0, (r) => {
              if (r._conversionApi.schema.checkChild(n.name, "$text"))
                throw new O("conversion-element-to-structure-disallowed-text", r, { elementName: n.name });
              var s, a;
              r.on(`insert:${n.name}`, (s = i, a = Yh(n), (l, d, h) => {
                if (!a(d.item, h.consumable, { preflight: !0 }))
                  return;
                const m = /* @__PURE__ */ new Map();
                h.writer._registerSlotFactory(/* @__PURE__ */ function(S, B, T) {
                  return (R, N) => {
                    const U = R.createContainerElement("$slot");
                    let ee = null;
                    if (N === "children")
                      ee = Array.from(S.getChildren());
                    else {
                      if (typeof N != "function")
                        throw new O("conversion-slot-mode-unknown", T.dispatcher, { modeOrFilter: N });
                      ee = Array.from(S.getChildren()).filter((we) => N(we));
                    }
                    return B.set(U, ee), U;
                  };
                }(d.item, m, h));
                const f = s(d.item, h, d);
                if (h.writer._clearSlotFactory(), !f)
                  return;
                (function(S, B, T) {
                  const R = Array.from(B.values()).flat(), N = new Set(R);
                  if (N.size != R.length)
                    throw new O("conversion-slot-filter-overlap", T.dispatcher, { element: S });
                  if (N.size != S.childCount)
                    throw new O("conversion-slot-filter-incomplete", T.dispatcher, { element: S });
                })(d.item, m, h), a(d.item, h.consumable);
                const _ = h.mapper.toViewPosition(d.range.start);
                h.mapper.bindElements(d.item, f), h.writer.insert(_, f), h.convertAttributes(d.item), function(S, B, T, R) {
                  T.mapper.on("modelToViewPosition", ee, { priority: "highest" });
                  let N = null, U = null;
                  for ([N, U] of B)
                    Qh(S, U, T, R), T.writer.move(T.writer.createRangeIn(N), T.writer.createPositionBefore(N)), T.writer.remove(N);
                  function ee(we, Ge) {
                    const Te = Ge.modelPosition.nodeAfter, yn = U.indexOf(Te);
                    yn < 0 || (Ge.viewPosition = Ge.mapper.findPositionIn(N, yn));
                  }
                  T.mapper.off("modelToViewPosition", ee);
                }(f, m, h, { reconversion: d.reconversion });
              }), { priority: t.converterPriority || "normal" }), r.on("reduceChanges", Jh(n), { priority: "low" });
            };
          }(e));
        }
        attributeToElement(e) {
          return this.add(function(t) {
            t = Rn(t);
            let n = t.model;
            typeof n == "string" && (n = { key: n });
            let i = `attribute:${n.key}`;
            if (n.name && (i += ":" + n.name), n.values)
              for (const s of n.values)
                t.view[s] = zi(t.view[s], "attribute");
            else
              t.view = zi(t.view, "attribute");
            const r = Kh(t);
            return (s) => {
              s.on(i, /* @__PURE__ */ function(a) {
                return (l, d, h) => {
                  if (!h.consumable.test(d.item, l.name))
                    return;
                  const m = a(d.attributeOldValue, h, d), f = a(d.attributeNewValue, h, d);
                  if (!m && !f)
                    return;
                  h.consumable.consume(d.item, l.name);
                  const _ = h.writer, S = _.document.selection;
                  if (d.item instanceof Ft || d.item instanceof Qt)
                    _.wrap(S.getFirstRange(), f);
                  else {
                    let B = h.mapper.toViewRange(d.range);
                    d.attributeOldValue !== null && m && (B = _.unwrap(B, m)), d.attributeNewValue !== null && f && _.wrap(B, f);
                  }
                };
              }(r), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        attributeToAttribute(e) {
          return this.add(function(t) {
            t = Rn(t);
            let n = t.model;
            typeof n == "string" && (n = { key: n });
            let i = `attribute:${n.key}`;
            if (n.name && (i += ":" + n.name), n.values)
              for (const s of n.values)
                t.view[s] = Zh(t.view[s]);
            else
              t.view = Zh(t.view);
            const r = Kh(t);
            return (s) => {
              var a;
              s.on(i, (a = r, (l, d, h) => {
                if (!h.consumable.test(d.item, l.name))
                  return;
                const m = a(d.attributeOldValue, h, d), f = a(d.attributeNewValue, h, d);
                if (!m && !f)
                  return;
                h.consumable.consume(d.item, l.name);
                const _ = h.mapper.toViewElement(d.item), S = h.writer;
                if (!_)
                  throw new O("conversion-attribute-to-attribute-on-text", h.dispatcher, d);
                if (d.attributeOldValue !== null && m)
                  if (m.key == "class") {
                    const B = Xe(m.value);
                    for (const T of B)
                      S.removeClass(T, _);
                  } else if (m.key == "style") {
                    const B = Object.keys(m.value);
                    for (const T of B)
                      S.removeStyle(T, _);
                  } else
                    S.removeAttribute(m.key, _);
                if (d.attributeNewValue !== null && f)
                  if (f.key == "class") {
                    const B = Xe(f.value);
                    for (const T of B)
                      S.addClass(T, _);
                  } else if (f.key == "style") {
                    const B = Object.keys(f.value);
                    for (const T of B)
                      S.setStyle(T, f.value[T], _);
                  } else
                    S.setAttribute(f.key, f.value, _);
              }), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        markerToElement(e) {
          return this.add(function(t) {
            const n = zi(t.view, "ui");
            return (i) => {
              var r;
              i.on(`addMarker:${t.model}`, (r = n, (s, a, l) => {
                a.isOpening = !0;
                const d = r(a, l);
                a.isOpening = !1;
                const h = r(a, l);
                if (!d || !h)
                  return;
                const m = a.markerRange;
                if (m.isCollapsed && !l.consumable.consume(m, s.name))
                  return;
                for (const S of m)
                  if (!l.consumable.consume(S.item, s.name))
                    return;
                const f = l.mapper, _ = l.writer;
                _.insert(f.toViewPosition(m.start), d), l.mapper.bindElementToMarker(d, a.markerName), m.isCollapsed || (_.insert(f.toViewPosition(m.end), h), l.mapper.bindElementToMarker(h, a.markerName)), s.stop();
              }), { priority: t.converterPriority || "normal" }), i.on(`removeMarker:${t.model}`, (s, a, l) => {
                const d = l.mapper.markerNameToElements(a.markerName);
                if (d) {
                  for (const h of d)
                    l.mapper.unbindElementFromMarkerName(h, a.markerName), l.writer.clear(l.writer.createRangeOn(h), h);
                  l.writer.clearClonedElementsGroup(a.markerName), s.stop();
                }
              }, { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        markerToHighlight(e) {
          return this.add(/* @__PURE__ */ function(t) {
            return (n) => {
              var i;
              n.on(`addMarker:${t.model}`, (i = t.view, (r, s, a) => {
                if (!s.item || !(s.item instanceof Ft || s.item instanceof Qt || s.item.is("$textProxy")))
                  return;
                const l = Za(i, s, a);
                if (!l || !a.consumable.consume(s.item, r.name))
                  return;
                const d = a.writer, h = qh(d, l), m = d.document.selection;
                if (s.item instanceof Ft || s.item instanceof Qt)
                  d.wrap(m.getFirstRange(), h);
                else {
                  const f = a.mapper.toViewRange(s.range), _ = d.wrap(f, h);
                  for (const S of _.getItems())
                    if (S.is("attributeElement") && S.isSimilar(h)) {
                      a.mapper.bindElementToMarker(S, s.markerName);
                      break;
                    }
                }
              }), { priority: t.converterPriority || "normal" }), n.on(`addMarker:${t.model}`, /* @__PURE__ */ function(r) {
                return (s, a, l) => {
                  if (!a.item || !(a.item instanceof Fe))
                    return;
                  const d = Za(r, a, l);
                  if (!d || !l.consumable.test(a.item, s.name))
                    return;
                  const h = l.mapper.toViewElement(a.item);
                  if (h && h.getCustomProperty("addHighlight")) {
                    l.consumable.consume(a.item, s.name);
                    for (const m of $._createIn(a.item))
                      l.consumable.consume(m.item, s.name);
                    h.getCustomProperty("addHighlight")(h, d, l.writer), l.mapper.bindElementToMarker(h, a.markerName);
                  }
                };
              }(t.view), { priority: t.converterPriority || "normal" }), n.on(`removeMarker:${t.model}`, /* @__PURE__ */ function(r) {
                return (s, a, l) => {
                  if (a.markerRange.isCollapsed)
                    return;
                  const d = Za(r, a, l);
                  if (!d)
                    return;
                  const h = qh(l.writer, d), m = l.mapper.markerNameToElements(a.markerName);
                  if (m) {
                    for (const f of m)
                      l.mapper.unbindElementFromMarkerName(f, a.markerName), f.is("attributeElement") ? l.writer.unwrap(l.writer.createRangeOn(f), h) : f.getCustomProperty("removeHighlight")(f, d.id, l.writer);
                    l.writer.clearClonedElementsGroup(a.markerName), s.stop();
                  }
                };
              }(t.view), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        markerToData(e) {
          return this.add(function(t) {
            t = Rn(t);
            const n = t.model;
            let i = t.view;
            return i || (i = (r) => ({ group: n, name: r.substr(t.model.length + 1) })), (r) => {
              var s;
              r.on(`addMarker:${n}`, (s = i, (a, l, d) => {
                const h = s(l.markerName, d);
                if (!h)
                  return;
                const m = l.markerRange;
                d.consumable.consume(m, a.name) && (Wh(m, !1, d, l, h), Wh(m, !0, d, l, h), a.stop());
              }), { priority: t.converterPriority || "normal" }), r.on(`removeMarker:${n}`, /* @__PURE__ */ function(a) {
                return (l, d, h) => {
                  const m = a(d.markerName, h);
                  if (!m)
                    return;
                  const f = h.mapper.markerNameToElements(d.markerName);
                  if (f) {
                    for (const S of f)
                      h.mapper.unbindElementFromMarkerName(S, d.markerName), S.is("containerElement") ? (_(`data-${m.group}-start-before`, S), _(`data-${m.group}-start-after`, S), _(`data-${m.group}-end-before`, S), _(`data-${m.group}-end-after`, S)) : h.writer.clear(h.writer.createRangeOn(S), S);
                    h.writer.clearClonedElementsGroup(d.markerName), l.stop();
                  }
                  function _(S, B) {
                    if (B.hasAttribute(S)) {
                      const T = new Set(B.getAttribute(S).split(","));
                      T.delete(m.name), T.size == 0 ? h.writer.removeAttribute(S, B) : h.writer.setAttribute(S, Array.from(T).join(","), B);
                    }
                  }
                };
              }(i), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
      }
      function qh(o, e) {
        const t = o.createAttributeElement("span", e.attributes);
        return e.classes && t._addClass(e.classes), typeof e.priority == "number" && (t._priority = e.priority), t._id = e.id, t;
      }
      function Wh(o, e, t, n, i) {
        const r = e ? o.start : o.end, s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null, a = r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null;
        if (s || a) {
          let l, d;
          e && s || !e && !a ? (l = s, d = !0) : (l = a, d = !1);
          const h = t.mapper.toViewElement(l);
          if (h)
            return void function(m, f, _, S, B, T) {
              const R = `data-${T.group}-${f ? "start" : "end"}-${_ ? "before" : "after"}`, N = m.hasAttribute(R) ? m.getAttribute(R).split(",") : [];
              N.unshift(T.name), S.writer.setAttribute(R, N.join(","), m), S.mapper.bindElementToMarker(m, B.markerName);
            }(h, e, d, t, n, i);
        }
        (function(l, d, h, m, f) {
          const _ = `${f.group}-${d ? "start" : "end"}`, S = f.name ? { name: f.name } : null, B = h.writer.createUIElement(_, S);
          h.writer.insert(l, B), h.mapper.bindElementToMarker(B, m.markerName);
        })(t.mapper.toViewPosition(r), e, t, n, i);
      }
      function Gh(o) {
        return typeof o == "string" && (o = { name: o }), o.attributes ? Array.isArray(o.attributes) || (o.attributes = [o.attributes]) : o.attributes = [], o.children = !!o.children, o;
      }
      function zi(o, e) {
        return typeof o == "function" ? o : (t, n) => function(i, r, s) {
          typeof i == "string" && (i = { name: i });
          let a;
          const l = r.writer, d = Object.assign({}, i.attributes);
          if (s == "container")
            a = l.createContainerElement(i.name, d);
          else if (s == "attribute") {
            const h = { priority: i.priority || no.DEFAULT_PRIORITY };
            a = l.createAttributeElement(i.name, d, h);
          } else
            a = l.createUIElement(i.name, d);
          if (i.styles) {
            const h = Object.keys(i.styles);
            for (const m of h)
              l.setStyle(m, i.styles[m], a);
          }
          if (i.classes) {
            const h = i.classes;
            if (typeof h == "string")
              l.addClass(h, a);
            else
              for (const m of h)
                l.addClass(m, a);
          }
          return a;
        }(o, n, e);
      }
      function Kh(o) {
        return o.model.values ? (e, t, n) => {
          const i = o.view[e];
          return i ? i(e, t, n) : null;
        } : o.view;
      }
      function Zh(o) {
        return typeof o == "string" ? (e) => ({ key: o, value: e }) : typeof o == "object" ? o.value ? () => o : (e) => ({ key: o.key, value: e }) : o;
      }
      function Za(o, e, t) {
        const n = typeof o == "function" ? o(e, t) : o;
        return n ? (n.priority || (n.priority = 10), n.id || (n.id = e.markerName), n) : null;
      }
      function Jh(o) {
        const e = /* @__PURE__ */ function(t) {
          return (n, i) => {
            if (!n.is("element", t.name))
              return !1;
            if (i.type == "attribute") {
              if (t.attributes.includes(i.attributeKey))
                return !0;
            } else if (t.children)
              return !0;
            return !1;
          };
        }(o);
        return (t, n) => {
          const i = [];
          n.reconvertedElements || (n.reconvertedElements = /* @__PURE__ */ new Set());
          for (const r of n.changes) {
            const s = r.type == "attribute" ? r.range.start.nodeAfter : r.position.parent;
            if (s && e(s, r)) {
              if (!n.reconvertedElements.has(s)) {
                n.reconvertedElements.add(s);
                const a = q._createBefore(s);
                let l = i.length;
                for (let d = i.length - 1; d >= 0; d--) {
                  const h = i[d], m = (h.type == "attribute" ? h.range.start : h.position).compareWith(a);
                  if (m == "before" || h.type == "remove" && m == "same")
                    break;
                  l = d;
                }
                i.splice(l, 0, { type: "remove", name: s.name, position: a, length: 1 }, { type: "reinsert", name: s.name, position: a, length: 1 });
              }
            } else
              i.push(r);
          }
          n.changes = i;
        };
      }
      function Yh(o) {
        return (e, t, n = {}) => {
          const i = ["insert"];
          for (const r of o.attributes)
            e.hasAttribute(r) && i.push(`attribute:${r}`);
          return !!i.every((r) => t.test(e, r)) && (n.preflight || i.forEach((r) => t.consume(e, r)), !0);
        };
      }
      function Qh(o, e, t, n) {
        for (const i of e)
          _C(o.root, i, t, n) || t.convertItem(i);
      }
      function _C(o, e, t, n) {
        const { writer: i, mapper: r } = t;
        if (!n.reconversion)
          return !1;
        const s = r.toViewElement(e);
        return !(!s || s.root == o) && !!t.canReuseView(s) && (i.move(i.createRangeOn(s), r.toViewPosition(q._createBefore(e))), !0);
      }
      function AC(o, e, { preflight: t } = {}) {
        return t ? e.test(o, "insert") : e.consume(o, "insert");
      }
      function Xh(o) {
        const { schema: e, document: t } = o.model;
        for (const n of t.getRootNames()) {
          const i = t.getRoot(n);
          if (i.isEmpty && !e.checkChild(i, "$text") && e.checkChild(i, "paragraph"))
            return o.insertElement("paragraph", i), !0;
        }
        return !1;
      }
      function eg(o, e, t) {
        const n = t.createContext(o);
        return !!t.checkChild(n, "paragraph") && !!t.checkChild(n.push("paragraph"), e);
      }
      function tg(o, e) {
        const t = e.createElement("paragraph");
        return e.insert(t, o), e.createPositionAt(t, 0);
      }
      var CC = Object.defineProperty, yC = Object.defineProperties, EC = Object.getOwnPropertyDescriptors, ng = Object.getOwnPropertySymbols, xC = Object.prototype.hasOwnProperty, SC = Object.prototype.propertyIsEnumerable, og = (o, e, t) => e in o ? CC(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class DC extends Uh {
        elementToElement(e) {
          return this.add(ig(e));
        }
        elementToAttribute(e) {
          return this.add(function(t) {
            t = Rn(t), rg(t);
            const n = sg(t, !1), i = Ja(t.view), r = i ? `element:${i}` : "element";
            return (s) => {
              s.on(r, n, { priority: t.converterPriority || "low" });
            };
          }(e));
        }
        attributeToAttribute(e) {
          return this.add(function(t) {
            t = Rn(t);
            let n = null;
            (typeof t.view == "string" || t.view.key) && (n = function(r) {
              typeof r.view == "string" && (r.view = { key: r.view });
              const s = r.view.key;
              let a;
              return s == "class" || s == "style" ? a = { [s == "class" ? "classes" : "styles"]: r.view.value } : a = { attributes: { [s]: r.view.value === void 0 ? /[\s\S]*/ : r.view.value } }, r.view.name && (a.name = r.view.name), r.view = a, s;
            }(t)), rg(t, n);
            const i = sg(t, !0);
            return (r) => {
              r.on("element", i, { priority: t.converterPriority || "low" });
            };
          }(e));
        }
        elementToMarker(e) {
          return this.add(function(t) {
            const n = /* @__PURE__ */ function(s) {
              return (a, l) => {
                const d = typeof s == "string" ? s : s(a, l);
                return l.writer.createElement("$marker", { "data-name": d });
              };
            }(t.model);
            return ig((i = ((s, a) => {
              for (var l in a || (a = {}))
                xC.call(a, l) && og(s, l, a[l]);
              if (ng)
                for (var l of ng(a))
                  SC.call(a, l) && og(s, l, a[l]);
              return s;
            })({}, t), r = { model: n }, yC(i, EC(r))));
            var i, r;
          }(e));
        }
        dataToMarker(e) {
          return this.add(function(t) {
            t = Rn(t), t.model || (t.model = (s) => s ? t.view + ":" + s : t.view);
            const n = { view: t.view, model: t.model }, i = Ya(ag(n, "start")), r = Ya(ag(n, "end"));
            return (s) => {
              s.on(`element:${t.view}-start`, i, { priority: t.converterPriority || "normal" }), s.on(`element:${t.view}-end`, r, { priority: t.converterPriority || "normal" });
              const a = se.get("low"), l = se.get("highest"), d = se.get(t.converterPriority) / l;
              s.on("element", /* @__PURE__ */ function(h) {
                return (m, f, _) => {
                  const S = `data-${h.view}`;
                  function B(T, R) {
                    for (const N of R) {
                      const U = h.model(N, _), ee = _.writer.createElement("$marker", { "data-name": U });
                      _.writer.insert(ee, T), f.modelCursor.isEqual(T) ? f.modelCursor = f.modelCursor.getShiftedBy(1) : f.modelCursor = f.modelCursor._getTransformedByInsertion(T, 1), f.modelRange = f.modelRange._getTransformedByInsertion(T, 1)[0];
                    }
                  }
                  (_.consumable.test(f.viewItem, { attributes: S + "-end-after" }) || _.consumable.test(f.viewItem, { attributes: S + "-start-after" }) || _.consumable.test(f.viewItem, { attributes: S + "-end-before" }) || _.consumable.test(f.viewItem, { attributes: S + "-start-before" })) && (f.modelRange || Object.assign(f, _.convertChildren(f.viewItem, f.modelCursor)), _.consumable.consume(f.viewItem, { attributes: S + "-end-after" }) && B(f.modelRange.end, f.viewItem.getAttribute(S + "-end-after").split(",")), _.consumable.consume(f.viewItem, { attributes: S + "-start-after" }) && B(f.modelRange.end, f.viewItem.getAttribute(S + "-start-after").split(",")), _.consumable.consume(f.viewItem, { attributes: S + "-end-before" }) && B(f.modelRange.start, f.viewItem.getAttribute(S + "-end-before").split(",")), _.consumable.consume(f.viewItem, { attributes: S + "-start-before" }) && B(f.modelRange.start, f.viewItem.getAttribute(S + "-start-before").split(",")));
                };
              }(n), { priority: a + d });
            };
          }(e));
        }
      }
      function ig(o) {
        const e = Ya(o = Rn(o)), t = Ja(o.view), n = t ? `element:${t}` : "element";
        return (i) => {
          i.on(n, e, { priority: o.converterPriority || "normal" });
        };
      }
      function Ja(o) {
        return typeof o == "string" ? o : typeof o == "object" && typeof o.name == "string" ? o.name : null;
      }
      function Ya(o) {
        const e = new No(o.view);
        return (t, n, i) => {
          const r = e.match(n.viewItem);
          if (!r)
            return;
          const s = r.match;
          if (s.name = !0, !i.consumable.test(n.viewItem, s))
            return;
          const a = function(l, d, h) {
            return l instanceof Function ? l(d, h) : h.writer.createElement(l);
          }(o.model, n.viewItem, i);
          a && i.safeInsert(a, n.modelCursor) && (i.consumable.consume(n.viewItem, s), i.convertChildren(n.viewItem, a), i.updateConversionResult(a, n));
        };
      }
      function rg(o, e = null) {
        const t = e === null || ((r) => r.getAttribute(e)), n = typeof o.model != "object" ? o.model : o.model.key, i = typeof o.model != "object" || o.model.value === void 0 ? t : o.model.value;
        o.model = { key: n, value: i };
      }
      function sg(o, e) {
        const t = new No(o.view);
        return (n, i, r) => {
          if (!i.modelRange && e)
            return;
          const s = t.match(i.viewItem);
          if (!s || (function(h, m) {
            const f = typeof h == "function" ? h(m) : h;
            return typeof f == "object" && !Ja(f) ? !1 : !f.classes && !f.attributes && !f.styles;
          }(o.view, i.viewItem) ? s.match.name = !0 : delete s.match.name, !r.consumable.test(i.viewItem, s.match)))
            return;
          const a = o.model.key, l = typeof o.model.value == "function" ? o.model.value(i.viewItem, r) : o.model.value;
          if (l === null)
            return;
          i.modelRange || Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor)), function(h, m, f, _) {
            let S = !1;
            for (const B of Array.from(h.getItems({ shallow: f })))
              _.schema.checkAttribute(B, m.key) && (S = !0, B.hasAttribute(m.key) || _.writer.setAttribute(m.key, m.value, B));
            return S;
          }(i.modelRange, { key: a, value: l }, e, r) && (r.consumable.test(i.viewItem, { name: !0 }) && (s.match.name = !0), r.consumable.consume(i.viewItem, s.match));
        };
      }
      function ag(o, e) {
        return { view: `${o.view}-${e}`, model: (t, n) => {
          const i = t.getAttribute("name"), r = o.model(i, n);
          return n.writer.createElement("$marker", { "data-name": r });
        } };
      }
      function BC(o) {
        o.document.registerPostFixer((e) => function(t, n) {
          const i = n.document.selection, r = n.schema, s = [];
          let a = !1;
          for (const l of i.getRanges()) {
            const d = lg(l, r);
            d && !d.isEqual(l) ? (s.push(d), a = !0) : s.push(l);
          }
          return a && t.setSelection(function(l) {
            const d = [...l], h = /* @__PURE__ */ new Set();
            let m = 1;
            for (; m < d.length; ) {
              const f = d[m], _ = d.slice(0, m);
              for (const [S, B] of _.entries())
                if (!h.has(S)) {
                  if (f.isEqual(B))
                    h.add(S);
                  else if (f.isIntersecting(B)) {
                    h.add(S), h.add(m);
                    const T = f.getJoined(B);
                    d.push(T);
                  }
                }
              m++;
            }
            return d.filter((f, _) => !h.has(_));
          }(s), { backward: i.isBackward }), !1;
        }(e, o));
      }
      function lg(o, e) {
        return o.isCollapsed ? function(t, n) {
          const i = t.start, r = n.getNearestSelectionRange(i);
          if (!r) {
            const a = i.getAncestors().reverse().find((l) => n.isObject(l));
            return a ? $._createOn(a) : null;
          }
          if (!r.isCollapsed)
            return r;
          const s = r.start;
          return i.isEqual(s) ? null : new $(s);
        }(o, e) : function(t, n) {
          const { start: i, end: r } = t, s = n.checkChild(i, "$text"), a = n.checkChild(r, "$text"), l = n.getLimitElement(i), d = n.getLimitElement(r);
          if (l === d) {
            if (s && a)
              return null;
            if (function(f, _, S) {
              const B = f.nodeAfter && !S.isLimit(f.nodeAfter) || S.checkChild(f, "$text"), T = _.nodeBefore && !S.isLimit(_.nodeBefore) || S.checkChild(_, "$text");
              return B || T;
            }(i, r, n)) {
              const f = i.nodeAfter && n.isSelectable(i.nodeAfter) ? null : n.getNearestSelectionRange(i, "forward"), _ = r.nodeBefore && n.isSelectable(r.nodeBefore) ? null : n.getNearestSelectionRange(r, "backward"), S = f ? f.start : i, B = _ ? _.end : r;
              return new $(S, B);
            }
          }
          const h = l && !l.is("rootElement"), m = d && !d.is("rootElement");
          if (h || m) {
            const f = i.nodeAfter && r.nodeBefore && i.nodeAfter.parent === r.nodeBefore.parent, _ = h && (!f || !dg(i.nodeAfter, n)), S = m && (!f || !dg(r.nodeBefore, n));
            let B = i, T = r;
            return _ && (B = q._createBefore(cg(l, n))), S && (T = q._createAfter(cg(d, n))), new $(B, T);
          }
          return null;
        }(o, e);
      }
      function cg(o, e) {
        let t = o, n = t;
        for (; e.isLimit(n) && n.parent; )
          t = n, n = n.parent;
        return t;
      }
      function dg(o, e) {
        return o && e.isSelectable(o);
      }
      class TC extends re() {
        constructor(e, t) {
          super(), this.model = e, this.view = new sC(t), this.mapper = new Mh(), this.downcastDispatcher = new Vh({ mapper: this.mapper, schema: e.schema });
          const n = this.model.document, i = n.selection, r = this.model.markers;
          var s, a, l;
          this.listenTo(this.model, "_beforeChanges", () => {
            this.view._disableRendering(!0);
          }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
            this.view._disableRendering(!1);
          }, { priority: "lowest" }), this.listenTo(n, "change", () => {
            this.view.change((d) => {
              this.downcastDispatcher.convertChanges(n.differ, r, d), this.downcastDispatcher.convertSelection(i, r, d);
            });
          }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", /* @__PURE__ */ function(d, h) {
            return (m, f) => {
              const _ = f.newSelection, S = [];
              for (const T of _.getRanges())
                S.push(h.toModelRange(T));
              const B = d.createSelection(S, { backward: _.isBackward });
              B.isEqual(d.document.selection) || d.change((T) => {
                T.setSelection(B);
              });
            };
          }(this.model, this.mapper)), this.listenTo(this.view.document, "beforeinput", (s = this.mapper, a = this.model.schema, l = this.view, (d, h) => {
            if (!l.document.isComposing || k.isAndroid)
              for (let m = 0; m < h.targetRanges.length; m++) {
                const f = h.targetRanges[m], _ = s.toModelRange(f), S = lg(_, a);
                S && !S.isEqual(_) && (h.targetRanges[m] = s.toViewRange(S));
              }
          }), { priority: "high" }), this.downcastDispatcher.on("insert:$text", (d, h, m) => {
            if (!m.consumable.consume(h.item, d.name))
              return;
            const f = m.writer, _ = m.mapper.toViewPosition(h.range.start), S = f.createText(h.item.data);
            f.insert(_, S);
          }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (d, h, m) => {
            m.convertAttributes(h.item), h.reconversion || !h.item.is("element") || h.item.isEmpty || m.convertChildren(h.item);
          }, { priority: "lowest" }), this.downcastDispatcher.on("remove", (d, h, m) => {
            const f = m.mapper.toViewPosition(h.position), _ = h.position.getShiftedBy(h.length), S = m.mapper.toViewPosition(_, { isPhantom: !0 }), B = m.writer.createRange(f, S), T = m.writer.remove(B.getTrimmed());
            for (const R of m.writer.createRangeIn(T).getItems())
              m.mapper.unbindViewElement(R, { defer: !0 });
          }, { priority: "low" }), this.downcastDispatcher.on("selection", (d, h, m) => {
            const f = m.writer, _ = f.document.selection;
            for (const S of _.getRanges())
              S.isCollapsed && S.end.parent.isAttached() && m.writer.mergeAttributes(S.start);
            f.setSelection(null);
          }, { priority: "high" }), this.downcastDispatcher.on("selection", (d, h, m) => {
            const f = h.selection;
            if (f.isCollapsed || !m.consumable.consume(f, "selection"))
              return;
            const _ = [];
            for (const S of f.getRanges())
              _.push(m.mapper.toViewRange(S));
            m.writer.setSelection(_, { backward: f.isBackward });
          }, { priority: "low" }), this.downcastDispatcher.on("selection", (d, h, m) => {
            const f = h.selection;
            if (!f.isCollapsed || !m.consumable.consume(f, "selection"))
              return;
            const _ = m.writer, S = f.getFirstPosition(), B = m.mapper.toViewPosition(S), T = _.breakAttributes(B);
            _.setSelection(T);
          }, { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((d) => {
            if (d.rootName == "$graveyard")
              return null;
            const h = new nh(this.view.document, d.name);
            return h.rootName = d.rootName, this.mapper.bindElements(d, h), h;
          });
        }
        destroy() {
          this.view.destroy(), this.stopListening();
        }
        reconvertMarker(e) {
          const t = typeof e == "string" ? e : e.name, n = this.model.markers.get(t);
          if (!n)
            throw new O("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: t });
          this.model.change(() => {
            this.model.markers._refresh(n);
          });
        }
        reconvertItem(e) {
          this.model.change(() => {
            this.model.document.differ._refreshItem(e);
          });
        }
      }
      class Mi {
        constructor() {
          this._consumables = /* @__PURE__ */ new Map();
        }
        add(e, t) {
          let n;
          e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : (this._consumables.has(e) ? n = this._consumables.get(e) : (n = new IC(e), this._consumables.set(e, n)), n.add(t));
        }
        test(e, t) {
          const n = this._consumables.get(e);
          return n === void 0 ? null : e.is("$text") || e.is("documentFragment") ? n : n.test(t);
        }
        consume(e, t) {
          return !!this.test(e, t) && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !1) : this._consumables.get(e).consume(t), !0);
        }
        revert(e, t) {
          const n = this._consumables.get(e);
          n !== void 0 && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : n.revert(t));
        }
        static consumablesFromElement(e) {
          const t = { element: e, name: !0, attributes: [], classes: [], styles: [] }, n = e.getAttributeKeys();
          for (const s of n)
            s != "style" && s != "class" && t.attributes.push(s);
          const i = e.getClassNames();
          for (const s of i)
            t.classes.push(s);
          const r = e.getStyleNames();
          for (const s of r)
            t.styles.push(s);
          return t;
        }
        static createFrom(e, t) {
          if (t || (t = new Mi()), e.is("$text"))
            return t.add(e), t;
          e.is("element") && t.add(e, Mi.consumablesFromElement(e)), e.is("documentFragment") && t.add(e);
          for (const n of e.getChildren())
            t = Mi.createFrom(n, t);
          return t;
        }
      }
      const Gr = ["attributes", "classes", "styles"];
      class IC {
        constructor(e) {
          this.element = e, this._canConsumeName = null, this._consumables = { attributes: /* @__PURE__ */ new Map(), styles: /* @__PURE__ */ new Map(), classes: /* @__PURE__ */ new Map() };
        }
        add(e) {
          e.name && (this._canConsumeName = !0);
          for (const t of Gr)
            t in e && this._add(t, e[t]);
        }
        test(e) {
          if (e.name && !this._canConsumeName)
            return this._canConsumeName;
          for (const t of Gr)
            if (t in e) {
              const n = this._test(t, e[t]);
              if (n !== !0)
                return n;
            }
          return !0;
        }
        consume(e) {
          e.name && (this._canConsumeName = !1);
          for (const t of Gr)
            t in e && this._consume(t, e[t]);
        }
        revert(e) {
          e.name && (this._canConsumeName = !0);
          for (const t of Gr)
            t in e && this._revert(t, e[t]);
        }
        _add(e, t) {
          const n = At(t) ? t : [t], i = this._consumables[e];
          for (const r of n) {
            if (e === "attributes" && (r === "class" || r === "style"))
              throw new O("viewconsumable-invalid-attribute", this);
            if (i.set(r, !0), e === "styles")
              for (const s of this.element.document.stylesProcessor.getRelatedStyles(r))
                i.set(s, !0);
          }
        }
        _test(e, t) {
          const n = At(t) ? t : [t], i = this._consumables[e];
          for (const r of n)
            if (e !== "attributes" || r !== "class" && r !== "style") {
              const s = i.get(r);
              if (s === void 0)
                return null;
              if (!s)
                return !1;
            } else {
              const s = r == "class" ? "classes" : "styles", a = this._test(s, [...this._consumables[s].keys()]);
              if (a !== !0)
                return a;
            }
          return !0;
        }
        _consume(e, t) {
          const n = At(t) ? t : [t], i = this._consumables[e];
          for (const r of n)
            if (e !== "attributes" || r !== "class" && r !== "style") {
              if (i.set(r, !1), e == "styles")
                for (const s of this.element.document.stylesProcessor.getRelatedStyles(r))
                  i.set(s, !1);
            } else {
              const s = r == "class" ? "classes" : "styles";
              this._consume(s, [...this._consumables[s].keys()]);
            }
        }
        _revert(e, t) {
          const n = At(t) ? t : [t], i = this._consumables[e];
          for (const r of n)
            if (e !== "attributes" || r !== "class" && r !== "style")
              i.get(r) === !1 && i.set(r, !0);
            else {
              const s = r == "class" ? "classes" : "styles";
              this._revert(s, [...this._consumables[s].keys()]);
            }
        }
      }
      class PC extends re() {
        constructor() {
          super(), this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (e, t) => {
            t[0] = new so(t[0]);
          }, { priority: "highest" }), this.on("checkChild", (e, t) => {
            t[0] = new so(t[0]), t[1] = this.getDefinition(t[1]);
          }, { priority: "highest" });
        }
        register(e, t) {
          if (this._sourceDefinitions[e])
            throw new O("schema-cannot-register-item-twice", this, { itemName: e });
          this._sourceDefinitions[e] = [Object.assign({}, t)], this._clearCache();
        }
        extend(e, t) {
          if (!this._sourceDefinitions[e])
            throw new O("schema-cannot-extend-missing-item", this, { itemName: e });
          this._sourceDefinitions[e].push(Object.assign({}, t)), this._clearCache();
        }
        getDefinitions() {
          return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
        }
        getDefinition(e) {
          let t;
          return t = typeof e == "string" ? e : "is" in e && (e.is("$text") || e.is("$textProxy")) ? "$text" : e.name, this.getDefinitions()[t];
        }
        isRegistered(e) {
          return !!this.getDefinition(e);
        }
        isBlock(e) {
          const t = this.getDefinition(e);
          return !(!t || !t.isBlock);
        }
        isLimit(e) {
          const t = this.getDefinition(e);
          return !!t && !(!t.isLimit && !t.isObject);
        }
        isObject(e) {
          const t = this.getDefinition(e);
          return !!t && !!(t.isObject || t.isLimit && t.isSelectable && t.isContent);
        }
        isInline(e) {
          const t = this.getDefinition(e);
          return !(!t || !t.isInline);
        }
        isSelectable(e) {
          const t = this.getDefinition(e);
          return !!t && !(!t.isSelectable && !t.isObject);
        }
        isContent(e) {
          const t = this.getDefinition(e);
          return !!t && !(!t.isContent && !t.isObject);
        }
        checkChild(e, t) {
          return !!t && this._checkContextMatch(t, e);
        }
        checkAttribute(e, t) {
          const n = this.getDefinition(e.last);
          return !!n && n.allowAttributes.includes(t);
        }
        checkMerge(e, t) {
          if (e instanceof q) {
            const n = e.nodeBefore, i = e.nodeAfter;
            if (!(n instanceof Fe))
              throw new O("schema-check-merge-no-element-before", this);
            if (!(i instanceof Fe))
              throw new O("schema-check-merge-no-element-after", this);
            return this.checkMerge(n, i);
          }
          for (const n of t.getChildren())
            if (!this.checkChild(e, n))
              return !1;
          return !0;
        }
        addChildCheck(e) {
          this.on("checkChild", (t, [n, i]) => {
            if (!i)
              return;
            const r = e(n, i);
            typeof r == "boolean" && (t.stop(), t.return = r);
          }, { priority: "high" });
        }
        addAttributeCheck(e) {
          this.on("checkAttribute", (t, [n, i]) => {
            const r = e(n, i);
            typeof r == "boolean" && (t.stop(), t.return = r);
          }, { priority: "high" });
        }
        setAttributeProperties(e, t) {
          this._attributeProperties[e] = Object.assign(this.getAttributeProperties(e), t);
        }
        getAttributeProperties(e) {
          return this._attributeProperties[e] || {};
        }
        getLimitElement(e) {
          let t;
          for (e instanceof q ? t = e.parent : t = (e instanceof $ ? [e] : Array.from(e.getRanges())).reduce((n, i) => {
            const r = i.getCommonAncestor();
            return n ? n.getCommonAncestor(r, { includeSelf: !0 }) : r;
          }, null); !this.isLimit(t) && t.parent; )
            t = t.parent;
          return t;
        }
        checkAttributeInSelection(e, t) {
          if (e.isCollapsed) {
            const n = [...e.getFirstPosition().getAncestors(), new Ne("", e.getAttributes())];
            return this.checkAttribute(n, t);
          }
          {
            const n = e.getRanges();
            for (const i of n)
              for (const r of i)
                if (this.checkAttribute(r.item, t))
                  return !0;
          }
          return !1;
        }
        *getValidRanges(e, t) {
          e = function* (n) {
            for (const i of n)
              yield* i.getMinimalFlatRanges();
          }(e);
          for (const n of e)
            yield* this._getValidRangesForRange(n, t);
        }
        getNearestSelectionRange(e, t = "both") {
          if (this.checkChild(e, "$text"))
            return new $(e);
          let n, i;
          const r = e.getAncestors().reverse().find((s) => this.isLimit(s)) || e.root;
          t != "both" && t != "backward" || (n = new dn({ boundaries: $._createIn(r), startPosition: e, direction: "backward" })), t != "both" && t != "forward" || (i = new dn({ boundaries: $._createIn(r), startPosition: e }));
          for (const s of function* (a, l) {
            let d = !1;
            for (; !d; ) {
              if (d = !0, a) {
                const h = a.next();
                h.done || (d = !1, yield { walker: a, value: h.value });
              }
              if (l) {
                const h = l.next();
                h.done || (d = !1, yield { walker: l, value: h.value });
              }
            }
          }(n, i)) {
            const a = s.walker == n ? "elementEnd" : "elementStart", l = s.value;
            if (l.type == a && this.isObject(l.item))
              return $._createOn(l.item);
            if (this.checkChild(l.nextPosition, "$text"))
              return new $(l.nextPosition);
          }
          return null;
        }
        findAllowedParent(e, t) {
          let n = e.parent;
          for (; n; ) {
            if (this.checkChild(n, t))
              return n;
            if (this.isLimit(n))
              return null;
            n = n.parent;
          }
          return null;
        }
        setAllowedAttributes(e, t, n) {
          const i = n.model;
          for (const [r, s] of Object.entries(t))
            i.schema.checkAttribute(e, r) && n.setAttribute(r, s, e);
        }
        removeDisallowedAttributes(e, t) {
          for (const n of e)
            if (n.is("$text"))
              ug(this, n, t);
            else {
              const i = $._createIn(n).getPositions();
              for (const r of i)
                ug(this, r.nodeBefore || r.parent, t);
            }
        }
        getAttributesWithProperty(e, t, n) {
          const i = {};
          for (const [r, s] of e.getAttributes()) {
            const a = this.getAttributeProperties(r);
            a[t] !== void 0 && (n !== void 0 && n !== a[t] || (i[r] = s));
          }
          return i;
        }
        createContext(e) {
          return new so(e);
        }
        _clearCache() {
          this._compiledDefinitions = null;
        }
        _compile() {
          const e = {}, t = this._sourceDefinitions, n = Object.keys(t);
          for (const i of n)
            e[i] = OC(t[i], i);
          for (const i of n)
            RC(e, i);
          for (const i of n)
            zC(e, i);
          for (const i of n)
            MC(e, i);
          for (const i of n)
            NC(e, i), FC(e, i);
          for (const i of n)
            $C(e, i), VC(e, i), LC(e, i);
          this._compiledDefinitions = e;
        }
        _checkContextMatch(e, t, n = t.length - 1) {
          const i = t.getItem(n);
          if (e.allowIn.includes(i.name)) {
            if (n == 0)
              return !0;
            {
              const r = this.getDefinition(i);
              return this._checkContextMatch(r, t, n - 1);
            }
          }
          return !1;
        }
        *_getValidRangesForRange(e, t) {
          let n = e.start, i = e.start;
          for (const r of e.getItems({ shallow: !0 }))
            r.is("element") && (yield* this._getValidRangesForRange($._createIn(r), t)), this.checkAttribute(r, t) || (n.isEqual(i) || (yield new $(n, i)), n = q._createAfter(r)), i = q._createAfter(r);
          n.isEqual(i) || (yield new $(n, i));
        }
      }
      class so {
        constructor(e) {
          if (e instanceof so)
            return e;
          let t;
          t = typeof e == "string" ? [e] : Array.isArray(e) ? e : e.getAncestors({ includeSelf: !0 }), this._items = t.map(HC);
        }
        get length() {
          return this._items.length;
        }
        get last() {
          return this._items[this._items.length - 1];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
        push(e) {
          const t = new so([e]);
          return t._items = [...this._items, ...t._items], t;
        }
        getItem(e) {
          return this._items[e];
        }
        *getNames() {
          yield* this._items.map((e) => e.name);
        }
        endsWith(e) {
          return Array.from(this.getNames()).join(" ").endsWith(e);
        }
        startsWith(e) {
          return Array.from(this.getNames()).join(" ").startsWith(e);
        }
      }
      function OC(o, e) {
        const t = { name: e, allowIn: [], allowContentOf: [], allowWhere: [], allowAttributes: [], allowAttributesOf: [], allowChildren: [], inheritTypesFrom: [] };
        return function(n, i) {
          for (const r of n) {
            const s = Object.keys(r).filter((a) => a.startsWith("is"));
            for (const a of s)
              i[a] = !!r[a];
          }
        }(o, t), ao(o, t, "allowIn"), ao(o, t, "allowContentOf"), ao(o, t, "allowWhere"), ao(o, t, "allowAttributes"), ao(o, t, "allowAttributesOf"), ao(o, t, "allowChildren"), ao(o, t, "inheritTypesFrom"), function(n, i) {
          for (const r of n) {
            const s = r.inheritAllFrom;
            s && (i.allowContentOf.push(s), i.allowWhere.push(s), i.allowAttributesOf.push(s), i.inheritTypesFrom.push(s));
          }
        }(o, t), t;
      }
      function RC(o, e) {
        const t = o[e];
        for (const n of t.allowChildren) {
          const i = o[n];
          i && i.allowIn.push(e);
        }
        t.allowChildren.length = 0;
      }
      function zC(o, e) {
        for (const t of o[e].allowContentOf)
          o[t] && jC(o, t).forEach((n) => {
            n.allowIn.push(e);
          });
        delete o[e].allowContentOf;
      }
      function MC(o, e) {
        for (const t of o[e].allowWhere) {
          const n = o[t];
          if (n) {
            const i = n.allowIn;
            o[e].allowIn.push(...i);
          }
        }
        delete o[e].allowWhere;
      }
      function NC(o, e) {
        for (const t of o[e].allowAttributesOf) {
          const n = o[t];
          if (n) {
            const i = n.allowAttributes;
            o[e].allowAttributes.push(...i);
          }
        }
        delete o[e].allowAttributesOf;
      }
      function FC(o, e) {
        const t = o[e];
        for (const n of t.inheritTypesFrom) {
          const i = o[n];
          if (i) {
            const r = Object.keys(i).filter((s) => s.startsWith("is"));
            for (const s of r)
              s in t || (t[s] = i[s]);
          }
        }
        delete t.inheritTypesFrom;
      }
      function $C(o, e) {
        const t = o[e], n = t.allowIn.filter((i) => o[i]);
        t.allowIn = Array.from(new Set(n));
      }
      function VC(o, e) {
        const t = o[e];
        for (const n of t.allowIn)
          o[n].allowChildren.push(e);
      }
      function LC(o, e) {
        const t = o[e];
        t.allowAttributes = Array.from(new Set(t.allowAttributes));
      }
      function ao(o, e, t) {
        for (const n of o) {
          const i = n[t];
          typeof i == "string" ? e[t].push(i) : Array.isArray(i) && e[t].push(...i);
        }
      }
      function jC(o, e) {
        const t = o[e];
        return (n = o, Object.keys(n).map((i) => n[i])).filter((i) => i.allowIn.includes(t.name));
        var n;
      }
      function HC(o) {
        return typeof o == "string" || o.is("documentFragment") ? { name: typeof o == "string" ? o : "$documentFragment", *getAttributeKeys() {
        }, getAttribute() {
        } } : { name: o.is("element") ? o.name : "$text", *getAttributeKeys() {
          yield* o.getAttributeKeys();
        }, getAttribute: (e) => o.getAttribute(e) };
      }
      function ug(o, e, t) {
        for (const n of e.getAttributeKeys())
          o.checkAttribute(e, n) || t.removeAttribute(n, e);
      }
      var UC = Object.defineProperty, qC = Object.defineProperties, WC = Object.getOwnPropertyDescriptors, hg = Object.getOwnPropertySymbols, GC = Object.prototype.hasOwnProperty, KC = Object.prototype.propertyIsEnumerable, gg = (o, e, t) => e in o ? UC(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class ZC extends Se() {
        constructor(e) {
          var t;
          super(), this._splitParts = /* @__PURE__ */ new Map(), this._cursorParents = /* @__PURE__ */ new Map(), this._modelCursor = null, this._emptyElementsToKeep = /* @__PURE__ */ new Set(), this.conversionApi = (t = ((n, i) => {
            for (var r in i || (i = {}))
              GC.call(i, r) && gg(n, r, i[r]);
            if (hg)
              for (var r of hg(i))
                KC.call(i, r) && gg(n, r, i[r]);
            return n;
          })({}, e), qC(t, WC({ consumable: null, writer: null, store: null, convertItem: (n, i) => this._convertItem(n, i), convertChildren: (n, i) => this._convertChildren(n, i), safeInsert: (n, i) => this._safeInsert(n, i), updateConversionResult: (n, i) => this._updateConversionResult(n, i), splitToAllowedParent: (n, i) => this._splitToAllowedParent(n, i), getSplitParts: (n) => this._getSplitParts(n), keepEmptyElement: (n) => this._keepEmptyElement(n) })));
        }
        convert(e, t, n = ["$root"]) {
          this.fire("viewCleanup", e), this._modelCursor = function(s, a) {
            let l;
            for (const d of new so(s)) {
              const h = {};
              for (const f of d.getAttributeKeys())
                h[f] = d.getAttribute(f);
              const m = a.createElement(d.name, h);
              l && a.insert(m, l), l = q._createAt(m, 0);
            }
            return l;
          }(n, t), this.conversionApi.writer = t, this.conversionApi.consumable = Mi.createFrom(e), this.conversionApi.store = {};
          const { modelRange: i } = this._convertItem(e, this._modelCursor), r = t.createDocumentFragment();
          if (i) {
            this._removeEmptyElements();
            for (const s of Array.from(this._modelCursor.parent.getChildren()))
              t.append(s, r);
            r.markers = function(s, a) {
              const l = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Map(), h = $._createIn(s).getItems();
              for (const m of h)
                m.is("element", "$marker") && l.add(m);
              for (const m of l) {
                const f = m.getAttribute("data-name"), _ = a.createPositionBefore(m);
                d.has(f) ? d.get(f).end = _.clone() : d.set(f, new $(_.clone())), a.remove(m);
              }
              return d;
            }(r, t);
          }
          return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, r;
        }
        _convertItem(e, t) {
          const n = { viewItem: e, modelCursor: t, modelRange: null };
          if (e.is("element") ? this.fire(`element:${e.name}`, n, this.conversionApi) : e.is("$text") ? this.fire("text", n, this.conversionApi) : this.fire("documentFragment", n, this.conversionApi), n.modelRange && !(n.modelRange instanceof $))
            throw new O("view-conversion-dispatcher-incorrect-result", this);
          return { modelRange: n.modelRange, modelCursor: n.modelCursor };
        }
        _convertChildren(e, t) {
          let n = t.is("position") ? t : q._createAt(t, 0);
          const i = new $(n);
          for (const r of Array.from(e.getChildren())) {
            const s = this._convertItem(r, n);
            s.modelRange instanceof $ && (i.end = s.modelRange.end, n = s.modelCursor);
          }
          return { modelRange: i, modelCursor: n };
        }
        _safeInsert(e, t) {
          const n = this._splitToAllowedParent(e, t);
          return !!n && (this.conversionApi.writer.insert(e, n.position), !0);
        }
        _updateConversionResult(e, t) {
          const n = this._getSplitParts(e), i = this.conversionApi.writer;
          t.modelRange || (t.modelRange = i.createRange(i.createPositionBefore(e), i.createPositionAfter(n[n.length - 1])));
          const r = this._cursorParents.get(e);
          t.modelCursor = r ? i.createPositionAt(r, 0) : t.modelRange.end;
        }
        _splitToAllowedParent(e, t) {
          const { schema: n, writer: i } = this.conversionApi;
          let r = n.findAllowedParent(t, e);
          if (r) {
            if (r === t.parent)
              return { position: t };
            this._modelCursor.parent.getAncestors().includes(r) && (r = null);
          }
          if (!r)
            return eg(t, e, n) ? { position: tg(t, i) } : null;
          const s = this.conversionApi.writer.split(t, r), a = [];
          for (const d of s.range.getWalker())
            if (d.type == "elementEnd")
              a.push(d.item);
            else {
              const h = a.pop(), m = d.item;
              this._registerSplitPair(h, m);
            }
          const l = s.range.end.parent;
          return this._cursorParents.set(e, l), { position: s.position, cursorParent: l };
        }
        _registerSplitPair(e, t) {
          this._splitParts.has(e) || this._splitParts.set(e, [e]);
          const n = this._splitParts.get(e);
          this._splitParts.set(t, n), n.push(t);
        }
        _getSplitParts(e) {
          let t;
          return t = this._splitParts.has(e) ? this._splitParts.get(e) : [e], t;
        }
        _keepEmptyElement(e) {
          this._emptyElementsToKeep.add(e);
        }
        _removeEmptyElements() {
          let e = !1;
          for (const t of this._splitParts.keys())
            t.isEmpty && !this._emptyElementsToKeep.has(t) && (this.conversionApi.writer.remove(t), this._splitParts.delete(t), e = !0);
          e && this._removeEmptyElements();
        }
      }
      class JC {
        getHtml(e) {
          const t = document.implementation.createHTMLDocument("").createElement("div");
          return t.appendChild(e), t.innerHTML;
        }
      }
      class YC {
        constructor(e) {
          this.skipComments = !0, this.domParser = new DOMParser(), this.domConverter = new kh(e, { renderingMode: "data" }), this.htmlWriter = new JC();
        }
        toData(e) {
          const t = this.domConverter.viewToDom(e);
          return this.htmlWriter.getHtml(t);
        }
        toView(e) {
          const t = this._toDom(e);
          return this.domConverter.domToView(t, { skipComments: this.skipComments });
        }
        registerRawContentMatcher(e) {
          this.domConverter.registerRawContentMatcher(e);
        }
        useFillerType(e) {
          this.domConverter.blockFillerMode = e == "marked" ? "markedNbsp" : "nbsp";
        }
        _toDom(e) {
          e.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (e = `<body>${e}</body>`);
          const t = this.domParser.parseFromString(e, "text/html"), n = t.createDocumentFragment(), i = t.body.childNodes;
          for (; i.length > 0; )
            n.appendChild(i[0]);
          return n;
        }
      }
      class QC extends Se() {
        constructor(e, t) {
          super(), this.model = e, this.mapper = new Mh(), this.downcastDispatcher = new Vh({ mapper: this.mapper, schema: e.schema }), this.downcastDispatcher.on("insert:$text", (n, i, r) => {
            if (!r.consumable.consume(i.item, n.name))
              return;
            const s = r.writer, a = r.mapper.toViewPosition(i.range.start), l = s.createText(i.item.data);
            s.insert(a, l);
          }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (n, i, r) => {
            r.convertAttributes(i.item), i.reconversion || !i.item.is("element") || i.item.isEmpty || r.convertChildren(i.item);
          }, { priority: "lowest" }), this.upcastDispatcher = new ZC({ schema: e.schema }), this.viewDocument = new ih(t), this.stylesProcessor = t, this.htmlProcessor = new YC(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new rh(this.viewDocument), this.upcastDispatcher.on("text", (n, i, { schema: r, consumable: s, writer: a }) => {
            let l = i.modelCursor;
            if (!s.test(i.viewItem))
              return;
            if (!r.checkChild(l, "$text")) {
              if (!eg(l, "$text", r) || i.viewItem.data.trim().length == 0)
                return;
              const h = l.nodeBefore;
              l = tg(l, a), h && h.is("element", "$marker") && (a.move(a.createRangeOn(h), l), l = a.createPositionAfter(h));
            }
            s.consume(i.viewItem);
            const d = a.createText(i.viewItem.data);
            a.insert(d, l), i.modelRange = a.createRange(l, l.getShiftedBy(d.offsetSize)), i.modelCursor = i.modelRange.end;
          }, { priority: "lowest" }), this.upcastDispatcher.on("element", (n, i, r) => {
            if (!i.modelRange && r.consumable.consume(i.viewItem, { name: !0 })) {
              const { modelRange: s, modelCursor: a } = r.convertChildren(i.viewItem, i.modelCursor);
              i.modelRange = s, i.modelCursor = a;
            }
          }, { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", (n, i, r) => {
            if (!i.modelRange && r.consumable.consume(i.viewItem, { name: !0 })) {
              const { modelRange: s, modelCursor: a } = r.convertChildren(i.viewItem, i.modelCursor);
              i.modelRange = s, i.modelCursor = a;
            }
          }, { priority: "lowest" }), re().prototype.decorate.call(this, "init"), re().prototype.decorate.call(this, "set"), re().prototype.decorate.call(this, "get"), re().prototype.decorate.call(this, "toView"), re().prototype.decorate.call(this, "toModel"), this.on("init", () => {
            this.fire("ready");
          }, { priority: "lowest" }), this.on("ready", () => {
            this.model.enqueueChange({ isUndoable: !1 }, Xh);
          }, { priority: "lowest" });
        }
        get(e = {}) {
          const { rootName: t = "main", trim: n = "empty" } = e;
          if (!this._checkIfRootsExists([t]))
            throw new O("datacontroller-get-non-existent-root", this);
          const i = this.model.document.getRoot(t);
          return i.isAttached() || oe("datacontroller-get-detached-root", this), n !== "empty" || this.model.hasContent(i, { ignoreWhitespaces: !0 }) ? this.stringify(i, e) : "";
        }
        stringify(e, t = {}) {
          const n = this.toView(e, t);
          return this.processor.toData(n);
        }
        toView(e, t = {}) {
          const n = this.viewDocument, i = this._viewWriter;
          this.mapper.clearBindings();
          const r = $._createIn(e), s = new oo(n);
          this.mapper.bindElements(e, s);
          const a = e.is("documentFragment") ? e.markers : function(l) {
            const d = [], h = l.root.document;
            if (!h)
              return /* @__PURE__ */ new Map();
            const m = $._createIn(l);
            for (const f of h.model.markers) {
              const _ = f.getRange(), S = _.isCollapsed, B = _.start.isEqual(m.start) || _.end.isEqual(m.end);
              if (S && B)
                d.push([f.name, _]);
              else {
                const T = m.getIntersection(_);
                T && d.push([f.name, T]);
              }
            }
            return d.sort(([f, _], [S, B]) => {
              if (_.end.compareWith(B.start) !== "after")
                return 1;
              if (_.start.compareWith(B.end) !== "before")
                return -1;
              switch (_.start.compareWith(B.start)) {
                case "before":
                  return 1;
                case "after":
                  return -1;
                default:
                  switch (_.end.compareWith(B.end)) {
                    case "before":
                      return 1;
                    case "after":
                      return -1;
                    default:
                      return S.localeCompare(f);
                  }
              }
            }), new Map(d);
          }(e);
          return this.downcastDispatcher.convert(r, a, i, t), s;
        }
        init(e) {
          if (this.model.document.version)
            throw new O("datacontroller-init-document-not-empty", this);
          let t = {};
          if (typeof e == "string" ? t.main = e : t = e, !this._checkIfRootsExists(Object.keys(t)))
            throw new O("datacontroller-init-non-existent-root", this);
          return this.model.enqueueChange({ isUndoable: !1 }, (n) => {
            for (const i of Object.keys(t)) {
              const r = this.model.document.getRoot(i);
              n.insert(this.parse(t[i], r), r, 0);
            }
          }), Promise.resolve();
        }
        set(e, t = {}) {
          let n = {};
          if (typeof e == "string" ? n.main = e : n = e, !this._checkIfRootsExists(Object.keys(n)))
            throw new O("datacontroller-set-non-existent-root", this);
          this.model.enqueueChange(t.batchType || {}, (i) => {
            i.setSelection(null), i.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
            for (const r of Object.keys(n)) {
              const s = this.model.document.getRoot(r);
              i.remove(i.createRangeIn(s)), i.insert(this.parse(n[r], s), s, 0);
            }
          });
        }
        parse(e, t = "$root") {
          const n = this.processor.toView(e);
          return this.toModel(n, t);
        }
        toModel(e, t = "$root") {
          return this.model.change((n) => this.upcastDispatcher.convert(e, n, t));
        }
        addStyleProcessorRules(e) {
          e(this.stylesProcessor);
        }
        registerRawContentMatcher(e) {
          this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(e), this.htmlProcessor.registerRawContentMatcher(e);
        }
        destroy() {
          this.stopListening();
        }
        _checkIfRootsExists(e) {
          for (const t of e)
            if (!this.model.document.getRoot(t))
              return !1;
          return !0;
        }
      }
      class XC {
        constructor(e, t) {
          this._helpers = /* @__PURE__ */ new Map(), this._downcast = Xe(e), this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: !0 }), this._upcast = Xe(t), this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: !1 });
        }
        addAlias(e, t) {
          const n = this._downcast.includes(t);
          if (!this._upcast.includes(t) && !n)
            throw new O("conversion-add-alias-dispatcher-not-registered", this);
          this._createConversionHelpers({ name: e, dispatchers: [t], isDowncast: n });
        }
        for(e) {
          if (!this._helpers.has(e))
            throw new O("conversion-for-unknown-group", this);
          return this._helpers.get(e);
        }
        elementToElement(e) {
          this.for("downcast").elementToElement(e);
          for (const { model: t, view: n } of Qa(e))
            this.for("upcast").elementToElement({ model: t, view: n, converterPriority: e.converterPriority });
        }
        attributeToElement(e) {
          this.for("downcast").attributeToElement(e);
          for (const { model: t, view: n } of Qa(e))
            this.for("upcast").elementToAttribute({ view: n, model: t, converterPriority: e.converterPriority });
        }
        attributeToAttribute(e) {
          this.for("downcast").attributeToAttribute(e);
          for (const { model: t, view: n } of Qa(e))
            this.for("upcast").attributeToAttribute({ view: n, model: t });
        }
        _createConversionHelpers({ name: e, dispatchers: t, isDowncast: n }) {
          if (this._helpers.has(e))
            throw new O("conversion-group-exists", this);
          const i = n ? new vC(t) : new DC(t);
          this._helpers.set(e, i);
        }
      }
      function* Qa(o) {
        if (o.model.values)
          for (const e of o.model.values) {
            const t = { key: o.model.key, value: e }, n = o.view[e], i = o.upcastAlso ? o.upcastAlso[e] : void 0;
            yield* mg(t, n, i);
          }
        else
          yield* mg(o.model, o.view, o.upcastAlso);
      }
      function* mg(o, e, t) {
        if (yield { model: o, view: e }, t)
          for (const n of Xe(t))
            yield { model: o, view: n };
      }
      class $t {
        constructor(e) {
          this.baseVersion = e, this.isDocumentOperation = this.baseVersion !== null, this.batch = null;
        }
        _validate() {
        }
        toJSON() {
          const e = Object.assign({}, this);
          return e.__className = this.constructor.className, delete e.batch, delete e.isDocumentOperation, e;
        }
        static get className() {
          return "Operation";
        }
        static fromJSON(e, t) {
          return new this(e.baseVersion);
        }
      }
      function Xa(o, e) {
        const t = fg(e), n = t.reduce((s, a) => s + a.offsetSize, 0), i = o.parent;
        $i(o);
        const r = o.index;
        return i._insertChild(r, t), Fi(i, r + t.length), Fi(i, r), new $(o, o.getShiftedBy(n));
      }
      function pg(o) {
        if (!o.isFlat)
          throw new O("operation-utils-remove-range-not-flat", this);
        const e = o.start.parent;
        $i(o.start), $i(o.end);
        const t = e._removeChildren(o.start.index, o.end.index - o.start.index);
        return Fi(e, o.start.index), t;
      }
      function Ni(o, e) {
        if (!o.isFlat)
          throw new O("operation-utils-move-range-not-flat", this);
        const t = pg(o);
        return Xa(e = e._getTransformedByDeletion(o.start, o.end.offset - o.start.offset), t);
      }
      function fg(o) {
        const e = [];
        (function t(n) {
          if (typeof n == "string")
            e.push(new Ne(n));
          else if (n instanceof Yt)
            e.push(new Ne(n.data, n.getAttributes()));
          else if (n instanceof io)
            e.push(n);
          else if (zt(n))
            for (const i of n)
              t(i);
        })(o);
        for (let t = 1; t < e.length; t++) {
          const n = e[t], i = e[t - 1];
          n instanceof Ne && i instanceof Ne && bg(n, i) && (e.splice(t - 1, 2, new Ne(i.data + n.data, i.getAttributes())), t--);
        }
        return e;
      }
      function Fi(o, e) {
        const t = o.getChild(e - 1), n = o.getChild(e);
        if (t && n && t.is("$text") && n.is("$text") && bg(t, n)) {
          const i = new Ne(t.data + n.data, t.getAttributes());
          o._removeChildren(e - 1, 2), o._insertChild(e - 1, i);
        }
      }
      function $i(o) {
        const e = o.textNode, t = o.parent;
        if (e) {
          const n = o.offset - e.startOffset, i = e.index;
          t._removeChildren(i, 1);
          const r = new Ne(e.data.substr(0, n), e.getAttributes()), s = new Ne(e.data.substr(n), e.getAttributes());
          t._insertChild(i, [r, s]);
        }
      }
      function bg(o, e) {
        const t = o.getAttributes(), n = e.getAttributes();
        for (const i of t) {
          if (i[1] !== e.getAttribute(i[0]))
            return !1;
          n.next();
        }
        return n.next().done;
      }
      class De extends $t {
        constructor(e, t, n, i) {
          super(i), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNone";
        }
        get type() {
          return this.targetPosition.root.rootName == "$graveyard" ? "remove" : this.sourcePosition.root.rootName == "$graveyard" ? "reinsert" : "move";
        }
        get affectedSelectable() {
          return [$._createFromPositionAndShift(this.sourcePosition, this.howMany), $._createFromPositionAndShift(this.targetPosition, 0)];
        }
        clone() {
          return new De(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
        }
        getReversed() {
          const e = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
          return new De(this.getMovedRangeStart(), this.howMany, e, this.baseVersion + 1);
        }
        _validate() {
          const e = this.sourcePosition.parent, t = this.targetPosition.parent, n = this.sourcePosition.offset, i = this.targetPosition.offset;
          if (n + this.howMany > e.maxOffset)
            throw new O("move-operation-nodes-do-not-exist", this);
          if (e === t && n < i && i < n + this.howMany)
            throw new O("move-operation-range-into-itself", this);
          if (this.sourcePosition.root == this.targetPosition.root && _t(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
            const r = this.sourcePosition.path.length - 1;
            if (this.targetPosition.path[r] >= n && this.targetPosition.path[r] < n + this.howMany)
              throw new O("move-operation-node-into-itself", this);
          }
        }
        _execute() {
          Ni($._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
        }
        toJSON() {
          const e = super.toJSON();
          return e.sourcePosition = this.sourcePosition.toJSON(), e.targetPosition = this.targetPosition.toJSON(), e;
        }
        static get className() {
          return "MoveOperation";
        }
        static fromJSON(e, t) {
          const n = q.fromJSON(e.sourcePosition, t), i = q.fromJSON(e.targetPosition, t);
          return new this(n, e.howMany, i, e.baseVersion);
        }
      }
      class ht extends $t {
        constructor(e, t, n) {
          super(n), this.position = e.clone(), this.position.stickiness = "toNone", this.nodes = new Oi(fg(t)), this.shouldReceiveAttributes = !1;
        }
        get type() {
          return "insert";
        }
        get howMany() {
          return this.nodes.maxOffset;
        }
        get affectedSelectable() {
          return this.position.clone();
        }
        clone() {
          const e = new Oi([...this.nodes].map((n) => n._clone(!0))), t = new ht(this.position, e, this.baseVersion);
          return t.shouldReceiveAttributes = this.shouldReceiveAttributes, t;
        }
        getReversed() {
          const e = this.position.root.document.graveyard, t = new q(e, [0]);
          return new De(this.position, this.nodes.maxOffset, t, this.baseVersion + 1);
        }
        _validate() {
          const e = this.position.parent;
          if (!e || e.maxOffset < this.position.offset)
            throw new O("insert-operation-position-invalid", this);
        }
        _execute() {
          const e = this.nodes;
          this.nodes = new Oi([...e].map((t) => t._clone(!0))), Xa(this.position, e);
        }
        toJSON() {
          const e = super.toJSON();
          return e.position = this.position.toJSON(), e.nodes = this.nodes.toJSON(), e;
        }
        static get className() {
          return "InsertOperation";
        }
        static fromJSON(e, t) {
          const n = [];
          for (const r of e.nodes)
            r.name ? n.push(Fe.fromJSON(r)) : n.push(Ne.fromJSON(r));
          const i = new ht(q.fromJSON(e.position, t), n, e.baseVersion);
          return i.shouldReceiveAttributes = e.shouldReceiveAttributes, i;
        }
      }
      class $e extends $t {
        constructor(e, t, n, i, r) {
          super(r), this.splitPosition = e.clone(), this.splitPosition.stickiness = "toNext", this.howMany = t, this.insertionPosition = n, this.graveyardPosition = i ? i.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
        }
        get type() {
          return "split";
        }
        get moveTargetPosition() {
          const e = this.insertionPosition.path.slice();
          return e.push(0), new q(this.insertionPosition.root, e);
        }
        get movedRange() {
          const e = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new $(this.splitPosition, e);
        }
        get affectedSelectable() {
          const e = [$._createFromPositionAndShift(this.splitPosition, 0), $._createFromPositionAndShift(this.insertionPosition, 0)];
          return this.graveyardPosition && e.push($._createFromPositionAndShift(this.graveyardPosition, 0)), e;
        }
        clone() {
          return new $e(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
        }
        getReversed() {
          const e = this.splitPosition.root.document.graveyard, t = new q(e, [0]);
          return new et(this.moveTargetPosition, this.howMany, this.splitPosition, t, this.baseVersion + 1);
        }
        _validate() {
          const e = this.splitPosition.parent, t = this.splitPosition.offset;
          if (!e || e.maxOffset < t)
            throw new O("split-operation-position-invalid", this);
          if (!e.parent)
            throw new O("split-operation-split-in-root", this);
          if (this.howMany != e.maxOffset - this.splitPosition.offset)
            throw new O("split-operation-how-many-invalid", this);
          if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
            throw new O("split-operation-graveyard-position-invalid", this);
        }
        _execute() {
          const e = this.splitPosition.parent;
          if (this.graveyardPosition)
            Ni($._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
          else {
            const t = e._clone();
            Xa(this.insertionPosition, t);
          }
          Ni(new $(q._createAt(e, this.splitPosition.offset), q._createAt(e, e.maxOffset)), this.moveTargetPosition);
        }
        toJSON() {
          const e = super.toJSON();
          return e.splitPosition = this.splitPosition.toJSON(), e.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (e.graveyardPosition = this.graveyardPosition.toJSON()), e;
        }
        static get className() {
          return "SplitOperation";
        }
        static getInsertionPosition(e) {
          const t = e.path.slice(0, -1);
          return t[t.length - 1]++, new q(e.root, t, "toPrevious");
        }
        static fromJSON(e, t) {
          const n = q.fromJSON(e.splitPosition, t), i = q.fromJSON(e.insertionPosition, t), r = e.graveyardPosition ? q.fromJSON(e.graveyardPosition, t) : null;
          return new this(n, e.howMany, i, r, e.baseVersion);
        }
      }
      class et extends $t {
        constructor(e, t, n, i, r) {
          super(r), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = i.clone();
        }
        get type() {
          return "merge";
        }
        get deletionPosition() {
          return new q(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
        }
        get movedRange() {
          const e = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new $(this.sourcePosition, e);
        }
        get affectedSelectable() {
          const e = this.sourcePosition.parent;
          return [$._createOn(e), $._createFromPositionAndShift(this.targetPosition, 0), $._createFromPositionAndShift(this.graveyardPosition, 0)];
        }
        clone() {
          return new et(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
        }
        getReversed() {
          const e = this.targetPosition._getTransformedByMergeOperation(this), t = this.sourcePosition.path.slice(0, -1), n = new q(this.sourcePosition.root, t)._getTransformedByMergeOperation(this);
          return new $e(e, this.howMany, n, this.graveyardPosition, this.baseVersion + 1);
        }
        _validate() {
          const e = this.sourcePosition.parent, t = this.targetPosition.parent;
          if (!e.parent)
            throw new O("merge-operation-source-position-invalid", this);
          if (!t.parent)
            throw new O("merge-operation-target-position-invalid", this);
          if (this.howMany != e.maxOffset)
            throw new O("merge-operation-how-many-invalid", this);
        }
        _execute() {
          const e = this.sourcePosition.parent;
          Ni($._createIn(e), this.targetPosition), Ni($._createOn(e), this.graveyardPosition);
        }
        toJSON() {
          const e = super.toJSON();
          return e.sourcePosition = e.sourcePosition.toJSON(), e.targetPosition = e.targetPosition.toJSON(), e.graveyardPosition = e.graveyardPosition.toJSON(), e;
        }
        static get className() {
          return "MergeOperation";
        }
        static fromJSON(e, t) {
          const n = q.fromJSON(e.sourcePosition, t), i = q.fromJSON(e.targetPosition, t), r = q.fromJSON(e.graveyardPosition, t);
          return new this(n, e.howMany, i, r, e.baseVersion);
        }
      }
      class St extends $t {
        constructor(e, t, n, i, r, s) {
          super(s), this.name = e, this.oldRange = t ? t.clone() : null, this.newRange = n ? n.clone() : null, this.affectsData = r, this._markers = i;
        }
        get type() {
          return "marker";
        }
        get affectedSelectable() {
          const e = [];
          return this.oldRange && e.push(this.oldRange.clone()), this.newRange && (this.oldRange ? e.push(...this.newRange.getDifference(this.oldRange)) : e.push(this.newRange.clone())), e;
        }
        clone() {
          return new St(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
        }
        getReversed() {
          return new St(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
        }
        _execute() {
          this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name);
        }
        toJSON() {
          const e = super.toJSON();
          return this.oldRange && (e.oldRange = this.oldRange.toJSON()), this.newRange && (e.newRange = this.newRange.toJSON()), delete e._markers, e;
        }
        static get className() {
          return "MarkerOperation";
        }
        static fromJSON(e, t) {
          return new St(e.name, e.oldRange ? $.fromJSON(e.oldRange, t) : null, e.newRange ? $.fromJSON(e.newRange, t) : null, t.model.markers, e.affectsData, e.baseVersion);
        }
      }
      const Kr = function(o, e) {
        return Bh(o, e);
      };
      class rt extends $t {
        constructor(e, t, n, i, r) {
          super(r), this.range = e.clone(), this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = i === void 0 ? null : i;
        }
        get type() {
          return this.oldValue === null ? "addAttribute" : this.newValue === null ? "removeAttribute" : "changeAttribute";
        }
        get affectedSelectable() {
          return this.range.clone();
        }
        clone() {
          return new rt(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new rt(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        toJSON() {
          const e = super.toJSON();
          return e.range = this.range.toJSON(), e;
        }
        _validate() {
          if (!this.range.isFlat)
            throw new O("attribute-operation-range-not-flat", this);
          for (const e of this.range.getItems({ shallow: !0 })) {
            if (this.oldValue !== null && !Kr(e.getAttribute(this.key), this.oldValue))
              throw new O("attribute-operation-wrong-old-value", this, { item: e, key: this.key, value: this.oldValue });
            if (this.oldValue === null && this.newValue !== null && e.hasAttribute(this.key))
              throw new O("attribute-operation-attribute-exists", this, { node: e, key: this.key });
          }
        }
        _execute() {
          Kr(this.oldValue, this.newValue) || function(e, t, n) {
            $i(e.start), $i(e.end);
            for (const i of e.getItems({ shallow: !0 })) {
              const r = i.is("$textProxy") ? i.textNode : i;
              n !== null ? r._setAttribute(t, n) : r._removeAttribute(t), Fi(r.parent, r.index);
            }
            Fi(e.end.parent, e.end.index);
          }(this.range, this.key, this.newValue);
        }
        static get className() {
          return "AttributeOperation";
        }
        static fromJSON(e, t) {
          return new rt($.fromJSON(e.range, t), e.key, e.oldValue, e.newValue, e.baseVersion);
        }
      }
      class ct extends $t {
        get type() {
          return "noop";
        }
        get affectedSelectable() {
          return null;
        }
        clone() {
          return new ct(this.baseVersion);
        }
        getReversed() {
          return new ct(this.baseVersion + 1);
        }
        _execute() {
        }
        static get className() {
          return "NoOperation";
        }
      }
      class Dt extends $t {
        constructor(e, t, n, i) {
          super(i), this.position = e, this.position.stickiness = "toNext", this.oldName = t, this.newName = n;
        }
        get type() {
          return "rename";
        }
        get affectedSelectable() {
          return this.position.nodeAfter;
        }
        clone() {
          return new Dt(this.position.clone(), this.oldName, this.newName, this.baseVersion);
        }
        getReversed() {
          return new Dt(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
        }
        _validate() {
          const e = this.position.nodeAfter;
          if (!(e instanceof Fe))
            throw new O("rename-operation-wrong-position", this);
          if (e.name !== this.oldName)
            throw new O("rename-operation-wrong-name", this);
        }
        _execute() {
          this.position.nodeAfter.name = this.newName;
        }
        toJSON() {
          const e = super.toJSON();
          return e.position = this.position.toJSON(), e;
        }
        static get className() {
          return "RenameOperation";
        }
        static fromJSON(e, t) {
          return new Dt(q.fromJSON(e.position, t), e.oldName, e.newName, e.baseVersion);
        }
      }
      class bn extends $t {
        constructor(e, t, n, i, r) {
          super(r), this.root = e, this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = i === void 0 ? null : i;
        }
        get type() {
          return this.oldValue === null ? "addRootAttribute" : this.newValue === null ? "removeRootAttribute" : "changeRootAttribute";
        }
        get affectedSelectable() {
          return this.root;
        }
        clone() {
          return new bn(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new bn(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        _validate() {
          if (this.root != this.root.root || this.root.is("documentFragment"))
            throw new O("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
          if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue)
            throw new O("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
          if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key))
            throw new O("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
        }
        _execute() {
          this.newValue !== null ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
        }
        toJSON() {
          const e = super.toJSON();
          return e.root = this.root.toJSON(), e;
        }
        static get className() {
          return "RootAttributeOperation";
        }
        static fromJSON(e, t) {
          if (!t.getRoot(e.root))
            throw new O("rootattribute-operation-fromjson-no-root", this, { rootName: e.root });
          return new bn(t.getRoot(e.root), e.key, e.oldValue, e.newValue, e.baseVersion);
        }
      }
      class un extends $t {
        constructor(e, t, n, i, r) {
          super(r), this.rootName = e, this.elementName = t, this.isAdd = n, this._document = i, !this._document.getRoot(this.rootName) && (this._document.createRoot(this.elementName, this.rootName)._isAttached = !1);
        }
        get type() {
          return this.isAdd ? "addRoot" : "detachRoot";
        }
        get affectedSelectable() {
          return this._document.getRoot(this.rootName);
        }
        clone() {
          return new un(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
        }
        getReversed() {
          return new un(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
        }
        _validate() {
          const e = this._document.getRoot(this.rootName);
          if (e.isAttached() && this.isAdd)
            throw new O("root-operation-root-attached", this);
          if (!e.isAttached() && !this.isAdd)
            throw new O("root-operation-root-detached", this);
        }
        _execute() {
          this._document.getRoot(this.rootName)._isAttached = this.isAdd;
        }
        toJSON() {
          const e = super.toJSON();
          return delete e._document, e;
        }
        static get className() {
          return "RootOperation";
        }
        static fromJSON(e, t) {
          return new un(e.rootName, e.elementName, e.isAdd, t, e.baseVersion);
        }
      }
      const Ut = {};
      Ut[rt.className] = rt, Ut[ht.className] = ht, Ut[St.className] = St, Ut[De.className] = De, Ut[ct.className] = ct, Ut[$t.className] = $t, Ut[Dt.className] = Dt, Ut[bn.className] = bn, Ut[un.className] = un, Ut[$e.className] = $e, Ut[et.className] = et;
      class e1 {
        static fromJSON(e, t) {
          return Ut[e.__className].fromJSON(e, t);
        }
      }
      const el = /* @__PURE__ */ new Map();
      function ye(o, e, t) {
        let n = el.get(o);
        n || (n = /* @__PURE__ */ new Map(), el.set(o, n)), n.set(e, t);
      }
      function t1(o) {
        return [o];
      }
      function kg(o, e, t = {}) {
        const n = function(i, r) {
          const s = el.get(i);
          return s && s.has(r) ? s.get(r) : t1;
        }(o.constructor, e.constructor);
        try {
          return n(o = o.clone(), e, t);
        } catch (i) {
          throw i;
        }
      }
      function n1(o, e, t) {
        o = o.slice(), e = e.slice();
        const n = new o1(t.document, t.useRelations, t.forceWeakRemove);
        n.setOriginalOperations(o), n.setOriginalOperations(e);
        const i = n.originalOperations;
        if (o.length == 0 || e.length == 0)
          return { operationsA: o, operationsB: e, originalOperations: i };
        const r = /* @__PURE__ */ new WeakMap();
        for (const l of o)
          r.set(l, 0);
        const s = { nextBaseVersionA: o[o.length - 1].baseVersion + 1, nextBaseVersionB: e[e.length - 1].baseVersion + 1, originalOperationsACount: o.length, originalOperationsBCount: e.length };
        let a = 0;
        for (; a < o.length; ) {
          const l = o[a], d = r.get(l);
          if (d == e.length) {
            a++;
            continue;
          }
          const h = e[d], m = kg(l, h, n.getContext(l, h, !0)), f = kg(h, l, n.getContext(h, l, !1));
          n.updateRelation(l, h), n.setOriginalOperations(m, l), n.setOriginalOperations(f, h);
          for (const _ of m)
            r.set(_, d + f.length);
          o.splice(a, 1, ...m), e.splice(d, 1, ...f);
        }
        if (t.padWithNoOps) {
          const l = o.length - s.originalOperationsACount, d = e.length - s.originalOperationsBCount;
          vg(o, d - l), vg(e, l - d);
        }
        return wg(o, s.nextBaseVersionB), wg(e, s.nextBaseVersionA), { operationsA: o, operationsB: e, originalOperations: i };
      }
      class o1 {
        constructor(e, t, n = !1) {
          this.originalOperations = /* @__PURE__ */ new Map(), this._history = e.history, this._useRelations = t, this._forceWeakRemove = !!n, this._relations = /* @__PURE__ */ new Map();
        }
        setOriginalOperations(e, t = null) {
          const n = t ? this.originalOperations.get(t) : null;
          for (const i of e)
            this.originalOperations.set(i, n || i);
        }
        updateRelation(e, t) {
          if (e instanceof De)
            t instanceof et ? e.targetPosition.isEqual(t.sourcePosition) || t.movedRange.containsPosition(e.targetPosition) ? this._setRelation(e, t, "insertAtSource") : e.targetPosition.isEqual(t.deletionPosition) ? this._setRelation(e, t, "insertBetween") : e.targetPosition.isAfter(t.sourcePosition) && this._setRelation(e, t, "moveTargetAfter") : t instanceof De && (e.targetPosition.isEqual(t.sourcePosition) || e.targetPosition.isBefore(t.sourcePosition) ? this._setRelation(e, t, "insertBefore") : this._setRelation(e, t, "insertAfter"));
          else if (e instanceof $e) {
            if (t instanceof et)
              e.splitPosition.isBefore(t.sourcePosition) && this._setRelation(e, t, "splitBefore");
            else if (t instanceof De)
              if (e.splitPosition.isEqual(t.sourcePosition) || e.splitPosition.isBefore(t.sourcePosition))
                this._setRelation(e, t, "splitBefore");
              else {
                const n = $._createFromPositionAndShift(t.sourcePosition, t.howMany);
                if (e.splitPosition.hasSameParentAs(t.sourcePosition) && n.containsPosition(e.splitPosition)) {
                  const i = n.end.offset - e.splitPosition.offset, r = e.splitPosition.offset - n.start.offset;
                  this._setRelation(e, t, { howMany: i, offset: r });
                }
              }
          } else if (e instanceof et)
            t instanceof et ? (e.targetPosition.isEqual(t.sourcePosition) || this._setRelation(e, t, "mergeTargetNotMoved"), e.sourcePosition.isEqual(t.targetPosition) && this._setRelation(e, t, "mergeSourceNotMoved"), e.sourcePosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeSameElement")) : t instanceof $e && e.sourcePosition.isEqual(t.splitPosition) && this._setRelation(e, t, "splitAtSource");
          else if (e instanceof St) {
            const n = e.newRange;
            if (!n)
              return;
            if (t instanceof De) {
              const i = $._createFromPositionAndShift(t.sourcePosition, t.howMany), r = i.containsPosition(n.start) || i.start.isEqual(n.start), s = i.containsPosition(n.end) || i.end.isEqual(n.end);
              !r && !s || i.containsRange(n) || this._setRelation(e, t, { side: r ? "left" : "right", path: r ? n.start.path.slice() : n.end.path.slice() });
            } else if (t instanceof et) {
              const i = n.start.isEqual(t.targetPosition), r = n.start.isEqual(t.deletionPosition), s = n.end.isEqual(t.deletionPosition), a = n.end.isEqual(t.sourcePosition);
              (i || r || s || a) && this._setRelation(e, t, { wasInLeftElement: i, wasStartBeforeMergedElement: r, wasEndBeforeMergedElement: s, wasInRightElement: a });
            }
          }
        }
        getContext(e, t, n) {
          return { aIsStrong: n, aWasUndone: this._wasUndone(e), bWasUndone: this._wasUndone(t), abRelation: this._useRelations ? this._getRelation(e, t) : null, baRelation: this._useRelations ? this._getRelation(t, e) : null, forceWeakRemove: this._forceWeakRemove };
        }
        _wasUndone(e) {
          const t = this.originalOperations.get(e);
          return t.wasUndone || this._history.isUndoneOperation(t);
        }
        _getRelation(e, t) {
          const n = this.originalOperations.get(t), i = this._history.getUndoneOperation(n);
          if (!i)
            return null;
          const r = this.originalOperations.get(e), s = this._relations.get(r);
          return s && s.get(i) || null;
        }
        _setRelation(e, t, n) {
          const i = this.originalOperations.get(e), r = this.originalOperations.get(t);
          let s = this._relations.get(i);
          s || (s = /* @__PURE__ */ new Map(), this._relations.set(i, s)), s.set(r, n);
        }
      }
      function wg(o, e) {
        for (const t of o)
          t.baseVersion = e++;
      }
      function vg(o, e) {
        for (let t = 0; t < e; t++)
          o.push(new ct(0));
      }
      function _g(o, e, t) {
        const n = o.nodes.getNode(0).getAttribute(e);
        if (n == t)
          return null;
        const i = new $(o.position, o.position.getShiftedBy(o.howMany));
        return new rt(i, e, n, t, 0);
      }
      function Ag(o, e) {
        return o.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null;
      }
      function Lo(o, e) {
        const t = [];
        for (let n = 0; n < o.length; n++) {
          const i = o[n], r = new De(i.start, i.end.offset - i.start.offset, e, 0);
          t.push(r);
          for (let s = n + 1; s < o.length; s++)
            o[s] = o[s]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0];
          e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany);
        }
        return t;
      }
      ye(rt, rt, (o, e, t) => {
        if (o.key === e.key && o.range.start.hasSameParentAs(e.range.start)) {
          const n = o.range.getDifference(e.range).map((r) => new rt(r, o.key, o.oldValue, o.newValue, 0)), i = o.range.getIntersection(e.range);
          return i && t.aIsStrong && n.push(new rt(i, e.key, e.newValue, o.newValue, 0)), n.length == 0 ? [new ct(0)] : n;
        }
        return [o];
      }), ye(rt, ht, (o, e) => {
        if (o.range.start.hasSameParentAs(e.position) && o.range.containsPosition(e.position)) {
          const t = o.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes).map((n) => new rt(n, o.key, o.oldValue, o.newValue, o.baseVersion));
          if (e.shouldReceiveAttributes) {
            const n = _g(e, o.key, o.oldValue);
            n && t.unshift(n);
          }
          return t;
        }
        return o.range = o.range._getTransformedByInsertion(e.position, e.howMany, !1)[0], [o];
      }), ye(rt, et, (o, e) => {
        const t = [];
        o.range.start.hasSameParentAs(e.deletionPosition) && (o.range.containsPosition(e.deletionPosition) || o.range.start.isEqual(e.deletionPosition)) && t.push($._createFromPositionAndShift(e.graveyardPosition, 1));
        const n = o.range._getTransformedByMergeOperation(e);
        return n.isCollapsed || t.push(n), t.map((i) => new rt(i, o.key, o.oldValue, o.newValue, o.baseVersion));
      }), ye(rt, De, (o, e) => function(n, i) {
        const r = $._createFromPositionAndShift(i.sourcePosition, i.howMany);
        let s = null, a = [];
        r.containsRange(n, !0) ? s = n : n.start.hasSameParentAs(r.start) ? (a = n.getDifference(r), s = n.getIntersection(r)) : a = [n];
        const l = [];
        for (let d of a) {
          d = d._getTransformedByDeletion(i.sourcePosition, i.howMany);
          const h = i.getMovedRangeStart(), m = d.start.hasSameParentAs(h), f = d._getTransformedByInsertion(h, i.howMany, m);
          l.push(...f);
        }
        return s && l.push(s._getTransformedByMove(i.sourcePosition, i.targetPosition, i.howMany, !1)[0]), l;
      }(o.range, e).map((n) => new rt(n, o.key, o.oldValue, o.newValue, o.baseVersion))), ye(rt, $e, (o, e) => {
        if (o.range.end.isEqual(e.insertionPosition))
          return e.graveyardPosition || o.range.end.offset++, [o];
        if (o.range.start.hasSameParentAs(e.splitPosition) && o.range.containsPosition(e.splitPosition)) {
          const t = o.clone();
          return t.range = new $(e.moveTargetPosition.clone(), o.range.end._getCombined(e.splitPosition, e.moveTargetPosition)), o.range.end = e.splitPosition.clone(), o.range.end.stickiness = "toPrevious", [o, t];
        }
        return o.range = o.range._getTransformedBySplitOperation(e), [o];
      }), ye(ht, rt, (o, e) => {
        const t = [o];
        if (o.shouldReceiveAttributes && o.position.hasSameParentAs(e.range.start) && e.range.containsPosition(o.position)) {
          const n = _g(o, e.key, e.newValue);
          n && t.push(n);
        }
        return t;
      }), ye(ht, ht, (o, e, t) => (o.position.isEqual(e.position) && t.aIsStrong || (o.position = o.position._getTransformedByInsertOperation(e)), [o])), ye(ht, De, (o, e) => (o.position = o.position._getTransformedByMoveOperation(e), [o])), ye(ht, $e, (o, e) => (o.position = o.position._getTransformedBySplitOperation(e), [o])), ye(ht, et, (o, e) => (o.position = o.position._getTransformedByMergeOperation(e), [o])), ye(St, ht, (o, e) => (o.oldRange && (o.oldRange = o.oldRange._getTransformedByInsertOperation(e)[0]), o.newRange && (o.newRange = o.newRange._getTransformedByInsertOperation(e)[0]), [o])), ye(St, St, (o, e, t) => {
        if (o.name == e.name) {
          if (!t.aIsStrong)
            return [new ct(0)];
          o.oldRange = e.newRange ? e.newRange.clone() : null;
        }
        return [o];
      }), ye(St, et, (o, e) => (o.oldRange && (o.oldRange = o.oldRange._getTransformedByMergeOperation(e)), o.newRange && (o.newRange = o.newRange._getTransformedByMergeOperation(e)), [o])), ye(St, De, (o, e, t) => {
        if (o.oldRange && (o.oldRange = $._createFromRanges(o.oldRange._getTransformedByMoveOperation(e))), o.newRange) {
          if (t.abRelation) {
            const n = $._createFromRanges(o.newRange._getTransformedByMoveOperation(e));
            if (t.abRelation.side == "left" && e.targetPosition.isEqual(o.newRange.start))
              return o.newRange.end = n.end, o.newRange.start.path = t.abRelation.path, [o];
            if (t.abRelation.side == "right" && e.targetPosition.isEqual(o.newRange.end))
              return o.newRange.start = n.start, o.newRange.end.path = t.abRelation.path, [o];
          }
          o.newRange = $._createFromRanges(o.newRange._getTransformedByMoveOperation(e));
        }
        return [o];
      }), ye(St, $e, (o, e, t) => {
        if (o.oldRange && (o.oldRange = o.oldRange._getTransformedBySplitOperation(e)), o.newRange) {
          if (t.abRelation) {
            const n = o.newRange._getTransformedBySplitOperation(e);
            return o.newRange.start.isEqual(e.splitPosition) && t.abRelation.wasStartBeforeMergedElement ? o.newRange.start = q._createAt(e.insertionPosition) : o.newRange.start.isEqual(e.splitPosition) && !t.abRelation.wasInLeftElement && (o.newRange.start = q._createAt(e.moveTargetPosition)), o.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasInRightElement ? o.newRange.end = q._createAt(e.moveTargetPosition) : o.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasEndBeforeMergedElement ? o.newRange.end = q._createAt(e.insertionPosition) : o.newRange.end = n.end, [o];
          }
          o.newRange = o.newRange._getTransformedBySplitOperation(e);
        }
        return [o];
      }), ye(et, ht, (o, e) => (o.sourcePosition.hasSameParentAs(e.position) && (o.howMany += e.howMany), o.sourcePosition = o.sourcePosition._getTransformedByInsertOperation(e), o.targetPosition = o.targetPosition._getTransformedByInsertOperation(e), [o])), ye(et, et, (o, e, t) => {
        if (o.sourcePosition.isEqual(e.sourcePosition) && o.targetPosition.isEqual(e.targetPosition)) {
          if (t.bWasUndone) {
            const n = e.graveyardPosition.path.slice();
            return n.push(0), o.sourcePosition = new q(e.graveyardPosition.root, n), o.howMany = 0, [o];
          }
          return [new ct(0)];
        }
        if (o.sourcePosition.isEqual(e.sourcePosition) && !o.targetPosition.isEqual(e.targetPosition) && !t.bWasUndone && t.abRelation != "splitAtSource") {
          const n = o.targetPosition.root.rootName == "$graveyard", i = e.targetPosition.root.rootName == "$graveyard";
          if (i && !n || !(n && !i) && t.aIsStrong) {
            const r = e.targetPosition._getTransformedByMergeOperation(e), s = o.targetPosition._getTransformedByMergeOperation(e);
            return [new De(r, o.howMany, s, 0)];
          }
          return [new ct(0)];
        }
        return o.sourcePosition.hasSameParentAs(e.targetPosition) && (o.howMany += e.howMany), o.sourcePosition = o.sourcePosition._getTransformedByMergeOperation(e), o.targetPosition = o.targetPosition._getTransformedByMergeOperation(e), o.graveyardPosition.isEqual(e.graveyardPosition) && t.aIsStrong || (o.graveyardPosition = o.graveyardPosition._getTransformedByMergeOperation(e)), [o];
      }), ye(et, De, (o, e, t) => {
        const n = $._createFromPositionAndShift(e.sourcePosition, e.howMany);
        return e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && o.deletionPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(o.sourcePosition) ? [new ct(0)] : (o.sourcePosition.hasSameParentAs(e.targetPosition) && (o.howMany += e.howMany), o.sourcePosition.hasSameParentAs(e.sourcePosition) && (o.howMany -= e.howMany), o.sourcePosition = o.sourcePosition._getTransformedByMoveOperation(e), o.targetPosition = o.targetPosition._getTransformedByMoveOperation(e), o.graveyardPosition.isEqual(e.targetPosition) || (o.graveyardPosition = o.graveyardPosition._getTransformedByMoveOperation(e)), [o]);
      }), ye(et, $e, (o, e, t) => {
        if (e.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1), o.deletionPosition.isEqual(e.graveyardPosition) && (o.howMany = e.howMany)), o.targetPosition.isEqual(e.splitPosition)) {
          const n = e.howMany != 0, i = e.graveyardPosition && o.deletionPosition.isEqual(e.graveyardPosition);
          if (n || i || t.abRelation == "mergeTargetNotMoved")
            return o.sourcePosition = o.sourcePosition._getTransformedBySplitOperation(e), [o];
        }
        if (o.sourcePosition.isEqual(e.splitPosition)) {
          if (t.abRelation == "mergeSourceNotMoved")
            return o.howMany = 0, o.targetPosition = o.targetPosition._getTransformedBySplitOperation(e), [o];
          if (t.abRelation == "mergeSameElement" || o.sourcePosition.offset > 0)
            return o.sourcePosition = e.moveTargetPosition.clone(), o.targetPosition = o.targetPosition._getTransformedBySplitOperation(e), [o];
        }
        return o.sourcePosition.hasSameParentAs(e.splitPosition) && (o.howMany = e.splitPosition.offset), o.sourcePosition = o.sourcePosition._getTransformedBySplitOperation(e), o.targetPosition = o.targetPosition._getTransformedBySplitOperation(e), [o];
      }), ye(De, ht, (o, e) => {
        const t = $._createFromPositionAndShift(o.sourcePosition, o.howMany)._getTransformedByInsertOperation(e, !1)[0];
        return o.sourcePosition = t.start, o.howMany = t.end.offset - t.start.offset, o.targetPosition.isEqual(e.position) || (o.targetPosition = o.targetPosition._getTransformedByInsertOperation(e)), [o];
      }), ye(De, De, (o, e, t) => {
        const n = $._createFromPositionAndShift(o.sourcePosition, o.howMany), i = $._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let r, s = t.aIsStrong, a = !t.aIsStrong;
        if (t.abRelation == "insertBefore" || t.baRelation == "insertAfter" ? a = !0 : t.abRelation != "insertAfter" && t.baRelation != "insertBefore" || (a = !1), r = o.targetPosition.isEqual(e.targetPosition) && a ? o.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) : o.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Ag(o, e) && Ag(e, o))
          return [e.getReversed()];
        if (n.containsPosition(e.targetPosition) && n.containsRange(i, !0))
          return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Lo([n], r);
        if (i.containsPosition(o.targetPosition) && i.containsRange(n, !0))
          return n.start = n.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), n.end = n.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), Lo([n], r);
        const l = _t(o.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
        if (l == "prefix" || l == "extension")
          return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Lo([n], r);
        o.type != "remove" || e.type == "remove" || t.aWasUndone || t.forceWeakRemove ? o.type == "remove" || e.type != "remove" || t.bWasUndone || t.forceWeakRemove || (s = !1) : s = !0;
        const d = [], h = n.getDifference(i);
        for (const f of h) {
          f.start = f.start._getTransformedByDeletion(e.sourcePosition, e.howMany), f.end = f.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
          const _ = _t(f.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same", S = f._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, _);
          d.push(...S);
        }
        const m = n.getIntersection(i);
        return m !== null && s && (m.start = m.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), m.end = m.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), d.length === 0 ? d.push(m) : d.length == 1 ? i.start.isBefore(n.start) || i.start.isEqual(n.start) ? d.unshift(m) : d.push(m) : d.splice(1, 0, m)), d.length === 0 ? [new ct(o.baseVersion)] : Lo(d, r);
      }), ye(De, $e, (o, e, t) => {
        let n = o.targetPosition.clone();
        o.targetPosition.isEqual(e.insertionPosition) && e.graveyardPosition && t.abRelation != "moveTargetAfter" || (n = o.targetPosition._getTransformedBySplitOperation(e));
        const i = $._createFromPositionAndShift(o.sourcePosition, o.howMany);
        if (i.end.isEqual(e.insertionPosition))
          return e.graveyardPosition || o.howMany++, o.targetPosition = n, [o];
        if (i.start.hasSameParentAs(e.splitPosition) && i.containsPosition(e.splitPosition)) {
          let s = new $(e.splitPosition, i.end);
          return s = s._getTransformedBySplitOperation(e), Lo([new $(i.start, e.splitPosition), s], n);
        }
        o.targetPosition.isEqual(e.splitPosition) && t.abRelation == "insertAtSource" && (n = e.moveTargetPosition), o.targetPosition.isEqual(e.insertionPosition) && t.abRelation == "insertBetween" && (n = o.targetPosition);
        const r = [i._getTransformedBySplitOperation(e)];
        if (e.graveyardPosition) {
          const s = i.start.isEqual(e.graveyardPosition) || i.containsPosition(e.graveyardPosition);
          o.howMany > 1 && s && !t.aWasUndone && r.push($._createFromPositionAndShift(e.insertionPosition, 1));
        }
        return Lo(r, n);
      }), ye(De, et, (o, e, t) => {
        const n = $._createFromPositionAndShift(o.sourcePosition, o.howMany);
        if (e.deletionPosition.hasSameParentAs(o.sourcePosition) && n.containsPosition(e.sourcePosition)) {
          if (o.type != "remove" || t.forceWeakRemove) {
            if (o.howMany == 1)
              return t.bWasUndone ? (o.sourcePosition = e.graveyardPosition.clone(), o.targetPosition = o.targetPosition._getTransformedByMergeOperation(e), [o]) : [new ct(0)];
          } else if (!t.aWasUndone) {
            const r = [];
            let s = e.graveyardPosition.clone(), a = e.targetPosition._getTransformedByMergeOperation(e);
            o.howMany > 1 && (r.push(new De(o.sourcePosition, o.howMany - 1, o.targetPosition, 0)), s = s._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany - 1), a = a._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany - 1));
            const l = e.deletionPosition._getCombined(o.sourcePosition, o.targetPosition), d = new De(s, 1, l, 0), h = d.getMovedRangeStart().path.slice();
            h.push(0);
            const m = new q(d.targetPosition.root, h);
            a = a._getTransformedByMove(s, l, 1);
            const f = new De(a, e.howMany, m, 0);
            return r.push(d), r.push(f), r;
          }
        }
        const i = $._createFromPositionAndShift(o.sourcePosition, o.howMany)._getTransformedByMergeOperation(e);
        return o.sourcePosition = i.start, o.howMany = i.end.offset - i.start.offset, o.targetPosition = o.targetPosition._getTransformedByMergeOperation(e), [o];
      }), ye(Dt, ht, (o, e) => (o.position = o.position._getTransformedByInsertOperation(e), [o])), ye(Dt, et, (o, e) => o.position.isEqual(e.deletionPosition) ? (o.position = e.graveyardPosition.clone(), o.position.stickiness = "toNext", [o]) : (o.position = o.position._getTransformedByMergeOperation(e), [o])), ye(Dt, De, (o, e) => (o.position = o.position._getTransformedByMoveOperation(e), [o])), ye(Dt, Dt, (o, e, t) => {
        if (o.position.isEqual(e.position)) {
          if (!t.aIsStrong)
            return [new ct(0)];
          o.oldName = e.newName;
        }
        return [o];
      }), ye(Dt, $e, (o, e) => {
        if (_t(o.position.path, e.splitPosition.getParentPath()) == "same" && !e.graveyardPosition) {
          const t = new Dt(o.position.getShiftedBy(1), o.oldName, o.newName, 0);
          return [o, t];
        }
        return o.position = o.position._getTransformedBySplitOperation(e), [o];
      }), ye(bn, bn, (o, e, t) => {
        if (o.root === e.root && o.key === e.key) {
          if (!t.aIsStrong || o.newValue === e.newValue)
            return [new ct(0)];
          o.oldValue = e.newValue;
        }
        return [o];
      }), ye(un, un, (o, e, t) => o.rootName !== e.rootName || o.isAdd !== e.isAdd || t.bWasUndone ? [o] : [new ct(0)]), ye($e, ht, (o, e) => (o.splitPosition.hasSameParentAs(e.position) && o.splitPosition.offset < e.position.offset && (o.howMany += e.howMany), o.splitPosition = o.splitPosition._getTransformedByInsertOperation(e), o.insertionPosition = o.insertionPosition._getTransformedByInsertOperation(e), [o])), ye($e, et, (o, e, t) => {
        if (!o.graveyardPosition && !t.bWasUndone && o.splitPosition.hasSameParentAs(e.sourcePosition)) {
          const n = e.graveyardPosition.path.slice();
          n.push(0);
          const i = new q(e.graveyardPosition.root, n), r = $e.getInsertionPosition(new q(e.graveyardPosition.root, n)), s = new $e(i, 0, r, null, 0);
          return o.splitPosition = o.splitPosition._getTransformedByMergeOperation(e), o.insertionPosition = $e.getInsertionPosition(o.splitPosition), o.graveyardPosition = s.insertionPosition.clone(), o.graveyardPosition.stickiness = "toNext", [s, o];
        }
        return o.splitPosition.hasSameParentAs(e.deletionPosition) && !o.splitPosition.isAfter(e.deletionPosition) && o.howMany--, o.splitPosition.hasSameParentAs(e.targetPosition) && (o.howMany += e.howMany), o.splitPosition = o.splitPosition._getTransformedByMergeOperation(e), o.insertionPosition = $e.getInsertionPosition(o.splitPosition), o.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedByMergeOperation(e)), [o];
      }), ye($e, De, (o, e, t) => {
        const n = $._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (o.graveyardPosition) {
          const r = n.start.isEqual(o.graveyardPosition) || n.containsPosition(o.graveyardPosition);
          if (!t.bWasUndone && r) {
            const s = o.splitPosition._getTransformedByMoveOperation(e), a = o.graveyardPosition._getTransformedByMoveOperation(e), l = a.path.slice();
            l.push(0);
            const d = new q(a.root, l);
            return [new De(s, o.howMany, d, 0)];
          }
          o.graveyardPosition = o.graveyardPosition._getTransformedByMoveOperation(e);
        }
        const i = o.splitPosition.isEqual(e.targetPosition);
        if (i && (t.baRelation == "insertAtSource" || t.abRelation == "splitBefore"))
          return o.howMany += e.howMany, o.splitPosition = o.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany), o.insertionPosition = $e.getInsertionPosition(o.splitPosition), [o];
        if (i && t.abRelation && t.abRelation.howMany) {
          const { howMany: r, offset: s } = t.abRelation;
          return o.howMany += r, o.splitPosition = o.splitPosition.getShiftedBy(s), [o];
        }
        if (o.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(o.splitPosition)) {
          const r = e.howMany - (o.splitPosition.offset - e.sourcePosition.offset);
          return o.howMany -= r, o.splitPosition.hasSameParentAs(e.targetPosition) && o.splitPosition.offset < e.targetPosition.offset && (o.howMany += e.howMany), o.splitPosition = e.sourcePosition.clone(), o.insertionPosition = $e.getInsertionPosition(o.splitPosition), [o];
        }
        return e.sourcePosition.isEqual(e.targetPosition) || (o.splitPosition.hasSameParentAs(e.sourcePosition) && o.splitPosition.offset <= e.sourcePosition.offset && (o.howMany -= e.howMany), o.splitPosition.hasSameParentAs(e.targetPosition) && o.splitPosition.offset < e.targetPosition.offset && (o.howMany += e.howMany)), o.splitPosition.stickiness = "toNone", o.splitPosition = o.splitPosition._getTransformedByMoveOperation(e), o.splitPosition.stickiness = "toNext", o.graveyardPosition ? o.insertionPosition = o.insertionPosition._getTransformedByMoveOperation(e) : o.insertionPosition = $e.getInsertionPosition(o.splitPosition), [o];
      }), ye($e, $e, (o, e, t) => {
        if (o.splitPosition.isEqual(e.splitPosition)) {
          if (!o.graveyardPosition && !e.graveyardPosition)
            return [new ct(0)];
          if (o.graveyardPosition && e.graveyardPosition && o.graveyardPosition.isEqual(e.graveyardPosition))
            return [new ct(0)];
          if (t.abRelation == "splitBefore")
            return o.howMany = 0, o.graveyardPosition = o.graveyardPosition._getTransformedBySplitOperation(e), [o];
        }
        if (o.graveyardPosition && e.graveyardPosition && o.graveyardPosition.isEqual(e.graveyardPosition)) {
          const n = o.splitPosition.root.rootName == "$graveyard", i = e.splitPosition.root.rootName == "$graveyard";
          if (i && !n || !(n && !i) && t.aIsStrong) {
            const r = [];
            return e.howMany && r.push(new De(e.moveTargetPosition, e.howMany, e.splitPosition, 0)), o.howMany && r.push(new De(o.splitPosition, o.howMany, o.moveTargetPosition, 0)), r;
          }
          return [new ct(0)];
        }
        if (o.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedBySplitOperation(e)), o.splitPosition.isEqual(e.insertionPosition) && t.abRelation == "splitBefore")
          return o.howMany++, [o];
        if (e.splitPosition.isEqual(o.insertionPosition) && t.baRelation == "splitBefore") {
          const n = e.insertionPosition.path.slice();
          n.push(0);
          const i = new q(e.insertionPosition.root, n);
          return [o, new De(o.insertionPosition, 1, i, 0)];
        }
        return o.splitPosition.hasSameParentAs(e.splitPosition) && o.splitPosition.offset < e.splitPosition.offset && (o.howMany -= e.howMany), o.splitPosition = o.splitPosition._getTransformedBySplitOperation(e), o.insertionPosition = $e.getInsertionPosition(o.splitPosition), [o];
      });
      class Bt extends Se(q) {
        constructor(e, t, n = "toNone") {
          if (super(e, t, n), !this.root.is("rootElement"))
            throw new O("model-liveposition-root-not-rootelement", e);
          i1.call(this);
        }
        detach() {
          this.stopListening();
        }
        toPosition() {
          return new q(this.root, this.path.slice(), this.stickiness);
        }
        static fromPosition(e, t) {
          return new this(e.root, e.path.slice(), t || e.stickiness);
        }
      }
      function i1() {
        this.listenTo(this.root.document.model, "applyOperation", (o, e) => {
          const t = e[0];
          t.isDocumentOperation && r1.call(this, t);
        }, { priority: "low" });
      }
      function r1(o) {
        const e = this.getTransformedByOperation(o);
        if (!this.isEqual(e)) {
          const t = this.toPosition();
          this.path = e.path, this.root = e.root, this.fire("change", t);
        }
      }
      Bt.prototype.is = function(o) {
        return o === "livePosition" || o === "model:livePosition" || o == "position" || o === "model:position";
      };
      class jo {
        constructor(e = {}) {
          typeof e == "string" && (e = e === "transparent" ? { isUndoable: !1 } : {}, oe("batch-constructor-deprecated-string-type"));
          const { isUndoable: t = !0, isLocal: n = !0, isUndo: i = !1, isTyping: r = !1 } = e;
          this.operations = [], this.isUndoable = t, this.isLocal = n, this.isUndo = i, this.isTyping = r;
        }
        get type() {
          return oe("batch-type-deprecated"), "default";
        }
        get baseVersion() {
          for (const e of this.operations)
            if (e.baseVersion !== null)
              return e.baseVersion;
          return null;
        }
        addOperation(e) {
          return e.batch = this, this.operations.push(e), e;
        }
      }
      var s1 = Object.defineProperty, Cg = Object.getOwnPropertySymbols, a1 = Object.prototype.hasOwnProperty, l1 = Object.prototype.propertyIsEnumerable, yg = (o, e, t) => e in o ? s1(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class c1 {
        constructor(e) {
          this._changesInElement = /* @__PURE__ */ new Map(), this._elementSnapshots = /* @__PURE__ */ new Map(), this._changedMarkers = /* @__PURE__ */ new Map(), this._changedRoots = /* @__PURE__ */ new Map(), this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = /* @__PURE__ */ new Set(), this._markerCollection = e;
        }
        get isEmpty() {
          return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
        }
        bufferOperation(e) {
          const t = e;
          switch (t.type) {
            case "insert":
              if (this._isInInsertedElement(t.position.parent))
                return;
              this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
              break;
            case "addAttribute":
            case "removeAttribute":
            case "changeAttribute":
              for (const n of t.range.getItems({ shallow: !0 }))
                this._isInInsertedElement(n.parent) || this._markAttribute(n);
              break;
            case "remove":
            case "move":
            case "reinsert": {
              if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition))
                return;
              const n = this._isInInsertedElement(t.sourcePosition.parent), i = this._isInInsertedElement(t.targetPosition.parent);
              n || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany), i || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
              break;
            }
            case "rename": {
              if (this._isInInsertedElement(t.position.parent))
                return;
              this._markRemove(t.position.parent, t.position.offset, 1), this._markInsert(t.position.parent, t.position.offset, 1);
              const n = $._createFromPositionAndShift(t.position, 1);
              for (const i of this._markerCollection.getMarkersIntersectingRange(n)) {
                const r = i.getData();
                this.bufferMarkerChange(i.name, r, r);
              }
              break;
            }
            case "split": {
              const n = t.splitPosition.parent;
              this._isInInsertedElement(n) || this._markRemove(n, t.splitPosition.offset, t.howMany), this._isInInsertedElement(t.insertionPosition.parent) || this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1), t.graveyardPosition && this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1);
              break;
            }
            case "merge": {
              const n = t.sourcePosition.parent;
              this._isInInsertedElement(n.parent) || this._markRemove(n.parent, n.startOffset, 1);
              const i = t.graveyardPosition.parent;
              this._markInsert(i, t.graveyardPosition.offset, 1);
              const r = t.targetPosition.parent;
              this._isInInsertedElement(r) || this._markInsert(r, t.targetPosition.offset, n.maxOffset);
              break;
            }
            case "detachRoot":
            case "addRoot":
              this._bufferRootStateChange(t.rootName, t.isAdd);
              break;
            case "addRootAttribute":
            case "removeRootAttribute":
            case "changeRootAttribute": {
              const n = t.root.rootName;
              this._bufferRootAttributeChange(n, t.key, t.oldValue, t.newValue);
              break;
            }
          }
          this._cachedChanges = null;
        }
        bufferMarkerChange(e, t, n) {
          const i = this._changedMarkers.get(e);
          i ? (i.newMarkerData = n, i.oldMarkerData.range == null && n.range == null && this._changedMarkers.delete(e)) : this._changedMarkers.set(e, { newMarkerData: n, oldMarkerData: t });
        }
        getMarkersToRemove() {
          const e = [];
          for (const [t, n] of this._changedMarkers)
            n.oldMarkerData.range != null && e.push({ name: t, range: n.oldMarkerData.range });
          return e;
        }
        getMarkersToAdd() {
          const e = [];
          for (const [t, n] of this._changedMarkers)
            n.newMarkerData.range != null && e.push({ name: t, range: n.newMarkerData.range });
          return e;
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map(([e, t]) => ({ name: e, data: { oldRange: t.oldMarkerData.range, newRange: t.newMarkerData.range } }));
        }
        hasDataChanges() {
          if (this._changesInElement.size > 0 || this._changedRoots.size > 0)
            return !0;
          for (const { newMarkerData: e, oldMarkerData: t } of this._changedMarkers.values()) {
            if (e.affectsData !== t.affectsData)
              return !0;
            if (e.affectsData) {
              const n = e.range && !t.range, i = !e.range && t.range, r = e.range && t.range && !e.range.isEqual(t.range);
              if (n || i || r)
                return !0;
            }
          }
          return !1;
        }
        getChanges(e = {}) {
          if (this._cachedChanges)
            return e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
          let t = [];
          for (const n of this._changesInElement.keys()) {
            const i = this._changesInElement.get(n).sort((h, m) => h.offset === m.offset ? h.type != m.type ? h.type == "remove" ? -1 : 1 : 0 : h.offset < m.offset ? -1 : 1), r = this._elementSnapshots.get(n), s = Eg(n.getChildren()), a = d1(r.length, i);
            let l = 0, d = 0;
            for (const h of a)
              if (h === "i")
                t.push(this._getInsertDiff(n, l, s[l])), l++;
              else if (h === "r")
                t.push(this._getRemoveDiff(n, l, r[d])), d++;
              else if (h === "a") {
                const m = s[l].attributes, f = r[d].attributes;
                let _;
                if (s[l].name == "$text")
                  _ = new $(q._createAt(n, l), q._createAt(n, l + 1));
                else {
                  const S = n.offsetToIndex(l);
                  _ = new $(q._createAt(n, l), q._createAt(n.getChild(S), 0));
                }
                t.push(...this._getAttributesDiff(_, f, m)), l++, d++;
              } else
                l++, d++;
          }
          t.sort((n, i) => n.position.root != i.position.root ? n.position.root.rootName < i.position.root.rootName ? -1 : 1 : n.position.isEqual(i.position) ? n.changeCount - i.changeCount : n.position.isBefore(i.position) ? -1 : 1);
          for (let n = 1, i = 0; n < t.length; n++) {
            const r = t[i], s = t[n], a = r.type == "remove" && s.type == "remove" && r.name == "$text" && s.name == "$text" && r.position.isEqual(s.position), l = r.type == "insert" && s.type == "insert" && r.name == "$text" && s.name == "$text" && r.position.parent == s.position.parent && r.position.offset + r.length == s.position.offset, d = r.type == "attribute" && s.type == "attribute" && r.position.parent == s.position.parent && r.range.isFlat && s.range.isFlat && r.position.offset + r.length == s.position.offset && r.attributeKey == s.attributeKey && r.attributeOldValue == s.attributeOldValue && r.attributeNewValue == s.attributeNewValue;
            a || l || d ? (r.length++, d && (r.range.end = r.range.end.getShiftedBy(1)), t[n] = null) : i = n;
          }
          t = t.filter((n) => n);
          for (const n of t)
            delete n.changeCount, n.type == "attribute" && (delete n.position, delete n.length);
          return this._changeCount = 0, this._cachedChangesWithGraveyard = t, this._cachedChanges = t.filter(u1), e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
        }
        getChangedRoots() {
          return Array.from(this._changedRoots.values()).map((e) => {
            const t = ((n, i) => {
              for (var r in i || (i = {}))
                a1.call(i, r) && yg(n, r, i[r]);
              if (Cg)
                for (var r of Cg(i))
                  l1.call(i, r) && yg(n, r, i[r]);
              return n;
            })({}, e);
            return t.state !== void 0 && delete t.attributes, t;
          });
        }
        getRefreshedItems() {
          return new Set(this._refreshedItems);
        }
        reset() {
          this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems = /* @__PURE__ */ new Set(), this._cachedChanges = null;
        }
        _bufferRootStateChange(e, t) {
          if (!this._changedRoots.has(e))
            return void this._changedRoots.set(e, { name: e, state: t ? "attached" : "detached" });
          const n = this._changedRoots.get(e);
          n.state !== void 0 ? (delete n.state, n.attributes === void 0 && this._changedRoots.delete(e)) : n.state = t ? "attached" : "detached";
        }
        _bufferRootAttributeChange(e, t, n, i) {
          const r = this._changedRoots.get(e) || { name: e }, s = r.attributes || {};
          if (s[t]) {
            const a = s[t];
            i === a.oldValue ? delete s[t] : a.newValue = i;
          } else
            s[t] = { oldValue: n, newValue: i };
          Object.entries(s).length === 0 ? (delete r.attributes, r.state === void 0 && this._changedRoots.delete(e)) : (r.attributes = s, this._changedRoots.set(e, r));
        }
        _refreshItem(e) {
          if (this._isInInsertedElement(e.parent))
            return;
          this._markRemove(e.parent, e.startOffset, e.offsetSize), this._markInsert(e.parent, e.startOffset, e.offsetSize), this._refreshedItems.add(e);
          const t = $._createOn(e);
          for (const n of this._markerCollection.getMarkersIntersectingRange(t)) {
            const i = n.getData();
            this.bufferMarkerChange(n.name, i, i);
          }
          this._cachedChanges = null;
        }
        _markInsert(e, t, n) {
          const i = { type: "insert", offset: t, howMany: n, count: this._changeCount++ };
          this._markChange(e, i);
        }
        _markRemove(e, t, n) {
          const i = { type: "remove", offset: t, howMany: n, count: this._changeCount++ };
          this._markChange(e, i), this._removeAllNestedChanges(e, t, n);
        }
        _markAttribute(e) {
          const t = { type: "attribute", offset: e.startOffset, howMany: e.offsetSize, count: this._changeCount++ };
          this._markChange(e.parent, t);
        }
        _markChange(e, t) {
          this._makeSnapshot(e);
          const n = this._getChangesForElement(e);
          this._handleChange(t, n), n.push(t);
          for (let i = 0; i < n.length; i++)
            n[i].howMany < 1 && (n.splice(i, 1), i--);
        }
        _getChangesForElement(e) {
          let t;
          return this._changesInElement.has(e) ? t = this._changesInElement.get(e) : (t = [], this._changesInElement.set(e, t)), t;
        }
        _makeSnapshot(e) {
          this._elementSnapshots.has(e) || this._elementSnapshots.set(e, Eg(e.getChildren()));
        }
        _handleChange(e, t) {
          e.nodesToHandle = e.howMany;
          for (const n of t) {
            const i = e.offset + e.howMany, r = n.offset + n.howMany;
            if (e.type == "insert" && (n.type == "insert" && (e.offset <= n.offset ? n.offset += e.howMany : e.offset < r && (n.howMany += e.nodesToHandle, e.nodesToHandle = 0)), n.type == "remove" && e.offset < n.offset && (n.offset += e.howMany), n.type == "attribute")) {
              if (e.offset <= n.offset)
                n.offset += e.howMany;
              else if (e.offset < r) {
                const s = n.howMany;
                n.howMany = e.offset - n.offset, t.unshift({ type: "attribute", offset: i, howMany: s - n.howMany, count: this._changeCount++ });
              }
            }
            if (e.type == "remove") {
              if (n.type == "insert") {
                if (i <= n.offset)
                  n.offset -= e.howMany;
                else if (i <= r)
                  if (e.offset < n.offset) {
                    const s = i - n.offset;
                    n.offset = e.offset, n.howMany -= s, e.nodesToHandle -= s;
                  } else
                    n.howMany -= e.nodesToHandle, e.nodesToHandle = 0;
                else if (e.offset <= n.offset)
                  e.nodesToHandle -= n.howMany, n.howMany = 0;
                else if (e.offset < r) {
                  const s = r - e.offset;
                  n.howMany -= s, e.nodesToHandle -= s;
                }
              }
              if (n.type == "remove" && (i <= n.offset ? n.offset -= e.howMany : e.offset < n.offset && (e.nodesToHandle += n.howMany, n.howMany = 0)), n.type == "attribute") {
                if (i <= n.offset)
                  n.offset -= e.howMany;
                else if (e.offset < n.offset) {
                  const s = i - n.offset;
                  n.offset = e.offset, n.howMany -= s;
                } else if (e.offset < r)
                  if (i <= r) {
                    const s = n.howMany;
                    n.howMany = e.offset - n.offset;
                    const a = s - n.howMany - e.nodesToHandle;
                    t.unshift({ type: "attribute", offset: e.offset, howMany: a, count: this._changeCount++ });
                  } else
                    n.howMany -= r - e.offset;
              }
            }
            if (e.type == "attribute") {
              if (n.type == "insert")
                if (e.offset < n.offset && i > n.offset) {
                  if (i > r) {
                    const s = { type: "attribute", offset: r, howMany: i - r, count: this._changeCount++ };
                    this._handleChange(s, t), t.push(s);
                  }
                  e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle;
                } else
                  e.offset >= n.offset && e.offset < r && (i > r ? (e.nodesToHandle = i - r, e.offset = r) : e.nodesToHandle = 0);
              if (n.type == "remove" && e.offset < n.offset && i > n.offset) {
                const s = { type: "attribute", offset: n.offset, howMany: i - n.offset, count: this._changeCount++ };
                this._handleChange(s, t), t.push(s), e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle;
              }
              n.type == "attribute" && (e.offset >= n.offset && i <= r ? (e.nodesToHandle = 0, e.howMany = 0, e.offset = 0) : e.offset <= n.offset && i >= r && (n.howMany = 0));
            }
          }
          e.howMany = e.nodesToHandle, delete e.nodesToHandle;
        }
        _getInsertDiff(e, t, n) {
          return { type: "insert", position: q._createAt(e, t), name: n.name, attributes: new Map(n.attributes), length: 1, changeCount: this._changeCount++ };
        }
        _getRemoveDiff(e, t, n) {
          return { type: "remove", position: q._createAt(e, t), name: n.name, attributes: new Map(n.attributes), length: 1, changeCount: this._changeCount++ };
        }
        _getAttributesDiff(e, t, n) {
          const i = [];
          n = new Map(n);
          for (const [r, s] of t) {
            const a = n.has(r) ? n.get(r) : null;
            a !== s && i.push({ type: "attribute", position: e.start, range: e.clone(), length: 1, attributeKey: r, attributeOldValue: s, attributeNewValue: a, changeCount: this._changeCount++ }), n.delete(r);
          }
          for (const [r, s] of n)
            i.push({ type: "attribute", position: e.start, range: e.clone(), length: 1, attributeKey: r, attributeOldValue: null, attributeNewValue: s, changeCount: this._changeCount++ });
          return i;
        }
        _isInInsertedElement(e) {
          const t = e.parent;
          if (!t)
            return !1;
          const n = this._changesInElement.get(t), i = e.startOffset;
          if (n) {
            for (const r of n)
              if (r.type == "insert" && i >= r.offset && i < r.offset + r.howMany)
                return !0;
          }
          return this._isInInsertedElement(t);
        }
        _removeAllNestedChanges(e, t, n) {
          const i = new $(q._createAt(e, t), q._createAt(e, t + n));
          for (const r of i.getItems({ shallow: !0 }))
            r.is("element") && (this._elementSnapshots.delete(r), this._changesInElement.delete(r), this._removeAllNestedChanges(r, 0, r.maxOffset));
        }
      }
      function Eg(o) {
        const e = [];
        for (const t of o)
          if (t.is("$text"))
            for (let n = 0; n < t.data.length; n++)
              e.push({ name: "$text", attributes: new Map(t.getAttributes()) });
          else
            e.push({ name: t.name, attributes: new Map(t.getAttributes()) });
        return e;
      }
      function d1(o, e) {
        const t = [];
        let n = 0, i = 0;
        for (const r of e) {
          if (r.offset > n) {
            for (let s = 0; s < r.offset - n; s++)
              t.push("e");
            i += r.offset - n;
          }
          if (r.type == "insert") {
            for (let s = 0; s < r.howMany; s++)
              t.push("i");
            n = r.offset + r.howMany;
          } else if (r.type == "remove") {
            for (let s = 0; s < r.howMany; s++)
              t.push("r");
            n = r.offset, i += r.howMany;
          } else
            t.push(..."a".repeat(r.howMany).split("")), n = r.offset + r.howMany, i += r.howMany;
        }
        if (i < o)
          for (let r = 0; r < o - i - n; r++)
            t.push("e");
        return t;
      }
      function u1(o) {
        const e = "position" in o && o.position.root.rootName == "$graveyard", t = "range" in o && o.range.root.rootName == "$graveyard";
        return !e && !t;
      }
      class h1 {
        constructor() {
          this._operations = [], this._undoPairs = /* @__PURE__ */ new Map(), this._undoneOperations = /* @__PURE__ */ new Set(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map(), this._version = 0, this._gaps = /* @__PURE__ */ new Map();
        }
        get version() {
          return this._version;
        }
        set version(e) {
          this._operations.length && e > this._version + 1 && this._gaps.set(this._version, e), this._version = e;
        }
        get lastOperation() {
          return this._operations[this._operations.length - 1];
        }
        addOperation(e) {
          if (e.baseVersion !== this.version)
            throw new O("model-document-history-addoperation-incorrect-version", this, { operation: e, historyVersion: this.version });
          this._operations.push(e), this._version++, this._baseVersionToOperationIndex.set(e.baseVersion, this._operations.length - 1);
        }
        getOperations(e, t = this.version) {
          if (!this._operations.length)
            return [];
          const n = this._operations[0];
          e === void 0 && (e = n.baseVersion);
          let i = t - 1;
          for (const [a, l] of this._gaps)
            e > a && e < l && (e = l), i > a && i < l && (i = a - 1);
          if (i < n.baseVersion || e > this.lastOperation.baseVersion)
            return [];
          let r = this._baseVersionToOperationIndex.get(e);
          r === void 0 && (r = 0);
          let s = this._baseVersionToOperationIndex.get(i);
          return s === void 0 && (s = this._operations.length - 1), this._operations.slice(r, s + 1);
        }
        getOperation(e) {
          const t = this._baseVersionToOperationIndex.get(e);
          if (t !== void 0)
            return this._operations[t];
        }
        setOperationAsUndone(e, t) {
          this._undoPairs.set(t, e), this._undoneOperations.add(e);
        }
        isUndoingOperation(e) {
          return this._undoPairs.has(e);
        }
        isUndoneOperation(e) {
          return this._undoneOperations.has(e);
        }
        getUndoneOperation(e) {
          return this._undoPairs.get(e);
        }
        reset() {
          this._version = 0, this._undoPairs = /* @__PURE__ */ new Map(), this._operations = [], this._undoneOperations = /* @__PURE__ */ new Set(), this._gaps = /* @__PURE__ */ new Map(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
        }
      }
      class Zr extends Fe {
        constructor(e, t, n = "main") {
          super(t), this._isAttached = !0, this._document = e, this.rootName = n;
        }
        get document() {
          return this._document;
        }
        isAttached() {
          return this._isAttached;
        }
        toJSON() {
          return this.rootName;
        }
      }
      Zr.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "rootElement" || o === "model:rootElement" || o === "element" || o === "model:element") : o === "rootElement" || o === "model:rootElement" || o === "element" || o === "model:element" || o === "node" || o === "model:node";
      };
      var g1 = Object.defineProperty, m1 = Object.defineProperties, p1 = Object.getOwnPropertyDescriptors, xg = Object.getOwnPropertySymbols, f1 = Object.prototype.hasOwnProperty, b1 = Object.prototype.propertyIsEnumerable, Sg = (o, e, t) => e in o ? g1(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Dg = (o, e) => {
        for (var t in e || (e = {}))
          f1.call(e, t) && Sg(o, t, e[t]);
        if (xg)
          for (var t of xg(e))
            b1.call(e, t) && Sg(o, t, e[t]);
        return o;
      }, Bg = (o, e) => m1(o, p1(e));
      const tl = "$graveyard";
      class k1 extends Se() {
        constructor(e) {
          super(), this.model = e, this.history = new h1(), this.selection = new Qt(this), this.roots = new Ht({ idProperty: "rootName" }), this.differ = new c1(e.markers), this.isReadOnly = !1, this._postFixers = /* @__PURE__ */ new Set(), this._hasSelectionChangedFromTheLastChangeBlock = !1, this.createRoot("$root", tl), this.listenTo(e, "applyOperation", (t, n) => {
            const i = n[0];
            i.isDocumentOperation && this.differ.bufferOperation(i);
          }, { priority: "high" }), this.listenTo(e, "applyOperation", (t, n) => {
            const i = n[0];
            i.isDocumentOperation && this.history.addOperation(i);
          }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
            this._hasSelectionChangedFromTheLastChangeBlock = !0;
          }), this.listenTo(e.markers, "update", (t, n, i, r, s) => {
            const a = Bg(Dg({}, n.getData()), { range: r });
            this.differ.bufferMarkerChange(n.name, s, a), i === null && n.on("change", (l, d) => {
              const h = n.getData();
              this.differ.bufferMarkerChange(n.name, Bg(Dg({}, h), { range: d }), h);
            });
          }), this.registerPostFixer((t) => {
            let n = !1;
            for (const i of this.roots)
              i.isAttached() || i.isEmpty || (t.remove(t.createRangeIn(i)), n = !0);
            for (const i of this.model.markers)
              i.getRange().root.isAttached() || (t.removeMarker(i), n = !0);
            return n;
          });
        }
        get version() {
          return this.history.version;
        }
        set version(e) {
          this.history.version = e;
        }
        get graveyard() {
          return this.getRoot(tl);
        }
        createRoot(e = "$root", t = "main") {
          if (this.roots.get(t))
            throw new O("model-document-createroot-name-exists", this, { name: t });
          const n = new Zr(this, e, t);
          return this.roots.add(n), n;
        }
        destroy() {
          this.selection.destroy(), this.stopListening();
        }
        getRoot(e = "main") {
          return this.roots.get(e);
        }
        getRootNames(e = !1) {
          return Array.from(this.roots).filter((t) => t.rootName != tl && (e || t.isAttached())).map((t) => t.rootName);
        }
        registerPostFixer(e) {
          this._postFixers.add(e);
        }
        toJSON() {
          const e = ju(this);
          return e.selection = "[engine.model.DocumentSelection]", e.model = "[engine.model.Model]", e;
        }
        _handleChangeBlock(e) {
          this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(e), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", e.batch) : this.fire("change", e.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = !1;
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
        }
        _getDefaultRoot() {
          for (const e of this.roots)
            if (e !== this.graveyard)
              return e;
          return this.graveyard;
        }
        _getDefaultRange() {
          const e = this._getDefaultRoot(), t = this.model, n = t.schema, i = t.createPositionFromPath(e, [0]);
          return n.getNearestSelectionRange(i) || t.createRange(i);
        }
        _validateSelectionRange(e) {
          return Tg(e.start) && Tg(e.end);
        }
        _callPostFixers(e) {
          let t = !1;
          do
            for (const n of this._postFixers)
              if (this.selection.refresh(), t = n(e), t)
                break;
          while (t);
        }
      }
      function Tg(o) {
        const e = o.textNode;
        if (e) {
          const t = e.data, n = o.offset - e.startOffset;
          return !pa(t, n) && !fa(t, n);
        }
        return !0;
      }
      var w1 = Object.defineProperty, v1 = Object.defineProperties, _1 = Object.getOwnPropertyDescriptors, Ig = Object.getOwnPropertySymbols, A1 = Object.prototype.hasOwnProperty, C1 = Object.prototype.propertyIsEnumerable, Pg = (o, e, t) => e in o ? w1(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class y1 extends Se() {
        constructor() {
          super(...arguments), this._markers = /* @__PURE__ */ new Map();
        }
        [Symbol.iterator]() {
          return this._markers.values();
        }
        has(e) {
          const t = e instanceof Ho ? e.name : e;
          return this._markers.has(t);
        }
        get(e) {
          return this._markers.get(e) || null;
        }
        _set(e, t, n = !1, i = !1) {
          const r = e instanceof Ho ? e.name : e;
          if (r.includes(","))
            throw new O("markercollection-incorrect-marker-name", this);
          const s = this._markers.get(r);
          if (s) {
            const h = s.getData(), m = s.getRange();
            let f = !1;
            return m.isEqual(t) || (s._attachLiveRange(fn.fromRange(t)), f = !0), n != s.managedUsingOperations && (s._managedUsingOperations = n, f = !0), typeof i == "boolean" && i != s.affectsData && (s._affectsData = i, f = !0), f && this.fire(`update:${r}`, s, m, t, h), s;
          }
          const a = fn.fromRange(t), l = new Ho(r, a, n, i);
          var d;
          return this._markers.set(r, l), this.fire(`update:${r}`, l, null, t, (d = ((h, m) => {
            for (var f in m || (m = {}))
              A1.call(m, f) && Pg(h, f, m[f]);
            if (Ig)
              for (var f of Ig(m))
                C1.call(m, f) && Pg(h, f, m[f]);
            return h;
          })({}, l.getData()), v1(d, _1({ range: null })))), l;
        }
        _remove(e) {
          const t = e instanceof Ho ? e.name : e, n = this._markers.get(t);
          return !!n && (this._markers.delete(t), this.fire(`update:${t}`, n, n.getRange(), null, n.getData()), this._destroyMarker(n), !0);
        }
        _refresh(e) {
          const t = e instanceof Ho ? e.name : e, n = this._markers.get(t);
          if (!n)
            throw new O("markercollection-refresh-marker-not-exists", this);
          const i = n.getRange();
          this.fire(`update:${t}`, n, i, i, n.getData());
        }
        *getMarkersAtPosition(e) {
          for (const t of this)
            t.getRange().containsPosition(e) && (yield t);
        }
        *getMarkersIntersectingRange(e) {
          for (const t of this)
            t.getRange().getIntersection(e) !== null && (yield t);
        }
        destroy() {
          for (const e of this._markers.values())
            this._destroyMarker(e);
          this._markers = null, this.stopListening();
        }
        *getMarkersGroup(e) {
          for (const t of this._markers.values())
            t.name.startsWith(e + ":") && (yield t);
        }
        _destroyMarker(e) {
          e.stopListening(), e._detachLiveRange();
        }
      }
      class Ho extends Se(On) {
        constructor(e, t, n, i) {
          super(), this.name = e, this._liveRange = this._attachLiveRange(t), this._managedUsingOperations = n, this._affectsData = i;
        }
        get managedUsingOperations() {
          if (!this._liveRange)
            throw new O("marker-destroyed", this);
          return this._managedUsingOperations;
        }
        get affectsData() {
          if (!this._liveRange)
            throw new O("marker-destroyed", this);
          return this._affectsData;
        }
        getData() {
          return { range: this.getRange(), affectsData: this.affectsData, managedUsingOperations: this.managedUsingOperations };
        }
        getStart() {
          if (!this._liveRange)
            throw new O("marker-destroyed", this);
          return this._liveRange.start.clone();
        }
        getEnd() {
          if (!this._liveRange)
            throw new O("marker-destroyed", this);
          return this._liveRange.end.clone();
        }
        getRange() {
          if (!this._liveRange)
            throw new O("marker-destroyed", this);
          return this._liveRange.toRange();
        }
        _attachLiveRange(e) {
          return this._liveRange && this._detachLiveRange(), e.delegate("change:range").to(this), e.delegate("change:content").to(this), this._liveRange = e, e;
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
        }
      }
      Ho.prototype.is = function(o) {
        return o === "marker" || o === "model:marker";
      };
      class E1 extends $t {
        constructor(e, t) {
          super(null), this.sourcePosition = e.clone(), this.howMany = t;
        }
        get type() {
          return "detach";
        }
        get affectedSelectable() {
          return null;
        }
        toJSON() {
          const e = super.toJSON();
          return e.sourcePosition = this.sourcePosition.toJSON(), e;
        }
        _validate() {
          if (this.sourcePosition.root.document)
            throw new O("detach-operation-on-document-node", this);
        }
        _execute() {
          pg($._createFromPositionAndShift(this.sourcePosition, this.howMany));
        }
        static get className() {
          return "DetachOperation";
        }
      }
      class kn extends On {
        constructor(e) {
          super(), this.markers = /* @__PURE__ */ new Map(), this._children = new Oi(), e && this._insertChild(0, e);
        }
        [Symbol.iterator]() {
          return this.getChildren();
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get nextSibling() {
          return null;
        }
        get previousSibling() {
          return null;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get document() {
          return null;
        }
        isAttached() {
          return !1;
        }
        getAncestors() {
          return [];
        }
        getChild(e) {
          return this._children.getNode(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(e) {
          return this._children.getNodeIndex(e);
        }
        getChildStartOffset(e) {
          return this._children.getNodeStartOffset(e);
        }
        getPath() {
          return [];
        }
        getNodeByPath(e) {
          let t = this;
          for (const n of e)
            t = t.getChild(t.offsetToIndex(n));
          return t;
        }
        offsetToIndex(e) {
          return this._children.offsetToIndex(e);
        }
        toJSON() {
          const e = [];
          for (const t of this._children)
            e.push(t.toJSON());
          return e;
        }
        static fromJSON(e) {
          const t = [];
          for (const n of e)
            n.name ? t.push(Fe.fromJSON(n)) : t.push(Ne.fromJSON(n));
          return new kn(t);
        }
        _appendChild(e) {
          this._insertChild(this.childCount, e);
        }
        _insertChild(e, t) {
          const n = function(i) {
            return typeof i == "string" ? [new Ne(i)] : (zt(i) || (i = [i]), Array.from(i).map((r) => typeof r == "string" ? new Ne(r) : r instanceof Yt ? new Ne(r.data, r.getAttributes()) : r));
          }(t);
          for (const i of n)
            i.parent !== null && i._remove(), i.parent = this;
          this._children._insertNodes(e, n);
        }
        _removeChildren(e, t = 1) {
          const n = this._children._removeNodes(e, t);
          for (const i of n)
            i.parent = null;
          return n;
        }
      }
      kn.prototype.is = function(o) {
        return o === "documentFragment" || o === "model:documentFragment";
      };
      class x1 {
        constructor(e, t) {
          this.model = e, this.batch = t;
        }
        createText(e, t) {
          return new Ne(e, t);
        }
        createElement(e, t) {
          return new Fe(e, t);
        }
        createDocumentFragment() {
          return new kn();
        }
        cloneElement(e, t = !0) {
          return e._clone(t);
        }
        insert(e, t, n = 0) {
          if (this._assertWriterUsedCorrectly(), e instanceof Ne && e.data == "")
            return;
          const i = q._createAt(t, n);
          if (e.parent) {
            if (zg(e.root, i.root))
              return void this.move($._createOn(e), i);
            if (e.root.document)
              throw new O("model-writer-insert-forbidden-move", this);
            this.remove(e);
          }
          const r = i.root.document ? i.root.document.version : null, s = new ht(i, e, r);
          if (e instanceof Ne && (s.shouldReceiveAttributes = !0), this.batch.addOperation(s), this.model.applyOperation(s), e instanceof kn)
            for (const [a, l] of e.markers) {
              const d = q._createAt(l.root, 0), h = { range: new $(l.start._getCombined(d, i), l.end._getCombined(d, i)), usingOperation: !0, affectsData: !0 };
              this.model.markers.has(a) ? this.updateMarker(a, h) : this.addMarker(a, h);
            }
        }
        insertText(e, t, n, i) {
          t instanceof kn || t instanceof Fe || t instanceof q ? this.insert(this.createText(e), t, n) : this.insert(this.createText(e, t), n, i);
        }
        insertElement(e, t, n, i) {
          t instanceof kn || t instanceof Fe || t instanceof q ? this.insert(this.createElement(e), t, n) : this.insert(this.createElement(e, t), n, i);
        }
        append(e, t) {
          this.insert(e, t, "end");
        }
        appendText(e, t, n) {
          t instanceof kn || t instanceof Fe ? this.insert(this.createText(e), t, "end") : this.insert(this.createText(e, t), n, "end");
        }
        appendElement(e, t, n) {
          t instanceof kn || t instanceof Fe ? this.insert(this.createElement(e), t, "end") : this.insert(this.createElement(e, t), n, "end");
        }
        setAttribute(e, t, n) {
          if (this._assertWriterUsedCorrectly(), n instanceof $) {
            const i = n.getMinimalFlatRanges();
            for (const r of i)
              Og(this, e, t, r);
          } else
            Rg(this, e, t, n);
        }
        setAttributes(e, t) {
          for (const [n, i] of pn(e))
            this.setAttribute(n, i, t);
        }
        removeAttribute(e, t) {
          if (this._assertWriterUsedCorrectly(), t instanceof $) {
            const n = t.getMinimalFlatRanges();
            for (const i of n)
              Og(this, e, null, i);
          } else
            Rg(this, e, null, t);
        }
        clearAttributes(e) {
          this._assertWriterUsedCorrectly();
          const t = (n) => {
            for (const i of n.getAttributeKeys())
              this.removeAttribute(i, n);
          };
          if (e instanceof $)
            for (const n of e.getItems())
              t(n);
          else
            t(e);
        }
        move(e, t, n) {
          if (this._assertWriterUsedCorrectly(), !(e instanceof $))
            throw new O("writer-move-invalid-range", this);
          if (!e.isFlat)
            throw new O("writer-move-range-not-flat", this);
          const i = q._createAt(t, n);
          if (i.isEqual(e.start))
            return;
          if (this._addOperationForAffectedMarkers("move", e), !zg(e.root, i.root))
            throw new O("writer-move-different-document", this);
          const r = e.root.document ? e.root.document.version : null, s = new De(e.start, e.end.offset - e.start.offset, i, r);
          this.batch.addOperation(s), this.model.applyOperation(s);
        }
        remove(e) {
          this._assertWriterUsedCorrectly();
          const t = (e instanceof $ ? e : $._createOn(e)).getMinimalFlatRanges().reverse();
          for (const n of t)
            this._addOperationForAffectedMarkers("move", n), S1(n.start, n.end.offset - n.start.offset, this.batch, this.model);
        }
        merge(e) {
          this._assertWriterUsedCorrectly();
          const t = e.nodeBefore, n = e.nodeAfter;
          if (this._addOperationForAffectedMarkers("merge", e), !(t instanceof Fe))
            throw new O("writer-merge-no-element-before", this);
          if (!(n instanceof Fe))
            throw new O("writer-merge-no-element-after", this);
          e.root.document ? this._merge(e) : this._mergeDetached(e);
        }
        createPositionFromPath(e, t, n) {
          return this.model.createPositionFromPath(e, t, n);
        }
        createPositionAt(e, t) {
          return this.model.createPositionAt(e, t);
        }
        createPositionAfter(e) {
          return this.model.createPositionAfter(e);
        }
        createPositionBefore(e) {
          return this.model.createPositionBefore(e);
        }
        createRange(e, t) {
          return this.model.createRange(e, t);
        }
        createRangeIn(e) {
          return this.model.createRangeIn(e);
        }
        createRangeOn(e) {
          return this.model.createRangeOn(e);
        }
        createSelection(...e) {
          return this.model.createSelection(...e);
        }
        _mergeDetached(e) {
          const t = e.nodeBefore, n = e.nodeAfter;
          this.move($._createIn(n), q._createAt(t, "end")), this.remove(n);
        }
        _merge(e) {
          const t = q._createAt(e.nodeBefore, "end"), n = q._createAt(e.nodeAfter, 0), i = e.root.document.graveyard, r = new q(i, [0]), s = e.root.document.version, a = new et(n, e.nodeAfter.maxOffset, t, r, s);
          this.batch.addOperation(a), this.model.applyOperation(a);
        }
        rename(e, t) {
          if (this._assertWriterUsedCorrectly(), !(e instanceof Fe))
            throw new O("writer-rename-not-element-instance", this);
          const n = e.root.document ? e.root.document.version : null, i = new Dt(q._createBefore(e), e.name, t, n);
          this.batch.addOperation(i), this.model.applyOperation(i);
        }
        split(e, t) {
          this._assertWriterUsedCorrectly();
          let n, i, r = e.parent;
          if (!r.parent)
            throw new O("writer-split-element-no-parent", this);
          if (t || (t = r.parent), !e.parent.getAncestors({ includeSelf: !0 }).includes(t))
            throw new O("writer-split-invalid-limit-element", this);
          do {
            const s = r.root.document ? r.root.document.version : null, a = r.maxOffset - e.offset, l = $e.getInsertionPosition(e), d = new $e(e, a, l, null, s);
            this.batch.addOperation(d), this.model.applyOperation(d), n || i || (n = r, i = e.parent.nextSibling), r = (e = this.createPositionAfter(e.parent)).parent;
          } while (r !== t);
          return { position: e, range: new $(q._createAt(n, "end"), q._createAt(i, 0)) };
        }
        wrap(e, t) {
          if (this._assertWriterUsedCorrectly(), !e.isFlat)
            throw new O("writer-wrap-range-not-flat", this);
          const n = t instanceof Fe ? t : new Fe(t);
          if (n.childCount > 0)
            throw new O("writer-wrap-element-not-empty", this);
          if (n.parent !== null)
            throw new O("writer-wrap-element-attached", this);
          this.insert(n, e.start);
          const i = new $(e.start.getShiftedBy(1), e.end.getShiftedBy(1));
          this.move(i, q._createAt(n, 0));
        }
        unwrap(e) {
          if (this._assertWriterUsedCorrectly(), e.parent === null)
            throw new O("writer-unwrap-element-no-parent", this);
          this.move($._createIn(e), this.createPositionAfter(e)), this.remove(e);
        }
        addMarker(e, t) {
          if (this._assertWriterUsedCorrectly(), !t || typeof t.usingOperation != "boolean")
            throw new O("writer-addmarker-no-usingoperation", this);
          const n = t.usingOperation, i = t.range, r = t.affectsData !== void 0 && t.affectsData;
          if (this.model.markers.has(e))
            throw new O("writer-addmarker-marker-exists", this);
          if (!i)
            throw new O("writer-addmarker-no-range", this);
          return n ? (Vi(this, e, null, i, r), this.model.markers.get(e)) : this.model.markers._set(e, i, n, r);
        }
        updateMarker(e, t) {
          this._assertWriterUsedCorrectly();
          const n = typeof e == "string" ? e : e.name, i = this.model.markers.get(n);
          if (!i)
            throw new O("writer-updatemarker-marker-not-exists", this);
          if (!t)
            return oe("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n }), void this.model.markers._refresh(i);
          const r = typeof t.usingOperation == "boolean", s = typeof t.affectsData == "boolean", a = s ? t.affectsData : i.affectsData;
          if (!r && !t.range && !s)
            throw new O("writer-updatemarker-wrong-options", this);
          const l = i.getRange(), d = t.range ? t.range : l;
          r && t.usingOperation !== i.managedUsingOperations ? t.usingOperation ? Vi(this, n, null, d, a) : (Vi(this, n, l, null, a), this.model.markers._set(n, d, void 0, a)) : i.managedUsingOperations ? Vi(this, n, l, d, a) : this.model.markers._set(n, d, void 0, a);
        }
        removeMarker(e) {
          this._assertWriterUsedCorrectly();
          const t = typeof e == "string" ? e : e.name;
          if (!this.model.markers.has(t))
            throw new O("writer-removemarker-no-marker", this);
          const n = this.model.markers.get(t);
          if (!n.managedUsingOperations)
            return void this.model.markers._remove(t);
          Vi(this, t, n.getRange(), null, n.affectsData);
        }
        addRoot(e, t = "$root") {
          this._assertWriterUsedCorrectly();
          const n = this.model.document.getRoot(e);
          if (n && n.isAttached())
            throw new O("writer-addroot-root-exists", this);
          const i = this.model.document, r = new un(e, t, !0, i, i.version);
          return this.batch.addOperation(r), this.model.applyOperation(r), this.model.document.getRoot(e);
        }
        detachRoot(e) {
          this._assertWriterUsedCorrectly();
          const t = typeof e == "string" ? this.model.document.getRoot(e) : e;
          if (!t || !t.isAttached())
            throw new O("writer-detachroot-no-root", this);
          for (const r of this.model.markers)
            r.getRange().root === t && this.removeMarker(r);
          for (const r of t.getAttributeKeys())
            this.removeAttribute(r, t);
          this.remove(this.createRangeIn(t));
          const n = this.model.document, i = new un(t.rootName, t.name, !1, n, n.version);
          this.batch.addOperation(i), this.model.applyOperation(i);
        }
        setSelection(...e) {
          this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...e);
        }
        setSelectionFocus(e, t) {
          this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(e, t);
        }
        setSelectionAttribute(e, t) {
          if (this._assertWriterUsedCorrectly(), typeof e == "string")
            this._setSelectionAttribute(e, t);
          else
            for (const [n, i] of pn(e))
              this._setSelectionAttribute(n, i);
        }
        removeSelectionAttribute(e) {
          if (this._assertWriterUsedCorrectly(), typeof e == "string")
            this._removeSelectionAttribute(e);
          else
            for (const t of e)
              this._removeSelectionAttribute(t);
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity();
        }
        restoreSelectionGravity(e) {
          this.model.document.selection._restoreGravity(e);
        }
        _setSelectionAttribute(e, t) {
          const n = this.model.document.selection;
          if (n.isCollapsed && n.anchor.parent.isEmpty) {
            const i = Qt._getStoreAttributeKey(e);
            this.setAttribute(i, t, n.anchor.parent);
          }
          n._setAttribute(e, t);
        }
        _removeSelectionAttribute(e) {
          const t = this.model.document.selection;
          if (t.isCollapsed && t.anchor.parent.isEmpty) {
            const n = Qt._getStoreAttributeKey(e);
            this.removeAttribute(n, t.anchor.parent);
          }
          t._removeAttribute(e);
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this)
            throw new O("writer-incorrect-use", this);
        }
        _addOperationForAffectedMarkers(e, t) {
          for (const n of this.model.markers) {
            if (!n.managedUsingOperations)
              continue;
            const i = n.getRange();
            let r = !1;
            if (e === "move") {
              const s = t;
              r = s.containsPosition(i.start) || s.start.isEqual(i.start) || s.containsPosition(i.end) || s.end.isEqual(i.end);
            } else {
              const s = t, a = s.nodeBefore, l = s.nodeAfter, d = i.start.parent == a && i.start.isAtEnd, h = i.end.parent == l && i.end.offset == 0, m = i.end.nodeAfter == l, f = i.start.nodeAfter == l;
              r = d || h || m || f;
            }
            r && this.updateMarker(n.name, { range: i });
          }
        }
      }
      function Og(o, e, t, n) {
        const i = o.model, r = i.document;
        let s, a, l, d = n.start;
        for (const m of n.getWalker({ shallow: !0 }))
          l = m.item.getAttribute(e), s && a != l && (a != t && h(), d = s), s = m.nextPosition, a = l;
        function h() {
          const m = new $(d, s), f = m.root.document ? r.version : null, _ = new rt(m, e, a, t, f);
          o.batch.addOperation(_), i.applyOperation(_);
        }
        s instanceof q && s != d && a != t && h();
      }
      function Rg(o, e, t, n) {
        const i = o.model, r = i.document, s = n.getAttribute(e);
        let a, l;
        if (s != t) {
          if (n.root === n) {
            const d = n.document ? r.version : null;
            l = new bn(n, e, s, t, d);
          } else {
            a = new $(q._createBefore(n), o.createPositionAfter(n));
            const d = a.root.document ? r.version : null;
            l = new rt(a, e, s, t, d);
          }
          o.batch.addOperation(l), i.applyOperation(l);
        }
      }
      function Vi(o, e, t, n, i) {
        const r = o.model, s = r.document, a = new St(e, t, n, r.markers, !!i, s.version);
        o.batch.addOperation(a), r.applyOperation(a);
      }
      function S1(o, e, t, n) {
        let i;
        if (o.root.document) {
          const r = n.document, s = new q(r.graveyard, [0]);
          i = new De(o, e, s, r.version);
        } else
          i = new E1(o, e);
        t.addOperation(i), n.applyOperation(i);
      }
      function zg(o, e) {
        return o === e || o instanceof Zr && e instanceof Zr;
      }
      function D1(o, e, t = {}) {
        if (e.isCollapsed)
          return;
        const n = e.getFirstRange();
        if (n.root.rootName == "$graveyard")
          return;
        const i = o.schema;
        o.change((r) => {
          if (!t.doNotResetEntireContent && function(d, h) {
            const m = d.getLimitElement(h);
            if (!h.containsEntireContent(m))
              return !1;
            const f = h.getFirstRange();
            return f.start.parent == f.end.parent ? !1 : d.checkChild(m, "paragraph");
          }(i, e))
            return void function(d, h) {
              const m = d.model.schema.getLimitElement(h);
              d.remove(d.createRangeIn(m)), Fg(d, d.createPositionAt(m, 0), h);
            }(r, e);
          const s = {};
          if (!t.doNotAutoparagraph) {
            const d = e.getSelectedElement();
            d && Object.assign(s, i.getAttributesWithProperty(d, "copyOnReplace", !0));
          }
          const [a, l] = function(d) {
            const h = d.root.document.model, m = d.start;
            let f = d.end;
            if (h.hasContent(d, { ignoreMarkers: !0 })) {
              const _ = function(S) {
                const B = S.parent, T = B.root.document.model.schema, R = B.getAncestors({ parentFirst: !0, includeSelf: !0 });
                for (const N of R) {
                  if (T.isLimit(N))
                    return null;
                  if (T.isBlock(N))
                    return N;
                }
              }(f);
              if (_ && f.isTouching(h.createPositionAt(_, 0))) {
                const S = h.createSelection(d);
                h.modifySelection(S, { direction: "backward" });
                const B = S.getLastPosition(), T = h.createRange(B, f);
                h.hasContent(T, { ignoreMarkers: !0 }) || (f = B);
              }
            }
            return [Bt.fromPosition(m, "toPrevious"), Bt.fromPosition(f, "toNext")];
          }(n);
          a.isTouching(l) || r.remove(r.createRange(a, l)), t.leaveUnmerged || (function(d, h, m) {
            const f = d.model;
            if (!nl(d.model.schema, h, m))
              return;
            const [_, S] = function(B, T) {
              const R = B.getAncestors(), N = T.getAncestors();
              let U = 0;
              for (; R[U] && R[U] == N[U]; )
                U++;
              return [R[U], N[U]];
            }(h, m);
            !_ || !S || (!f.hasContent(_, { ignoreMarkers: !0 }) && f.hasContent(S, { ignoreMarkers: !0 }) ? Ng(d, h, m, _.parent) : Mg(d, h, m, _.parent));
          }(r, a, l), i.removeDisallowedAttributes(a.parent.getChildren(), r)), $g(r, e, a), !t.doNotAutoparagraph && function(d, h) {
            const m = d.checkChild(h, "$text"), f = d.checkChild(h, "paragraph");
            return !m && f;
          }(i, a) && Fg(r, a, e, s), a.detach(), l.detach();
        });
      }
      function Mg(o, e, t, n) {
        const i = e.parent, r = t.parent;
        if (i != n && r != n) {
          for (e = o.createPositionAfter(i), (t = o.createPositionBefore(r)).isEqual(e) || o.insert(r, e), o.merge(e); t.parent.isEmpty; ) {
            const s = t.parent;
            t = o.createPositionBefore(s), o.remove(s);
          }
          nl(o.model.schema, e, t) && Mg(o, e, t, n);
        }
      }
      function Ng(o, e, t, n) {
        const i = e.parent, r = t.parent;
        if (i != n && r != n) {
          for (e = o.createPositionAfter(i), (t = o.createPositionBefore(r)).isEqual(e) || o.insert(i, t); e.parent.isEmpty; ) {
            const s = e.parent;
            e = o.createPositionBefore(s), o.remove(s);
          }
          t = o.createPositionBefore(r), function(s, a) {
            const l = a.nodeBefore, d = a.nodeAfter;
            l.name != d.name && s.rename(l, d.name), s.clearAttributes(l), s.setAttributes(Object.fromEntries(d.getAttributes()), l), s.merge(a);
          }(o, t), nl(o.model.schema, e, t) && Ng(o, e, t, n);
        }
      }
      function nl(o, e, t) {
        const n = e.parent, i = t.parent;
        return n != i && !o.isLimit(n) && !o.isLimit(i) && function(r, s, a) {
          const l = new $(r, s);
          for (const d of l.getWalker())
            if (a.isLimit(d.item))
              return !1;
          return !0;
        }(e, t, o);
      }
      function Fg(o, e, t, n = {}) {
        const i = o.createElement("paragraph");
        o.model.schema.setAllowedAttributes(i, n, o), o.insert(i, e), $g(o, t, o.createPositionAt(i, 0));
      }
      function $g(o, e, t) {
        e instanceof Qt ? o.setSelection(t) : e.setTo(t);
      }
      function Vg(o, e) {
        const t = [];
        Array.from(o.getItems({ direction: "backward" })).map((n) => e.createRangeOn(n)).filter((n) => (n.start.isAfter(o.start) || n.start.isEqual(o.start)) && (n.end.isBefore(o.end) || n.end.isEqual(o.end))).forEach((n) => {
          t.push(n.start.parent), e.remove(n);
        }), t.forEach((n) => {
          let i = n;
          for (; i.parent && i.isEmpty; ) {
            const r = e.createRangeOn(i);
            i = i.parent, e.remove(r);
          }
        });
      }
      class B1 {
        constructor(e, t, n) {
          this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null, this._nodeToSelect = null, this.model = e, this.writer = t, this.position = n, this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]), this.schema = e.schema, this._documentFragment = t.createDocumentFragment(), this._documentFragmentPosition = t.createPositionAt(this._documentFragment, 0);
        }
        handleNodes(e) {
          for (const t of Array.from(e))
            this._handleNode(t);
          this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
        }
        _updateLastNodeFromAutoParagraph(e) {
          const t = this.writer.createPositionAfter(this._lastNode), n = this.writer.createPositionAfter(e);
          if (n.isAfter(t)) {
            if (this._lastNode = e, this.position.parent != e || !this.position.isAtEnd)
              throw new O("insertcontent-invalid-insertion-position", this);
            this.position = n, this._setAffectedBoundaries(this.position);
          }
        }
        getSelectionRange() {
          return this._nodeToSelect ? $._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
        }
        getAffectedRange() {
          return this._affectedStart ? new $(this._affectedStart, this._affectedEnd) : null;
        }
        destroy() {
          this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
        }
        _handleNode(e) {
          if (this.schema.isObject(e))
            return void this._handleObject(e);
          let t = this._checkAndAutoParagraphToAllowedPosition(e);
          t || (t = this._checkAndSplitToAllowedPosition(e), t) ? (this._appendToFragment(e), this._firstNode || (this._firstNode = e), this._lastNode = e) : this._handleDisallowedNode(e);
        }
        _insertPartialFragment() {
          if (this._documentFragment.isEmpty)
            return;
          const e = Bt.fromPosition(this.position, "toNext");
          this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = e.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = e.toPosition(), e.detach();
        }
        _handleObject(e) {
          this._checkAndSplitToAllowedPosition(e) ? this._appendToFragment(e) : this._tryAutoparagraphing(e);
        }
        _handleDisallowedNode(e) {
          e.is("element") ? this.handleNodes(e.getChildren()) : this._tryAutoparagraphing(e);
        }
        _appendToFragment(e) {
          if (!this.schema.checkChild(this.position, e))
            throw new O("insertcontent-wrong-position", this, { node: e, position: this.position });
          this.writer.insert(e, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(e.offsetSize), this.schema.isObject(e) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = e : this._nodeToSelect = null, this._filterAttributesOf.push(e);
        }
        _setAffectedBoundaries(e) {
          this._affectedStart || (this._affectedStart = Bt.fromPosition(e, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(e) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = Bt.fromPosition(e, "toNext"));
        }
        _mergeOnLeft() {
          const e = this._firstNode;
          if (!(e instanceof Fe) || !this._canMergeLeft(e))
            return;
          const t = Bt._createBefore(e);
          t.stickiness = "toNext";
          const n = Bt.fromPosition(this.position, "toNext");
          this._affectedStart.isEqual(t) && (this._affectedStart.detach(), this._affectedStart = Bt._createAt(t.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = Bt._createAt(t.nodeBefore, "end", "toNext")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
        }
        _mergeOnRight() {
          const e = this._lastNode;
          if (!(e instanceof Fe) || !this._canMergeRight(e))
            return;
          const t = Bt._createAfter(e);
          if (t.stickiness = "toNext", !this.position.isEqual(t))
            throw new O("insertcontent-invalid-insertion-position", this);
          this.position = q._createAt(t.nodeBefore, "end");
          const n = Bt.fromPosition(this.position, "toPrevious");
          this._affectedEnd.isEqual(t) && (this._affectedEnd.detach(), this._affectedEnd = Bt._createAt(t.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = Bt._createAt(t.nodeBefore, 0, "toPrevious")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
        }
        _canMergeLeft(e) {
          const t = e.previousSibling;
          return t instanceof Fe && this.canMergeWith.has(t) && this.model.schema.checkMerge(t, e);
        }
        _canMergeRight(e) {
          const t = e.nextSibling;
          return t instanceof Fe && this.canMergeWith.has(t) && this.model.schema.checkMerge(e, t);
        }
        _tryAutoparagraphing(e) {
          const t = this.writer.createElement("paragraph");
          this._getAllowedIn(this.position.parent, t) && this.schema.checkChild(t, e) && (t._appendChild(e), this._handleNode(t));
        }
        _checkAndAutoParagraphToAllowedPosition(e) {
          if (this.schema.checkChild(this.position.parent, e))
            return !0;
          if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", e))
            return !1;
          this._insertPartialFragment();
          const t = this.writer.createElement("paragraph");
          return this.writer.insert(t, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = t, this.position = this.writer.createPositionAt(t, 0), !0;
        }
        _checkAndSplitToAllowedPosition(e) {
          const t = this._getAllowedIn(this.position.parent, e);
          if (!t)
            return !1;
          for (t != this.position.parent && this._insertPartialFragment(); t != this.position.parent; )
            if (this.position.isAtStart) {
              const n = this.position.parent;
              this.position = this.writer.createPositionBefore(n), n.isEmpty && n.parent === t && this.writer.remove(n);
            } else if (this.position.isAtEnd)
              this.position = this.writer.createPositionAfter(this.position.parent);
            else {
              const n = this.writer.createPositionAfter(this.position.parent);
              this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = n, this.canMergeWith.add(this.position.nodeAfter);
            }
          return !0;
        }
        _getAllowedIn(e, t) {
          return this.schema.checkChild(e, t) ? e : this.schema.isLimit(e) ? null : this._getAllowedIn(e.parent, t);
        }
      }
      function Lg(o, e, t = "auto") {
        const n = o.getSelectedElement();
        if (n && e.schema.isObject(n) && !e.schema.isInline(n))
          return t == "before" || t == "after" ? e.createRange(e.createPositionAt(n, t)) : e.createRangeOn(n);
        const i = it(o.getSelectedBlocks());
        if (!i)
          return e.createRange(o.focus);
        if (i.isEmpty)
          return e.createRange(e.createPositionAt(i, 0));
        const r = e.createPositionAfter(i);
        return o.focus.isTouching(r) ? e.createRange(r) : e.createRange(e.createPositionBefore(i));
      }
      function T1(o, e, t, n = {}) {
        if (!o.schema.isObject(e))
          throw new O("insertobject-element-not-an-object", o, { object: e });
        const i = t || o.document.selection;
        let r = i;
        n.findOptimalPosition && o.schema.isBlock(e) && (r = o.createSelection(Lg(i, o, n.findOptimalPosition)));
        const s = it(i.getSelectedBlocks()), a = {};
        return s && Object.assign(a, o.schema.getAttributesWithProperty(s, "copyOnReplace", !0)), o.change((l) => {
          r.isCollapsed || o.deleteContent(r, { doNotAutoparagraph: !0 });
          let d = e;
          const h = r.anchor.parent;
          !o.schema.checkChild(h, e) && o.schema.checkChild(h, "paragraph") && o.schema.checkChild("paragraph", e) && (d = l.createElement("paragraph"), l.insert(e, d)), o.schema.setAllowedAttributes(d, a, l);
          const m = o.insertContent(d, r);
          return m.isCollapsed || n.setSelection && function(f, _, S, B) {
            const T = f.model;
            if (S == "on")
              return void f.setSelection(_, "on");
            if (S != "after")
              throw new O("insertobject-invalid-place-parameter-value", T);
            let R = _.nextSibling;
            if (T.schema.isInline(_))
              return void f.setSelection(_, "after");
            !(R && T.schema.checkChild(R, "$text")) && T.schema.checkChild(_.parent, "paragraph") && (R = f.createElement("paragraph"), T.schema.setAllowedAttributes(R, B, f), T.insertContent(R, f.createPositionAfter(_))), R && f.setSelection(R, 0);
          }(l, e, n.setSelection, a), m;
        });
      }
      const I1 = ' ,.?!:;"-()';
      function P1(o, e) {
        const { isForward: t, walker: n, unit: i, schema: r, treatEmojiAsSingleUnit: s } = o, { type: a, item: l, nextPosition: d } = e;
        if (a == "text")
          return o.unit === "word" ? function(h, m) {
            let f = h.position.textNode;
            for (f || (f = m ? h.position.nodeAfter : h.position.nodeBefore); f && f.is("$text"); ) {
              const _ = h.position.offset - f.startOffset;
              if (z1(f, _, m))
                f = m ? h.position.nodeAfter : h.position.nodeBefore;
              else {
                if (R1(f.data, _, m))
                  break;
                h.next();
              }
            }
            return h.position;
          }(n, t) : function(h, m, f) {
            const _ = h.position.textNode;
            if (_) {
              const S = _.data;
              let B = h.position.offset - _.startOffset;
              for (; pa(S, B) || m == "character" && fa(S, B) || f && lu(S, B); )
                h.next(), B = h.position.offset - _.startOffset;
            }
            return h.position;
          }(n, i, s);
        if (a == (t ? "elementStart" : "elementEnd")) {
          if (r.isSelectable(l))
            return q._createAt(l, t ? "after" : "before");
          if (r.checkChild(d, "$text"))
            return d;
        } else {
          if (r.isLimit(l))
            return void n.skip(() => !0);
          if (r.checkChild(d, "$text"))
            return d;
        }
      }
      function O1(o, e) {
        const t = o.root, n = q._createAt(t, e ? "end" : 0);
        return e ? new $(o, n) : new $(n, o);
      }
      function R1(o, e, t) {
        const n = e + (t ? 0 : -1);
        return I1.includes(o.charAt(n));
      }
      function z1(o, e, t) {
        return e === (t ? o.offsetSize : 0);
      }
      class M1 extends re() {
        constructor() {
          super(), this.markers = new y1(), this.document = new k1(this), this.schema = new PC(), this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((e) => this.decorate(e)), this.on("applyOperation", (e, t) => {
            t[0]._validate();
          }, { priority: "highest" }), this.schema.register("$root", { isLimit: !0 }), this.schema.register("$container", { allowIn: ["$root", "$container"] }), this.schema.register("$block", { allowIn: ["$root", "$container"], isBlock: !0 }), this.schema.register("$blockObject", { allowWhere: "$block", isBlock: !0, isObject: !0 }), this.schema.register("$inlineObject", { allowWhere: "$text", allowAttributesOf: "$text", isInline: !0, isObject: !0 }), this.schema.register("$text", { allowIn: "$block", isInline: !0, isContent: !0 }), this.schema.register("$clipboardHolder", { allowContentOf: "$root", allowChildren: "$text", isLimit: !0 }), this.schema.register("$documentFragment", { allowContentOf: "$root", allowChildren: "$text", isLimit: !0 }), this.schema.register("$marker"), this.schema.addChildCheck((e, t) => {
            if (t.name === "$marker")
              return !0;
          }), BC(this), this.document.registerPostFixer(Xh), this.on("insertContent", (e, [t, n]) => {
            e.return = function(i, r, s) {
              return i.change((a) => {
                const l = s || i.document.selection;
                l.isCollapsed || i.deleteContent(l, { doNotAutoparagraph: !0 });
                const d = new B1(i, a, l.anchor), h = [];
                let m;
                if (r.is("documentFragment")) {
                  if (r.markers.size) {
                    const S = [];
                    for (const [B, T] of r.markers) {
                      const { start: R, end: N } = T, U = R.isEqual(N);
                      S.push({ position: R, name: B, isCollapsed: U }, { position: N, name: B, isCollapsed: U });
                    }
                    S.sort(({ position: B }, { position: T }) => B.isBefore(T) ? 1 : -1);
                    for (const { position: B, name: T, isCollapsed: R } of S) {
                      let N = null, U = null;
                      const ee = B.parent === r && B.isAtStart, we = B.parent === r && B.isAtEnd;
                      ee || we ? R && (U = ee ? "start" : "end") : (N = a.createElement("$marker"), a.insert(N, B)), h.push({ name: T, element: N, collapsed: U });
                    }
                  }
                  m = r.getChildren();
                } else
                  m = [r];
                d.handleNodes(m);
                let f = d.getSelectionRange();
                if (r.is("documentFragment") && h.length) {
                  const S = f ? fn.fromRange(f) : null, B = {};
                  for (let T = h.length - 1; T >= 0; T--) {
                    const { name: R, element: N, collapsed: U } = h[T], ee = !B[R];
                    if (ee && (B[R] = []), N) {
                      const we = a.createPositionAt(N, "before");
                      B[R].push(we), a.remove(N);
                    } else {
                      const we = d.getAffectedRange();
                      if (!we) {
                        U && B[R].push(d.position);
                        continue;
                      }
                      U ? B[R].push(we[U]) : B[R].push(ee ? we.start : we.end);
                    }
                  }
                  for (const [T, [R, N]] of Object.entries(B))
                    R && N && R.root === N.root && a.addMarker(T, { usingOperation: !0, affectsData: !0, range: new $(R, N) });
                  S && (f = S.toRange(), S.detach());
                }
                f && (l instanceof Qt ? a.setSelection(f) : l.setTo(f));
                const _ = d.getAffectedRange() || i.createRange(l.anchor);
                return d.destroy(), _;
              });
            }(this, t, n);
          }), this.on("insertObject", (e, [t, n, i]) => {
            e.return = T1(this, t, n, i);
          }), this.on("canEditAt", (e) => {
            const t = !this.document.isReadOnly;
            e.return = t, t || e.stop();
          });
        }
        change(e) {
          try {
            return this._pendingChanges.length === 0 ? (this._pendingChanges.push({ batch: new jo(), callback: e }), this._runPendingChanges()[0]) : e(this._currentWriter);
          } catch (t) {
            O.rethrowUnexpectedError(t, this);
          }
        }
        enqueueChange(e, t) {
          try {
            e ? typeof e == "function" ? (t = e, e = new jo()) : e instanceof jo || (e = new jo(e)) : e = new jo(), this._pendingChanges.push({ batch: e, callback: t }), this._pendingChanges.length == 1 && this._runPendingChanges();
          } catch (n) {
            O.rethrowUnexpectedError(n, this);
          }
        }
        applyOperation(e) {
          e._execute();
        }
        insertContent(e, t, n, ...i) {
          const r = ol(t, n);
          return this.fire("insertContent", [e, r, n, ...i]);
        }
        insertObject(e, t, n, i, ...r) {
          const s = ol(t, n);
          return this.fire("insertObject", [e, s, i, i, ...r]);
        }
        deleteContent(e, t) {
          D1(this, e, t);
        }
        modifySelection(e, t) {
          (function(n, i, r = {}) {
            const s = n.schema, a = r.direction != "backward", l = r.unit ? r.unit : "character", d = !!r.treatEmojiAsSingleUnit, h = i.focus, m = new dn({ boundaries: O1(h, a), singleCharacters: !0, direction: a ? "forward" : "backward" }), f = { walker: m, schema: s, isForward: a, unit: l, treatEmojiAsSingleUnit: d };
            let _;
            for (; _ = m.next(); ) {
              if (_.done)
                return;
              const S = P1(f, _.value);
              if (S)
                return void (i instanceof Qt ? n.change((B) => {
                  B.setSelectionFocus(S);
                }) : i.setFocus(S));
            }
          })(this, e, t);
        }
        getSelectedContent(e) {
          return function(t, n) {
            return t.change((i) => {
              const r = i.createDocumentFragment(), s = n.getFirstRange();
              if (!s || s.isCollapsed)
                return r;
              const a = s.start.root, l = s.start.getCommonPath(s.end), d = a.getNodeByPath(l);
              let h;
              h = s.start.parent == s.end.parent ? s : i.createRange(i.createPositionAt(d, s.start.path[l.length]), i.createPositionAt(d, s.end.path[l.length] + 1));
              const m = h.end.offset - h.start.offset;
              for (const f of h.getItems({ shallow: !0 }))
                f.is("$textProxy") ? i.appendText(f.data, f.getAttributes(), r) : i.append(i.cloneElement(f, !0), r);
              if (h != s) {
                const f = s._getTransformedByMove(h.start, i.createPositionAt(r, 0), m)[0], _ = i.createRange(i.createPositionAt(r, 0), f.start);
                Vg(i.createRange(f.end, i.createPositionAt(r, "end")), i), Vg(_, i);
              }
              return r;
            });
          }(this, e);
        }
        hasContent(e, t = {}) {
          const n = e instanceof $ ? e : $._createIn(e);
          if (n.isCollapsed)
            return !1;
          const { ignoreWhitespaces: i = !1, ignoreMarkers: r = !1 } = t;
          if (!r) {
            for (const s of this.markers.getMarkersIntersectingRange(n))
              if (s.affectsData)
                return !0;
          }
          for (const s of n.getItems())
            if (this.schema.isContent(s) && (!s.is("$textProxy") || !i || s.data.search(/\S/) !== -1))
              return !0;
          return !1;
        }
        canEditAt(e) {
          const t = ol(e);
          return this.fire("canEditAt", [t]);
        }
        createPositionFromPath(e, t, n) {
          return new q(e, t, n);
        }
        createPositionAt(e, t) {
          return q._createAt(e, t);
        }
        createPositionAfter(e) {
          return q._createAfter(e);
        }
        createPositionBefore(e) {
          return q._createBefore(e);
        }
        createRange(e, t) {
          return new $(e, t);
        }
        createRangeIn(e) {
          return $._createIn(e);
        }
        createRangeOn(e) {
          return $._createOn(e);
        }
        createSelection(...e) {
          return new Ft(...e);
        }
        createBatch(e) {
          return new jo(e);
        }
        createOperationFromJSON(e) {
          return e1.fromJSON(e, this.document);
        }
        destroy() {
          this.document.destroy(), this.stopListening();
        }
        _runPendingChanges() {
          const e = [];
          this.fire("_beforeChanges");
          try {
            for (; this._pendingChanges.length; ) {
              const t = this._pendingChanges[0].batch;
              this._currentWriter = new x1(this, t);
              const n = this._pendingChanges[0].callback(this._currentWriter);
              e.push(n), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
            }
          } finally {
            this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges");
          }
          return e;
        }
      }
      function ol(o, e) {
        if (o)
          return o instanceof Ft || o instanceof Qt ? o : o instanceof io ? e || e === 0 ? new Ft(o, e) : o.is("rootElement") ? new Ft(o, "in") : new Ft(o, "on") : new Ft(o);
      }
      class N1 extends Pn {
        constructor() {
          super(...arguments), this.domEventType = "click";
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
      }
      class il extends Pn {
        constructor() {
          super(...arguments), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
      }
      class Jr {
        constructor(e) {
          this.document = e;
        }
        createDocumentFragment(e) {
          return new oo(this.document, e);
        }
        createElement(e, t, n) {
          return new Mt(this.document, e, t, n);
        }
        createText(e) {
          return new Me(this.document, e);
        }
        clone(e, t = !1) {
          return e._clone(t);
        }
        appendChild(e, t) {
          return t._appendChild(e);
        }
        insertChild(e, t, n) {
          return n._insertChild(e, t);
        }
        removeChildren(e, t, n) {
          return n._removeChildren(e, t);
        }
        remove(e) {
          const t = e.parent;
          return t ? this.removeChildren(t.getChildIndex(e), 1, t) : [];
        }
        replace(e, t) {
          const n = e.parent;
          if (n) {
            const i = n.getChildIndex(e);
            return this.removeChildren(i, 1, n), this.insertChild(i, t, n), !0;
          }
          return !1;
        }
        unwrapElement(e) {
          const t = e.parent;
          if (t) {
            const n = t.getChildIndex(e);
            this.remove(e), this.insertChild(n, e.getChildren(), t);
          }
        }
        rename(e, t) {
          const n = new Mt(this.document, e, t.getAttributes(), t.getChildren());
          return this.replace(t, n) ? n : null;
        }
        setAttribute(e, t, n) {
          n._setAttribute(e, t);
        }
        removeAttribute(e, t) {
          t._removeAttribute(e);
        }
        addClass(e, t) {
          t._addClass(e);
        }
        removeClass(e, t) {
          t._removeClass(e);
        }
        setStyle(e, t, n) {
          xt(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t);
        }
        removeStyle(e, t) {
          t._removeStyle(e);
        }
        setCustomProperty(e, t, n) {
          n._setCustomProperty(e, t);
        }
        removeCustomProperty(e, t) {
          return t._removeCustomProperty(e);
        }
        createPositionAt(e, t) {
          return J._createAt(e, t);
        }
        createPositionAfter(e) {
          return J._createAfter(e);
        }
        createPositionBefore(e) {
          return J._createBefore(e);
        }
        createRange(e, t) {
          return new ae(e, t);
        }
        createRangeOn(e) {
          return ae._createOn(e);
        }
        createRangeIn(e) {
          return ae._createIn(e);
        }
        createSelection(...e) {
          return new an(...e);
        }
      }
      function F1(o = "") {
        if (o === "")
          return { top: void 0, right: void 0, bottom: void 0, left: void 0 };
        const e = o.replace(/, /g, ",").split(" ").map((r) => r.replace(/,/g, ", ")), t = e[0], n = e[2] || t, i = e[1] || t;
        return { top: t, bottom: n, right: i, left: e[3] || i };
      }
      function $1({ top: o, right: e, bottom: t, left: n }) {
        const i = [];
        return n !== e ? i.push(o, e, t, n) : t !== o ? i.push(o, e, t) : e !== o ? i.push(o, e) : i.push(o), i.join(" ");
      }
      function V1(o) {
        var e, t;
        o.setNormalizer("margin", (e = "margin", (n) => ({ path: e, value: F1(n) }))), o.setNormalizer("margin-top", (n) => ({ path: "margin.top", value: n })), o.setNormalizer("margin-right", (n) => ({ path: "margin.right", value: n })), o.setNormalizer("margin-bottom", (n) => ({ path: "margin.bottom", value: n })), o.setNormalizer("margin-left", (n) => ({ path: "margin.left", value: n })), o.setReducer("margin", (t = "margin", (n) => {
          const { top: i, right: r, bottom: s, left: a } = n, l = [];
          return [i, r, a, s].every((d) => !!d) ? l.push([t, $1(n)]) : (i && l.push([t + "-top", i]), r && l.push([t + "-right", r]), s && l.push([t + "-bottom", s]), a && l.push([t + "-left", a])), l;
        })), o.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"]);
      }
      class L1 {
        constructor() {
          this._commands = /* @__PURE__ */ new Map();
        }
        add(e, t) {
          this._commands.set(e, t);
        }
        get(e) {
          return this._commands.get(e);
        }
        execute(e, ...t) {
          const n = this.get(e);
          if (!n)
            throw new O("commandcollection-command-not-found", this, { commandName: e });
          return n.execute(...t);
        }
        *names() {
          yield* this._commands.keys();
        }
        *commands() {
          yield* this._commands.values();
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]();
        }
        destroy() {
          for (const e of this.commands())
            e.destroy();
        }
      }
      class j1 extends re() {
        constructor(e = {}) {
          super();
          const t = this.constructor, n = e.language || t.defaultConfig && t.defaultConfig.language;
          this._context = e.context || new $u({ language: n }), this._context._addEditor(this, !e.context);
          const i = Array.from(t.builtinPlugins || []);
          this.config = new Vd(e, t.defaultConfig), this.config.define("plugins", i), this.config.define(this._context._getEditorConfig()), this.plugins = new Fu(this, i, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = /* @__PURE__ */ new Set(), this.commands = new L1(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.model = new M1(), this.on("change:isReadOnly", () => {
            this.model.document.isReadOnly = this.isReadOnly;
          });
          const r = new gA();
          this.data = new QC(this.model, r), this.editing = new TC(this.model, r), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new XC([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new z_(this), this.keystrokes.listenTo(this.editing.view.document);
        }
        get isReadOnly() {
          return this._readOnlyLocks.size > 0;
        }
        set isReadOnly(e) {
          throw new O("editor-isreadonly-has-no-setter");
        }
        enableReadOnlyMode(e) {
          if (typeof e != "string" && typeof e != "symbol")
            throw new O("editor-read-only-lock-id-invalid", null, { lockId: e });
          this._readOnlyLocks.has(e) || (this._readOnlyLocks.add(e), this._readOnlyLocks.size === 1 && this.fire("change:isReadOnly", "isReadOnly", !0, !1));
        }
        disableReadOnlyMode(e) {
          if (typeof e != "string" && typeof e != "symbol")
            throw new O("editor-read-only-lock-id-invalid", null, { lockId: e });
          this._readOnlyLocks.has(e) && (this._readOnlyLocks.delete(e), this._readOnlyLocks.size === 0 && this.fire("change:isReadOnly", "isReadOnly", !1, !0));
        }
        initPlugins() {
          const e = this.config, t = e.get("plugins"), n = e.get("removePlugins") || [], i = e.get("extraPlugins") || [], r = e.get("substitutePlugins") || [];
          return this.plugins.init(t.concat(i), n, r);
        }
        destroy() {
          let e = Promise.resolve();
          return this.state == "initializing" && (e = new Promise((t) => this.once("ready", t))), e.then(() => {
            this.fire("destroy"), this.stopListening(), this.commands.destroy();
          }).then(() => this.plugins.destroy()).then(() => {
            this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
          }).then(() => this._context._removeEditor(this));
        }
        execute(e, ...t) {
          try {
            return this.commands.execute(e, ...t);
          } catch (n) {
            O.rethrowUnexpectedError(n, this);
          }
        }
        focus() {
          this.editing.view.focus();
        }
        static create(...e) {
          throw new Error("This is an abstract method.");
        }
      }
      function Yr(o) {
        return class extends o {
          setData(e) {
            this.data.set(e);
          }
          getData(e) {
            return this.data.get(e);
          }
        };
      }
      {
        const o = Yr(Object);
        Yr.setData = o.prototype.setData, Yr.getData = o.prototype.getData;
      }
      function rl(o) {
        return class extends o {
          updateSourceElement(e = this.data.get()) {
            if (!this.sourceElement)
              throw new O("editor-missing-sourceelement", this);
            const t = this.config.get("updateSourceElementOnDestroy"), n = this.sourceElement instanceof HTMLTextAreaElement;
            r_(this.sourceElement, t || n ? e : "");
          }
        };
      }
      rl.updateSourceElement = rl(Object).prototype.updateSourceElement;
      class Qr extends Or {
        static get pluginName() {
          return "PendingActions";
        }
        init() {
          this.set("hasAny", !1), this._actions = new Ht({ idProperty: "_id" }), this._actions.delegate("add", "remove").to(this);
        }
        add(e) {
          if (typeof e != "string")
            throw new O("pendingactions-add-invalid-message", this);
          const t = new (re())();
          return t.set("message", e), this._actions.add(t), this.hasAny = !0, t;
        }
        remove(e) {
          this._actions.remove(e), this.hasAny = !!this._actions.length;
        }
        get first() {
          return this._actions.get(0);
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]();
        }
      }
      const qe = { bold: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', cancel: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>', caption: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>', check: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>', eraser: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>', image: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>', lowVision: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>', importExport: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path clip-rule="evenodd" d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>', paragraph: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>', plus: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>', text: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path clip-rule="evenodd" d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>', alignBottom: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>', alignMiddle: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>', alignTop: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>', alignLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', alignCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>', alignRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>', alignJustify: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', objectLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>', objectRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectFullWidth: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>', objectInline: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectSizeFull: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>', objectSizeLarge: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>', objectSizeSmall: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>', objectSizeMedium: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>', pencil: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>', pilcrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>', quote: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', threeVerticalDots: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>' };
      var jg = b(5542), H1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(jg.Z, H1), jg.Z.locals;
      const { threeVerticalDots: Hg } = qe, U1 = { alignLeft: qe.alignLeft, bold: qe.bold, importExport: qe.importExport, paragraph: qe.paragraph, plus: qe.plus, text: qe.text, threeVerticalDots: qe.threeVerticalDots };
      class sl extends _e {
        constructor(e, t) {
          super(e);
          const n = this.bindTemplate, i = this.t;
          this.options = t || {}, this.set("ariaLabel", i("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new Jt(), this.keystrokes = new mn(), this.set("class", void 0), this.set("isCompact", !1), this.itemsView = new q1(e), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
          const r = e.uiLanguageDirection === "rtl";
          this._focusCycler = new Si({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: [r ? "arrowright" : "arrowleft", "arrowup"], focusNext: [r ? "arrowleft" : "arrowright", "arrowdown"] } });
          const s = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")];
          var a;
          this.options.shouldGroupWhenFull && this.options.isFloating && s.push("ck-toolbar_floating"), this.setTemplate({ tag: "div", attributes: { class: s, role: "toolbar", "aria-label": n.to("ariaLabel"), style: { maxWidth: n.to("maxWidth") }, tabindex: -1 }, children: this.children, on: { mousedown: (a = this, a.bindTemplate.to((l) => {
            l.target === a.element && l.preventDefault();
          })) } }), this._behavior = this.options.shouldGroupWhenFull ? new G1(this) : new W1(this);
        }
        render() {
          super.render(), this.focusTracker.add(this.element);
          for (const e of this.items)
            this.focusTracker.add(e.element);
          this.items.on("add", (e, t) => {
            this.focusTracker.add(t.element);
          }), this.items.on("remove", (e, t) => {
            this.focusTracker.remove(t.element);
          }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
        }
        destroy() {
          return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        fillFromConfig(e, t, n) {
          this.items.addMany(this._buildItemsFromConfig(e, t, n));
        }
        _buildItemsFromConfig(e, t, n) {
          const i = Ru(e), r = n || i.removeItems;
          return this._cleanItemsConfiguration(i.items, t, r).map((s) => K(s) ? this._createNestedToolbarDropdown(s, t, r) : s === "|" ? new Ou() : s === "-" ? new R_() : t.create(s)).filter((s) => !!s);
        }
        _cleanItemsConfiguration(e, t, n) {
          const i = e.filter((r, s, a) => r === "|" || n.indexOf(r) === -1 && (r === "-" ? !this.options.shouldGroupWhenFull || (oe("toolbarview-line-break-ignored-when-grouping-items", a), !1) : !(!K(r) && !t.has(r)) || (oe("toolbarview-item-unavailable", { item: r }), !1)));
          return this._cleanSeparatorsAndLineBreaks(i);
        }
        _cleanSeparatorsAndLineBreaks(e) {
          const t = (s) => s !== "-" && s !== "|", n = e.length, i = e.findIndex(t);
          if (i === -1)
            return [];
          const r = n - e.slice().reverse().findIndex(t);
          return e.slice(i, r).filter((s, a, l) => t(s) ? !0 : !(a > 0 && l[a - 1] === s));
        }
        _createNestedToolbarDropdown(e, t, n) {
          let { label: i, icon: r, items: s, tooltip: a = !0, withText: l = !1 } = e;
          if (s = this._cleanItemsConfiguration(s, t, n), !s.length)
            return null;
          const d = wn(this.locale);
          return i || oe("toolbarview-nested-toolbar-dropdown-missing-label", e), d.class = "ck-toolbar__nested-toolbar-dropdown", d.buttonView.set({ label: i, tooltip: a, withText: !!l }), r !== !1 ? d.buttonView.icon = U1[r] || r || Hg : d.buttonView.withText = !0, Xr(d, () => d.toolbarView._buildItemsFromConfig(s, t, n)), d;
        }
      }
      class q1 extends _e {
        constructor(e) {
          super(e), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar__items"] }, children: this.children });
        }
      }
      class W1 {
        constructor(e) {
          const t = e.bindTemplate;
          e.set("isVertical", !1), e.itemsView.children.bindTo(e.items).using((n) => n), e.focusables.bindTo(e.items).using((n) => n), e.extendTemplate({ attributes: { class: [t.if("isVertical", "ck-toolbar_vertical")] } });
        }
        render() {
        }
        destroy() {
        }
      }
      class G1 {
        constructor(e) {
          this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = !1, this.view = e, this.viewChildren = e.children, this.viewFocusables = e.focusables, this.viewItemsView = e.itemsView, this.viewFocusTracker = e.focusTracker, this.viewLocale = e.locale, this.ungroupedItems = e.createCollection(), this.groupedItems = e.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), e.itemsView.children.bindTo(this.ungroupedItems).using((t) => t), this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this)), e.children.on("change", this._updateFocusCycleableItems.bind(this)), e.items.on("change", (t, n) => {
            const i = n.index, r = Array.from(n.added);
            for (const s of n.removed)
              i >= this.ungroupedItems.length ? this.groupedItems.remove(s) : this.ungroupedItems.remove(s);
            for (let s = i; s < i + r.length; s++) {
              const a = r[s - i];
              s > this.ungroupedItems.length ? this.groupedItems.add(a, s - this.ungroupedItems.length) : this.ungroupedItems.add(a, s);
            }
            this._updateGrouping();
          }), e.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
        }
        render(e) {
          this.viewElement = e.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(e);
        }
        destroy() {
          this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
        }
        _updateGrouping() {
          if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
            return;
          if (!Jn(this.viewElement))
            return void (this.shouldUpdateGroupingOnNextResize = !0);
          const e = this.groupedItems.length;
          let t;
          for (; this._areItemsOverflowing; )
            this._groupLastItem(), t = !0;
          if (!t && this.groupedItems.length) {
            for (; this.groupedItems.length && !this._areItemsOverflowing; )
              this._ungroupFirstItem();
            this._areItemsOverflowing && this._groupLastItem();
          }
          this.groupedItems.length !== e && this.view.fire("groupedItemsUpdate");
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length)
            return !1;
          const e = this.viewElement, t = this.viewLocale.uiLanguageDirection, n = new Ze(e.lastChild), i = new Ze(e);
          if (!this.cachedPadding) {
            const r = ke.window.getComputedStyle(e), s = t === "ltr" ? "paddingRight" : "paddingLeft";
            this.cachedPadding = Number.parseInt(r[s]);
          }
          return t === "ltr" ? n.right > i.right - this.cachedPadding : n.left < i.left + this.cachedPadding;
        }
        _enableGroupingOnResize() {
          let e;
          this.resizeObserver = new Sr(this.viewElement, (t) => {
            e && e === t.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = !1, this._updateGrouping(), e = t.contentRect.width);
          }), this._updateGrouping();
        }
        _enableGroupingOnMaxWidthChange(e) {
          e.on("change:maxWidth", () => {
            this._updateGrouping();
          });
        }
        _groupLastItem() {
          this.groupedItems.length || (this.viewChildren.add(new Ou()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
        }
        _createGroupedItemsDropdown() {
          const e = this.viewLocale, t = e.t, n = wn(e);
          return n.class = "ck-toolbar__grouped-dropdown", n.panelPosition = e.uiLanguageDirection === "ltr" ? "sw" : "se", Xr(n, this.groupedItems), n.buttonView.set({ label: t("Show more items"), tooltip: !0, tooltipPosition: e.uiLanguageDirection === "rtl" ? "se" : "sw", icon: Hg }), n;
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear(), this.ungroupedItems.map((e) => {
            this.viewFocusables.add(e);
          }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
        }
      }
      var Ug = b(1046), K1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Ug.Z, K1), Ug.Z.locals;
      class Z1 extends _e {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.items = this.createCollection(), this.focusTracker = new Jt(), this.keystrokes = new mn(), this._focusCycler = new Si({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowup", focusNext: "arrowdown" } }), this.set("ariaLabel", void 0), this.set("role", void 0), this.setTemplate({ tag: "ul", attributes: { class: ["ck", "ck-reset", "ck-list"], role: t.to("role"), "aria-label": t.to("ariaLabel") }, children: this.items });
        }
        render() {
          super.render();
          for (const e of this.items)
            this.focusTracker.add(e.element);
          this.items.on("add", (e, t) => {
            this.focusTracker.add(t.element);
          }), this.items.on("remove", (e, t) => {
            this.focusTracker.remove(t.element);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
      }
      class qg extends _e {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("isVisible", !0), this.children = this.createCollection(), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__item", t.if("isVisible", "ck-hidden", (n) => !n)], role: "presentation" }, children: this.children });
        }
        focus() {
          this.children.first.focus();
        }
      }
      class J1 extends _e {
        constructor(e) {
          super(e), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } });
        }
      }
      var Wg = b(7686), Y1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Wg.Z, Y1), Wg.Z.locals;
      class al extends _e {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isToggleable", !1), this.set("isVisible", !0), this.set("keystroke", void 0), this.set("withKeystroke", !1), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.children = this.createCollection(), this.actionView = this._createActionView(), this.arrowView = this._createArrowView(), this.keystrokes = new mn(), this.focusTracker = new Jt(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-splitbutton", t.to("class"), t.if("isVisible", "ck-hidden", (n) => !n), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")] }, children: this.children });
        }
        render() {
          super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (e, t) => {
            this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), t());
          }), this.keystrokes.set("arrowleft", (e, t) => {
            this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), t());
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this.actionView.focus();
        }
        _createActionView() {
          const e = new je();
          return e.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), e.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }), e.delegate("execute").to(this), e;
        }
        _createArrowView() {
          const e = new je(), t = e.bindTemplate;
          return e.icon = Iu, e.extendTemplate({ attributes: { class: ["ck-splitbutton__arrow"], "data-cke-tooltip-disabled": t.to("isOn"), "aria-haspopup": !0, "aria-expanded": t.to("isOn", (n) => String(n)) } }), e.bind("isEnabled").to(this), e.bind("label").to(this), e.bind("tooltip").to(this), e.delegate("execute").to(this, "open"), e;
        }
      }
      var Gg = b(7339), Q1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Gg.Z, Q1), Gg.Z.locals;
      var Kg = b(3949), X1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Kg.Z, X1), Kg.Z.locals;
      function wn(o, e = Pu) {
        const t = new e(o), n = new P_(o), i = new va(o, t, n);
        return t.bind("isEnabled").to(i), t instanceof al ? t.arrowView.bind("isOn").to(i, "isOpen") : t.bind("isOn").to(i, "isOpen"), function(r) {
          (function(s) {
            s.on("render", () => {
              v({ emitter: s, activator: () => s.isOpen, callback: () => {
                s.isOpen = !1;
              }, contextElements: [s.element] });
            });
          })(r), function(s) {
            s.on("execute", (a) => {
              a.source instanceof Pr || (s.isOpen = !1);
            });
          }(r), function(s) {
            s.focusTracker.on("change:isFocused", (a, l, d) => {
              s.isOpen && !d && (s.isOpen = !1);
            });
          }(r), function(s) {
            s.keystrokes.set("arrowdown", (a, l) => {
              s.isOpen && (s.panelView.focus(), l());
            }), s.keystrokes.set("arrowup", (a, l) => {
              s.isOpen && (s.panelView.focusLast(), l());
            });
          }(r), function(s) {
            s.on("change:isOpen", (a, l, d) => {
              if (d)
                return;
              const h = s.panelView.element;
              h && h.contains(ke.document.activeElement) && s.buttonView.focus();
            });
          }(r), function(s) {
            s.on("change:isOpen", (a, l, d) => {
              d && s.panelView.focus();
            }, { priority: "low" });
          }(r);
        }(i), i;
      }
      function Xr(o, e, t = {}) {
        o.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }), o.isOpen ? Zg(o, e, t) : o.once("change:isOpen", () => Zg(o, e, t), { priority: "highest" }), t.enableActiveItemFocusOnDropdownOpen && Yg(o, () => o.toolbarView.items.find((n) => n.isOn));
      }
      function Zg(o, e, t) {
        const n = o.locale, i = n.t, r = o.toolbarView = new sl(n), s = typeof e == "function" ? e() : e;
        r.ariaLabel = t.ariaLabel || i("Dropdown toolbar"), t.maxWidth && (r.maxWidth = t.maxWidth), t.class && (r.class = t.class), t.isCompact && (r.isCompact = t.isCompact), t.isVertical && (r.isVertical = !0), s instanceof Yn ? r.items.bindTo(s).using((a) => a) : r.items.addMany(s), o.panelView.children.add(r), r.items.delegate("execute").to(o);
      }
      function ll(o, e, t = {}) {
        o.isOpen ? Jg(o, e, t) : o.once("change:isOpen", () => Jg(o, e, t), { priority: "highest" }), Yg(o, () => o.listView.items.find((n) => n instanceof qg && n.children.first.isOn));
      }
      function Jg(o, e, t) {
        const n = o.locale, i = o.listView = new Z1(n), r = typeof e == "function" ? e() : e;
        i.ariaLabel = t.ariaLabel, i.role = t.role, i.items.bindTo(r).using((s) => {
          if (s.type === "separator")
            return new J1(n);
          if (s.type === "button" || s.type === "switchbutton") {
            const a = new qg(n);
            let l;
            return l = s.type === "button" ? new je(n) : new Pr(n), l.bind(...Object.keys(s.model)).to(s.model), l.delegate("execute").to(a), a.children.add(l), a;
          }
          return null;
        }), o.panelView.children.add(i), i.items.delegate("execute").to(o);
      }
      function Yg(o, e) {
        o.on("change:isOpen", () => {
          if (!o.isOpen)
            return;
          const t = e();
          t && (typeof t.focus == "function" ? t.focus() : oe("ui-dropdown-focus-child-on-open-child-missing-focus", { view: t }));
        }, { priority: se.low - 10 });
      }
      function Qg(o, e, t) {
        const n = new I_(o.locale);
        return n.set({ id: e, ariaDescribedById: t }), n.bind("isReadOnly").to(o, "isEnabled", (i) => !i), n.bind("hasError").to(o, "errorText", (i) => !!i), n.on("input", () => {
          o.errorText = null;
        }), o.bind("isEmpty", "isFocused", "placeholder").to(n), n;
      }
      const Li = (o, e = 0, t = 1) => o > t ? t : o < e ? e : o, bt = (o, e = 0, t = Math.pow(10, e)) => Math.round(t * o) / t, cl = (o) => (o[0] === "#" && (o = o.substring(1)), o.length < 6 ? { r: parseInt(o[0] + o[0], 16), g: parseInt(o[1] + o[1], 16), b: parseInt(o[2] + o[2], 16), a: o.length === 4 ? bt(parseInt(o[3] + o[3], 16) / 255, 2) : 1 } : { r: parseInt(o.substring(0, 2), 16), g: parseInt(o.substring(2, 4), 16), b: parseInt(o.substring(4, 6), 16), a: o.length === 8 ? bt(parseInt(o.substring(6, 8), 16) / 255, 2) : 1 }), ey = ({ h: o, s: e, v: t, a: n }) => {
        const i = (200 - e) * t / 100;
        return { h: bt(o), s: bt(i > 0 && i < 200 ? e * t / 100 / (i <= 100 ? i : 200 - i) * 100 : 0), l: bt(i / 2), a: bt(n, 2) };
      }, dl = (o) => {
        const { h: e, s: t, l: n } = ey(o);
        return `hsl(${e}, ${t}%, ${n}%)`;
      }, ty = ({ h: o, s: e, v: t, a: n }) => {
        o = o / 360 * 6, e /= 100, t /= 100;
        const i = Math.floor(o), r = t * (1 - e), s = t * (1 - (o - i) * e), a = t * (1 - (1 - o + i) * e), l = i % 6;
        return { r: bt(255 * [t, s, r, r, a, t][l]), g: bt(255 * [a, t, t, s, r, r][l]), b: bt(255 * [r, r, a, t, t, s][l]), a: bt(n, 2) };
      }, es = (o) => {
        const e = o.toString(16);
        return e.length < 2 ? "0" + e : e;
      }, ny = ({ r: o, g: e, b: t, a: n }) => {
        const i = n < 1 ? es(bt(255 * n)) : "";
        return "#" + es(o) + es(e) + es(t) + i;
      }, oy = ({ r: o, g: e, b: t, a: n }) => {
        const i = Math.max(o, e, t), r = i - Math.min(o, e, t), s = r ? i === o ? (e - t) / r : i === e ? 2 + (t - o) / r : 4 + (o - e) / r : 0;
        return { h: bt(60 * (s < 0 ? s + 6 : s)), s: bt(i ? r / i * 100 : 0), v: bt(i / 255 * 100), a: n };
      }, Xg = (o, e) => {
        if (o === e)
          return !0;
        for (const t in o)
          if (o[t] !== e[t])
            return !1;
        return !0;
      }, em = {}, tm = (o) => {
        let e = em[o];
        return e || (e = document.createElement("template"), e.innerHTML = o, em[o] = e), e;
      }, ul = (o, e, t) => {
        o.dispatchEvent(new CustomEvent(e, { bubbles: !0, detail: t }));
      };
      let Uo = !1;
      const hl = (o) => "touches" in o, nm = (o, e) => {
        const t = hl(e) ? e.touches[0] : e, n = o.el.getBoundingClientRect();
        ul(o.el, "move", o.getMove({ x: Li((t.pageX - (n.left + window.pageXOffset)) / n.width), y: Li((t.pageY - (n.top + window.pageYOffset)) / n.height) }));
      };
      class om {
        constructor(e, t, n, i) {
          const r = tm(`<div role="slider" tabindex="0" part="${t}" ${n}><div part="${t}-pointer"></div></div>`);
          e.appendChild(r.content.cloneNode(!0));
          const s = e.querySelector(`[part=${t}]`);
          s.addEventListener("mousedown", this), s.addEventListener("touchstart", this), s.addEventListener("keydown", this), this.el = s, this.xy = i, this.nodes = [s.firstChild, s];
        }
        set dragging(e) {
          const t = e ? document.addEventListener : document.removeEventListener;
          t(Uo ? "touchmove" : "mousemove", this), t(Uo ? "touchend" : "mouseup", this);
        }
        handleEvent(e) {
          switch (e.type) {
            case "mousedown":
            case "touchstart":
              if (e.preventDefault(), !((t) => !(Uo && !hl(t) || (Uo || (Uo = hl(t)), 0)))(e) || !Uo && e.button != 0)
                return;
              this.el.focus(), nm(this, e), this.dragging = !0;
              break;
            case "mousemove":
            case "touchmove":
              e.preventDefault(), nm(this, e);
              break;
            case "mouseup":
            case "touchend":
              this.dragging = !1;
              break;
            case "keydown":
              ((t, n) => {
                const i = n.keyCode;
                i > 40 || t.xy && i < 37 || i < 33 || (n.preventDefault(), ul(t.el, "move", t.getMove({ x: i === 39 ? 0.01 : i === 37 ? -0.01 : i === 34 ? 0.05 : i === 33 ? -0.05 : i === 35 ? 1 : i === 36 ? -1 : 0, y: i === 40 ? 0.01 : i === 38 ? -0.01 : 0 }, !0)));
              })(this, e);
          }
        }
        style(e) {
          e.forEach((t, n) => {
            for (const i in t)
              this.nodes[n].style.setProperty(i, t[i]);
          });
        }
      }
      class iy extends om {
        constructor(e) {
          super(e, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', !1);
        }
        update({ h: e }) {
          this.h = e, this.style([{ left: e / 360 * 100 + "%", color: dl({ h: e, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuenow", `${bt(e)}`);
        }
        getMove(e, t) {
          return { h: t ? Li(this.h + 360 * e.x, 0, 360) : 360 * e.x };
        }
      }
      class ry extends om {
        constructor(e) {
          super(e, "saturation", 'aria-label="Color"', !0);
        }
        update(e) {
          this.hsva = e, this.style([{ top: 100 - e.v + "%", left: `${e.s}%`, color: dl(e) }, { "background-color": dl({ h: e.h, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuetext", `Saturation ${bt(e.s)}%, Brightness ${bt(e.v)}%`);
        }
        getMove(e, t) {
          return { s: t ? Li(this.hsva.s + 100 * e.x, 0, 100) : 100 * e.x, v: t ? Li(this.hsva.v - 100 * e.y, 0, 100) : Math.round(100 - 100 * e.y) };
        }
      }
      const ts = Symbol("same"), gl = Symbol("color"), im = Symbol("hsva"), ml = Symbol("update"), rm = Symbol("parts"), sm = Symbol("css"), am = Symbol("sliders");
      class sy extends HTMLElement {
        static get observedAttributes() {
          return ["color"];
        }
        get [sm]() {
          return [':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}', "[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}", "[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}"];
        }
        get [am]() {
          return [ry, iy];
        }
        get color() {
          return this[gl];
        }
        set color(e) {
          if (!this[ts](e)) {
            const t = this.colorModel.toHsva(e);
            this[ml](t), this[gl] = e;
          }
        }
        constructor() {
          super();
          const e = tm(`<style>${this[sm].join("")}</style>`), t = this.attachShadow({ mode: "open" });
          t.appendChild(e.content.cloneNode(!0)), t.addEventListener("move", this), this[rm] = this[am].map((n) => new n(t));
        }
        connectedCallback() {
          if (this.hasOwnProperty("color")) {
            const e = this.color;
            delete this.color, this.color = e;
          } else
            this.color || (this.color = this.colorModel.defaultColor);
        }
        attributeChangedCallback(e, t, n) {
          const i = this.colorModel.fromAttr(n);
          this[ts](i) || (this.color = i);
        }
        handleEvent(e) {
          const t = this[im], n = { ...t, ...e.detail };
          let i;
          this[ml](n), Xg(n, t) || this[ts](i = this.colorModel.fromHsva(n)) || (this[gl] = i, ul(this, "color-changed", { value: i }));
        }
        [ts](e) {
          return this.color && this.colorModel.equal(e, this.color);
        }
        [ml](e) {
          this[im] = e, this[rm].forEach((t) => t.update(e));
        }
      }
      const ay = { defaultColor: "#000", toHsva: (o) => oy(cl(o)), fromHsva: ({ h: o, s: e, v: t }) => ny(ty({ h: o, s: e, v: t, a: 1 })), equal: (o, e) => o.toLowerCase() === e.toLowerCase() || Xg(cl(o), cl(e)), fromAttr: (o) => o };
      class ly extends sy {
        get colorModel() {
          return ay;
        }
      }
      customElements.define("hex-color-picker", class extends ly {
      });
      var lm = b(3398), cy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(lm.Z, cy), lm.Z.locals;
      class dy {
        constructor(e) {
          this._components = /* @__PURE__ */ new Map(), this.editor = e;
        }
        *names() {
          for (const e of this._components.values())
            yield e.originalName;
        }
        add(e, t) {
          this._components.set(pl(e), { callback: t, originalName: e });
        }
        create(e) {
          if (!this.has(e))
            throw new O("componentfactory-item-missing", this, { name: e });
          return this._components.get(pl(e)).callback(this.editor.locale);
        }
        has(e) {
          return this._components.has(pl(e));
        }
      }
      function pl(o) {
        return String(o).toLowerCase();
      }
      var cm = b(8793), uy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(cm.Z, uy), cm.Z.locals;
      var hy = Object.defineProperty, dm = Object.getOwnPropertySymbols, gy = Object.prototype.hasOwnProperty, my = Object.prototype.propertyIsEnumerable, um = (o, e, t) => e in o ? hy(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, xe = (o, e) => {
        for (var t in e || (e = {}))
          gy.call(e, t) && um(o, t, e[t]);
        if (dm)
          for (var t of dm(e))
            my.call(e, t) && um(o, t, e[t]);
        return o;
      };
      const hm = da("px"), gm = ke.document.body, fl = class extends _e {
        constructor(o) {
          super(o);
          const e = this.bindTemplate;
          this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", !1), this.set("withArrow", !0), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-panel", e.to("position", (t) => `ck-balloon-panel_${t}`), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")], style: { top: e.to("top", hm), left: e.to("left", hm) } }, children: this.content });
        }
        show() {
          this.isVisible = !0;
        }
        hide() {
          this.isVisible = !1;
        }
        attachTo(o) {
          this.show();
          const e = fl.defaultPositions, t = Object.assign({}, { element: this.element, positions: [e.southArrowNorth, e.southArrowNorthMiddleWest, e.southArrowNorthMiddleEast, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthMiddleWest, e.northArrowSouthMiddleEast, e.northArrowSouthWest, e.northArrowSouthEast, e.viewportStickyNorth], limiter: gm, fitInViewport: !0 }, o), n = fl._getOptimalPosition(t), i = parseInt(n.left), r = parseInt(n.top), s = n.name, a = n.config || {}, { withArrow: l = !0 } = a;
          this.top = r, this.left = i, this.position = s, this.withArrow = l;
        }
        pin(o) {
          this.unpin(), this._pinWhenIsVisibleCallback = () => {
            this.isVisible ? this._startPinning(o) : this._stopPinning();
          }, this._startPinning(o), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
        }
        unpin() {
          this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
        }
        _startPinning(o) {
          this.attachTo(o);
          const e = bl(o.target), t = o.limiter ? bl(o.limiter) : gm;
          this.listenTo(ke.document, "scroll", (n, i) => {
            const r = i.target, s = e && r.contains(e), a = t && r.contains(t);
            !s && !a && e && t || this.attachTo(o);
          }, { useCapture: !0 }), this.listenTo(ke.window, "resize", () => {
            this.attachTo(o);
          });
        }
        _stopPinning() {
          this.stopListening(ke.document, "scroll"), this.stopListening(ke.window, "resize");
        }
      };
      let Tt = fl;
      function bl(o) {
        return Oo(o) ? o : Er(o) ? o.commonAncestorContainer : typeof o == "function" ? bl(o()) : null;
      }
      function mm(o = {}) {
        const { sideOffset: e = Tt.arrowSideOffset, heightOffset: t = Tt.arrowHeightOffset, stickyVerticalOffset: n = Tt.stickyVerticalOffset, config: i } = o;
        return { northWestArrowSouthWest: (a, l) => xe({ top: r(a, l), left: a.left - e, name: "arrow_sw" }, i && { config: i }), northWestArrowSouthMiddleWest: (a, l) => xe({ top: r(a, l), left: a.left - 0.25 * l.width - e, name: "arrow_smw" }, i && { config: i }), northWestArrowSouth: (a, l) => xe({ top: r(a, l), left: a.left - l.width / 2, name: "arrow_s" }, i && { config: i }), northWestArrowSouthMiddleEast: (a, l) => xe({ top: r(a, l), left: a.left - 0.75 * l.width + e, name: "arrow_sme" }, i && { config: i }), northWestArrowSouthEast: (a, l) => xe({ top: r(a, l), left: a.left - l.width + e, name: "arrow_se" }, i && { config: i }), northArrowSouthWest: (a, l) => xe({ top: r(a, l), left: a.left + a.width / 2 - e, name: "arrow_sw" }, i && { config: i }), northArrowSouthMiddleWest: (a, l) => xe({ top: r(a, l), left: a.left + a.width / 2 - 0.25 * l.width - e, name: "arrow_smw" }, i && { config: i }), northArrowSouth: (a, l) => xe({ top: r(a, l), left: a.left + a.width / 2 - l.width / 2, name: "arrow_s" }, i && { config: i }), northArrowSouthMiddleEast: (a, l) => xe({ top: r(a, l), left: a.left + a.width / 2 - 0.75 * l.width + e, name: "arrow_sme" }, i && { config: i }), northArrowSouthEast: (a, l) => xe({ top: r(a, l), left: a.left + a.width / 2 - l.width + e, name: "arrow_se" }, i && { config: i }), northEastArrowSouthWest: (a, l) => xe({ top: r(a, l), left: a.right - e, name: "arrow_sw" }, i && { config: i }), northEastArrowSouthMiddleWest: (a, l) => xe({ top: r(a, l), left: a.right - 0.25 * l.width - e, name: "arrow_smw" }, i && { config: i }), northEastArrowSouth: (a, l) => xe({ top: r(a, l), left: a.right - l.width / 2, name: "arrow_s" }, i && { config: i }), northEastArrowSouthMiddleEast: (a, l) => xe({ top: r(a, l), left: a.right - 0.75 * l.width + e, name: "arrow_sme" }, i && { config: i }), northEastArrowSouthEast: (a, l) => xe({ top: r(a, l), left: a.right - l.width + e, name: "arrow_se" }, i && { config: i }), southWestArrowNorthWest: (a) => xe({ top: s(a), left: a.left - e, name: "arrow_nw" }, i && { config: i }), southWestArrowNorthMiddleWest: (a, l) => xe({ top: s(a), left: a.left - 0.25 * l.width - e, name: "arrow_nmw" }, i && { config: i }), southWestArrowNorth: (a, l) => xe({ top: s(a), left: a.left - l.width / 2, name: "arrow_n" }, i && { config: i }), southWestArrowNorthMiddleEast: (a, l) => xe({ top: s(a), left: a.left - 0.75 * l.width + e, name: "arrow_nme" }, i && { config: i }), southWestArrowNorthEast: (a, l) => xe({ top: s(a), left: a.left - l.width + e, name: "arrow_ne" }, i && { config: i }), southArrowNorthWest: (a) => xe({ top: s(a), left: a.left + a.width / 2 - e, name: "arrow_nw" }, i && { config: i }), southArrowNorthMiddleWest: (a, l) => xe({ top: s(a), left: a.left + a.width / 2 - 0.25 * l.width - e, name: "arrow_nmw" }, i && { config: i }), southArrowNorth: (a, l) => xe({ top: s(a), left: a.left + a.width / 2 - l.width / 2, name: "arrow_n" }, i && { config: i }), southArrowNorthMiddleEast: (a, l) => xe({ top: s(a), left: a.left + a.width / 2 - 0.75 * l.width + e, name: "arrow_nme" }, i && { config: i }), southArrowNorthEast: (a, l) => xe({ top: s(a), left: a.left + a.width / 2 - l.width + e, name: "arrow_ne" }, i && { config: i }), southEastArrowNorthWest: (a) => xe({ top: s(a), left: a.right - e, name: "arrow_nw" }, i && { config: i }), southEastArrowNorthMiddleWest: (a, l) => xe({ top: s(a), left: a.right - 0.25 * l.width - e, name: "arrow_nmw" }, i && { config: i }), southEastArrowNorth: (a, l) => xe({ top: s(a), left: a.right - l.width / 2, name: "arrow_n" }, i && { config: i }), southEastArrowNorthMiddleEast: (a, l) => xe({ top: s(a), left: a.right - 0.75 * l.width + e, name: "arrow_nme" }, i && { config: i }), southEastArrowNorthEast: (a, l) => xe({ top: s(a), left: a.right - l.width + e, name: "arrow_ne" }, i && { config: i }), westArrowEast: (a, l) => xe({ top: a.top + a.height / 2 - l.height / 2, left: a.left - l.width - t, name: "arrow_e" }, i && { config: i }), eastArrowWest: (a, l) => xe({ top: a.top + a.height / 2 - l.height / 2, left: a.right + t, name: "arrow_w" }, i && { config: i }), viewportStickyNorth: (a, l, d) => a.getIntersection(d) ? { top: d.top + n, left: a.left + a.width / 2 - l.width / 2, name: "arrowless", config: xe({ withArrow: !1 }, i) } : null };
        function r(a, l) {
          return a.top - l.height - t;
        }
        function s(a) {
          return a.bottom + t;
        }
      }
      Tt.arrowSideOffset = 25, Tt.arrowHeightOffset = 10, Tt.stickyVerticalOffset = 20, Tt._getOptimalPosition = Qd, Tt.defaultPositions = mm();
      var pm = b(3332), py = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(pm.Z, py), pm.Z.locals;
      const fm = "ck-tooltip", It = class extends In() {
        constructor(o) {
          if (super(), this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver = null, It._editors.add(o), It._instance)
            return It._instance;
          It._instance = this, this.tooltipTextView = new _e(o.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-tooltip__text"] }, children: [{ text: this.tooltipTextView.bindTemplate.to("text") }] }), this.balloonPanelView = new Tt(o.locale), this.balloonPanelView.class = fm, this.balloonPanelView.content.add(this.tooltipTextView), this._pinTooltipDebounced = Pi(this._pinTooltip, 600), this.listenTo(ke.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(ke.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(ke.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(ke.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(ke.document, "scroll", this._onScroll.bind(this), { useCapture: !0 }), this._watchdogExcluded = !0;
        }
        destroy(o) {
          const e = o.ui.view && o.ui.view.body;
          It._editors.delete(o), this.stopListening(o.ui), e && e.has(this.balloonPanelView) && e.remove(this.balloonPanelView), It._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), It._instance = null);
        }
        static getPositioningFunctions(o) {
          const e = It.defaultBalloonPositions;
          return { s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest], n: [e.northArrowSouth], e: [e.eastArrowWest], w: [e.westArrowEast], sw: [e.southArrowNorthEast], se: [e.southArrowNorthWest] }[o];
        }
        _onEnterOrFocus(o, { target: e }) {
          const t = kl(e);
          var n;
          t && t !== this._currentElementWithTooltip && (this._unpinTooltip(), this._pinTooltipDebounced(t, { text: (n = t).dataset.ckeTooltipText, position: n.dataset.ckeTooltipPosition || "s", cssClass: n.dataset.ckeTooltipClass || "" }));
        }
        _onLeaveOrBlur(o, { target: e, relatedTarget: t }) {
          if (o.name === "mouseleave") {
            if (!Oo(e) || this._currentElementWithTooltip && e !== this._currentElementWithTooltip)
              return;
            const n = kl(e), i = kl(t);
            n && n !== i && this._unpinTooltip();
          } else {
            if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip)
              return;
            this._unpinTooltip();
          }
        }
        _onScroll(o, { target: e }) {
          this._currentElementWithTooltip && (e.contains(this.balloonPanelView.element) && e.contains(this._currentElementWithTooltip) || this._unpinTooltip());
        }
        _pinTooltip(o, { text: e, position: t, cssClass: n }) {
          const i = it(It._editors.values()).ui.view.body;
          i.has(this.balloonPanelView) || i.add(this.balloonPanelView), this.tooltipTextView.text = e, this.balloonPanelView.pin({ target: o, positions: It.getPositioningFunctions(t) }), this._resizeObserver = new Sr(o, () => {
            Jn(o) || this._unpinTooltip();
          }), this.balloonPanelView.class = [fm, n].filter((r) => r).join(" ");
          for (const r of It._editors)
            this.listenTo(r.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
          this._currentElementWithTooltip = o, this._currentTooltipPosition = t;
        }
        _unpinTooltip() {
          this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
          for (const o of It._editors)
            this.stopListening(o.ui, "update");
          this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver && this._resizeObserver.destroy();
        }
        _updateTooltipPosition() {
          Jn(this._currentElementWithTooltip) ? this.balloonPanelView.pin({ target: this._currentElementWithTooltip, positions: It.getPositioningFunctions(this._currentTooltipPosition) }) : this._unpinTooltip();
        }
      };
      let ns = It;
      function kl(o) {
        return Oo(o) ? o.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null;
      }
      ns.defaultBalloonPositions = mm({ heightOffset: 5, sideOffset: 13 }), ns._editors = /* @__PURE__ */ new Set(), ns._instance = null;
      const wl = function(o, e, t) {
        var n = !0, i = !0;
        if (typeof o != "function")
          throw new TypeError("Expected a function");
        return K(t) && (n = "leading" in t ? !!t.leading : n, i = "trailing" in t ? !!t.trailing : i), Pi(o, e, { leading: n, maxWait: e, trailing: i });
      };
      var fy = Object.defineProperty, bm = Object.getOwnPropertySymbols, by = Object.prototype.hasOwnProperty, ky = Object.prototype.propertyIsEnumerable, km = (o, e, t) => e in o ? fy(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, wy = (o, e) => {
        for (var t in e || (e = {}))
          by.call(e, t) && km(o, t, e[t]);
        if (bm)
          for (var t of bm(e))
            ky.call(e, t) && km(o, t, e[t]);
        return o;
      };
      const vy = 50, _y = 350, Ay = "Powered by", os = { top: -99999, left: -99999, name: "invalid", config: { withArrow: !1 } };
      class Cy extends In() {
        constructor(e) {
          super(), this.editor = e, this._balloonView = null, this._lastFocusedEditableElement = null, this._showBalloonThrottled = wl(this._showBalloon.bind(this), 50, { leading: !0 }), e.on("ready", this._handleEditorReady.bind(this));
        }
        destroy() {
          const e = this._balloonView;
          e && (e.unpin(), this._balloonView = null), this._showBalloonThrottled.cancel(), this.stopListening();
        }
        _handleEditorReady() {
          const e = this.editor;
          (function(t) {
            function n(_) {
              return _.match(/^[a-zA-Z0-9+/=$]+$/g) && _.length >= 40 && _.length <= 255 ? "VALID" : "INVALID";
            }
            let i = "", r = "";
            if (!t)
              return "INVALID";
            try {
              i = atob(t);
            } catch {
              return "INVALID";
            }
            const s = i.split("-"), a = s[0], l = s[1];
            if (!l)
              return n(t);
            try {
              atob(l);
            } catch {
              try {
                if (atob(a), !atob(a).length)
                  return n(t);
              } catch {
                return n(t);
              }
            }
            if (a.length < 40 || a.length > 255)
              return "INVALID";
            try {
              atob(a);
            } catch {
              return "INVALID";
            }
            try {
              r = atob(l);
            } catch {
              return "INVALID";
            }
            if (r.length !== 8)
              return "INVALID";
            const d = Number(r.substring(0, 4)), h = Number(r.substring(4, 6)) - 1, m = Number(r.substring(6, 8)), f = new Date(d, h, m);
            return f < nn || isNaN(Number(f)) ? "INVALID" : "VALID";
          })(e.config.get("licenseKey")) !== "VALID" && e.ui.view && (e.ui.focusTracker.on("change:isFocused", (t, n, i) => {
            this._updateLastFocusedEditableElement(), i ? this._showBalloon() : this._hideBalloon();
          }), e.ui.focusTracker.on("change:focusedElement", (t, n, i) => {
            this._updateLastFocusedEditableElement(), i && this._showBalloon();
          }), e.ui.on("update", () => {
            this._showBalloonThrottled();
          }));
        }
        _createBalloonView() {
          const e = this.editor, t = this._balloonView = new Tt(), n = vm(e), i = new yy(e.locale, n.label);
          t.content.add(i), t.set({ class: "ck-powered-by-balloon" }), e.ui.view.body.add(t), e.ui.focusTracker.add(t.element), this._balloonView = t;
        }
        _showBalloon() {
          if (!this._lastFocusedEditableElement)
            return;
          const e = function(t, n) {
            const i = vm(t), r = i.side === "right" ? function(s, a) {
              return wm(s, a, (l, d) => l.left + l.width - d.width - a.horizontalOffset);
            }(n, i) : function(s, a) {
              return wm(s, a, (l) => l.left + a.horizontalOffset);
            }(n, i);
            return { target: n, positions: [r] };
          }(this.editor, this._lastFocusedEditableElement);
          e && (this._balloonView || this._createBalloonView(), this._balloonView.pin(e));
        }
        _hideBalloon() {
          this._balloonView && this._balloonView.unpin();
        }
        _updateLastFocusedEditableElement() {
          const e = this.editor, t = e.ui.focusTracker.isFocused, n = e.ui.focusTracker.focusedElement;
          if (!t || !n)
            return void (this._lastFocusedEditableElement = null);
          const i = Array.from(e.ui.getEditableElementsNames()).map((r) => e.ui.getEditableElement(r));
          i.includes(n) ? this._lastFocusedEditableElement = n : this._lastFocusedEditableElement = i[0];
        }
      }
      class yy extends _e {
        constructor(e, t) {
          super(e);
          const n = new xi(), i = this.bindTemplate;
          n.set({ content: `<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><g clip-path="url(#a)"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h52.4v10H0z"/></clipPath></defs></svg>
`, isColorInherited: !1 }), n.extendTemplate({ attributes: { style: { width: "53px", height: "10px" } } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-powered-by"], "aria-hidden": !0 }, children: [{ tag: "a", attributes: { href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo", target: "_blank", tabindex: "-1" }, children: [...t ? [{ tag: "span", attributes: { class: ["ck", "ck-powered-by__label"] }, children: [t] }] : [], n], on: { dragstart: i.to((r) => r.preventDefault()) } }] });
        }
      }
      function wm(o, e, t) {
        return (n, i) => {
          const r = n.getVisible();
          if (!r || n.width < _y || n.height < vy)
            return os;
          let s;
          s = e.position === "inside" ? n.bottom - i.height : n.bottom - i.height / 2, s -= e.verticalOffset;
          const a = t(n, i);
          if (e.position === "inside") {
            const l = i.clone().moveTo(a, s);
            if (l.getIntersectionArea(r) < l.getArea())
              return os;
          } else {
            const l = function(d) {
              let h = d.parentElement;
              if (!h)
                return null;
              for (; h.tagName != "BODY"; ) {
                const m = h.style.overflowY || ke.window.getComputedStyle(h).overflowY;
                if (m === "auto" || m === "scroll")
                  break;
                if (h = h.parentElement, !h)
                  return null;
              }
              return h;
            }(o);
            if (l) {
              const d = new Ze(l);
              if (r.bottom + i.height / 2 > d.bottom)
                return os;
            }
          }
          return { top: s, left: a, name: `position_${e.position}-side_${e.side}`, config: { withArrow: !1 } };
        };
      }
      function vm(o) {
        const e = o.config.get("ui.poweredBy"), t = e && e.position || "border";
        return wy({ position: t, label: Ay, verticalOffset: t === "inside" ? 5 : 0, horizontalOffset: 5, side: o.locale.contentLanguageDirection === "ltr" ? "right" : "left" }, e);
      }
      class Ey extends re() {
        constructor(e) {
          super(), this.isReady = !1, this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [], this.editor = e, this.componentFactory = new dy(e), this.focusTracker = new Jt(), this.tooltipManager = new ns(e), this.poweredBy = new Cy(e), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.once("ready", () => {
            this.isReady = !0;
          }), this.listenTo(e.editing.view.document, "layoutChanged", () => this.update()), this._initFocusTracking();
        }
        get element() {
          return null;
        }
        update() {
          this.fire("update");
        }
        destroy() {
          this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor), this.poweredBy.destroy();
          for (const e of this._editableElementsMap.values())
            e.ckeditorInstance = null, this.editor.keystrokes.stopListening(e);
          this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
        }
        setEditableElement(e, t) {
          this._editableElementsMap.set(e, t), t.ckeditorInstance || (t.ckeditorInstance = this.editor), this.focusTracker.add(t);
          const n = () => {
            this.editor.editing.view.getDomRoot(e) || this.editor.keystrokes.listenTo(t);
          };
          this.isReady ? n() : this.once("ready", n);
        }
        removeEditableElement(e) {
          const t = this._editableElementsMap.get(e);
          t && (this._editableElementsMap.delete(e), this.editor.keystrokes.stopListening(t), this.focusTracker.remove(t), t.ckeditorInstance = null);
        }
        getEditableElement(e = "main") {
          return this._editableElementsMap.get(e);
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys();
        }
        addToolbar(e, t = {}) {
          e.isRendered ? (this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element)) : e.once("render", () => {
            this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element);
          }), this._focusableToolbarDefinitions.push({ toolbarView: e, options: t });
        }
        get _editableElements() {
          return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
        }
        _readViewportOffsetFromConfig() {
          const e = this.editor, t = e.config.get("ui.viewportOffset");
          if (t)
            return t;
          const n = e.config.get("toolbar.viewportTopOffset");
          return n ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), { top: n }) : { top: 0 };
        }
        _initFocusTracking() {
          const e = this.editor, t = e.editing.view;
          let n, i;
          e.keystrokes.set("Alt+F10", (r, s) => {
            const a = this.focusTracker.focusedElement;
            Array.from(this._editableElementsMap.values()).includes(a) && !Array.from(t.domRoots.values()).includes(a) && (n = a);
            const l = this._getCurrentFocusedToolbarDefinition();
            l && i || (i = this._getFocusableCandidateToolbarDefinitions());
            for (let d = 0; d < i.length; d++) {
              const h = i.shift();
              if (i.push(h), h !== l && this._focusFocusableCandidateToolbar(h)) {
                l && l.options.afterBlur && l.options.afterBlur();
                break;
              }
            }
            s();
          }), e.keystrokes.set("Esc", (r, s) => {
            const a = this._getCurrentFocusedToolbarDefinition();
            a && (n ? (n.focus(), n = null) : e.editing.view.focus(), a.options.afterBlur && a.options.afterBlur(), s());
          });
        }
        _getFocusableCandidateToolbarDefinitions() {
          const e = [];
          for (const t of this._focusableToolbarDefinitions) {
            const { toolbarView: n, options: i } = t;
            (Jn(n.element) || i.beforeFocus) && e.push(t);
          }
          return e.sort((t, n) => _m(t) - _m(n)), e;
        }
        _getCurrentFocusedToolbarDefinition() {
          for (const e of this._focusableToolbarDefinitions)
            if (e.toolbarView.element && e.toolbarView.element.contains(this.focusTracker.focusedElement))
              return e;
          return null;
        }
        _focusFocusableCandidateToolbar(e) {
          const { toolbarView: t, options: { beforeFocus: n } } = e;
          return n && n(), !!Jn(t.element) && (t.focus(), !0);
        }
      }
      function _m(o) {
        const { toolbarView: e, options: t } = o;
        let n = 10;
        return Jn(e.element) && n--, t.isContextual && n--, n;
      }
      var Am = b(9688), xy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Am.Z, xy), Am.Z.locals;
      class Sy extends _e {
        constructor(e) {
          super(e), this.body = new A_(e);
        }
        render() {
          super.render(), this.body.attachToDom();
        }
        destroy() {
          return this.body.detachFromDom(), super.destroy();
        }
      }
      class Dy extends Sy {
        constructor(e) {
          super(e), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"], role: "application", dir: e.uiLanguageDirection, lang: e.uiLanguage, "aria-labelledby": this._voiceLabelView.id }, children: [this._voiceLabelView, { tag: "div", attributes: { class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation" }, children: this.top }, { tag: "div", attributes: { class: ["ck", "ck-editor__main"], role: "presentation" }, children: this.main }] });
        }
        _createVoiceLabel() {
          const e = this.t, t = new xu();
          return t.text = e("Rich Text Editor"), t.extendTemplate({ attributes: { class: "ck-voice-label" } }), t;
        }
      }
      class By extends _e {
        constructor(e, t, n) {
          super(e), this.name = null, this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"], lang: e.contentLanguage, dir: e.contentLanguageDirection } }), this.set("isFocused", !1), this._editableElement = n, this._hasExternalElement = !!this._editableElement, this._editingView = t;
        }
        render() {
          super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
        }
        destroy() {
          this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
        }
        get hasExternalElement() {
          return this._hasExternalElement;
        }
        _updateIsFocusedClasses() {
          const e = this._editingView;
          function t(n) {
            e.change((i) => {
              const r = e.document.getRoot(n.name);
              i.addClass(n.isFocused ? "ck-focused" : "ck-blurred", r), i.removeClass(n.isFocused ? "ck-blurred" : "ck-focused", r);
            });
          }
          e.isRenderingInProgress ? function n(i) {
            e.once("change:isRenderingInProgress", (r, s, a) => {
              a ? n(i) : t(i);
            });
          }(this) : t(this);
        }
      }
      class Ty extends By {
        constructor(e, t, n, i = {}) {
          super(e, t, n);
          const r = e.t;
          this.extendTemplate({ attributes: { role: "textbox", class: "ck-editor__editable_inline" } }), this._generateLabel = i.label || (() => r("Editor editing area: %0", this.name));
        }
        render() {
          super.render();
          const e = this._editingView;
          e.change((t) => {
            const n = e.document.getRoot(this.name);
            t.setAttribute("aria-label", this._generateLabel(this), n);
          });
        }
      }
      var Cm = b(8847), Iy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Cm.Z, Iy), Cm.Z.locals;
      class ym extends Or {
        static get pluginName() {
          return "Notification";
        }
        init() {
          this.on("show:warning", (e, t) => {
            window.alert(t.message);
          }, { priority: "lowest" });
        }
        showSuccess(e, t = {}) {
          this._showNotification({ message: e, type: "success", namespace: t.namespace, title: t.title });
        }
        showInfo(e, t = {}) {
          this._showNotification({ message: e, type: "info", namespace: t.namespace, title: t.title });
        }
        showWarning(e, t = {}) {
          this._showNotification({ message: e, type: "warning", namespace: t.namespace, title: t.title });
        }
        _showNotification(e) {
          const t = e.namespace ? `show:${e.type}:${e.namespace}` : `show:${e.type}`;
          this.fire(t, { message: e.message, type: e.type, title: e.title || "" });
        }
      }
      class vl extends re() {
        constructor(e, t) {
          super(), t && Ah(this, t), e && this.set(e);
        }
      }
      var Em = b(4650), Py = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Em.Z, Py), Em.Z.locals;
      var xm = b(7676), Oy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(xm.Z, Oy), xm.Z.locals;
      const is = da("px");
      class rs extends W {
        constructor(e) {
          super(e), this._viewToStack = /* @__PURE__ */ new Map(), this._idToStack = /* @__PURE__ */ new Map(), this._view = null, this._rotatorView = null, this._fakePanelsView = null, this.positionLimiter = () => {
            const t = this.editor.editing.view, n = t.document.selection.editableElement;
            return n ? t.domConverter.mapViewToDom(n.root) : null;
          }, this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", !1);
        }
        static get pluginName() {
          return "ContextualBalloon";
        }
        destroy() {
          super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy();
        }
        get view() {
          return this._view || this._createPanelView(), this._view;
        }
        hasView(e) {
          return Array.from(this._viewToStack.keys()).includes(e);
        }
        add(e) {
          if (this._view || this._createPanelView(), this.hasView(e.view))
            throw new O("contextualballoon-add-view-exist", [this, e]);
          const t = e.stackId || "main";
          if (!this._idToStack.has(t))
            return this._idToStack.set(t, /* @__PURE__ */ new Map([[e.view, e]])), this._viewToStack.set(e.view, this._idToStack.get(t)), this._numberOfStacks = this._idToStack.size, void (this._visibleStack && !e.singleViewMode || this.showStack(t));
          const n = this._idToStack.get(t);
          e.singleViewMode && this.showStack(t), n.set(e.view, e), this._viewToStack.set(e.view, n), n === this._visibleStack && this._showView(e);
        }
        remove(e) {
          if (!this.hasView(e))
            throw new O("contextualballoon-remove-view-not-exist", [this, e]);
          const t = this._viewToStack.get(e);
          this._singleViewMode && this.visibleView === e && (this._singleViewMode = !1), this.visibleView === e && (t.size === 1 ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(t.values())[t.size - 2])), t.size === 1 ? (this._idToStack.delete(this._getStackId(t)), this._numberOfStacks = this._idToStack.size) : t.delete(e), this._viewToStack.delete(e);
        }
        updatePosition(e) {
          e && (this._visibleStack.get(this.visibleView).position = e), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition();
        }
        showStack(e) {
          this.visibleStack = e;
          const t = this._idToStack.get(e);
          if (!t)
            throw new O("contextualballoon-showstack-stack-not-exist", this);
          this._visibleStack !== t && this._showView(Array.from(t.values()).pop());
        }
        _createPanelView() {
          this._view = new Tt(this.editor.locale), this.editor.ui.view.body.add(this._view), this.editor.ui.focusTracker.add(this._view.element), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView);
        }
        _getStackId(e) {
          return Array.from(this._idToStack.entries()).find((t) => t[1] === e)[0];
        }
        _showNextStack() {
          const e = Array.from(this._idToStack.values());
          let t = e.indexOf(this._visibleStack) + 1;
          e[t] || (t = 0), this.showStack(this._getStackId(e[t]));
        }
        _showPrevStack() {
          const e = Array.from(this._idToStack.values());
          let t = e.indexOf(this._visibleStack) - 1;
          e[t] || (t = e.length - 1), this.showStack(this._getStackId(e[t]));
        }
        _createRotatorView() {
          const e = new Ry(this.editor.locale), t = this.editor.locale.t;
          return this.view.content.add(e), e.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (n, i) => !i && n > 1), e.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), e.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (n, i) => {
            if (i < 2)
              return "";
            const r = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
            return t("%0 of %1", [r, i]);
          }), e.buttonNextView.on("execute", () => {
            e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
          }), e.buttonPrevView.on("execute", () => {
            e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
          }), e;
        }
        _createFakePanelsView() {
          const e = new zy(this.editor.locale, this.view);
          return e.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, n) => !n && t >= 2 ? Math.min(t - 1, 2) : 0), e.listenTo(this.view, "change:top", () => e.updatePosition()), e.listenTo(this.view, "change:left", () => e.updatePosition()), this.editor.ui.view.body.add(e), e;
        }
        _showView({ view: e, balloonClassName: t = "", withArrow: n = !0, singleViewMode: i = !1 }) {
          this.view.class = t, this.view.withArrow = n, this._rotatorView.showView(e), this.visibleView = e, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), i && (this._singleViewMode = !0);
        }
        _getBalloonPosition() {
          let e = Array.from(this._visibleStack.values()).pop().position;
          return e && (e.limiter || (e = Object.assign({}, e, { limiter: this.positionLimiter })), e = Object.assign({}, e, { viewportOffsetConfig: this.editor.ui.viewportOffset })), e;
        }
      }
      class Ry extends _e {
        constructor(e) {
          super(e);
          const t = e.t, n = this.bindTemplate;
          this.set("isNavigationVisible", !0), this.focusTracker = new Jt(), this.buttonPrevView = this._createButtonView(t("Previous"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'), this.buttonNextView = this._createButtonView(t("Next"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" }, children: [{ tag: "div", attributes: { class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", (i) => i ? "" : "ck-hidden")] }, children: [this.buttonPrevView, { tag: "span", attributes: { class: ["ck-balloon-rotator__counter"] }, children: [{ text: n.to("counter") }] }, this.buttonNextView] }, { tag: "div", attributes: { class: "ck-balloon-rotator__content" }, children: this.content }] });
        }
        render() {
          super.render(), this.focusTracker.add(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy();
        }
        showView(e) {
          this.hideView(), this.content.add(e);
        }
        hideView() {
          this.content.clear();
        }
        _createButtonView(e, t) {
          const n = new je(this.locale);
          return n.set({ label: e, icon: t, tooltip: !0 }), n;
        }
      }
      class zy extends _e {
        constructor(e, t) {
          super(e);
          const n = this.bindTemplate;
          this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = t, this.setTemplate({ tag: "div", attributes: { class: ["ck-fake-panel", n.to("numberOfPanels", (i) => i ? "" : "ck-hidden")], style: { top: n.to("top", is), left: n.to("left", is), width: n.to("width", is), height: n.to("height", is) } }, children: this.content }), this.on("change:numberOfPanels", (i, r, s, a) => {
            s > a ? this._addPanels(s - a) : this._removePanels(a - s), this.updatePosition();
          });
        }
        _addPanels(e) {
          for (; e--; ) {
            const t = new _e();
            t.setTemplate({ tag: "div" }), this.content.add(t), this.registerChild(t);
          }
        }
        _removePanels(e) {
          for (; e--; ) {
            const t = this.content.last;
            this.content.remove(t), this.deregisterChild(t), t.destroy();
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: e, left: t } = this._balloonPanelView, { width: n, height: i } = new Ze(this._balloonPanelView.element);
            Object.assign(this, { top: e, left: t, width: n, height: i });
          }
        }
      }
      var Sm = b(5868), My = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Sm.Z, My), Sm.Z.locals;
      const ji = da("px");
      class Ny extends _e {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("isActive", !1), this.set("isSticky", !1), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheLimiter", !1), this.set("_hasViewportTopOffset", !1), this.content = this.createCollection(), this._contentPanelPlaceholder = new rn({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__placeholder"], style: { display: t.to("isSticky", (n) => n ? "block" : "none"), height: t.to("isSticky", (n) => n ? ji(this._panelRect.height) : null) } } }).render(), this._contentPanel = new rn({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__content", t.if("isSticky", "ck-sticky-panel__content_sticky"), t.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")], style: { width: t.to("isSticky", (n) => n ? ji(this._contentPanelPlaceholder.getBoundingClientRect().width) : null), top: t.to("_hasViewportTopOffset", (n) => n ? ji(this.viewportTopOffset) : null), bottom: t.to("_isStickyToTheLimiter", (n) => n ? ji(this.limiterBottomOffset) : null), marginLeft: t.to("_marginLeft") } }, children: this.content }).render(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel"] }, children: [this._contentPanelPlaceholder, this._contentPanel] });
        }
        render() {
          super.render(), this._checkIfShouldBeSticky(), this.listenTo(ke.window, "scroll", () => {
            this._checkIfShouldBeSticky();
          }), this.listenTo(this, "change:isActive", () => {
            this._checkIfShouldBeSticky();
          });
        }
        _checkIfShouldBeSticky() {
          const e = this._panelRect = this._contentPanel.getBoundingClientRect();
          let t;
          this.limiterElement ? (t = this._limiterRect = this.limiterElement.getBoundingClientRect(), this.isSticky = this.isActive && t.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < t.height) : this.isSticky = !1, this.isSticky ? (this._isStickyToTheLimiter = t.bottom < e.height + this.limiterBottomOffset + this.viewportTopOffset, this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset, this._marginLeft = this._isStickyToTheLimiter ? null : ji(-ke.window.scrollX)) : (this._isStickyToTheLimiter = !1, this._hasViewportTopOffset = !1, this._marginLeft = null);
        }
      }
      var Dm = b(9695), Fy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Dm.Z, Fy), Dm.Z.locals;
      class $y extends Ey {
        constructor(e, t) {
          super(e), this.view = t, this._toolbarConfig = Ru(e.config.get("toolbar")), this._elementReplacer = new Yc();
        }
        get element() {
          return this.view.element;
        }
        init(e) {
          const t = this.editor, n = this.view, i = t.editing.view, r = n.editable, s = i.document.getRoot();
          r.name = s.rootName, n.render();
          const a = r.element;
          this.setEditableElement(r.name, a), n.editable.bind("isFocused").to(this.focusTracker), i.attachDomRoot(a), e && this._elementReplacer.replace(e, this.element), this._initPlaceholder(), this._initToolbar(), this.fire("ready");
        }
        destroy() {
          super.destroy();
          const e = this.view, t = this.editor.editing.view;
          this._elementReplacer.restore(), t.detachDomRoot(e.editable.name), e.destroy();
        }
        _initToolbar() {
          const e = this.view;
          e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), e.stickyPanel.limiterElement = e.element, e.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: t }) => t || 0), e.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(e.toolbar);
        }
        _initPlaceholder() {
          const e = this.editor, t = e.editing.view, n = t.document.getRoot(), i = e.sourceElement;
          let r;
          const s = e.config.get("placeholder");
          s && (r = typeof s == "string" ? s : s[this.view.editable.name]), !r && i && i.tagName.toLowerCase() === "textarea" && (r = i.getAttribute("placeholder")), r && function({ view: a, element: l, text: d, isDirectHost: h = !0, keepOnFocus: m = !1 }) {
            const f = a.document;
            Rr.has(f) || (Rr.set(f, /* @__PURE__ */ new Map()), f.registerPostFixer((_) => Aa(f, _)), f.on("change:isComposing", () => {
              a.change((_) => Aa(f, _));
            }, { priority: "high" })), Rr.get(f).set(l, { text: d, isDirectHost: h, keepOnFocus: m, hostElement: h ? l : null }), a.change((_) => Aa(f, _));
          }({ view: t, element: n, text: r, isDirectHost: !1, keepOnFocus: !0 });
        }
      }
      var Bm = b(3143), Vy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Bm.Z, Vy), Bm.Z.locals;
      class Ly extends Dy {
        constructor(e, t, n = {}) {
          super(e), this.stickyPanel = new Ny(e), this.toolbar = new sl(e, { shouldGroupWhenFull: n.shouldToolbarGroupWhenFull }), this.editable = new Ty(e, t);
        }
        render() {
          super.render(), this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable);
        }
      }
      class Tm {
        constructor(e) {
          if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = typeof e.crashNumberLimit == "number" ? e.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = typeof e.minimumNonErrorTimePeriod == "number" ? e.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (t) => {
            const n = "error" in t ? t.error : t.reason;
            n instanceof Error && this._handleError(n, t);
          }, this._listeners = {}, !this._restart)
            throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
        }
        destroy() {
          this._stopErrorHandling(), this._listeners = {};
        }
        on(e, t) {
          this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t);
        }
        off(e, t) {
          this._listeners[e] = this._listeners[e].filter((n) => n !== t);
        }
        _fire(e, ...t) {
          const n = this._listeners[e] || [];
          for (const i of n)
            i.apply(this, [null, ...t]);
        }
        _startErrorHandling() {
          window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _stopErrorHandling() {
          window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _handleError(e, t) {
          if (this._shouldReactToError(e)) {
            this.crashes.push({ message: e.message, stack: e.stack, filename: t instanceof ErrorEvent ? t.filename : void 0, lineno: t instanceof ErrorEvent ? t.lineno : void 0, colno: t instanceof ErrorEvent ? t.colno : void 0, date: this._now() });
            const n = this._shouldRestart();
            this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: e, causesRestart: n }), n ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
          }
        }
        _shouldReactToError(e) {
          return e.is && e.is("CKEditorError") && e.context !== void 0 && e.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(e);
        }
        _shouldRestart() {
          return this.crashes.length <= this._crashNumberLimit ? !0 : (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
        }
      }
      function _l(o, e = /* @__PURE__ */ new Set()) {
        const t = [o], n = /* @__PURE__ */ new Set();
        let i = 0;
        for (; t.length > i; ) {
          const r = t[i++];
          if (!n.has(r) && jy(r) && !e.has(r))
            if (n.add(r), Symbol.iterator in r)
              try {
                for (const s of r)
                  t.push(s);
              } catch {
              }
            else
              for (const s in r)
                s !== "defaultValue" && t.push(r[s]);
        }
        return n;
      }
      function jy(o) {
        const e = Object.prototype.toString.call(o), t = typeof o;
        return !(t === "number" || t === "boolean" || t === "string" || t === "symbol" || t === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || o == null || o._watchdogExcluded || o instanceof EventTarget || o instanceof Event);
      }
      function Im(o, e, t = /* @__PURE__ */ new Set()) {
        if (o === e && typeof (n = o) == "object" && n !== null)
          return !0;
        var n;
        const i = _l(o, t), r = _l(e, t);
        for (const s of i)
          if (r.has(s))
            return !0;
        return !1;
      }
      class Pm extends Tm {
        constructor(e, t = {}) {
          super(t), this._editor = null, this._throttledSave = wl(this._save.bind(this), typeof t.saveInterval == "number" ? t.saveInterval : 5e3), e && (this._creator = (n, i) => e.create(n, i)), this._destructor = (n) => n.destroy();
        }
        get editor() {
          return this._editor;
        }
        get _item() {
          return this._editor;
        }
        setCreator(e) {
          this._creator = e;
        }
        setDestructor(e) {
          this._destructor = e;
        }
        _restart() {
          return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((e) => {
            console.error("An error happened during the editor destroying.", e);
          }).then(() => {
            if (typeof this._elementOrData == "string")
              return this.create(this._data, this._config, this._config.context);
            {
              const e = Object.assign({}, this._config, { initialData: this._data });
              return this.create(this._elementOrData, e, e.context);
            }
          }).then(() => {
            this._fire("restart");
          });
        }
        create(e = this._elementOrData, t = this._config, n) {
          return Promise.resolve().then(() => (super._startErrorHandling(), this._elementOrData = e, this._config = this._cloneEditorConfiguration(t) || {}, this._config.context = n, this._creator(e, this._config))).then((i) => {
            this._editor = i, i.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = i.model.document.version, this._data = this._getData(), this.state = "ready", this._fire("stateChange");
          });
        }
        destroy() {
          return Promise.resolve().then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling(), this._throttledSave.flush();
            const e = this._editor;
            return this._editor = null, e.model.document.off("change:data", this._throttledSave), this._destructor(e);
          });
        }
        _save() {
          const e = this._editor.model.document.version;
          try {
            this._data = this._getData(), this._lastDocumentVersion = e;
          } catch (t) {
            console.error(t, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
          }
        }
        _setExcludedProperties(e) {
          this._excludedProps = e;
        }
        _getData() {
          const e = {};
          for (const t of this._editor.model.document.getRootNames())
            e[t] = this._editor.data.get({ rootName: t });
          return e;
        }
        _isErrorComingFromThisItem(e) {
          return Im(this._editor, e.context, this._excludedProps);
        }
        _cloneEditorConfiguration(e) {
          return la(e, (t, n) => Oo(t) || n === "context" ? t : void 0);
        }
      }
      const Hi = Symbol("MainQueueId");
      class Hy {
        constructor() {
          this._onEmptyCallbacks = [], this._queues = /* @__PURE__ */ new Map(), this._activeActions = 0;
        }
        onEmpty(e) {
          this._onEmptyCallbacks.push(e);
        }
        enqueue(e, t) {
          const n = e === Hi;
          this._activeActions++, this._queues.get(e) || this._queues.set(e, Promise.resolve());
          const i = (n ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Hi), this._queues.get(e)])).then(t), r = i.catch(() => {
          });
          return this._queues.set(e, r), i.finally(() => {
            this._activeActions--, this._queues.get(e) === r && this._activeActions === 0 && this._onEmptyCallbacks.forEach((s) => s());
          });
        }
      }
      function Om(o) {
        return Array.isArray(o) ? o : [o];
      }
      class ss extends Yr(rl(j1)) {
        constructor(e, t = {}) {
          if (!as(e) && t.initialData !== void 0)
            throw new O("editor-create-initial-data", null);
          super(t), this.config.get("initialData") === void 0 && this.config.set("initialData", function(r) {
            return as(r) ? (s = r, s instanceof HTMLTextAreaElement ? s.value : s.innerHTML) : r;
            var s;
          }(e)), as(e) && (this.sourceElement = e), this.model.document.createRoot();
          const n = !this.config.get("toolbar.shouldNotGroupWhenFull"), i = new Ly(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: n });
          this.ui = new $y(this, i), function(r) {
            if (!Wn(r.updateSourceElement))
              throw new O("attachtoform-missing-elementapi-interface", r);
            const s = r.sourceElement;
            if (function(a) {
              return !!a && a.tagName.toLowerCase() === "textarea";
            }(s) && s.form) {
              let a;
              const l = s.form, d = () => r.updateSourceElement();
              Wn(l.submit) && (a = l.submit, l.submit = () => {
                d(), a.apply(l);
              }), l.addEventListener("submit", d), r.on("destroy", () => {
                l.removeEventListener("submit", d), a && (l.submit = a);
              });
            }
          }(this);
        }
        destroy() {
          return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy();
        }
        static create(e, t = {}) {
          return new Promise((n) => {
            const i = new this(e, t);
            n(i.initPlugins().then(() => i.ui.init(as(e) ? e : null)).then(() => i.data.init(i.config.get("initialData"))).then(() => i.fire("ready")).then(() => i));
          });
        }
      }
      function as(o) {
        return Oo(o);
      }
      ss.Context = $u, ss.EditorWatchdog = Pm, ss.ContextWatchdog = class extends Tm {
        constructor(o, e = {}) {
          super(e), this._watchdogs = /* @__PURE__ */ new Map(), this._context = null, this._contextProps = /* @__PURE__ */ new Set(), this._actionQueues = new Hy(), this._watchdogConfig = e, this._creator = (t) => o.create(t), this._destructor = (t) => t.destroy(), this._actionQueues.onEmpty(() => {
            this.state === "initializing" && (this.state = "ready", this._fire("stateChange"));
          });
        }
        setCreator(o) {
          this._creator = o;
        }
        setDestructor(o) {
          this._destructor = o;
        }
        get context() {
          return this._context;
        }
        create(o = {}) {
          return this._actionQueues.enqueue(Hi, () => (this._contextConfig = o, this._create()));
        }
        getItem(o) {
          return this._getWatchdog(o)._item;
        }
        getItemState(o) {
          return this._getWatchdog(o).state;
        }
        add(o) {
          const e = Om(o);
          return Promise.all(e.map((t) => this._actionQueues.enqueue(t.id, () => {
            if (this.state === "destroyed")
              throw new Error("Cannot add items to destroyed watchdog.");
            if (!this._context)
              throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
            let n;
            if (this._watchdogs.has(t.id))
              throw new Error(`Item with the given id is already added: '${t.id}'.`);
            if (t.type === "editor")
              return n = new Pm(null, this._watchdogConfig), n.setCreator(t.creator), n._setExcludedProperties(this._contextProps), t.destructor && n.setDestructor(t.destructor), this._watchdogs.set(t.id, n), n.on("error", (i, { error: r, causesRestart: s }) => {
                this._fire("itemError", { itemId: t.id, error: r }), s && this._actionQueues.enqueue(t.id, () => new Promise((a) => {
                  const l = () => {
                    n.off("restart", l), this._fire("itemRestart", { itemId: t.id }), a();
                  };
                  n.on("restart", l);
                }));
              }), n.create(t.sourceElementOrData, t.config, this._context);
            throw new Error(`Not supported item type: '${t.type}'.`);
          })));
        }
        remove(o) {
          const e = Om(o);
          return Promise.all(e.map((t) => this._actionQueues.enqueue(t, () => {
            const n = this._getWatchdog(t);
            return this._watchdogs.delete(t), n.destroy();
          })));
        }
        destroy() {
          return this._actionQueues.enqueue(Hi, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _restart() {
          return this._actionQueues.enqueue(Hi, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((o) => {
            console.error("An error happened during destroying the context or items.", o);
          }).then(() => this._create()).then(() => this._fire("restart"))));
        }
        _create() {
          return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((o) => (this._context = o, this._contextProps = _l(this._context), Promise.all(Array.from(this._watchdogs.values()).map((e) => (e._setExcludedProperties(this._contextProps), e.create(void 0, void 0, this._context))))));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling();
            const o = this._context;
            return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((e) => e.destroy())).then(() => this._destructor(o));
          });
        }
        _getWatchdog(o) {
          const e = this._watchdogs.get(o);
          if (!e)
            throw new Error(`Item with the given id was not registered: ${o}.`);
          return e;
        }
        _isErrorComingFromThisItem(o) {
          for (const e of this._watchdogs.values())
            if (e._isErrorComingFromThisItem(o))
              return !1;
          return Im(this._context, o.context);
        }
      };
      class Al extends Pn {
        constructor(e) {
          super(e), this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"];
          const t = this.document;
          function n(i) {
            return (r, s) => {
              s.preventDefault();
              const a = s.dropRange ? [s.dropRange] : null, l = new j(t, i);
              t.fire(l, { dataTransfer: s.dataTransfer, method: r.name, targetRanges: a, target: s.target, domEvent: s.domEvent }), l.stop.called && s.stopPropagation();
            };
          }
          this.listenTo(t, "paste", n("clipboardInput"), { priority: "low" }), this.listenTo(t, "drop", n("clipboardInput"), { priority: "low" }), this.listenTo(t, "dragover", n("dragging"), { priority: "low" });
        }
        onDomEvent(e) {
          const t = "clipboardData" in e ? e.clipboardData : e.dataTransfer, n = e.type == "drop" || e.type == "paste", i = { dataTransfer: new Ih(t, { cacheFiles: n }) };
          e.type != "drop" && e.type != "dragover" || (i.dropRange = function(r, s) {
            const a = s.target.ownerDocument, l = s.clientX, d = s.clientY;
            let h;
            return a.caretRangeFromPoint && a.caretRangeFromPoint(l, d) ? h = a.caretRangeFromPoint(l, d) : s.rangeParent && (h = a.createRange(), h.setStart(s.rangeParent, s.rangeOffset), h.collapse(!0)), h ? r.domConverter.domRangeToView(h) : null;
          }(this.view, e)), this.fire(e.type, e, i);
        }
      }
      const Rm = ["figcaption", "li"];
      function zm(o) {
        let e = "";
        if (o.is("$text") || o.is("$textProxy"))
          e = o.data;
        else if (o.is("element", "img") && o.hasAttribute("alt"))
          e = o.getAttribute("alt");
        else if (o.is("element", "br"))
          e = `
`;
        else {
          let t = null;
          for (const n of o.getChildren()) {
            const i = zm(n);
            t && (t.is("containerElement") || n.is("containerElement")) && (Rm.includes(t.name) || Rm.includes(n.name) ? e += `
` : e += `

`), e += i, t = n;
          }
        }
        return e;
      }
      class vn extends W {
        static get pluginName() {
          return "ClipboardPipeline";
        }
        init() {
          this.editor.editing.view.addObserver(Al), this._setupPasteDrop(), this._setupCopyCut();
        }
        _setupPasteDrop() {
          const e = this.editor, t = e.model, n = e.editing.view, i = n.document;
          this.listenTo(i, "clipboardInput", (r, s) => {
            s.method != "paste" || e.model.canEditAt(e.model.document.selection) || r.stop();
          }, { priority: "highest" }), this.listenTo(i, "clipboardInput", (r, s) => {
            const a = s.dataTransfer;
            let l;
            if (s.content)
              l = s.content;
            else {
              let m = "";
              a.getData("text/html") ? m = function(f) {
                return f.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (_, S) => S.length == 1 ? " " : S).replace(/<!--[\s\S]*?-->/g, "");
              }(a.getData("text/html")) : a.getData("text/plain") && (((d = (d = a.getData("text/plain")).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || d.includes("<br>")) && (d = `<p>${d}</p>`), m = d), l = this.editor.data.htmlProcessor.toView(m);
            }
            var d;
            const h = new j(this, "inputTransformation");
            this.fire(h, { content: l, dataTransfer: a, targetRanges: s.targetRanges, method: s.method }), h.stop.called && r.stop(), n.scrollToTheSelection();
          }, { priority: "low" }), this.listenTo(this, "inputTransformation", (r, s) => {
            if (s.content.isEmpty)
              return;
            const a = this.editor.data.toModel(s.content, "$clipboardHolder");
            a.childCount != 0 && (r.stop(), t.change(() => {
              this.fire("contentInsertion", { content: a, method: s.method, dataTransfer: s.dataTransfer, targetRanges: s.targetRanges });
            }));
          }, { priority: "low" }), this.listenTo(this, "contentInsertion", (r, s) => {
            s.resultRange = t.insertContent(s.content);
          }, { priority: "low" });
        }
        _setupCopyCut() {
          const e = this.editor, t = e.model.document, n = e.editing.view.document, i = (r, s) => {
            const a = s.dataTransfer;
            s.preventDefault();
            const l = e.data.toView(e.model.getSelectedContent(t.selection));
            n.fire("clipboardOutput", { dataTransfer: a, content: l, method: r.name });
          };
          this.listenTo(n, "copy", i, { priority: "low" }), this.listenTo(n, "cut", (r, s) => {
            e.model.canEditAt(e.model.document.selection) ? i(r, s) : s.preventDefault();
          }, { priority: "low" }), this.listenTo(n, "clipboardOutput", (r, s) => {
            s.content.isEmpty || (s.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(s.content)), s.dataTransfer.setData("text/plain", zm(s.content))), s.method == "cut" && e.model.deleteContent(t.selection);
          }, { priority: "low" });
        }
      }
      class Mm {
        constructor(e, t = 20) {
          this._batch = null, this.model = e, this._size = 0, this.limit = t, this._isLocked = !1, this._changeCallback = (n, i) => {
            i.isLocal && i.isUndoable && i !== this._batch && this._reset(!0);
          }, this._selectionChangeCallback = () => {
            this._reset();
          }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
        }
        get batch() {
          return this._batch || (this._batch = this.model.createBatch({ isTyping: !0 })), this._batch;
        }
        get size() {
          return this._size;
        }
        input(e) {
          this._size += e, this._size >= this.limit && this._reset(!0);
        }
        get isLocked() {
          return this._isLocked;
        }
        lock() {
          this._isLocked = !0;
        }
        unlock() {
          this._isLocked = !1;
        }
        destroy() {
          this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
        }
        _reset(e = !1) {
          this.isLocked && !e || (this._batch = null, this._size = 0);
        }
      }
      class Uy extends be {
        constructor(e, t) {
          super(e), this._buffer = new Mm(e.model, t), this._isEnabledBasedOnSelection = !1;
        }
        get buffer() {
          return this._buffer;
        }
        destroy() {
          super.destroy(), this._buffer.destroy();
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document, i = e.text || "", r = i.length;
          let s = n.selection;
          if (e.selection ? s = e.selection : e.range && (s = t.createSelection(e.range)), !t.canEditAt(s))
            return;
          const a = e.resultRange;
          t.enqueueChange(this._buffer.batch, (l) => {
            this._buffer.lock(), t.deleteContent(s), i && t.insertContent(l.createText(i, n.selection.getAttributes()), s), a ? l.setSelection(a) : s.is("documentSelection") || l.setSelection(s), this._buffer.unlock(), this._buffer.input(r);
          });
        }
      }
      const Nm = ["insertText", "insertReplacementText"];
      class qy extends cn {
        constructor(e) {
          super(e), k.isAndroid && Nm.push("insertCompositionText");
          const t = e.document;
          t.on("beforeinput", (n, i) => {
            if (!this.isEnabled)
              return;
            const { data: r, targetRanges: s, inputType: a, domEvent: l } = i;
            if (!Nm.includes(a))
              return;
            const d = new j(t, "insertText");
            t.fire(d, new Vo(e, l, { text: r, selection: e.createSelection(s) })), d.stop.called && n.stop();
          }), t.on("compositionend", (n, { data: i, domEvent: r }) => {
            this.isEnabled && !k.isAndroid && i && t.fire("insertText", new Vo(e, r, { text: i, selection: t.selection }));
          }, { priority: "lowest" });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class Fm extends W {
        static get pluginName() {
          return "Input";
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view, i = t.document.selection;
          n.addObserver(qy);
          const r = new Uy(e, e.config.get("typing.undoStep") || 20);
          e.commands.add("insertText", r), e.commands.add("input", r), this.listenTo(n.document, "insertText", (s, a) => {
            n.document.isComposing || a.preventDefault();
            const { text: l, selection: d, resultRange: h } = a, m = Array.from(d.getRanges()).map((S) => e.editing.mapper.toModelRange(S));
            let f = l;
            if (k.isAndroid) {
              const S = Array.from(m[0].getItems()).reduce((B, T) => B + (T.is("$textProxy") ? T.data : ""), "");
              S && (S.length <= f.length ? f.startsWith(S) && (f = f.substring(S.length), m[0].start = m[0].start.getShiftedBy(S.length)) : S.startsWith(f) && (m[0].start = m[0].start.getShiftedBy(f.length), f = ""));
            }
            const _ = { text: f, selection: t.createSelection(m) };
            h && (_.resultRange = e.editing.mapper.toModelRange(h)), e.execute("insertText", _);
          }), k.isAndroid ? this.listenTo(n.document, "keydown", (s, a) => {
            !i.isCollapsed && a.keyCode == 229 && n.document.isComposing && $m(t, r);
          }) : this.listenTo(n.document, "compositionstart", () => {
            i.isCollapsed || $m(t, r);
          });
        }
      }
      function $m(o, e) {
        if (!e.isEnabled)
          return;
        const t = e.buffer;
        t.lock(), o.enqueueChange(t.batch, () => {
          o.deleteContent(o.document.selection);
        }), t.unlock();
      }
      class Vm extends be {
        constructor(e, t) {
          super(e), this.direction = t, this._buffer = new Mm(e.model, e.config.get("typing.undoStep")), this._isEnabledBasedOnSelection = !1;
        }
        get buffer() {
          return this._buffer;
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document;
          t.enqueueChange(this._buffer.batch, (i) => {
            this._buffer.lock();
            const r = i.createSelection(e.selection || n.selection);
            if (!t.canEditAt(r))
              return;
            const s = e.sequence || 1, a = r.isCollapsed;
            if (r.isCollapsed && t.modifySelection(r, { direction: this.direction, unit: e.unit, treatEmojiAsSingleUnit: !0 }), this._shouldEntireContentBeReplacedWithParagraph(s))
              return void this._replaceEntireContentWithParagraph(i);
            if (this._shouldReplaceFirstBlockWithParagraph(r, s))
              return void this.editor.execute("paragraph", { selection: r });
            if (r.isCollapsed)
              return;
            let l = 0;
            r.getFirstRange().getMinimalFlatRanges().forEach((d) => {
              l += Ls(d.getWalker({ singleCharacters: !0, ignoreElementEnd: !0, shallow: !0 }));
            }), t.deleteContent(r, { doNotResetEntireContent: a, direction: this.direction }), this._buffer.input(l), i.setSelection(r), this._buffer.unlock();
          });
        }
        _shouldEntireContentBeReplacedWithParagraph(e) {
          if (e > 1)
            return !1;
          const t = this.editor.model, n = t.document.selection, i = t.schema.getLimitElement(n);
          if (!(n.isCollapsed && n.containsEntireContent(i)) || !t.schema.checkChild(i, "paragraph"))
            return !1;
          const r = i.getChild(0);
          return !r || !r.is("element", "paragraph");
        }
        _replaceEntireContentWithParagraph(e) {
          const t = this.editor.model, n = t.document.selection, i = t.schema.getLimitElement(n), r = e.createElement("paragraph");
          e.remove(e.createRangeIn(i)), e.insert(r, i), e.setSelection(r, 0);
        }
        _shouldReplaceFirstBlockWithParagraph(e, t) {
          const n = this.editor.model;
          if (t > 1 || this.direction != "backward" || !e.isCollapsed)
            return !1;
          const i = e.getFirstPosition(), r = n.schema.getLimitElement(i), s = r.getChild(0);
          return i.parent == s && !!e.containsEntireContent(s) && !!n.schema.checkChild(r, "paragraph") && s.name != "paragraph";
        }
      }
      const Lm = "word", zn = "selection", qo = "backward", Ui = "forward", jm = { deleteContent: { unit: zn, direction: qo }, deleteContentBackward: { unit: "codePoint", direction: qo }, deleteWordBackward: { unit: Lm, direction: qo }, deleteHardLineBackward: { unit: zn, direction: qo }, deleteSoftLineBackward: { unit: zn, direction: qo }, deleteContentForward: { unit: "character", direction: Ui }, deleteWordForward: { unit: Lm, direction: Ui }, deleteHardLineForward: { unit: zn, direction: Ui }, deleteSoftLineForward: { unit: zn, direction: Ui } };
      class Wy extends cn {
        constructor(e) {
          super(e);
          const t = e.document;
          let n = 0;
          t.on("keydown", () => {
            n++;
          }), t.on("keyup", () => {
            n = 0;
          }), t.on("beforeinput", (i, r) => {
            if (!this.isEnabled)
              return;
            const { targetRanges: s, domEvent: a, inputType: l } = r, d = jm[l];
            if (!d)
              return;
            const h = { direction: d.direction, unit: d.unit, sequence: n };
            h.unit == zn && (h.selectionToRemove = e.createSelection(s[0])), l === "deleteContentBackward" && (k.isAndroid && (h.sequence = 1), function(f) {
              if (f.length != 1 || f[0].isCollapsed)
                return !1;
              const _ = f[0].getWalker({ direction: "backward", singleCharacters: !0, ignoreElementEnd: !0 });
              let S = 0;
              for (const { nextPosition: B } of _) {
                if (B.parent.is("$text")) {
                  const T = B.parent.data, R = B.offset;
                  if (pa(T, R) || fa(T, R) || lu(T, R))
                    continue;
                  S++;
                } else
                  S++;
                if (S > 1)
                  return !0;
              }
              return !1;
            }(s) && (h.unit = zn, h.selectionToRemove = e.createSelection(s)));
            const m = new Fo(t, "delete", s[0]);
            t.fire(m, new Vo(e, a, h)), m.stop.called && i.stop();
          }), k.isBlink && function(i) {
            const r = i.view, s = r.document;
            let a = null, l = !1;
            function d(m) {
              return m == Ce.backspace || m == Ce.delete;
            }
            function h(m) {
              return m == Ce.backspace ? qo : Ui;
            }
            s.on("keydown", (m, { keyCode: f }) => {
              a = f, l = !1;
            }), s.on("keyup", (m, { keyCode: f, domEvent: _ }) => {
              const S = s.selection, B = i.isEnabled && f == a && d(f) && !S.isCollapsed && !l;
              if (a = null, B) {
                const T = S.getFirstRange(), R = new Fo(s, "delete", T), N = { unit: zn, direction: h(f), selectionToRemove: S };
                s.fire(R, new Vo(r, _, N));
              }
            }), s.on("beforeinput", (m, { inputType: f }) => {
              const _ = jm[f];
              d(a) && _ && _.direction == h(a) && (l = !0);
            }, { priority: "high" }), s.on("beforeinput", (m, { inputType: f, data: _ }) => {
              a == Ce.delete && f == "insertText" && _ == "" && m.stop();
            }, { priority: "high" });
          }(this);
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class Wo extends W {
        static get pluginName() {
          return "Delete";
        }
        init() {
          const e = this.editor, t = e.editing.view, n = t.document, i = e.model.document;
          t.addObserver(Wy), this._undoOnBackspace = !1;
          const r = new Vm(e, "forward");
          e.commands.add("deleteForward", r), e.commands.add("forwardDelete", r), e.commands.add("delete", new Vm(e, "backward")), this.listenTo(n, "delete", (s, a) => {
            n.isComposing || a.preventDefault();
            const { direction: l, sequence: d, selectionToRemove: h, unit: m } = a, f = l === "forward" ? "deleteForward" : "delete", _ = { sequence: d };
            if (m == "selection") {
              const S = Array.from(h.getRanges()).map((B) => e.editing.mapper.toModelRange(B));
              _.selection = e.model.createSelection(S);
            } else
              _.unit = m;
            e.execute(f, _), t.scrollToTheSelection();
          }, { priority: "low" }), this.editor.plugins.has("UndoEditing") && (this.listenTo(n, "delete", (s, a) => {
            this._undoOnBackspace && a.direction == "backward" && a.sequence == 1 && a.unit == "codePoint" && (this._undoOnBackspace = !1, e.execute("undo"), a.preventDefault(), s.stop());
          }, { context: "$capture" }), this.listenTo(i, "change", () => {
            this._undoOnBackspace = !1;
          }));
        }
        requestUndoOnBackspace() {
          this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0);
        }
      }
      class Gy extends W {
        static get requires() {
          return [Fm, Wo];
        }
        static get pluginName() {
          return "Typing";
        }
      }
      function Hm(o, e) {
        let t = o.start;
        return { text: Array.from(o.getItems()).reduce((n, i) => i.is("$text") || i.is("$textProxy") ? n + i.data : (t = e.createPositionAfter(i), ""), ""), range: e.createRange(t, o.end) };
      }
      class Um extends re() {
        constructor(e, t) {
          super(), this.model = e, this.testCallback = t, this._hasMatch = !1, this.set("isEnabled", !0), this.on("change:isEnabled", () => {
            this.isEnabled ? this._startListening() : (this.stopListening(e.document.selection), this.stopListening(e.document));
          }), this._startListening();
        }
        get hasMatch() {
          return this._hasMatch;
        }
        _startListening() {
          const e = this.model.document;
          this.listenTo(e.selection, "change:range", (t, { directChange: n }) => {
            n && (e.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this._hasMatch = !1));
          }), this.listenTo(e, "change:data", (t, n) => {
            !n.isUndo && n.isLocal && this._evaluateTextBeforeSelection("data", { batch: n });
          });
        }
        _evaluateTextBeforeSelection(e, t = {}) {
          const n = this.model, i = n.document.selection, r = n.createRange(n.createPositionAt(i.focus.parent, 0), i.focus), { text: s, range: a } = Hm(r, n), l = this.testCallback(s);
          if (!l && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!l, l) {
            const d = Object.assign(t, { text: s, range: a });
            typeof l == "object" && Object.assign(d, l), this.fire(`matched:${e}`, d);
          }
        }
      }
      class qm extends W {
        constructor(e) {
          super(e), this.attributes = /* @__PURE__ */ new Set(), this._overrideUid = null;
        }
        static get pluginName() {
          return "TwoStepCaretMovement";
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view, i = e.locale, r = t.document.selection;
          this.listenTo(n.document, "arrowKey", (s, a) => {
            if (!r.isCollapsed || a.shiftKey || a.altKey || a.ctrlKey)
              return;
            const l = a.keyCode == Ce.arrowright, d = a.keyCode == Ce.arrowleft;
            if (!l && !d)
              return;
            const h = i.contentLanguageDirection;
            let m = !1;
            m = h === "ltr" && l || h === "rtl" && d ? this._handleForwardMovement(a) : this._handleBackwardMovement(a), m === !0 && s.stop();
          }, { context: "$text", priority: "highest" }), this._isNextGravityRestorationSkipped = !1, this.listenTo(r, "change:range", (s, a) => {
            this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = !1 : this._isGravityOverridden && (!a.directChange && cs(r.getFirstPosition(), this.attributes) || this._restoreGravity());
          });
        }
        registerAttribute(e) {
          this.attributes.add(e);
        }
        _handleForwardMovement(e) {
          const t = this.attributes, n = this.editor.model.document.selection, i = n.getFirstPosition();
          return !this._isGravityOverridden && (!i.isAtStart || !Cl(n, t)) && !!cs(i, t) && (ls(e), this._overrideGravity(), !0);
        }
        _handleBackwardMovement(e) {
          const t = this.attributes, n = this.editor.model, i = n.document.selection, r = i.getFirstPosition();
          return this._isGravityOverridden ? (ls(e), this._restoreGravity(), yl(n, t, r), !0) : r.isAtStart ? !!Cl(i, t) && (ls(e), yl(n, t, r), !0) : !!function(s, a) {
            const l = s.getShiftedBy(-1);
            return cs(l, a);
          }(r, t) && (r.isAtEnd && !Cl(i, t) && cs(r, t) ? (ls(e), yl(n, t, r), !0) : (this._isNextGravityRestorationSkipped = !0, this._overrideGravity(), !1));
        }
        get _isGravityOverridden() {
          return !!this._overrideUid;
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change((e) => e.overrideSelectionGravity());
        }
        _restoreGravity() {
          this.editor.model.change((e) => {
            e.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
          });
        }
      }
      function Cl(o, e) {
        for (const t of e)
          if (o.hasAttribute(t))
            return !0;
        return !1;
      }
      function yl(o, e, t) {
        const n = t.nodeBefore;
        o.change((i) => {
          n ? i.setSelectionAttribute(n.getAttributes()) : i.removeSelectionAttribute(e);
        });
      }
      function ls(o) {
        o.preventDefault();
      }
      function cs(o, e) {
        const { nodeBefore: t, nodeAfter: n } = o;
        for (const i of e) {
          const r = t ? t.getAttribute(i) : void 0;
          if ((n ? n.getAttribute(i) : void 0) !== r)
            return !0;
        }
        return !1;
      }
      var Wm = /[\\^$.*+?()[\]{}|]/g, Ky = RegExp(Wm.source);
      const Zy = function(o) {
        return (o = Ea(o)) && Ky.test(o) ? o.replace(Wm, "\\$&") : o;
      }, Gm = { copyright: { from: "(c)", to: "©" }, registeredTrademark: { from: "(r)", to: "®" }, trademark: { from: "(tm)", to: "™" }, oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null] }, oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null] }, twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null] }, oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null] }, threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null] }, lessThanOrEqual: { from: "<=", to: "≤" }, greaterThanOrEqual: { from: ">=", to: "≥" }, notEqual: { from: "!=", to: "≠" }, arrowLeft: { from: "<-", to: "←" }, arrowRight: { from: "->", to: "→" }, horizontalEllipsis: { from: "...", to: "…" }, enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] }, emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] }, quotesPrimary: { from: Go('"'), to: [null, "“", null, "”"] }, quotesSecondary: { from: Go("'"), to: [null, "‘", null, "’"] }, quotesPrimaryEnGb: { from: Go("'"), to: [null, "‘", null, "’"] }, quotesSecondaryEnGb: { from: Go('"'), to: [null, "“", null, "”"] }, quotesPrimaryPl: { from: Go('"'), to: [null, "„", null, "”"] }, quotesSecondaryPl: { from: Go("'"), to: [null, "‚", null, "’"] } }, Km = { symbols: ["copyright", "registeredTrademark", "trademark"], mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"], typography: ["horizontalEllipsis", "enDash", "emDash"], quotes: ["quotesPrimary", "quotesSecondary"] }, Jy = ["symbols", "mathematical", "typography", "quotes"];
      function Yy(o) {
        return typeof o == "string" ? new RegExp(`(${Zy(o)})$`) : o;
      }
      function Qy(o) {
        return typeof o == "string" ? () => [o] : o instanceof Array ? () => o : o;
      }
      function Xy(o) {
        return (o.textNode ? o.textNode : o.nodeAfter).getAttributes();
      }
      function Go(o) {
        return new RegExp(`(^|\\s)(${o})([^${o}]*)(${o})$`);
      }
      function Ko(o, e, t, n) {
        return n.createRange(Zm(o, e, t, !0, n), Zm(o, e, t, !1, n));
      }
      function Zm(o, e, t, n, i) {
        let r = o.textNode || (n ? o.nodeBefore : o.nodeAfter), s = null;
        for (; r && r.getAttribute(e) == t; )
          s = r, r = n ? r.previousSibling : r.nextSibling;
        return s ? i.createPositionAt(s, n ? "before" : "after") : o;
      }
      function* Jm(o, e) {
        for (const t of e)
          t && o.getAttributeProperties(t[0]).copyOnEnter && (yield t);
      }
      class e2 extends be {
        execute() {
          this.editor.model.change((e) => {
            this.enterBlock(e), this.fire("afterExecute", { writer: e });
          });
        }
        enterBlock(e) {
          const t = this.editor.model, n = t.document.selection, i = t.schema, r = n.isCollapsed, s = n.getFirstRange(), a = s.start.parent, l = s.end.parent;
          if (i.isLimit(a) || i.isLimit(l))
            return r || a != l || t.deleteContent(n), !1;
          if (r) {
            const d = Jm(e.model.schema, n.getAttributes());
            return Ym(e, s.start), e.setSelectionAttribute(d), !0;
          }
          {
            const d = !(s.start.isAtStart && s.end.isAtEnd), h = a == l;
            if (t.deleteContent(n, { leaveUnmerged: d }), d) {
              if (h)
                return Ym(e, n.focus), !0;
              e.setSelection(l, 0);
            }
          }
          return !1;
        }
      }
      function Ym(o, e) {
        o.split(e), o.setSelection(e.parent.nextSibling, 0);
      }
      const t2 = { insertParagraph: { isSoft: !1 }, insertLineBreak: { isSoft: !0 } };
      class Qm extends cn {
        constructor(e) {
          super(e);
          const t = this.document;
          let n = !1;
          t.on("keydown", (i, r) => {
            n = r.shiftKey;
          }), t.on("beforeinput", (i, r) => {
            if (!this.isEnabled)
              return;
            let s = r.inputType;
            k.isSafari && n && s == "insertParagraph" && (s = "insertLineBreak");
            const a = r.domEvent, l = t2[s];
            if (!l)
              return;
            const d = new Fo(t, "enter", r.targetRanges[0]);
            t.fire(d, new Vo(e, a, { isSoft: l.isSoft })), d.stop.called && i.stop();
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class qi extends W {
        static get pluginName() {
          return "Enter";
        }
        init() {
          const e = this.editor, t = e.editing.view, n = t.document;
          t.addObserver(Qm), e.commands.add("enter", new e2(e)), this.listenTo(n, "enter", (i, r) => {
            n.isComposing || r.preventDefault(), r.isSoft || (e.execute("enter"), t.scrollToTheSelection());
          }, { priority: "low" });
        }
      }
      class n2 extends be {
        execute() {
          const e = this.editor.model, t = e.document;
          e.change((n) => {
            (function(i, r, s) {
              const a = s.isCollapsed, l = s.getFirstRange(), d = l.start.parent, h = l.end.parent, m = d == h;
              if (a) {
                const f = Jm(i.schema, s.getAttributes());
                Xm(i, r, l.end), r.removeSelectionAttribute(s.getAttributeKeys()), r.setSelectionAttribute(f);
              } else {
                const f = !(l.start.isAtStart && l.end.isAtEnd);
                i.deleteContent(s, { leaveUnmerged: f }), m ? Xm(i, r, s.focus) : f && r.setSelection(h, 0);
              }
            })(e, n, t.selection), this.fire("afterExecute", { writer: n });
          });
        }
        refresh() {
          const e = this.editor.model, t = e.document;
          this.isEnabled = function(n, i) {
            if (i.rangeCount > 1)
              return !1;
            const r = i.anchor;
            if (!r || !n.checkChild(r, "softBreak"))
              return !1;
            const s = i.getFirstRange(), a = s.start.parent, l = s.end.parent;
            return !((El(a, n) || El(l, n)) && a !== l);
          }(e.schema, t.selection);
        }
      }
      function Xm(o, e, t) {
        const n = e.createElement("softBreak");
        o.insertContent(n, t), e.setSelection(n, "after");
      }
      function El(o, e) {
        return !o.is("rootElement") && (e.isLimit(o) || El(o.parent, e));
      }
      class o2 extends W {
        static get pluginName() {
          return "ShiftEnter";
        }
        init() {
          const e = this.editor, t = e.model.schema, n = e.conversion, i = e.editing.view, r = i.document;
          t.register("softBreak", { allowWhere: "$text", isInline: !0 }), n.for("upcast").elementToElement({ model: "softBreak", view: "br" }), n.for("downcast").elementToElement({ model: "softBreak", view: (s, { writer: a }) => a.createEmptyElement("br") }), i.addObserver(Qm), e.commands.add("shiftEnter", new n2(e)), this.listenTo(r, "enter", (s, a) => {
            r.isComposing || a.preventDefault(), a.isSoft && (e.execute("shiftEnter"), i.scrollToTheSelection());
          }, { priority: "low" });
        }
      }
      class i2 extends Se() {
        constructor() {
          super(...arguments), this._stack = [];
        }
        add(e, t) {
          const n = this._stack, i = n[0];
          this._insertDescriptor(e);
          const r = n[0];
          i === r || xl(i, r) || this.fire("change:top", { oldDescriptor: i, newDescriptor: r, writer: t });
        }
        remove(e, t) {
          const n = this._stack, i = n[0];
          this._removeDescriptor(e);
          const r = n[0];
          i === r || xl(i, r) || this.fire("change:top", { oldDescriptor: i, newDescriptor: r, writer: t });
        }
        _insertDescriptor(e) {
          const t = this._stack, n = t.findIndex((r) => r.id === e.id);
          if (xl(e, t[n]))
            return;
          n > -1 && t.splice(n, 1);
          let i = 0;
          for (; t[i] && r2(t[i], e); )
            i++;
          t.splice(i, 0, e);
        }
        _removeDescriptor(e) {
          const t = this._stack, n = t.findIndex((i) => i.id === e);
          n > -1 && t.splice(n, 1);
        }
      }
      function xl(o, e) {
        return o && e && o.priority == e.priority && ds(o.classes) == ds(e.classes);
      }
      function r2(o, e) {
        return o.priority > e.priority || !(o.priority < e.priority) && ds(o.classes) > ds(e.classes);
      }
      function ds(o) {
        return Array.isArray(o) ? o.sort().join(",") : o;
      }
      const s2 = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>', a2 = "ck-widget", ep = "ck-widget_selected";
      function Je(o) {
        return !!o.is("element") && !!o.getCustomProperty("widget");
      }
      function Sl(o, e, t = {}) {
        if (!o.is("containerElement"))
          throw new O("widget-to-widget-wrong-element-type", null, { element: o });
        return e.setAttribute("contenteditable", "false", o), e.addClass(a2, o), e.setCustomProperty("widget", !0, o), o.getFillerOffset = u2, e.setCustomProperty("widgetLabel", [], o), t.label && function(n, i) {
          n.getCustomProperty("widgetLabel").push(i);
        }(o, t.label), t.hasSelectionHandle && function(n, i) {
          const r = i.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(s) {
            const a = this.toDomElement(s), l = new xi();
            return l.set("content", s2), l.render(), a.appendChild(l.element), a;
          });
          i.insert(i.createPositionAt(n, 0), r), i.addClass(["ck-widget_with-selection-handle"], n);
        }(o, e), tp(o, e), o;
      }
      function l2(o, e, t) {
        if (e.classes && t.addClass(Xe(e.classes), o), e.attributes)
          for (const n in e.attributes)
            t.setAttribute(n, e.attributes[n], o);
      }
      function c2(o, e, t) {
        if (e.classes && t.removeClass(Xe(e.classes), o), e.attributes)
          for (const n in e.attributes)
            t.removeAttribute(n, o);
      }
      function tp(o, e, t = l2, n = c2) {
        const i = new i2();
        i.on("change:top", (r, s) => {
          s.oldDescriptor && n(o, s.oldDescriptor, s.writer), s.newDescriptor && t(o, s.newDescriptor, s.writer);
        }), e.setCustomProperty("addHighlight", (r, s, a) => i.add(s, a), o), e.setCustomProperty("removeHighlight", (r, s, a) => i.remove(s, a), o);
      }
      function d2(o, e, t = {}) {
        return e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], o), e.setAttribute("role", "textbox", o), t.label && e.setAttribute("aria-label", t.label, o), e.setAttribute("contenteditable", o.isReadOnly ? "false" : "true", o), o.on("change:isReadOnly", (n, i, r) => {
          e.setAttribute("contenteditable", r ? "false" : "true", o);
        }), o.on("change:isFocused", (n, i, r) => {
          r ? e.addClass("ck-editor__nested-editable_focused", o) : e.removeClass("ck-editor__nested-editable_focused", o);
        }), tp(o, e), o;
      }
      function u2() {
        return null;
      }
      const _n = "widget-type-around";
      function lo(o, e, t) {
        return !!o && Je(o) && !t.isInline(e);
      }
      function Mn(o) {
        return o.getAttribute(_n);
      }
      var np = b(4921), h2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(np.Z, h2), np.Z.locals;
      const op = ["before", "after"], g2 = new DOMParser().parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', "image/svg+xml").firstChild, ip = "ck-widget__type-around_disabled";
      class m2 extends W {
        constructor() {
          super(...arguments), this._currentFakeCaretModelElement = null;
        }
        static get pluginName() {
          return "WidgetTypeAround";
        }
        static get requires() {
          return [qi, Wo];
        }
        init() {
          const e = this.editor, t = e.editing.view;
          this.on("change:isEnabled", (n, i, r) => {
            t.change((s) => {
              for (const a of t.document.roots)
                r ? s.removeClass(ip, a) : s.addClass(ip, a);
            }), r || e.model.change((s) => {
              s.removeSelectionAttribute(_n);
            });
          }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration();
        }
        destroy() {
          super.destroy(), this._currentFakeCaretModelElement = null;
        }
        _insertParagraph(e, t) {
          const n = this.editor, i = n.editing.view, r = n.model.schema.getAttributesWithProperty(e, "copyOnReplace", !0);
          n.execute("insertParagraph", { position: n.model.createPositionAt(e, t), attributes: r }), i.focus(), i.scrollToTheSelection();
        }
        _listenToIfEnabled(e, t, n, i) {
          this.listenTo(e, t, (...r) => {
            this.isEnabled && n(...r);
          }, i);
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const e = this.editor.model.document.selection, t = Mn(e);
          if (!t)
            return !1;
          const n = e.getSelectedElement();
          return this._insertParagraph(n, t), !0;
        }
        _enableTypeAroundUIInjection() {
          const e = this.editor, t = e.model.schema, n = e.locale.t, i = { before: n("Insert paragraph before block"), after: n("Insert paragraph after block") };
          e.editing.downcastDispatcher.on("insert", (r, s, a) => {
            const l = a.mapper.toViewElement(s.item);
            l && lo(l, s.item, t) && (function(d, h, m) {
              const f = d.createUIElement("div", { class: "ck ck-reset_all ck-widget__type-around" }, function(_) {
                const S = this.toDomElement(_);
                return function(B, T) {
                  for (const R of op) {
                    const N = new rn({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${R}`], title: T[R], "aria-hidden": "true" }, children: [B.ownerDocument.importNode(g2, !0)] });
                    B.appendChild(N.render());
                  }
                }(S, h), function(B) {
                  const T = new rn({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] } });
                  B.appendChild(T.render());
                }(S), S;
              });
              d.insert(d.createPositionAt(m, "end"), f);
            }(a.writer, i, l), l.getCustomProperty("widgetLabel").push(() => this.isEnabled ? n("Press Enter to type after or press Shift + Enter to type before the widget") : ""));
          }, { priority: "low" });
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const e = this.editor, t = e.model, n = t.document.selection, i = t.schema, r = e.editing.view;
          function s(a) {
            return `ck-widget_type-around_show-fake-caret_${a}`;
          }
          this._listenToIfEnabled(r.document, "arrowKey", (a, l) => {
            this._handleArrowKeyPress(a, l);
          }, { context: [Je, "$text"], priority: "high" }), this._listenToIfEnabled(n, "change:range", (a, l) => {
            l.directChange && e.model.change((d) => {
              d.removeSelectionAttribute(_n);
            });
          }), this._listenToIfEnabled(t.document, "change:data", () => {
            const a = n.getSelectedElement();
            a && lo(e.editing.mapper.toViewElement(a), a, i) || e.model.change((l) => {
              l.removeSelectionAttribute(_n);
            });
          }), this._listenToIfEnabled(e.editing.downcastDispatcher, "selection", (a, l, d) => {
            const h = d.writer;
            if (this._currentFakeCaretModelElement) {
              const S = d.mapper.toViewElement(this._currentFakeCaretModelElement);
              S && (h.removeClass(op.map(s), S), this._currentFakeCaretModelElement = null);
            }
            const m = l.selection.getSelectedElement();
            if (!m)
              return;
            const f = d.mapper.toViewElement(m);
            if (!lo(f, m, i))
              return;
            const _ = Mn(l.selection);
            _ && (h.addClass(s(_), f), this._currentFakeCaretModelElement = m);
          }), this._listenToIfEnabled(e.ui.focusTracker, "change:isFocused", (a, l, d) => {
            d || e.model.change((h) => {
              h.removeSelectionAttribute(_n);
            });
          });
        }
        _handleArrowKeyPress(e, t) {
          const n = this.editor, i = n.model, r = i.document.selection, s = i.schema, a = n.editing.view, l = function(m, f) {
            const _ = ga(m, f);
            return _ === "down" || _ === "right";
          }(t.keyCode, n.locale.contentLanguageDirection), d = a.document.selection.getSelectedElement();
          let h;
          lo(d, n.editing.mapper.toModelElement(d), s) ? h = this._handleArrowKeyPressOnSelectedWidget(l) : r.isCollapsed ? h = this._handleArrowKeyPressWhenSelectionNextToAWidget(l) : t.shiftKey || (h = this._handleArrowKeyPressWhenNonCollapsedSelection(l)), h && (t.preventDefault(), e.stop());
        }
        _handleArrowKeyPressOnSelectedWidget(e) {
          const t = this.editor.model, n = Mn(t.document.selection);
          return t.change((i) => n ? n !== (e ? "after" : "before") ? (i.removeSelectionAttribute(_n), !0) : !1 : (i.setSelectionAttribute(_n, e ? "after" : "before"), !0));
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(e) {
          const t = this.editor, n = t.model, i = n.schema, r = t.plugins.get("Widget"), s = r._getObjectElementNextToSelection(e);
          return !!lo(t.editing.mapper.toViewElement(s), s, i) && (n.change((a) => {
            r._setSelectionOverElement(s), a.setSelectionAttribute(_n, e ? "before" : "after");
          }), !0);
        }
        _handleArrowKeyPressWhenNonCollapsedSelection(e) {
          const t = this.editor, n = t.model, i = n.schema, r = t.editing.mapper, s = n.document.selection, a = e ? s.getLastPosition().nodeBefore : s.getFirstPosition().nodeAfter;
          return !!lo(r.toViewElement(a), a, i) && (n.change((l) => {
            l.setSelection(a, "on"), l.setSelectionAttribute(_n, e ? "after" : "before");
          }), !0);
        }
        _enableInsertingParagraphsOnButtonClick() {
          const e = this.editor, t = e.editing.view;
          this._listenToIfEnabled(t.document, "mousedown", (n, i) => {
            const r = i.domTarget.closest(".ck-widget__type-around__button");
            if (!r)
              return;
            const s = function(d) {
              return d.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
            }(r), a = function(d, h) {
              const m = d.closest(".ck-widget");
              return h.mapDomToView(m);
            }(r, t.domConverter), l = e.editing.mapper.toModelElement(a);
            this._insertParagraph(l, s), i.preventDefault(), n.stop();
          });
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const e = this.editor, t = e.model.document.selection, n = e.editing.view;
          this._listenToIfEnabled(n.document, "enter", (i, r) => {
            if (i.eventPhase != "atTarget")
              return;
            const s = t.getSelectedElement(), a = e.editing.mapper.toViewElement(s), l = e.model.schema;
            let d;
            this._insertParagraphAccordingToFakeCaretPosition() ? d = !0 : lo(a, s, l) && (this._insertParagraph(s, r.isSoft ? "before" : "after"), d = !0), d && (r.preventDefault(), i.stop());
          }, { context: Je });
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const e = this.editor.editing.view.document;
          this._listenToIfEnabled(e, "insertText", (t, n) => {
            this._insertParagraphAccordingToFakeCaretPosition() && (n.selection = e.selection);
          }, { priority: "high" }), k.isAndroid ? this._listenToIfEnabled(e, "keydown", (t, n) => {
            n.keyCode == 229 && this._insertParagraphAccordingToFakeCaretPosition();
          }) : this._listenToIfEnabled(e, "compositionstart", () => {
            this._insertParagraphAccordingToFakeCaretPosition();
          }, { priority: "high" });
        }
        _enableDeleteIntegration() {
          const e = this.editor, t = e.editing.view, n = e.model, i = n.schema;
          this._listenToIfEnabled(t.document, "delete", (r, s) => {
            if (r.eventPhase != "atTarget")
              return;
            const a = Mn(n.document.selection);
            if (!a)
              return;
            const l = s.direction, d = n.document.selection.getSelectedElement(), h = l == "forward";
            if (a === "before" === h)
              e.execute("delete", { selection: n.createSelection(d, "on") });
            else {
              const m = i.getNearestSelectionRange(n.createPositionAt(d, a), l);
              if (m)
                if (m.isCollapsed) {
                  const f = n.createSelection(m.start);
                  if (n.modifySelection(f, { direction: l }), f.focus.isEqual(m.start)) {
                    const _ = function(S, B) {
                      let T = B;
                      for (const R of B.getAncestors({ parentFirst: !0 })) {
                        if (R.childCount > 1 || S.isLimit(R))
                          break;
                        T = R;
                      }
                      return T;
                    }(i, m.start.parent);
                    n.deleteContent(n.createSelection(_, "on"), { doNotAutoparagraph: !0 });
                  } else
                    n.change((_) => {
                      _.setSelection(m), e.execute(h ? "deleteForward" : "delete");
                    });
                } else
                  n.change((f) => {
                    f.setSelection(m), e.execute(h ? "deleteForward" : "delete");
                  });
            }
            s.preventDefault(), r.stop();
          }, { context: Je });
        }
        _enableInsertContentIntegration() {
          const e = this.editor, t = this.editor.model, n = t.document.selection;
          this._listenToIfEnabled(e.model, "insertContent", (i, [r, s]) => {
            if (s && !s.is("documentSelection"))
              return;
            const a = Mn(n);
            return a ? (i.stop(), t.change((l) => {
              const d = n.getSelectedElement(), h = t.createPositionAt(d, a), m = l.createSelection(h), f = t.insertContent(r, m);
              return l.setSelection(m), f;
            })) : void 0;
          }, { priority: "high" });
        }
        _enableInsertObjectIntegration() {
          const e = this.editor, t = this.editor.model.document.selection;
          this._listenToIfEnabled(e.model, "insertObject", (n, i) => {
            const [, r, s = {}] = i;
            if (r && !r.is("documentSelection"))
              return;
            const a = Mn(t);
            a && (s.findOptimalPosition = a, i[3] = s);
          }, { priority: "high" });
        }
        _enableDeleteContentIntegration() {
          const e = this.editor, t = this.editor.model.document.selection;
          this._listenToIfEnabled(e.model, "deleteContent", (n, [i]) => {
            i && !i.is("documentSelection") || Mn(t) && n.stop();
          }, { priority: "high" });
        }
      }
      function p2(o) {
        const e = o.model;
        return (t, n) => {
          const i = n.keyCode == Ce.arrowup, r = n.keyCode == Ce.arrowdown, s = n.shiftKey, a = e.document.selection;
          if (!i && !r)
            return;
          const l = r;
          if (s && function(h, m) {
            return !h.isCollapsed && h.isBackward == m;
          }(a, l))
            return;
          const d = function(h, m, f) {
            const _ = h.model;
            if (f) {
              const S = m.isCollapsed ? m.focus : m.getLastPosition(), B = rp(_, S, "forward");
              if (!B)
                return null;
              const T = _.createRange(S, B), R = sp(_.schema, T, "backward");
              return R ? _.createRange(S, R) : null;
            }
            {
              const S = m.isCollapsed ? m.focus : m.getFirstPosition(), B = rp(_, S, "backward");
              if (!B)
                return null;
              const T = _.createRange(B, S), R = sp(_.schema, T, "forward");
              return R ? _.createRange(R, S) : null;
            }
          }(o, a, l);
          if (d) {
            if (d.isCollapsed && (a.isCollapsed || s))
              return;
            (d.isCollapsed || function(h, m, f) {
              const _ = h.model, S = h.view.domConverter;
              if (f) {
                const U = _.createSelection(m.start);
                _.modifySelection(U), U.focus.isAtEnd || m.start.isEqual(U.focus) || (m = _.createRange(U.focus, m.end));
              }
              const B = h.mapper.toViewRange(m), T = S.viewRangeToDom(B), R = Ze.getDomRangeRects(T);
              let N;
              for (const U of R)
                if (N !== void 0) {
                  if (Math.round(U.top) >= N)
                    return !1;
                  N = Math.max(N, Math.round(U.bottom));
                } else
                  N = Math.round(U.bottom);
              return !0;
            }(o, d, l)) && (e.change((h) => {
              const m = l ? d.end : d.start;
              if (s) {
                const f = e.createSelection(a.anchor);
                f.setFocus(m), h.setSelection(f);
              } else
                h.setSelection(m);
            }), t.stop(), n.preventDefault(), n.stopPropagation());
          }
        };
      }
      function rp(o, e, t) {
        const n = o.schema, i = o.createRangeIn(e.root), r = t == "forward" ? "elementStart" : "elementEnd";
        for (const { previousPosition: s, item: a, type: l } of i.getWalker({ startPosition: e, direction: t })) {
          if (n.isLimit(a) && !n.isInline(a))
            return s;
          if (l == r && n.isBlock(a))
            return null;
        }
        return null;
      }
      function sp(o, e, t) {
        const n = t == "backward" ? e.end : e.start;
        if (o.checkChild(n, "$text"))
          return n;
        for (const { nextPosition: i } of e.getWalker({ direction: t }))
          if (o.checkChild(i, "$text"))
            return i;
        return null;
      }
      var ap = b(3488), f2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(ap.Z, f2), ap.Z.locals;
      class Wi extends W {
        constructor() {
          super(...arguments), this._previouslySelected = /* @__PURE__ */ new Set();
        }
        static get pluginName() {
          return "Widget";
        }
        static get requires() {
          return [m2, Wo];
        }
        init() {
          const e = this.editor, t = e.editing.view, n = t.document;
          this.editor.editing.downcastDispatcher.on("selection", (i, r, s) => {
            const a = s.writer, l = r.selection;
            if (l.isCollapsed)
              return;
            const d = l.getSelectedElement();
            if (!d)
              return;
            const h = e.editing.mapper.toViewElement(d);
            var m;
            Je(h) && s.consumable.consume(l, "selection") && a.setSelection(a.createRangeOn(h), { fake: !0, label: (m = h, m.getCustomProperty("widgetLabel").reduce((f, _) => typeof _ == "function" ? f ? f + ". " + _() : _() : f ? f + ". " + _ : _, "")) });
          }), this.editor.editing.downcastDispatcher.on("selection", (i, r, s) => {
            this._clearPreviouslySelectedWidgets(s.writer);
            const a = s.writer, l = a.document.selection;
            let d = null;
            for (const h of l.getRanges())
              for (const m of h) {
                const f = m.item;
                Je(f) && !b2(f, d) && (a.addClass(ep, f), this._previouslySelected.add(f), d = f);
              }
          }, { priority: "low" }), t.addObserver(il), this.listenTo(n, "mousedown", (...i) => this._onMousedown(...i)), this.listenTo(n, "arrowKey", (...i) => {
            this._handleSelectionChangeOnArrowKeyPress(...i);
          }, { context: [Je, "$text"] }), this.listenTo(n, "arrowKey", (...i) => {
            this._preventDefaultOnArrowKeyPress(...i);
          }, { context: "$root" }), this.listenTo(n, "arrowKey", p2(this.editor.editing), { context: "$text" }), this.listenTo(n, "delete", (i, r) => {
            this._handleDelete(r.direction == "forward") && (r.preventDefault(), i.stop());
          }, { context: "$root" });
        }
        _onMousedown(e, t) {
          const n = this.editor, i = n.editing.view, r = i.document;
          let s = t.target;
          if (function(l) {
            let d = l;
            for (; d; ) {
              if (d.is("editableElement") && !d.is("rootElement"))
                return !0;
              if (Je(d))
                return !1;
              d = d.parent;
            }
            return !1;
          }(s)) {
            if ((k.isSafari || k.isGecko) && t.domEvent.detail >= 3) {
              const l = n.editing.mapper, d = s.is("attributeElement") ? s.findAncestor((m) => !m.is("attributeElement")) : s, h = l.toModelElement(d);
              t.preventDefault(), this.editor.model.change((m) => {
                m.setSelection(h, "in");
              });
            }
            return;
          }
          if (!Je(s) && (s = s.findAncestor(Je), !s))
            return;
          k.isAndroid && t.preventDefault(), r.isFocused || i.focus();
          const a = n.editing.mapper.toModelElement(s);
          this._setSelectionOverElement(a);
        }
        _handleSelectionChangeOnArrowKeyPress(e, t) {
          const n = t.keyCode, i = this.editor.model, r = i.schema, s = i.document.selection, a = s.getSelectedElement(), l = ga(n, this.editor.locale.contentLanguageDirection), d = l == "down" || l == "right", h = l == "up" || l == "down";
          if (a && r.isObject(a)) {
            const f = d ? s.getLastPosition() : s.getFirstPosition(), _ = r.getNearestSelectionRange(f, d ? "forward" : "backward");
            return void (_ && (i.change((S) => {
              S.setSelection(_);
            }), t.preventDefault(), e.stop()));
          }
          if (!s.isCollapsed && !t.shiftKey) {
            const f = s.getFirstPosition(), _ = s.getLastPosition(), S = f.nodeAfter, B = _.nodeBefore;
            return void ((S && r.isObject(S) || B && r.isObject(B)) && (i.change((T) => {
              T.setSelection(d ? _ : f);
            }), t.preventDefault(), e.stop()));
          }
          if (!s.isCollapsed)
            return;
          const m = this._getObjectElementNextToSelection(d);
          if (m && r.isObject(m)) {
            if (r.isInline(m) && h)
              return;
            this._setSelectionOverElement(m), t.preventDefault(), e.stop();
          }
        }
        _preventDefaultOnArrowKeyPress(e, t) {
          const n = this.editor.model, i = n.schema, r = n.document.selection.getSelectedElement();
          r && i.isObject(r) && (t.preventDefault(), e.stop());
        }
        _handleDelete(e) {
          const t = this.editor.model.document.selection;
          if (!this.editor.model.canEditAt(t) || !t.isCollapsed)
            return;
          const n = this._getObjectElementNextToSelection(e);
          return n ? (this.editor.model.change((i) => {
            let r = t.anchor.parent;
            for (; r.isEmpty; ) {
              const s = r;
              r = s.parent, i.remove(s);
            }
            this._setSelectionOverElement(n);
          }), !0) : void 0;
        }
        _setSelectionOverElement(e) {
          this.editor.model.change((t) => {
            t.setSelection(t.createRangeOn(e));
          });
        }
        _getObjectElementNextToSelection(e) {
          const t = this.editor.model, n = t.schema, i = t.document.selection, r = t.createSelection(i);
          if (t.modifySelection(r, { direction: e ? "forward" : "backward" }), r.isEqual(i))
            return null;
          const s = e ? r.focus.nodeBefore : r.focus.nodeAfter;
          return s && n.isObject(s) ? s : null;
        }
        _clearPreviouslySelectedWidgets(e) {
          for (const t of this._previouslySelected)
            e.removeClass(ep, t);
          this._previouslySelected.clear();
        }
      }
      function b2(o, e) {
        return !!e && Array.from(o.getAncestors()).includes(e);
      }
      class us extends W {
        constructor() {
          super(...arguments), this._toolbarDefinitions = /* @__PURE__ */ new Map();
        }
        static get requires() {
          return [rs];
        }
        static get pluginName() {
          return "WidgetToolbarRepository";
        }
        init() {
          const e = this.editor;
          if (e.plugins.has("BalloonToolbar")) {
            const t = e.plugins.get("BalloonToolbar");
            this.listenTo(t, "show", (n) => {
              (function(i) {
                const r = i.getSelectedElement();
                return !(!r || !Je(r));
              })(e.editing.view.document.selection) && n.stop();
            }, { priority: "high" });
          }
          this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
            this._updateToolbarsVisibility();
          }), this.listenTo(e.ui, "update", () => {
            this._updateToolbarsVisibility();
          }), this.listenTo(e.ui.focusTracker, "change:isFocused", () => {
            this._updateToolbarsVisibility();
          }, { priority: "low" });
        }
        destroy() {
          super.destroy();
          for (const e of this._toolbarDefinitions.values())
            e.view.destroy();
        }
        register(e, { ariaLabel: t, items: n, getRelatedElement: i, balloonClassName: r = "ck-toolbar-container" }) {
          if (!n.length)
            return void oe("widget-toolbar-no-items", { toolbarId: e });
          const s = this.editor, a = s.t, l = new sl(s.locale);
          if (l.ariaLabel = t || a("Widget toolbar"), this._toolbarDefinitions.has(e))
            throw new O("widget-toolbar-duplicated", this, { toolbarId: e });
          const d = { view: l, getRelatedElement: i, balloonClassName: r, itemsConfig: n, initialized: !1 };
          s.ui.addToolbar(l, { isContextual: !0, beforeFocus: () => {
            const h = i(s.editing.view.document.selection);
            h && this._showToolbar(d, h);
          }, afterBlur: () => {
            this._hideToolbar(d);
          } }), this._toolbarDefinitions.set(e, d);
        }
        _updateToolbarsVisibility() {
          let e = 0, t = null, n = null;
          for (const i of this._toolbarDefinitions.values()) {
            const r = i.getRelatedElement(this.editor.editing.view.document.selection);
            if (this.isEnabled && r)
              if (this.editor.ui.focusTracker.isFocused) {
                const s = r.getAncestors().length;
                s > e && (e = s, t = r, n = i);
              } else
                this._isToolbarVisible(i) && this._hideToolbar(i);
            else
              this._isToolbarInBalloon(i) && this._hideToolbar(i);
          }
          n && this._showToolbar(n, t);
        }
        _hideToolbar(e) {
          this._balloon.remove(e.view), this.stopListening(this._balloon, "change:visibleView");
        }
        _showToolbar(e, t) {
          this._isToolbarVisible(e) ? lp(this.editor, t) : this._isToolbarInBalloon(e) || (e.initialized || (e.initialized = !0, e.view.fillFromConfig(e.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({ view: e.view, position: cp(this.editor, t), balloonClassName: e.balloonClassName }), this.listenTo(this._balloon, "change:visibleView", () => {
            for (const n of this._toolbarDefinitions.values())
              if (this._isToolbarVisible(n)) {
                const i = n.getRelatedElement(this.editor.editing.view.document.selection);
                lp(this.editor, i);
              }
          }));
        }
        _isToolbarVisible(e) {
          return this._balloon.visibleView === e.view;
        }
        _isToolbarInBalloon(e) {
          return this._balloon.hasView(e.view);
        }
      }
      function lp(o, e) {
        const t = o.plugins.get("ContextualBalloon"), n = cp(o, e);
        t.updatePosition(n);
      }
      function cp(o, e) {
        const t = o.editing.view, n = Tt.defaultPositions;
        return { target: t.domConverter.mapViewToDom(e), positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast, n.viewportStickyNorth] };
      }
      var dp = b(8506), k2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(dp.Z, k2), dp.Z.locals;
      var up = b(903), w2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(up.Z, w2), up.Z.locals;
      class v2 extends W {
        static get pluginName() {
          return "DragDrop";
        }
        static get requires() {
          return [vn, Wi];
        }
        init() {
          const e = this.editor, t = e.editing.view;
          this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, this._updateDropMarkerThrottled = wl((n) => this._updateDropMarker(n), 40), this._removeDropMarkerDelayed = ma(() => this._removeDropMarker(), 40), this._clearDraggableAttributesDelayed = ma(() => this._clearDraggableAttributes(), 40), e.plugins.has("DragDropExperimental") ? this.forceDisabled("DragDropExperimental") : (t.addObserver(Al), t.addObserver(il), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDropMarker(), this._setupDraggableAttributeHandling(), this.listenTo(e, "change:isReadOnly", (n, i, r) => {
            r ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
          }), this.on("change:isEnabled", (n, i, r) => {
            r || this._finalizeDragging(!1);
          }), k.isAndroid && this.forceDisabled("noAndroidSupport"));
        }
        destroy() {
          return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._updateDropMarkerThrottled.cancel(), this._removeDropMarkerDelayed.cancel(), this._clearDraggableAttributesDelayed.cancel(), super.destroy();
        }
        _setupDragging() {
          const e = this.editor, t = e.model, n = t.document, i = e.editing.view, r = i.document;
          this.listenTo(r, "dragstart", (s, a) => {
            const l = n.selection;
            if (a.target && a.target.is("editableElement"))
              return void a.preventDefault();
            const d = a.target ? mp(a.target) : null;
            if (d) {
              const _ = e.editing.mapper.toModelElement(d);
              this._draggedRange = fn.fromRange(t.createRangeOn(_)), e.plugins.has("WidgetToolbarRepository") && e.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
            } else if (!r.selection.isCollapsed) {
              const _ = r.selection.getSelectedElement();
              _ && Je(_) || (this._draggedRange = fn.fromRange(l.getFirstRange()));
            }
            if (!this._draggedRange)
              return void a.preventDefault();
            this._draggingUid = ne();
            const h = this.isEnabled && e.model.canEditAt(this._draggedRange);
            a.dataTransfer.effectAllowed = h ? "copyMove" : "copy", a.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
            const m = t.createSelection(this._draggedRange.toRange()), f = e.data.toView(t.getSelectedContent(m));
            r.fire("clipboardOutput", { dataTransfer: a.dataTransfer, content: f, method: "dragstart" }), h || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
          }, { priority: "low" }), this.listenTo(r, "dragend", (s, a) => {
            this._finalizeDragging(!a.dataTransfer.isCanceled && a.dataTransfer.dropEffect == "move");
          }, { priority: "low" }), this.listenTo(r, "dragenter", () => {
            this.isEnabled && i.focus();
          }), this.listenTo(r, "dragleave", () => {
            this._removeDropMarkerDelayed();
          }), this.listenTo(r, "dragging", (s, a) => {
            if (!this.isEnabled)
              return void (a.dataTransfer.dropEffect = "none");
            this._removeDropMarkerDelayed.cancel();
            const l = hp(e, a.targetRanges, a.target);
            e.model.canEditAt(l) ? (this._draggedRange || (a.dataTransfer.dropEffect = "copy"), k.isGecko || (a.dataTransfer.effectAllowed == "copy" ? a.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(a.dataTransfer.effectAllowed) && (a.dataTransfer.dropEffect = "move")), l && this._updateDropMarkerThrottled(l)) : a.dataTransfer.dropEffect = "none";
          }, { priority: "low" });
        }
        _setupClipboardInputIntegration() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "clipboardInput", (n, i) => {
            if (i.method != "drop")
              return;
            const r = hp(e, i.targetRanges, i.target);
            if (this._removeDropMarker(), !r || !e.model.canEditAt(r))
              return this._finalizeDragging(!1), void n.stop();
            if (this._draggedRange && this._draggingUid != i.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = ""), gp(i.dataTransfer) == "move" && this._draggedRange && this._draggedRange.containsRange(r, !0))
              return this._finalizeDragging(!1), void n.stop();
            i.targetRanges = [e.editing.mapper.toViewRange(r)];
          }, { priority: "high" });
        }
        _setupContentInsertionIntegration() {
          const e = this.editor.plugins.get(vn);
          e.on("contentInsertion", (t, n) => {
            if (!this.isEnabled || n.method !== "drop")
              return;
            const i = n.targetRanges.map((r) => this.editor.editing.mapper.toModelRange(r));
            this.editor.model.change((r) => r.setSelection(i));
          }, { priority: "high" }), e.on("contentInsertion", (t, n) => {
            if (!this.isEnabled || n.method !== "drop")
              return;
            const i = gp(n.dataTransfer) == "move", r = !n.resultRange || !n.resultRange.isCollapsed;
            this._finalizeDragging(r && i);
          }, { priority: "lowest" });
        }
        _setupDraggableAttributeHandling() {
          const e = this.editor, t = e.editing.view, n = t.document;
          this.listenTo(n, "mousedown", (i, r) => {
            if (k.isAndroid || !r)
              return;
            this._clearDraggableAttributesDelayed.cancel();
            let s = mp(r.target);
            if (k.isBlink && !s && !n.selection.isCollapsed) {
              const a = n.selection.getSelectedElement();
              if (!a || !Je(a)) {
                const l = n.selection.editableElement;
                l && !l.isReadOnly && (s = l);
              }
            }
            s && (t.change((a) => {
              a.setAttribute("draggable", "true", s);
            }), this._draggableElement = e.editing.mapper.toModelElement(s));
          }), this.listenTo(n, "mouseup", () => {
            k.isAndroid || this._clearDraggableAttributesDelayed();
          });
        }
        _clearDraggableAttributes() {
          const e = this.editor.editing;
          e.view.change((t) => {
            this._draggableElement && this._draggableElement.root.rootName != "$graveyard" && t.removeAttribute("draggable", e.mapper.toViewElement(this._draggableElement)), this._draggableElement = null;
          });
        }
        _setupDropMarker() {
          const e = this.editor;
          e.conversion.for("editingDowncast").markerToHighlight({ model: "drop-target", view: { classes: ["ck-clipboard-drop-target-range"] } }), e.conversion.for("editingDowncast").markerToElement({ model: "drop-target", view: (t, { writer: n }) => {
            if (e.model.schema.checkChild(t.markerRange.start, "$text"))
              return n.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(i) {
                const r = this.toDomElement(i);
                return r.append("⁠", i.createElement("span"), "⁠"), r;
              });
          } });
        }
        _updateDropMarker(e) {
          const t = this.editor, n = t.model.markers;
          t.model.change((i) => {
            n.has("drop-target") ? n.get("drop-target").getRange().isEqual(e) || i.updateMarker("drop-target", { range: e }) : i.addMarker("drop-target", { range: e, usingOperation: !1, affectsData: !1 });
          });
        }
        _removeDropMarker() {
          const e = this.editor.model;
          this._removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), e.markers.has("drop-target") && e.change((t) => {
            t.removeMarker("drop-target");
          });
        }
        _finalizeDragging(e) {
          const t = this.editor, n = t.model;
          this._removeDropMarker(), this._clearDraggableAttributes(), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._draggedRange && (e && this.isEnabled && n.deleteContent(n.createSelection(this._draggedRange), { doNotAutoparagraph: !0 }), this._draggedRange.detach(), this._draggedRange = null);
        }
      }
      function hp(o, e, t) {
        const n = o.model, i = o.editing.mapper;
        let r = null;
        const s = e ? e[0].start : null;
        if (t.is("uiElement") && (t = t.parent), r = function(d, h) {
          const m = d.model, f = d.editing.mapper;
          if (Je(h))
            return m.createRangeOn(f.toModelElement(h));
          if (!h.is("editableElement")) {
            const _ = h.findAncestor((S) => Je(S) || S.is("editableElement"));
            if (Je(_))
              return m.createRangeOn(f.toModelElement(_));
          }
          return null;
        }(o, t), r)
          return r;
        const a = function(d, h) {
          const m = d.editing.mapper, f = d.editing.view, _ = m.toModelElement(h);
          if (_)
            return _;
          const S = f.createPositionBefore(h), B = m.findMappedViewAncestor(S);
          return m.toModelElement(B);
        }(o, t), l = s ? i.toModelPosition(s) : null;
        return l ? (r = function(d, h, m) {
          const f = d.model;
          if (!f.schema.checkChild(m, "$block"))
            return null;
          const _ = f.createPositionAt(m, 0), S = h.path.slice(0, _.path.length), B = f.createPositionFromPath(h.root, S), T = B.nodeAfter;
          return T && f.schema.isObject(T) ? f.createRangeOn(T) : null;
        }(o, l, a), r || (r = n.schema.getNearestSelectionRange(l, k.isGecko ? "forward" : "backward"), r || function(d, h) {
          const m = d.model;
          let f = h;
          for (; f; ) {
            if (m.schema.isObject(f))
              return m.createRangeOn(f);
            f = f.parent;
          }
          return null;
        }(o, l.parent))) : function(d, h) {
          const m = d.model, f = m.schema, _ = m.createPositionAt(h, 0);
          return f.getNearestSelectionRange(_, "forward");
        }(o, a);
      }
      function gp(o) {
        return k.isGecko ? o.dropEffect : ["all", "copyMove"].includes(o.effectAllowed) ? "move" : "copy";
      }
      function mp(o) {
        if (o.is("editableElement"))
          return null;
        if (o.hasClass("ck-widget__selection-handle"))
          return o.findAncestor(Je);
        if (Je(o))
          return o;
        const e = o.findAncestor((t) => Je(t) || t.is("editableElement"));
        return Je(e) ? e : null;
      }
      class _2 extends W {
        static get pluginName() {
          return "PastePlainText";
        }
        static get requires() {
          return [vn];
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view, i = n.document, r = t.document.selection;
          let s = !1;
          n.addObserver(Al), this.listenTo(i, "keydown", (a, l) => {
            s = l.shiftKey;
          }), e.plugins.get(vn).on("contentInsertion", (a, l) => {
            (s || function(d, h) {
              if (d.childCount > 1)
                return !1;
              const m = d.getChild(0);
              return h.isObject(m) ? !1 : Array.from(m.getAttributeKeys()).length == 0;
            }(l.content, t.schema)) && t.change((d) => {
              const h = Array.from(r.getAttributes()).filter(([f]) => t.schema.getAttributeProperties(f).isFormatting);
              r.isCollapsed || t.deleteContent(r, { doNotAutoparagraph: !0 }), h.push(...r.getAttributes());
              const m = d.createRangeIn(l.content);
              for (const f of m.getItems())
                f.is("$textProxy") && d.setAttributes(h, f);
            });
          });
        }
      }
      class A2 extends W {
        static get pluginName() {
          return "Clipboard";
        }
        static get requires() {
          return [vn, v2, _2];
        }
      }
      class C2 extends be {
        constructor(e) {
          super(e), this.affectsData = !1;
        }
        execute() {
          const e = this.editor.model, t = e.document.selection;
          let n = e.schema.getLimitElement(t);
          if (t.containsEntireContent(n) || !pp(e.schema, n))
            do
              if (n = n.parent, !n)
                return;
            while (!pp(e.schema, n));
          e.change((i) => {
            i.setSelection(n, "in");
          });
        }
      }
      function pp(o, e) {
        return o.isLimit(e) && (o.checkChild(e, "$text") || o.checkChild(e, "paragraph"));
      }
      const y2 = Br("Ctrl+A");
      class E2 extends W {
        static get pluginName() {
          return "SelectAllEditing";
        }
        init() {
          const e = this.editor, t = e.editing.view.document;
          e.commands.add("selectAll", new C2(e)), this.listenTo(t, "keydown", (n, i) => {
            zo(i) === y2 && (e.execute("selectAll"), i.preventDefault());
          });
        }
      }
      class x2 extends W {
        static get pluginName() {
          return "SelectAllUI";
        }
        init() {
          const e = this.editor;
          e.ui.componentFactory.add("selectAll", (t) => {
            const n = e.commands.get("selectAll"), i = new je(t), r = t.t;
            return i.set({ label: r("Select all"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>', keystroke: "Ctrl+A", tooltip: !0 }), i.bind("isEnabled").to(n, "isEnabled"), this.listenTo(i, "execute", () => {
              e.execute("selectAll"), e.editing.view.focus();
            }), i;
          });
        }
      }
      class S2 extends W {
        static get requires() {
          return [E2, x2];
        }
        static get pluginName() {
          return "SelectAll";
        }
      }
      var D2 = Object.defineProperty, fp = Object.getOwnPropertySymbols, B2 = Object.prototype.hasOwnProperty, T2 = Object.prototype.propertyIsEnumerable, bp = (o, e, t) => e in o ? D2(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class kp extends be {
        constructor(e) {
          super(e), this._stack = [], this._createdBatches = /* @__PURE__ */ new WeakSet(), this.refresh(), this._isEnabledBasedOnSelection = !1, this.listenTo(e.data, "set", (t, n) => {
            n[1] = ((r, s) => {
              for (var a in s || (s = {}))
                B2.call(s, a) && bp(r, a, s[a]);
              if (fp)
                for (var a of fp(s))
                  T2.call(s, a) && bp(r, a, s[a]);
              return r;
            })({}, n[1]);
            const i = n[1];
            i.batchType || (i.batchType = { isUndoable: !1 });
          }, { priority: "high" }), this.listenTo(e.data, "set", (t, n) => {
            n[1].batchType.isUndoable || this.clearStack();
          });
        }
        refresh() {
          this.isEnabled = this._stack.length > 0;
        }
        get createdBatches() {
          return this._createdBatches;
        }
        addBatch(e) {
          const t = this.editor.model.document.selection, n = { ranges: t.hasOwnRange ? Array.from(t.getRanges()) : [], isBackward: t.isBackward };
          this._stack.push({ batch: e, selection: n }), this.refresh();
        }
        clearStack() {
          this._stack = [], this.refresh();
        }
        _restoreSelection(e, t, n) {
          const i = this.editor.model, r = i.document, s = [], a = e.map((d) => d.getTransformedByOperations(n)), l = a.flat();
          for (const d of a) {
            const h = d.filter((m) => m.root != r.graveyard).filter((m) => !P2(m, l));
            h.length && (I2(h), s.push(h[0]));
          }
          s.length && i.change((d) => {
            d.setSelection(s, { backward: t });
          });
        }
        _undo(e, t) {
          const n = this.editor.model, i = n.document;
          this._createdBatches.add(t);
          const r = e.operations.slice().filter((s) => s.isDocumentOperation);
          r.reverse();
          for (const s of r) {
            const a = s.baseVersion + 1, l = Array.from(i.history.getOperations(a)), d = n1([s.getReversed()], l, { useRelations: !0, document: this.editor.model.document, padWithNoOps: !1, forceWeakRemove: !0 }).operationsA;
            for (let h of d) {
              const m = h.affectedSelectable;
              m && !n.canEditAt(m) && (h = new ct(h.baseVersion)), t.addOperation(h), n.applyOperation(h), i.history.setOperationAsUndone(s, h);
            }
          }
        }
      }
      function I2(o) {
        o.sort((e, t) => e.start.isBefore(t.start) ? -1 : 1);
        for (let e = 1; e < o.length; e++) {
          const t = o[e - 1].getJoined(o[e], !0);
          t && (e--, o.splice(e, 2, t));
        }
      }
      function P2(o, e) {
        return e.some((t) => t !== o && t.containsRange(o, !0));
      }
      class O2 extends kp {
        execute(e = null) {
          const t = e ? this._stack.findIndex((r) => r.batch == e) : this._stack.length - 1, n = this._stack.splice(t, 1)[0], i = this.editor.model.createBatch({ isUndo: !0 });
          this.editor.model.enqueueChange(i, () => {
            this._undo(n.batch, i);
            const r = this.editor.model.document.history.getOperations(n.batch.baseVersion);
            this._restoreSelection(n.selection.ranges, n.selection.isBackward, r), this.fire("revert", n.batch, i);
          }), this.refresh();
        }
      }
      class R2 extends kp {
        execute() {
          const e = this._stack.pop(), t = this.editor.model.createBatch({ isUndo: !0 });
          this.editor.model.enqueueChange(t, () => {
            const n = e.batch.operations[e.batch.operations.length - 1].baseVersion + 1, i = this.editor.model.document.history.getOperations(n);
            this._restoreSelection(e.selection.ranges, e.selection.isBackward, i), this._undo(e.batch, t);
          }), this.refresh();
        }
      }
      class z2 extends W {
        constructor() {
          super(...arguments), this._batchRegistry = /* @__PURE__ */ new WeakSet();
        }
        static get pluginName() {
          return "UndoEditing";
        }
        init() {
          const e = this.editor;
          this._undoCommand = new O2(e), this._redoCommand = new R2(e), e.commands.add("undo", this._undoCommand), e.commands.add("redo", this._redoCommand), this.listenTo(e.model, "applyOperation", (t, n) => {
            const i = n[0];
            if (!i.isDocumentOperation)
              return;
            const r = i.batch, s = this._redoCommand.createdBatches.has(r), a = this._undoCommand.createdBatches.has(r);
            this._batchRegistry.has(r) || (this._batchRegistry.add(r), r.isUndoable && (s ? this._undoCommand.addBatch(r) : a || (this._undoCommand.addBatch(r), this._redoCommand.clearStack())));
          }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (t, n, i) => {
            this._redoCommand.addBatch(i);
          }), e.keystrokes.set("CTRL+Z", "undo"), e.keystrokes.set("CTRL+Y", "redo"), e.keystrokes.set("CTRL+SHIFT+Z", "redo");
        }
      }
      const wp = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', vp = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
      class M2 extends W {
        static get pluginName() {
          return "UndoUI";
        }
        init() {
          const e = this.editor, t = e.locale, n = e.t, i = t.uiLanguageDirection == "ltr" ? wp : vp, r = t.uiLanguageDirection == "ltr" ? vp : wp;
          this._addButton("undo", n("Undo"), "CTRL+Z", i), this._addButton("redo", n("Redo"), "CTRL+Y", r);
        }
        _addButton(e, t, n, i) {
          const r = this.editor;
          r.ui.componentFactory.add(e, (s) => {
            const a = r.commands.get(e), l = new je(s);
            return l.set({ label: t, icon: i, keystroke: n, tooltip: !0 }), l.bind("isEnabled").to(a, "isEnabled"), this.listenTo(l, "execute", () => {
              r.execute(e), r.editing.view.focus();
            }), l;
          });
        }
      }
      class N2 extends W {
        static get requires() {
          return [z2, M2];
        }
        static get pluginName() {
          return "Undo";
        }
      }
      class F2 extends re() {
        constructor() {
          super();
          const e = new window.FileReader();
          this._reader = e, this._data = void 0, this.set("loaded", 0), e.onprogress = (t) => {
            this.loaded = t.loaded;
          };
        }
        get error() {
          return this._reader.error;
        }
        get data() {
          return this._data;
        }
        read(e) {
          const t = this._reader;
          return this.total = e.size, new Promise((n, i) => {
            t.onload = () => {
              const r = t.result;
              this._data = r, n(r);
            }, t.onerror = () => {
              i("error");
            }, t.onabort = () => {
              i("aborted");
            }, this._reader.readAsDataURL(e);
          });
        }
        abort() {
          this._reader.abort();
        }
      }
      class An extends W {
        constructor() {
          super(...arguments), this.loaders = new Ht(), this._loadersMap = /* @__PURE__ */ new Map(), this._pendingAction = null;
        }
        static get pluginName() {
          return "FileRepository";
        }
        static get requires() {
          return [Qr];
        }
        init() {
          this.loaders.on("change", () => this._updatePendingAction()), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (e, t) => t ? e / t * 100 : 0);
        }
        getLoader(e) {
          return this._loadersMap.get(e) || null;
        }
        createLoader(e) {
          if (!this.createUploadAdapter)
            return oe("filerepository-no-upload-adapter"), null;
          const t = new _p(Promise.resolve(e), this.createUploadAdapter);
          return this.loaders.add(t), this._loadersMap.set(e, t), e instanceof Promise && t.file.then((n) => {
            this._loadersMap.set(n, t);
          }).catch(() => {
          }), t.on("change:uploaded", () => {
            let n = 0;
            for (const i of this.loaders)
              n += i.uploaded;
            this.uploaded = n;
          }), t.on("change:uploadTotal", () => {
            let n = 0;
            for (const i of this.loaders)
              i.uploadTotal && (n += i.uploadTotal);
            this.uploadTotal = n;
          }), t;
        }
        destroyLoader(e) {
          const t = e instanceof _p ? e : this.getLoader(e);
          t._destroy(), this.loaders.remove(t), this._loadersMap.forEach((n, i) => {
            n === t && this._loadersMap.delete(i);
          });
        }
        _updatePendingAction() {
          const e = this.editor.plugins.get(Qr);
          if (this.loaders.length) {
            if (!this._pendingAction) {
              const t = this.editor.t, n = (i) => `${t("Upload in progress")} ${parseInt(i)}%.`;
              this._pendingAction = e.add(n(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", n);
            }
          } else
            e.remove(this._pendingAction), this._pendingAction = null;
        }
      }
      class _p extends re() {
        constructor(e, t) {
          super(), this.id = ne(), this._filePromiseWrapper = this._createFilePromiseWrapper(e), this._adapter = t(this), this._reader = new F2(), this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (n, i) => i ? n / i * 100 : 0), this.set("uploadResponse", null);
        }
        get file() {
          return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((e) => this._filePromiseWrapper ? e : null) : Promise.resolve(null);
        }
        get data() {
          return this._reader.data;
        }
        read() {
          if (this.status != "idle")
            throw new O("filerepository-read-wrong-status", this);
          return this.status = "reading", this.file.then((e) => this._reader.read(e)).then((e) => {
            if (this.status !== "reading")
              throw this.status;
            return this.status = "idle", e;
          }).catch((e) => {
            throw e === "aborted" ? (this.status = "aborted", "aborted") : (this.status = "error", this._reader.error ? this._reader.error : e);
          });
        }
        upload() {
          if (this.status != "idle")
            throw new O("filerepository-upload-wrong-status", this);
          return this.status = "uploading", this.file.then(() => this._adapter.upload()).then((e) => (this.uploadResponse = e, this.status = "idle", e)).catch((e) => {
            throw this.status === "aborted" ? "aborted" : (this.status = "error", e);
          });
        }
        abort() {
          const e = this.status;
          this.status = "aborted", this._filePromiseWrapper.isFulfilled ? e == "reading" ? this._reader.abort() : e == "uploading" && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
          }), this._filePromiseWrapper.rejecter("aborted")), this._destroy();
        }
        _destroy() {
          this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0;
        }
        _createFilePromiseWrapper(e) {
          const t = {};
          return t.promise = new Promise((n, i) => {
            t.rejecter = i, t.isFulfilled = !1, e.then((r) => {
              t.isFulfilled = !0, n(r);
            }).catch((r) => {
              t.isFulfilled = !0, i(r);
            });
          }), t;
        }
      }
      class $2 extends _e {
        constructor(e) {
          super(e), this.buttonView = new je(e), this._fileInputView = new V2(e), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.setTemplate({ tag: "span", attributes: { class: "ck-file-dialog-button" }, children: [this.buttonView, this._fileInputView] }), this.buttonView.on("execute", () => {
            this._fileInputView.open();
          });
        }
        focus() {
          this.buttonView.focus();
        }
      }
      class V2 extends _e {
        constructor(e) {
          super(e), this.set("acceptedType", void 0), this.set("allowMultipleFiles", !1);
          const t = this.bindTemplate;
          this.setTemplate({ tag: "input", attributes: { class: ["ck-hidden"], type: "file", tabindex: "-1", accept: t.to("acceptedType"), multiple: t.to("allowMultipleFiles") }, on: { change: t.to(() => {
            this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = "";
          }) } });
        }
        open() {
          this.element.click();
        }
      }
      const Ap = "ckCsrfToken", Cp = "abcdefghijklmnopqrstuvwxyz0123456789";
      function L2() {
        let o = function(n) {
          n = n.toLowerCase();
          const i = document.cookie.split(";");
          for (const r of i) {
            const s = r.split("=");
            if (decodeURIComponent(s[0].trim().toLowerCase()) === n)
              return decodeURIComponent(s[1]);
          }
          return null;
        }(Ap);
        var e, t;
        return o && o.length == 40 || (o = function(n) {
          let i = "";
          const r = new Uint8Array(n);
          window.crypto.getRandomValues(r);
          for (let s = 0; s < r.length; s++) {
            const a = Cp.charAt(r[s] % Cp.length);
            i += Math.random() > 0.5 ? a.toUpperCase() : a;
          }
          return i;
        }(40), e = Ap, t = o, document.cookie = encodeURIComponent(e) + "=" + encodeURIComponent(t) + ";path=/"), o;
      }
      class j2 {
        constructor(e, t, n) {
          this.loader = e, this.url = t, this.t = n;
        }
        upload() {
          return this.loader.file.then((e) => new Promise((t, n) => {
            this._initRequest(), this._initListeners(t, n, e), this._sendRequest(e);
          }));
        }
        abort() {
          this.xhr && this.xhr.abort();
        }
        _initRequest() {
          const e = this.xhr = new XMLHttpRequest();
          e.open("POST", this.url, !0), e.responseType = "json";
        }
        _initListeners(e, t, n) {
          const i = this.xhr, r = this.loader, s = (0, this.t)("Cannot upload file:") + ` ${n.name}.`;
          i.addEventListener("error", () => t(s)), i.addEventListener("abort", () => t()), i.addEventListener("load", () => {
            const a = i.response;
            if (!a || !a.uploaded)
              return t(a && a.error && a.error.message ? a.error.message : s);
            e({ default: a.url });
          }), i.upload && i.upload.addEventListener("progress", (a) => {
            a.lengthComputable && (r.uploadTotal = a.total, r.uploaded = a.loaded);
          });
        }
        _sendRequest(e) {
          const t = new FormData();
          t.append("upload", e), t.append("ckCsrfToken", L2()), this.xhr.send(t);
        }
      }
      class Dl extends be {
        constructor(e, t) {
          super(e), this.attributeKey = t;
        }
        refresh() {
          const e = this.editor.model, t = e.document;
          this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey);
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document.selection, i = e.forceValue === void 0 ? !this.value : e.forceValue;
          t.change((r) => {
            if (n.isCollapsed)
              i ? r.setSelectionAttribute(this.attributeKey, !0) : r.removeSelectionAttribute(this.attributeKey);
            else {
              const s = t.schema.getValidRanges(n.getRanges(), this.attributeKey);
              for (const a of s)
                i ? r.setAttribute(this.attributeKey, i, a) : r.removeAttribute(this.attributeKey, a);
            }
          });
        }
        _getValueFromFirstAllowedNode() {
          const e = this.editor.model, t = e.schema, n = e.document.selection;
          if (n.isCollapsed)
            return n.hasAttribute(this.attributeKey);
          for (const i of n.getRanges())
            for (const r of i.getItems())
              if (t.checkAttribute(r, this.attributeKey))
                return r.hasAttribute(this.attributeKey);
          return !1;
        }
      }
      const Zo = "bold";
      class H2 extends W {
        static get pluginName() {
          return "BoldEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: Zo }), e.model.schema.setAttributeProperties(Zo, { isFormatting: !0, copyOnEnter: !0 }), e.conversion.attributeToElement({ model: Zo, view: "strong", upcastAlso: ["b", (t) => {
            const n = t.getStyle("font-weight");
            return n && (n == "bold" || Number(n) >= 600) ? { name: !0, styles: ["font-weight"] } : null;
          }] }), e.commands.add(Zo, new Dl(e, Zo)), e.keystrokes.set("CTRL+B", Zo);
        }
      }
      const Bl = "bold";
      class U2 extends W {
        static get pluginName() {
          return "BoldUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(Bl, (n) => {
            const i = e.commands.get(Bl), r = new je(n);
            return r.set({ label: t("Bold"), icon: qe.bold, keystroke: "CTRL+B", tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(Bl), e.editing.view.focus();
            }), r;
          });
        }
      }
      var yp = b(8603), q2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(yp.Z, q2), yp.Z.locals;
      const Jo = "italic";
      class W2 extends W {
        static get pluginName() {
          return "ItalicEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: Jo }), e.model.schema.setAttributeProperties(Jo, { isFormatting: !0, copyOnEnter: !0 }), e.conversion.attributeToElement({ model: Jo, view: "i", upcastAlso: ["em", { styles: { "font-style": "italic" } }] }), e.commands.add(Jo, new Dl(e, Jo)), e.keystrokes.set("CTRL+I", Jo);
        }
      }
      const Tl = "italic";
      class G2 extends W {
        static get pluginName() {
          return "ItalicUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(Tl, (n) => {
            const i = e.commands.get(Tl), r = new je(n);
            return r.set({ label: t("Italic"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>', keystroke: "CTRL+I", tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(Tl), e.editing.view.focus();
            }), r;
          });
        }
      }
      const Gi = "underline";
      class K2 extends W {
        static get pluginName() {
          return "UnderlineEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: Gi }), e.model.schema.setAttributeProperties(Gi, { isFormatting: !0, copyOnEnter: !0 }), e.conversion.attributeToElement({ model: Gi, view: "u", upcastAlso: { styles: { "text-decoration": "underline" } } }), e.commands.add(Gi, new Dl(e, Gi)), e.keystrokes.set("CTRL+U", "underline");
        }
      }
      const Il = "underline";
      class Z2 extends W {
        static get pluginName() {
          return "UnderlineUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(Il, (n) => {
            const i = e.commands.get(Il), r = new je(n);
            return r.set({ label: t("Underline"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>', keystroke: "CTRL+U", tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(Il), e.editing.view.focus();
            }), r;
          });
        }
      }
      class J2 extends be {
        refresh() {
          this.value = this._getValue(), this.isEnabled = this._checkEnabled();
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.schema, i = t.document.selection, r = Array.from(i.getSelectedBlocks()), s = e.forceValue === void 0 ? !this.value : e.forceValue;
          t.change((a) => {
            if (s) {
              const l = r.filter((d) => hs(d) || xp(n, d));
              this._applyQuote(a, l);
            } else
              this._removeQuote(a, r.filter(hs));
          });
        }
        _getValue() {
          const e = it(this.editor.model.document.selection.getSelectedBlocks());
          return !(!e || !hs(e));
        }
        _checkEnabled() {
          if (this.value)
            return !0;
          const e = this.editor.model.document.selection, t = this.editor.model.schema, n = it(e.getSelectedBlocks());
          return !!n && xp(t, n);
        }
        _removeQuote(e, t) {
          Ep(e, t).reverse().forEach((n) => {
            if (n.start.isAtStart && n.end.isAtEnd)
              return void e.unwrap(n.start.parent);
            if (n.start.isAtStart) {
              const r = e.createPositionBefore(n.start.parent);
              return void e.move(n, r);
            }
            n.end.isAtEnd || e.split(n.end);
            const i = e.createPositionAfter(n.end.parent);
            e.move(n, i);
          });
        }
        _applyQuote(e, t) {
          const n = [];
          Ep(e, t).reverse().forEach((i) => {
            let r = hs(i.start);
            r || (r = e.createElement("blockQuote"), e.wrap(i, r)), n.push(r);
          }), n.reverse().reduce((i, r) => i.nextSibling == r ? (e.merge(e.createPositionAfter(i)), i) : r);
        }
      }
      function hs(o) {
        return o.parent.name == "blockQuote" ? o.parent : null;
      }
      function Ep(o, e) {
        let t, n = 0;
        const i = [];
        for (; n < e.length; ) {
          const r = e[n], s = e[n + 1];
          t || (t = o.createPositionBefore(r)), s && r.nextSibling == s || (i.push(o.createRange(t, o.createPositionAfter(r))), t = null), n++;
        }
        return i;
      }
      function xp(o, e) {
        const t = o.checkChild(e.parent, "blockQuote"), n = o.checkChild(["$root", "blockQuote"], e);
        return t && n;
      }
      class Y2 extends W {
        static get pluginName() {
          return "BlockQuoteEditing";
        }
        static get requires() {
          return [qi, Wo];
        }
        init() {
          const e = this.editor, t = e.model.schema;
          e.commands.add("blockQuote", new J2(e)), t.register("blockQuote", { inheritAllFrom: "$container" }), e.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }), e.model.document.registerPostFixer((s) => {
            const a = e.model.document.differ.getChanges();
            for (const l of a)
              if (l.type == "insert") {
                const d = l.position.nodeAfter;
                if (!d)
                  continue;
                if (d.is("element", "blockQuote") && d.isEmpty)
                  return s.remove(d), !0;
                if (d.is("element", "blockQuote") && !t.checkChild(l.position, d))
                  return s.unwrap(d), !0;
                if (d.is("element")) {
                  const h = s.createRangeIn(d);
                  for (const m of h.getItems())
                    if (m.is("element", "blockQuote") && !t.checkChild(s.createPositionBefore(m), m))
                      return s.unwrap(m), !0;
                }
              } else if (l.type == "remove") {
                const d = l.position.parent;
                if (d.is("element", "blockQuote") && d.isEmpty)
                  return s.remove(d), !0;
              }
            return !1;
          });
          const n = this.editor.editing.view.document, i = e.model.document.selection, r = e.commands.get("blockQuote");
          this.listenTo(n, "enter", (s, a) => {
            !i.isCollapsed || !r.value || i.getLastPosition().parent.isEmpty && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), s.stop());
          }, { context: "blockquote" }), this.listenTo(n, "delete", (s, a) => {
            if (a.direction != "backward" || !i.isCollapsed || !r.value)
              return;
            const l = i.getLastPosition().parent;
            l.isEmpty && !l.previousSibling && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), s.stop());
          }, { context: "blockquote" });
        }
      }
      var Sp = b(3062), Q2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Sp.Z, Q2), Sp.Z.locals;
      class X2 extends W {
        static get pluginName() {
          return "BlockQuoteUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add("blockQuote", (n) => {
            const i = e.commands.get("blockQuote"), r = new je(n);
            return r.set({ label: t("Block quote"), icon: qe.quote, tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute("blockQuote"), e.editing.view.focus();
            }), r;
          });
        }
      }
      class eE extends W {
        static get pluginName() {
          return "CloudServicesUploadAdapter";
        }
        static get requires() {
          return ["CloudServices", An];
        }
        init() {
          const e = this.editor, t = e.plugins.get("CloudServices"), n = t.token, i = t.uploadUrl;
          if (!n)
            return;
          const r = e.plugins.get("CloudServicesCore");
          this._uploadGateway = r.createUploadGateway(n, i), e.plugins.get(An).createUploadAdapter = (s) => new tE(this._uploadGateway, s);
        }
      }
      class tE {
        constructor(e, t) {
          this.uploadGateway = e, this.loader = t;
        }
        upload() {
          return this.loader.file.then((e) => (this.fileUploader = this.uploadGateway.upload(e), this.fileUploader.on("progress", (t, n) => {
            this.loader.uploadTotal = n.total, this.loader.uploaded = n.uploaded;
          }), this.fileUploader.send()));
        }
        abort() {
          this.fileUploader.abort();
        }
      }
      class nE extends be {
        constructor(e) {
          super(e), this._isEnabledBasedOnSelection = !1;
        }
        refresh() {
          const e = this.editor.model, t = it(e.document.selection.getSelectedBlocks());
          this.value = !!t && t.is("element", "paragraph"), this.isEnabled = !!t && Dp(t, e.schema);
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document, i = e.selection || n.selection;
          t.canEditAt(i) && t.change((r) => {
            const s = i.getSelectedBlocks();
            for (const a of s)
              !a.is("element", "paragraph") && Dp(a, t.schema) && r.rename(a, "paragraph");
          });
        }
      }
      function Dp(o, e) {
        return e.checkChild(o.parent, "paragraph") && !e.isObject(o);
      }
      class oE extends be {
        constructor(e) {
          super(e), this._isEnabledBasedOnSelection = !1;
        }
        execute(e) {
          const t = this.editor.model, n = e.attributes;
          let i = e.position;
          t.canEditAt(i) && t.change((r) => {
            const s = r.createElement("paragraph");
            if (n && t.schema.setAllowedAttributes(s, n, r), !t.schema.checkChild(i.parent, s)) {
              const a = t.schema.findAllowedParent(i, s);
              if (!a)
                return;
              i = r.split(i, a).position;
            }
            t.insertContent(s, i), r.setSelection(s, "in");
          });
        }
      }
      const Bp = class extends W {
        static get pluginName() {
          return "Paragraph";
        }
        init() {
          const o = this.editor, e = o.model;
          o.commands.add("paragraph", new nE(o)), o.commands.add("insertParagraph", new oE(o)), e.schema.register("paragraph", { inheritAllFrom: "$block" }), o.conversion.elementToElement({ model: "paragraph", view: "p" }), o.conversion.for("upcast").elementToElement({ model: (t, { writer: n }) => Bp.paragraphLikeElements.has(t.name) ? t.isEmpty ? null : n.createElement("paragraph") : null, view: /.+/, converterPriority: "low" });
        }
      };
      let Pl = Bp;
      Pl.paragraphLikeElements = /* @__PURE__ */ new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);
      class iE extends be {
        constructor(e, t) {
          super(e), this.modelElements = t;
        }
        refresh() {
          const e = it(this.editor.model.document.selection.getSelectedBlocks());
          this.value = !!e && this.modelElements.includes(e.name) && e.name, this.isEnabled = !!e && this.modelElements.some((t) => Tp(e, t, this.editor.model.schema));
        }
        execute(e) {
          const t = this.editor.model, n = t.document, i = e.value;
          t.change((r) => {
            const s = Array.from(n.selection.getSelectedBlocks()).filter((a) => Tp(a, i, t.schema));
            for (const a of s)
              a.is("element", i) || r.rename(a, i);
          });
        }
      }
      function Tp(o, e, t) {
        return t.checkChild(o.parent, e) && !t.isObject(o);
      }
      const Ip = "paragraph";
      class rE extends W {
        static get pluginName() {
          return "HeadingEditing";
        }
        constructor(e) {
          super(e), e.config.define("heading", { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }] });
        }
        static get requires() {
          return [Pl];
        }
        init() {
          const e = this.editor, t = e.config.get("heading.options"), n = [];
          for (const i of t)
            i.model !== "paragraph" && (e.model.schema.register(i.model, { inheritAllFrom: "$block" }), e.conversion.elementToElement(i), n.push(i.model));
          this._addDefaultH1Conversion(e), e.commands.add("heading", new iE(e, n));
        }
        afterInit() {
          const e = this.editor, t = e.commands.get("enter"), n = e.config.get("heading.options");
          t && this.listenTo(t, "afterExecute", (i, r) => {
            const s = e.model.document.selection.getFirstPosition().parent;
            n.some((a) => s.is("element", a.model)) && !s.is("element", Ip) && s.childCount === 0 && r.writer.rename(s, Ip);
          });
        }
        _addDefaultH1Conversion(e) {
          e.conversion.for("upcast").elementToElement({ model: "heading1", view: "h1", converterPriority: se.get("low") + 1 });
        }
      }
      var Pp = b(8733), sE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Pp.Z, sE), Pp.Z.locals;
      class aE extends W {
        static get pluginName() {
          return "HeadingUI";
        }
        init() {
          const e = this.editor, t = e.t, n = function(s) {
            const a = s.t, l = { Paragraph: a("Paragraph"), "Heading 1": a("Heading 1"), "Heading 2": a("Heading 2"), "Heading 3": a("Heading 3"), "Heading 4": a("Heading 4"), "Heading 5": a("Heading 5"), "Heading 6": a("Heading 6") };
            return s.config.get("heading.options").map((d) => {
              const h = l[d.title];
              return h && h != d.title && (d.title = h), d;
            });
          }(e), i = t("Choose heading"), r = t("Heading");
          e.ui.componentFactory.add("heading", (s) => {
            const a = {}, l = new Ht(), d = e.commands.get("heading"), h = e.commands.get("paragraph"), m = [d];
            for (const _ of n) {
              const S = { type: "button", model: new vl({ label: _.title, class: _.class, role: "menuitemradio", withText: !0 }) };
              _.model === "paragraph" ? (S.model.bind("isOn").to(h, "value"), S.model.set("commandName", "paragraph"), m.push(h)) : (S.model.bind("isOn").to(d, "value", (B) => B === _.model), S.model.set({ commandName: "heading", commandValue: _.model })), l.add(S), a[_.model] = _.title;
            }
            const f = wn(s);
            return ll(f, l, { ariaLabel: r, role: "menu" }), f.buttonView.set({ ariaLabel: r, ariaLabelledBy: void 0, isOn: !1, withText: !0, tooltip: r }), f.extendTemplate({ attributes: { class: ["ck-heading-dropdown"] } }), f.bind("isEnabled").toMany(m, "isEnabled", (..._) => _.some((S) => S)), f.buttonView.bind("label").to(d, "value", h, "value", (_, S) => {
              const B = _ || S && "paragraph";
              return typeof B == "boolean" ? i : a[B] ? a[B] : i;
            }), this.listenTo(f, "execute", (_) => {
              const { commandName: S, commandValue: B } = _.source;
              e.execute(S, B ? { value: B } : void 0), e.editing.view.focus();
            }), f;
          });
        }
      }
      function Op(o) {
        return o.createContainerElement("figure", { class: "image" }, [o.createEmptyElement("img"), o.createSlot("children")]);
      }
      function Rp(o, e) {
        const t = o.plugins.get("ImageUtils"), n = o.plugins.has("ImageInlineEditing") && o.plugins.has("ImageBlockEditing");
        return (r) => t.isInlineImageView(r) ? n && (r.getStyle("display") == "block" || r.findAncestor(t.isBlockImageView) ? "imageBlock" : "imageInline") !== e ? null : i(r) : null;
        function i(r) {
          const s = { name: !0 };
          return r.hasAttribute("src") && (s.attributes = ["src"]), s;
        }
      }
      function Ol(o, e) {
        const t = it(e.getSelectedBlocks());
        return !t || o.isObject(t) || t.isEmpty && t.name != "listItem" ? "imageBlock" : "imageInline";
      }
      var lE = Object.defineProperty, zp = Object.getOwnPropertySymbols, cE = Object.prototype.hasOwnProperty, dE = Object.prototype.propertyIsEnumerable, Mp = (o, e, t) => e in o ? lE(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Np = (o, e) => {
        for (var t in e || (e = {}))
          cE.call(e, t) && Mp(o, t, e[t]);
        if (zp)
          for (var t of zp(e))
            dE.call(e, t) && Mp(o, t, e[t]);
        return o;
      };
      class Cn extends W {
        static get pluginName() {
          return "ImageUtils";
        }
        isImage(e) {
          return this.isInlineImage(e) || this.isBlockImage(e);
        }
        isInlineImageView(e) {
          return !!e && e.is("element", "img");
        }
        isBlockImageView(e) {
          return !!e && e.is("element", "figure") && e.hasClass("image");
        }
        insertImage(e = {}, t = null, n = null) {
          const i = this.editor, r = i.model, s = r.document.selection;
          n = Fp(i, t || s, n), e = Np(Np({}, Object.fromEntries(s.getAttributes())), e);
          for (const a in e)
            r.schema.checkAttribute(n, a) || delete e[a];
          return r.change((a) => {
            const l = a.createElement(n, e);
            return r.insertObject(l, t, null, { setSelection: "on", findOptimalPosition: t || n == "imageInline" ? void 0 : "auto" }), l.parent ? l : null;
          });
        }
        getClosestSelectedImageWidget(e) {
          const t = e.getFirstPosition();
          if (!t)
            return null;
          const n = e.getSelectedElement();
          if (n && this.isImageWidget(n))
            return n;
          let i = t.parent;
          for (; i; ) {
            if (i.is("element") && this.isImageWidget(i))
              return i;
            i = i.parent;
          }
          return null;
        }
        getClosestSelectedImageElement(e) {
          const t = e.getSelectedElement();
          return this.isImage(t) ? t : e.getFirstPosition().findAncestor("imageBlock");
        }
        isImageAllowed() {
          const e = this.editor.model.document.selection;
          return function(t, n) {
            if (Fp(t, n, null) == "imageBlock") {
              const r = function(s, a) {
                const l = function(h, m) {
                  const f = h.getSelectedElement();
                  if (f) {
                    const _ = Mn(h);
                    if (_)
                      return m.createRange(m.createPositionAt(f, _));
                  }
                  return Lg(h, m);
                }(s, a), d = l.start.parent;
                return d.isEmpty && !d.is("element", "$root") ? d.parent : d;
              }(n, t.model);
              if (t.model.schema.checkChild(r, "imageBlock"))
                return !0;
            } else if (t.model.schema.checkChild(n.focus, "imageInline"))
              return !0;
            return !1;
          }(this.editor, e) && function(t) {
            return [...t.focus.getAncestors()].every((n) => !n.is("element", "imageBlock"));
          }(e);
        }
        toImageWidget(e, t, n) {
          return t.setCustomProperty("image", !0, e), Sl(e, t, { label: () => {
            const i = this.findViewImgElement(e).getAttribute("alt");
            return i ? `${i} ${n}` : n;
          } });
        }
        isImageWidget(e) {
          return !!e.getCustomProperty("image") && Je(e);
        }
        isBlockImage(e) {
          return !!e && e.is("element", "imageBlock");
        }
        isInlineImage(e) {
          return !!e && e.is("element", "imageInline");
        }
        findViewImgElement(e) {
          if (this.isInlineImageView(e))
            return e;
          const t = this.editor.editing.view;
          for (const { item: n } of t.createRangeIn(e))
            if (this.isInlineImageView(n))
              return n;
        }
      }
      function Fp(o, e, t) {
        const n = o.model.schema, i = o.config.get("image.insert.type");
        return o.plugins.has("ImageBlockEditing") ? o.plugins.has("ImageInlineEditing") ? t || (i === "inline" ? "imageInline" : i === "block" ? "imageBlock" : e.is("selection") ? Ol(n, e) : n.checkChild(e, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline";
      }
      class uE extends be {
        refresh() {
          const e = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
          this.isEnabled = !!e, this.isEnabled && e.hasAttribute("alt") ? this.value = e.getAttribute("alt") : this.value = !1;
        }
        execute(e) {
          const t = this.editor, n = t.plugins.get("ImageUtils"), i = t.model, r = n.getClosestSelectedImageElement(i.document.selection);
          i.change((s) => {
            s.setAttribute("alt", e.newValue, r);
          });
        }
      }
      class hE extends W {
        static get requires() {
          return [Cn];
        }
        static get pluginName() {
          return "ImageTextAlternativeEditing";
        }
        init() {
          this.editor.commands.add("imageTextAlternative", new uE(this.editor));
        }
      }
      var $p = b(1905), gE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()($p.Z, gE), $p.Z.locals;
      var Vp = b(6764), mE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Vp.Z, mE), Vp.Z.locals;
      class pE extends _e {
        constructor(e) {
          super(e);
          const t = this.locale.t;
          this.focusTracker = new Jt(), this.keystrokes = new mn(), this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(t("Save"), qe.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(t("Cancel"), qe.cancel, "ck-button-cancel", "cancel"), this._focusables = new Yn(), this._focusCycler = new Si({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.labeledInput, this.saveButtonView, this.cancelButtonView] });
        }
        render() {
          super.render(), this.keystrokes.listenTo(this.element), p({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((e) => {
            this._focusables.add(e), this.focusTracker.add(e.element);
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        _createButton(e, t, n, i) {
          const r = new je(this.locale);
          return r.set({ label: e, icon: t, tooltip: !0 }), r.extendTemplate({ attributes: { class: n } }), i && r.delegate("execute").to(this, i), r;
        }
        _createLabeledInputView() {
          const e = this.locale.t, t = new Du(this.locale, Qg);
          return t.label = e("Text alternative"), t;
        }
      }
      function Lp(o) {
        const e = o.editing.view, t = Tt.defaultPositions, n = o.plugins.get("ImageUtils");
        return { target: e.domConverter.mapViewToDom(n.getClosestSelectedImageWidget(e.document.selection)), positions: [t.northArrowSouth, t.northArrowSouthWest, t.northArrowSouthEast, t.southArrowNorth, t.southArrowNorthWest, t.southArrowNorthEast, t.viewportStickyNorth] };
      }
      class fE extends W {
        static get requires() {
          return [rs];
        }
        static get pluginName() {
          return "ImageTextAlternativeUI";
        }
        init() {
          this._createButton();
        }
        destroy() {
          super.destroy(), this._form && this._form.destroy();
        }
        _createButton() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add("imageTextAlternative", (n) => {
            const i = e.commands.get("imageTextAlternative"), r = new je(n);
            return r.set({ label: t("Change image text alternative"), icon: qe.lowVision, tooltip: !0 }), r.bind("isEnabled").to(i, "isEnabled"), r.bind("isOn").to(i, "value", (s) => !!s), this.listenTo(r, "execute", () => {
              this._showForm();
            }), r;
          });
        }
        _createForm() {
          const e = this.editor, t = e.editing.view.document, n = e.plugins.get("ImageUtils");
          this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (C(pE))(e.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
            e.execute("imageTextAlternative", { newValue: this._form.labeledInput.fieldView.element.value }), this._hideForm(!0);
          }), this.listenTo(this._form, "cancel", () => {
            this._hideForm(!0);
          }), this._form.keystrokes.set("Esc", (i, r) => {
            this._hideForm(!0), r();
          }), this.listenTo(e.ui, "update", () => {
            n.getClosestSelectedImageWidget(t.selection) ? this._isVisible && function(i) {
              const r = i.plugins.get("ContextualBalloon");
              if (i.plugins.get("ImageUtils").getClosestSelectedImageWidget(i.editing.view.document.selection)) {
                const s = Lp(i);
                r.updatePosition(s);
              }
            }(e) : this._hideForm(!0);
          }), v({ emitter: this._form, activator: () => this._isVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideForm() });
        }
        _showForm() {
          if (this._isVisible)
            return;
          this._form || this._createForm();
          const e = this.editor, t = e.commands.get("imageTextAlternative"), n = this._form.labeledInput;
          this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({ view: this._form, position: Lp(e) }), n.fieldView.value = n.fieldView.element.value = t.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
        }
        _hideForm(e = !1) {
          this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), e && this.editor.editing.view.focus());
        }
        get _isVisible() {
          return !!this._balloon && this._balloon.visibleView === this._form;
        }
        get _isInBalloon() {
          return !!this._balloon && this._balloon.hasView(this._form);
        }
      }
      class jp extends W {
        static get requires() {
          return [hE, fE];
        }
        static get pluginName() {
          return "ImageTextAlternative";
        }
      }
      function Hp(o, e) {
        const t = (n, i, r) => {
          if (!r.consumable.consume(i.item, n.name))
            return;
          const s = r.writer, a = r.mapper.toViewElement(i.item), l = o.findViewImgElement(a);
          if (i.attributeNewValue === null) {
            const d = i.attributeOldValue;
            d && d.data && (s.removeAttribute("srcset", l), s.removeAttribute("sizes", l), d.width && s.removeAttribute("width", l));
          } else {
            const d = i.attributeNewValue;
            d && d.data && (s.setAttribute("srcset", d.data, l), s.setAttribute("sizes", "100vw", l), d.width && s.setAttribute("width", d.width, l));
          }
        };
        return (n) => {
          n.on(`attribute:srcset:${e}`, t);
        };
      }
      function gs(o, e, t) {
        const n = (i, r, s) => {
          if (!s.consumable.consume(r.item, i.name))
            return;
          const a = s.writer, l = s.mapper.toViewElement(r.item), d = o.findViewImgElement(l);
          a.setAttribute(r.attributeKey, r.attributeNewValue || "", d);
        };
        return (i) => {
          i.on(`attribute:${t}:${e}`, n);
        };
      }
      class bE extends cn {
        observe(e) {
          this.listenTo(e, "load", (t, n) => {
            const i = n.target;
            this.checkShouldIgnoreEventFromTarget(i) || i.tagName == "IMG" && this._fireEvents(n);
          }, { useCapture: !0 });
        }
        stopObserving(e) {
          this.stopListening(e);
        }
        _fireEvents(e) {
          this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", e));
        }
      }
      var kE = Object.defineProperty, Up = Object.getOwnPropertySymbols, wE = Object.prototype.hasOwnProperty, vE = Object.prototype.propertyIsEnumerable, qp = (o, e, t) => e in o ? kE(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, ms = (o, e) => {
        for (var t in e || (e = {}))
          wE.call(e, t) && qp(o, t, e[t]);
        if (Up)
          for (var t of Up(e))
            vE.call(e, t) && qp(o, t, e[t]);
        return o;
      };
      class _E extends be {
        constructor(e) {
          super(e);
          const t = e.config.get("image.insert.type");
          e.plugins.has("ImageBlockEditing") || t === "block" && oe("image-block-plugin-required"), e.plugins.has("ImageInlineEditing") || t === "inline" && oe("image-inline-plugin-required");
        }
        refresh() {
          const e = this.editor.plugins.get("ImageUtils");
          this.isEnabled = e.isImageAllowed();
        }
        execute(e) {
          const t = Xe(e.source), n = this.editor.model.document.selection, i = this.editor.plugins.get("ImageUtils"), r = Object.fromEntries(n.getAttributes());
          t.forEach((s, a) => {
            const l = n.getSelectedElement();
            if (typeof s == "string" && (s = { src: s }), a && l && i.isImage(l)) {
              const d = this.editor.model.createPositionAfter(l);
              i.insertImage(ms(ms({}, s), r), d);
            } else
              i.insertImage(ms(ms({}, s), r));
          });
        }
      }
      class AE extends be {
        refresh() {
          const e = this.editor.plugins.get("ImageUtils"), t = this.editor.model.document.selection.getSelectedElement();
          this.isEnabled = e.isImage(t), this.value = this.isEnabled ? t.getAttribute("src") : null;
        }
        execute(e) {
          const t = this.editor.model.document.selection.getSelectedElement();
          this.editor.model.change((n) => {
            n.setAttribute("src", e.source, t), n.removeAttribute("srcset", t), n.removeAttribute("sizes", t);
          });
        }
      }
      class Wp extends W {
        static get requires() {
          return [Cn];
        }
        static get pluginName() {
          return "ImageEditing";
        }
        init() {
          const e = this.editor, t = e.conversion;
          e.editing.view.addObserver(bE), t.for("upcast").attributeToAttribute({ view: { name: "img", key: "alt" }, model: "alt" }).attributeToAttribute({ view: { name: "img", key: "srcset" }, model: { key: "srcset", value: (r) => {
            const s = { data: r.getAttribute("srcset") };
            return r.hasAttribute("width") && (s.width = r.getAttribute("width")), s;
          } } });
          const n = new _E(e), i = new AE(e);
          e.commands.add("insertImage", n), e.commands.add("replaceImageSource", i), e.commands.add("imageInsert", n);
        }
      }
      class Gp extends be {
        constructor(e, t) {
          super(e), this._modelElementName = t;
        }
        refresh() {
          const e = this.editor.plugins.get("ImageUtils"), t = e.getClosestSelectedImageElement(this.editor.model.document.selection);
          this._modelElementName === "imageBlock" ? this.isEnabled = e.isInlineImage(t) : this.isEnabled = e.isBlockImage(t);
        }
        execute() {
          const e = this.editor, t = this.editor.model, n = e.plugins.get("ImageUtils"), i = n.getClosestSelectedImageElement(t.document.selection), r = Object.fromEntries(i.getAttributes());
          return r.src || r.uploadId ? t.change((s) => {
            const a = Array.from(t.markers).filter((h) => h.getRange().containsItem(i)), l = n.insertImage(r, t.createSelection(i, "on"), this._modelElementName);
            if (!l)
              return null;
            const d = s.createRangeOn(l);
            for (const h of a) {
              const m = h.getRange(), f = m.root.rootName != "$graveyard" ? m.getJoined(d, !0) : d;
              s.updateMarker(h, { range: f });
            }
            return { oldElement: i, newElement: l };
          }) : null;
        }
      }
      class CE extends W {
        static get requires() {
          return [Wp, Cn, vn];
        }
        static get pluginName() {
          return "ImageBlockEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.register("imageBlock", { inheritAllFrom: "$blockObject", allowAttributes: ["alt", "src", "srcset"] }), this._setupConversion(), e.plugins.has("ImageInlineEditing") && (e.commands.add("imageTypeBlock", new Gp(this.editor, "imageBlock")), this._setupClipboardIntegration());
        }
        _setupConversion() {
          const e = this.editor, t = e.t, n = e.conversion, i = e.plugins.get("ImageUtils");
          n.for("dataDowncast").elementToStructure({ model: "imageBlock", view: (r, { writer: s }) => Op(s) }), n.for("editingDowncast").elementToStructure({ model: "imageBlock", view: (r, { writer: s }) => i.toImageWidget(Op(s), s, t("image widget")) }), n.for("downcast").add(gs(i, "imageBlock", "src")).add(gs(i, "imageBlock", "alt")).add(Hp(i, "imageBlock")), n.for("upcast").elementToElement({ view: Rp(e, "imageBlock"), model: (r, { writer: s }) => s.createElement("imageBlock", r.hasAttribute("src") ? { src: r.getAttribute("src") } : void 0) }).add(/* @__PURE__ */ function(r) {
            const s = (a, l, d) => {
              if (!d.consumable.test(l.viewItem, { name: !0, classes: "image" }))
                return;
              const h = r.findViewImgElement(l.viewItem);
              if (!h || !d.consumable.test(h, { name: !0 }))
                return;
              d.consumable.consume(l.viewItem, { name: !0, classes: "image" });
              const m = it(d.convertItem(h, l.modelCursor).modelRange.getItems());
              m ? (d.convertChildren(l.viewItem, m), d.updateConversionResult(m, l)) : d.consumable.revert(l.viewItem, { name: !0, classes: "image" });
            };
            return (a) => {
              a.on("element:figure", s);
            };
          }(i));
        }
        _setupClipboardIntegration() {
          const e = this.editor, t = e.model, n = e.editing.view, i = e.plugins.get("ImageUtils"), r = e.plugins.get("ClipboardPipeline");
          this.listenTo(r, "inputTransformation", (s, a) => {
            const l = Array.from(a.content.getChildren());
            let d;
            if (!l.every(i.isInlineImageView))
              return;
            d = a.targetRanges ? e.editing.mapper.toModelRange(a.targetRanges[0]) : t.document.selection.getFirstRange();
            const h = t.createSelection(d);
            if (Ol(t.schema, h) === "imageBlock") {
              const m = new Jr(n.document), f = l.map((_) => m.createElement("figure", { class: "image" }, _));
              a.content = m.createDocumentFragment(f);
            }
          });
        }
      }
      var Kp = b(3508), yE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Kp.Z, yE), Kp.Z.locals;
      class EE extends W {
        static get requires() {
          return [CE, Wi, jp];
        }
        static get pluginName() {
          return "ImageBlock";
        }
      }
      class xE extends W {
        static get requires() {
          return [Wp, Cn, vn];
        }
        static get pluginName() {
          return "ImageInlineEditing";
        }
        init() {
          const e = this.editor, t = e.model.schema;
          t.register("imageInline", { inheritAllFrom: "$inlineObject", allowAttributes: ["alt", "src", "srcset"] }), t.addChildCheck((n, i) => {
            if (n.endsWith("caption") && i.name === "imageInline")
              return !1;
          }), this._setupConversion(), e.plugins.has("ImageBlockEditing") && (e.commands.add("imageTypeInline", new Gp(this.editor, "imageInline")), this._setupClipboardIntegration());
        }
        _setupConversion() {
          const e = this.editor, t = e.t, n = e.conversion, i = e.plugins.get("ImageUtils");
          n.for("dataDowncast").elementToElement({ model: "imageInline", view: (r, { writer: s }) => s.createEmptyElement("img") }), n.for("editingDowncast").elementToStructure({ model: "imageInline", view: (r, { writer: s }) => i.toImageWidget(function(a) {
            return a.createContainerElement("span", { class: "image-inline" }, a.createEmptyElement("img"));
          }(s), s, t("image widget")) }), n.for("downcast").add(gs(i, "imageInline", "src")).add(gs(i, "imageInline", "alt")).add(Hp(i, "imageInline")), n.for("upcast").elementToElement({ view: Rp(e, "imageInline"), model: (r, { writer: s }) => s.createElement("imageInline", r.hasAttribute("src") ? { src: r.getAttribute("src") } : void 0) });
        }
        _setupClipboardIntegration() {
          const e = this.editor, t = e.model, n = e.editing.view, i = e.plugins.get("ImageUtils"), r = e.plugins.get("ClipboardPipeline");
          this.listenTo(r, "inputTransformation", (s, a) => {
            const l = Array.from(a.content.getChildren());
            let d;
            if (!l.every(i.isBlockImageView))
              return;
            d = a.targetRanges ? e.editing.mapper.toModelRange(a.targetRanges[0]) : t.document.selection.getFirstRange();
            const h = t.createSelection(d);
            if (Ol(t.schema, h) === "imageInline") {
              const m = new Jr(n.document), f = l.map((_) => _.childCount === 1 ? (Array.from(_.getAttributes()).forEach((S) => m.setAttribute(...S, i.findViewImgElement(_))), _.getChild(0)) : _);
              a.content = m.createDocumentFragment(f);
            }
          });
        }
      }
      class SE extends W {
        static get requires() {
          return [xE, Wi, jp];
        }
        static get pluginName() {
          return "ImageInline";
        }
      }
      var Zp = b(2640), DE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Zp.Z, DE), Zp.Z.locals;
      function Jp(o) {
        const e = o.map((t) => t.replace("+", "\\+"));
        return new RegExp(`^image\\/(${e.join("|")})$`);
      }
      function BE(o) {
        return new Promise((e, t) => {
          const n = o.getAttribute("src");
          fetch(n).then((i) => i.blob()).then((i) => {
            const r = Yp(i, n), s = r.replace("image/", ""), a = new File([i], `image.${s}`, { type: r });
            e(a);
          }).catch((i) => i && i.name === "TypeError" ? function(r) {
            return function(s) {
              return new Promise((a, l) => {
                const d = ke.document.createElement("img");
                d.addEventListener("load", () => {
                  const h = ke.document.createElement("canvas");
                  h.width = d.width, h.height = d.height, h.getContext("2d").drawImage(d, 0, 0), h.toBlob((m) => m ? a(m) : l());
                }), d.addEventListener("error", () => l()), d.src = s;
              });
            }(r).then((s) => {
              const a = Yp(s, r), l = a.replace("image/", "");
              return new File([s], `image.${l}`, { type: a });
            });
          }(n).then(e).catch(t) : t(i));
        });
      }
      function Yp(o, e) {
        return o.type ? o.type : e.match(/data:(image\/\w+);base64/) ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg";
      }
      class TE extends W {
        static get pluginName() {
          return "ImageUploadUI";
        }
        init() {
          const e = this.editor, t = e.t, n = (i) => {
            const r = new $2(i), s = e.commands.get("uploadImage"), a = e.config.get("image.upload.types"), l = Jp(a);
            return r.set({ acceptedType: a.map((d) => `image/${d}`).join(","), allowMultipleFiles: !0 }), r.buttonView.set({ label: t("Insert image"), icon: qe.image, tooltip: !0 }), r.buttonView.bind("isEnabled").to(s), r.on("done", (d, h) => {
              const m = Array.from(h).filter((f) => l.test(f.type));
              m.length && (e.execute("uploadImage", { file: m }), e.editing.view.focus());
            }), r;
          };
          e.ui.componentFactory.add("uploadImage", n), e.ui.componentFactory.add("imageUpload", n);
        }
      }
      var Qp = b(3689), IE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Qp.Z, IE), Qp.Z.locals;
      var Xp = b(4036), PE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Xp.Z, PE), Xp.Z.locals;
      var ef = b(3773), OE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(ef.Z, OE), ef.Z.locals;
      class RE extends W {
        constructor(e) {
          super(e), this.uploadStatusChange = (t, n, i) => {
            const r = this.editor, s = n.item, a = s.getAttribute("uploadId");
            if (!i.consumable.consume(n.item, t.name))
              return;
            const l = r.plugins.get("ImageUtils"), d = r.plugins.get(An), h = a ? n.attributeNewValue : null, m = this.placeholder, f = r.editing.mapper.toViewElement(s), _ = i.writer;
            if (h == "reading")
              return tf(f, _), void nf(l, m, f, _);
            if (h == "uploading") {
              const S = d.loaders.get(a);
              return tf(f, _), void (S ? (of(f, _), function(B, T, R, N) {
                const U = function(ee) {
                  const we = ee.createUIElement("div", { class: "ck-progress-bar" });
                  return ee.setCustomProperty("progressBar", !0, we), we;
                }(T);
                T.insert(T.createPositionAt(B, "end"), U), R.on("change:uploadedPercent", (ee, we, Ge) => {
                  N.change((Te) => {
                    Te.setStyle("width", Ge + "%", U);
                  });
                });
              }(f, _, S, r.editing.view), function(B, T, R, N) {
                if (N.data) {
                  const U = B.findViewImgElement(T);
                  R.setAttribute("src", N.data, U);
                }
              }(l, f, _, S)) : nf(l, m, f, _));
            }
            h == "complete" && d.loaders.get(a) && function(S, B, T) {
              const R = B.createUIElement("div", { class: "ck-image-upload-complete-icon" });
              B.insert(B.createPositionAt(S, "end"), R), setTimeout(() => {
                T.change((N) => N.remove(N.createRangeOn(R)));
              }, 3e3);
            }(f, _, r.editing.view), function(S, B) {
              sf(S, B, "progressBar");
            }(f, _), of(f, _), function(S, B) {
              B.removeClass("ck-appear", S);
            }(f, _);
          }, this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        }
        static get pluginName() {
          return "ImageUploadProgress";
        }
        init() {
          const e = this.editor;
          e.plugins.has("ImageBlockEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange), e.plugins.has("ImageInlineEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange);
        }
      }
      function tf(o, e) {
        o.hasClass("ck-appear") || e.addClass("ck-appear", o);
      }
      function nf(o, e, t, n) {
        t.hasClass("ck-image-upload-placeholder") || n.addClass("ck-image-upload-placeholder", t);
        const i = o.findViewImgElement(t);
        i.getAttribute("src") !== e && n.setAttribute("src", e, i), rf(t, "placeholder") || n.insert(n.createPositionAfter(i), function(r) {
          const s = r.createUIElement("div", { class: "ck-upload-placeholder-loader" });
          return r.setCustomProperty("placeholder", !0, s), s;
        }(n));
      }
      function of(o, e) {
        o.hasClass("ck-image-upload-placeholder") && e.removeClass("ck-image-upload-placeholder", o), sf(o, e, "placeholder");
      }
      function rf(o, e) {
        for (const t of o.getChildren())
          if (t.getCustomProperty(e))
            return t;
      }
      function sf(o, e, t) {
        const n = rf(o, t);
        n && e.remove(e.createRangeOn(n));
      }
      var zE = Object.defineProperty, ME = Object.defineProperties, NE = Object.getOwnPropertyDescriptors, af = Object.getOwnPropertySymbols, FE = Object.prototype.hasOwnProperty, $E = Object.prototype.propertyIsEnumerable, lf = (o, e, t) => e in o ? zE(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class VE extends be {
        refresh() {
          const e = this.editor, t = e.plugins.get("ImageUtils"), n = e.model.document.selection.getSelectedElement();
          this.isEnabled = t.isImageAllowed() || t.isImage(n);
        }
        execute(e) {
          const t = Xe(e.file), n = this.editor.model.document.selection, i = this.editor.plugins.get("ImageUtils"), r = Object.fromEntries(n.getAttributes());
          t.forEach((s, a) => {
            const l = n.getSelectedElement();
            if (a && l && i.isImage(l)) {
              const d = this.editor.model.createPositionAfter(l);
              this._uploadImage(s, r, d);
            } else
              this._uploadImage(s, r);
          });
        }
        _uploadImage(e, t, n) {
          const i = this.editor, r = i.plugins.get(An).createLoader(e), s = i.plugins.get("ImageUtils");
          var a, l;
          r && s.insertImage((a = ((d, h) => {
            for (var m in h || (h = {}))
              FE.call(h, m) && lf(d, m, h[m]);
            if (af)
              for (var m of af(h))
                $E.call(h, m) && lf(d, m, h[m]);
            return d;
          })({}, t), l = { uploadId: r.id }, ME(a, NE(l))), n);
        }
      }
      class LE extends W {
        constructor(e) {
          super(e), e.config.define("image", { upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] } }), this._uploadImageElements = /* @__PURE__ */ new Map();
        }
        static get requires() {
          return [An, ym, vn, Cn];
        }
        static get pluginName() {
          return "ImageUploadEditing";
        }
        init() {
          const e = this.editor, t = e.model.document, n = e.conversion, i = e.plugins.get(An), r = e.plugins.get("ImageUtils"), s = e.plugins.get("ClipboardPipeline"), a = Jp(e.config.get("image.upload.types")), l = new VE(e);
          e.commands.add("uploadImage", l), e.commands.add("imageUpload", l), n.for("upcast").attributeToAttribute({ view: { name: "img", key: "uploadId" }, model: "uploadId" }), this.listenTo(e.editing.view.document, "clipboardInput", (d, h) => {
            if (m = h.dataTransfer, Array.from(m.types).includes("text/html") && m.getData("text/html") !== "")
              return;
            var m;
            const f = Array.from(h.dataTransfer.files).filter((_) => !!_ && a.test(_.type));
            f.length && (d.stop(), e.model.change((_) => {
              h.targetRanges && _.setSelection(h.targetRanges.map((S) => e.editing.mapper.toModelRange(S))), e.model.enqueueChange(() => {
                e.execute("uploadImage", { file: f });
              });
            }));
          }), this.listenTo(s, "inputTransformation", (d, h) => {
            const m = Array.from(e.editing.view.createRangeIn(h.content)).map((_) => _.item).filter((_) => function(S, B) {
              return !(!S.isInlineImageView(B) || !B.getAttribute("src") || !B.getAttribute("src").match(/^data:image\/\w+;base64,/g) && !B.getAttribute("src").match(/^blob:/g));
            }(r, _) && !_.getAttribute("uploadProcessed")).map((_) => ({ promise: BE(_), imageElement: _ }));
            if (!m.length)
              return;
            const f = new Jr(e.editing.view.document);
            for (const _ of m) {
              f.setAttribute("uploadProcessed", !0, _.imageElement);
              const S = i.createLoader(_.promise);
              S && (f.setAttribute("src", "", _.imageElement), f.setAttribute("uploadId", S.id, _.imageElement));
            }
          }), e.editing.view.document.on("dragover", (d, h) => {
            h.preventDefault();
          }), t.on("change", () => {
            const d = t.differ.getChanges({ includeChangesInGraveyard: !0 }).reverse(), h = /* @__PURE__ */ new Set();
            for (const m of d)
              if (m.type == "insert" && m.name != "$text") {
                const f = m.position.nodeAfter, _ = m.position.root.rootName == "$graveyard";
                for (const S of jE(e, f)) {
                  const B = S.getAttribute("uploadId");
                  if (!B)
                    continue;
                  const T = i.loaders.get(B);
                  T && (_ ? h.has(B) || T.abort() : (h.add(B), this._uploadImageElements.set(B, S), T.status == "idle" && this._readAndUpload(T)));
                }
              }
          }), this.on("uploadComplete", (d, { imageElement: h, data: m }) => {
            const f = m.urls ? m.urls : m;
            this.editor.model.change((_) => {
              _.setAttribute("src", f.default, h), this._parseAndSetSrcsetAttributeOnImage(f, h, _);
            });
          }, { priority: "low" });
        }
        afterInit() {
          const e = this.editor.model.schema;
          this.editor.plugins.has("ImageBlockEditing") && e.extend("imageBlock", { allowAttributes: ["uploadId", "uploadStatus"] }), this.editor.plugins.has("ImageInlineEditing") && e.extend("imageInline", { allowAttributes: ["uploadId", "uploadStatus"] });
        }
        _readAndUpload(e) {
          const t = this.editor, n = t.model, i = t.locale.t, r = t.plugins.get(An), s = t.plugins.get(ym), a = t.plugins.get("ImageUtils"), l = this._uploadImageElements;
          return n.enqueueChange({ isUndoable: !1 }, (h) => {
            h.setAttribute("uploadStatus", "reading", l.get(e.id));
          }), e.read().then(() => {
            const h = e.upload(), m = l.get(e.id);
            if (k.isSafari) {
              const f = t.editing.mapper.toViewElement(m), _ = a.findViewImgElement(f);
              t.editing.view.once("render", () => {
                if (!_.parent)
                  return;
                const S = t.editing.view.domConverter.mapViewToDom(_.parent);
                if (!S)
                  return;
                const B = S.style.display;
                S.style.display = "none", S._ckHack = S.offsetHeight, S.style.display = B;
              });
            }
            return n.enqueueChange({ isUndoable: !1 }, (f) => {
              f.setAttribute("uploadStatus", "uploading", m);
            }), h;
          }).then((h) => {
            n.enqueueChange({ isUndoable: !1 }, (m) => {
              const f = l.get(e.id);
              m.setAttribute("uploadStatus", "complete", f), this.fire("uploadComplete", { data: h, imageElement: f });
            }), d();
          }).catch((h) => {
            if (e.status !== "error" && e.status !== "aborted")
              throw h;
            e.status == "error" && h && s.showWarning(h, { title: i("Upload failed"), namespace: "upload" }), n.enqueueChange({ isUndoable: !1 }, (m) => {
              m.remove(l.get(e.id));
            }), d();
          });
          function d() {
            n.enqueueChange({ isUndoable: !1 }, (h) => {
              const m = l.get(e.id);
              h.removeAttribute("uploadId", m), h.removeAttribute("uploadStatus", m), l.delete(e.id);
            }), r.destroyLoader(e);
          }
        }
        _parseAndSetSrcsetAttributeOnImage(e, t, n) {
          let i = 0;
          const r = Object.keys(e).filter((s) => {
            const a = parseInt(s, 10);
            if (!isNaN(a))
              return i = Math.max(i, a), !0;
          }).map((s) => `${e[s]} ${s}w`).join(", ");
          r != "" && n.setAttribute("srcset", { data: r, width: i }, t);
        }
      }
      function jE(o, e) {
        const t = o.plugins.get("ImageUtils");
        return Array.from(o.model.createRangeOn(e)).filter((n) => t.isImage(n.item)).map((n) => n.item);
      }
      var cf = b(1568), HE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(cf.Z, HE), cf.Z.locals;
      var df = b(3535), UE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(df.Z, UE), df.Z.locals;
      class qE extends be {
        refresh() {
          const e = this.editor, t = e.plugins.get("ImageUtils").getClosestSelectedImageElement(e.model.document.selection);
          this.isEnabled = !!t, t && t.hasAttribute("width") ? this.value = { width: t.getAttribute("width"), height: null } : this.value = null;
        }
        execute(e) {
          const t = this.editor, n = t.model, i = t.plugins.get("ImageUtils").getClosestSelectedImageElement(n.document.selection);
          this.value = { width: e.width, height: null }, i && n.change((r) => {
            r.setAttribute("width", e.width, i);
          });
        }
      }
      class WE extends W {
        static get requires() {
          return [Cn];
        }
        static get pluginName() {
          return "ImageResizeEditing";
        }
        constructor(e) {
          super(e), e.config.define("image", { resizeUnit: "%", resizeOptions: [{ name: "resizeImage:original", value: null, icon: "original" }, { name: "resizeImage:25", value: "25", icon: "small" }, { name: "resizeImage:50", value: "50", icon: "medium" }, { name: "resizeImage:75", value: "75", icon: "large" }] });
        }
        init() {
          const e = this.editor, t = new qE(e);
          this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline"), e.commands.add("resizeImage", t), e.commands.add("imageResize", t);
        }
        _registerSchema() {
          this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: "width" }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: "width" });
        }
        _registerConverters(e) {
          const t = this.editor;
          t.conversion.for("downcast").add((n) => n.on(`attribute:width:${e}`, (i, r, s) => {
            if (!s.consumable.consume(r.item, i.name))
              return;
            const a = s.writer, l = s.mapper.toViewElement(r.item);
            r.attributeNewValue !== null ? (a.setStyle("width", r.attributeNewValue, l), a.addClass("image_resized", l)) : (a.removeStyle("width", l), a.removeClass("image_resized", l));
          })), t.conversion.for("upcast").attributeToAttribute({ view: { name: e === "imageBlock" ? "figure" : "img", styles: { width: /.+/ } }, model: { key: "width", value: (n) => n.getStyle("width") } });
        }
      }
      const Rl = { small: qe.objectSizeSmall, medium: qe.objectSizeMedium, large: qe.objectSizeLarge, original: qe.objectSizeFull };
      function uf(o) {
        return (e) => o === null && e === o || e !== null && e.width === o;
      }
      var hf = b(6270), GE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(hf.Z, GE), hf.Z.locals;
      class KE extends be {
        constructor(e, t) {
          super(e), this._defaultStyles = { imageBlock: !1, imageInline: !1 }, this._styles = new Map(t.map((n) => {
            if (n.isDefault)
              for (const i of n.modelElements)
                this._defaultStyles[i] = n.name;
            return [n.name, n];
          }));
        }
        refresh() {
          const e = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
          this.isEnabled = !!e, this.isEnabled ? e.hasAttribute("imageStyle") ? this.value = e.getAttribute("imageStyle") : this.value = this._defaultStyles[e.name] : this.value = !1;
        }
        execute(e = {}) {
          const t = this.editor, n = t.model, i = t.plugins.get("ImageUtils");
          n.change((r) => {
            const s = e.value;
            let a = i.getClosestSelectedImageElement(n.document.selection);
            s && this.shouldConvertImageType(s, a) && (this.editor.execute(i.isBlockImage(a) ? "imageTypeInline" : "imageTypeBlock"), a = i.getClosestSelectedImageElement(n.document.selection)), !s || this._styles.get(s).isDefault ? r.removeAttribute("imageStyle", a) : r.setAttribute("imageStyle", s, a);
          });
        }
        shouldConvertImageType(e, t) {
          return !this._styles.get(e).modelElements.includes(t.name);
        }
      }
      var ZE = Object.defineProperty, gf = Object.getOwnPropertySymbols, JE = Object.prototype.hasOwnProperty, YE = Object.prototype.propertyIsEnumerable, mf = (o, e, t) => e in o ? ZE(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, pf = (o, e) => {
        for (var t in e || (e = {}))
          JE.call(e, t) && mf(o, t, e[t]);
        if (gf)
          for (var t of gf(e))
            YE.call(e, t) && mf(o, t, e[t]);
        return o;
      };
      const { objectFullWidth: QE, objectInline: ff, objectLeft: bf, objectRight: zl, objectCenter: Ml, objectBlockLeft: kf, objectBlockRight: wf } = qe, ps = { get inline() {
        return { name: "inline", title: "In line", icon: ff, modelElements: ["imageInline"], isDefault: !0 };
      }, get alignLeft() {
        return { name: "alignLeft", title: "Left aligned image", icon: bf, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-left" };
      }, get alignBlockLeft() {
        return { name: "alignBlockLeft", title: "Left aligned image", icon: kf, modelElements: ["imageBlock"], className: "image-style-block-align-left" };
      }, get alignCenter() {
        return { name: "alignCenter", title: "Centered image", icon: Ml, modelElements: ["imageBlock"], className: "image-style-align-center" };
      }, get alignRight() {
        return { name: "alignRight", title: "Right aligned image", icon: zl, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-right" };
      }, get alignBlockRight() {
        return { name: "alignBlockRight", title: "Right aligned image", icon: wf, modelElements: ["imageBlock"], className: "image-style-block-align-right" };
      }, get block() {
        return { name: "block", title: "Centered image", icon: Ml, modelElements: ["imageBlock"], isDefault: !0 };
      }, get side() {
        return { name: "side", title: "Side image", icon: zl, modelElements: ["imageBlock"], className: "image-style-side" };
      } }, vf = { full: QE, left: kf, right: wf, center: Ml, inlineLeft: bf, inlineRight: zl, inline: ff }, _f = [{ name: "imageStyle:wrapText", title: "Wrap text", defaultItem: "imageStyle:alignLeft", items: ["imageStyle:alignLeft", "imageStyle:alignRight"] }, { name: "imageStyle:breakText", title: "Break text", defaultItem: "imageStyle:block", items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"] }];
      function Af(o) {
        oe("image-style-configuration-definition-invalid", o);
      }
      const Nl = { normalizeStyles: function(o) {
        return (o.configuredStyles.options || []).map((e) => function(t) {
          return t = typeof t == "string" ? ps[t] ? pf({}, ps[t]) : { name: t } : function(n, i) {
            const r = pf({}, i);
            for (const s in n)
              Object.prototype.hasOwnProperty.call(i, s) || (r[s] = n[s]);
            return r;
          }(ps[t.name], t), typeof t.icon == "string" && (t.icon = vf[t.icon] || t.icon), t;
        }(e)).filter((e) => function(t, { isBlockPluginLoaded: n, isInlinePluginLoaded: i }) {
          const { modelElements: r, name: s } = t;
          if (!(r && r.length && s))
            return Af({ style: t }), !1;
          {
            const a = [n ? "imageBlock" : null, i ? "imageInline" : null];
            if (!r.some((l) => a.includes(l)))
              return oe("image-style-missing-dependency", { style: t, missingPlugins: r.map((l) => l === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing") }), !1;
          }
          return !0;
        }(e, o));
      }, getDefaultStylesConfiguration: function(o, e) {
        return o && e ? { options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"] } : o ? { options: ["block", "side"] } : e ? { options: ["inline", "alignLeft", "alignRight"] } : {};
      }, getDefaultDropdownDefinitions: function(o) {
        return o.has("ImageBlockEditing") && o.has("ImageInlineEditing") ? [..._f] : [];
      }, warnInvalidStyle: Af, DEFAULT_OPTIONS: ps, DEFAULT_ICONS: vf, DEFAULT_DROPDOWN_DEFINITIONS: _f };
      function Cf(o, e) {
        for (const t of e)
          if (t.name === o)
            return t;
      }
      class yf extends W {
        static get pluginName() {
          return "ImageStyleEditing";
        }
        static get requires() {
          return [Cn];
        }
        init() {
          const { normalizeStyles: e, getDefaultStylesConfiguration: t } = Nl, n = this.editor, i = n.plugins.has("ImageBlockEditing"), r = n.plugins.has("ImageInlineEditing");
          n.config.define("image.styles", t(i, r)), this.normalizedStyles = e({ configuredStyles: n.config.get("image.styles"), isBlockPluginLoaded: i, isInlinePluginLoaded: r }), this._setupConversion(i, r), this._setupPostFixer(), n.commands.add("imageStyle", new KE(n, this.normalizedStyles));
        }
        _setupConversion(e, t) {
          const n = this.editor, i = n.model.schema, r = (s = this.normalizedStyles, (l, d, h) => {
            if (!h.consumable.consume(d.item, l.name))
              return;
            const m = Cf(d.attributeNewValue, s), f = Cf(d.attributeOldValue, s), _ = h.mapper.toViewElement(d.item), S = h.writer;
            f && S.removeClass(f.className, _), m && S.addClass(m.className, _);
          });
          var s;
          const a = function(l) {
            const d = { imageInline: l.filter((h) => !h.isDefault && h.modelElements.includes("imageInline")), imageBlock: l.filter((h) => !h.isDefault && h.modelElements.includes("imageBlock")) };
            return (h, m, f) => {
              if (!m.modelRange)
                return;
              const _ = m.viewItem, S = it(m.modelRange.getItems());
              if (S && f.schema.checkAttribute(S, "imageStyle"))
                for (const B of d[S.name])
                  f.consumable.consume(_, { classes: B.className }) && f.writer.setAttribute("imageStyle", B.name, S);
            };
          }(this.normalizedStyles);
          n.editing.downcastDispatcher.on("attribute:imageStyle", r), n.data.downcastDispatcher.on("attribute:imageStyle", r), e && (i.extend("imageBlock", { allowAttributes: "imageStyle" }), n.data.upcastDispatcher.on("element:figure", a, { priority: "low" })), t && (i.extend("imageInline", { allowAttributes: "imageStyle" }), n.data.upcastDispatcher.on("element:img", a, { priority: "low" }));
        }
        _setupPostFixer() {
          const e = this.editor, t = e.model.document, n = e.plugins.get(Cn), i = new Map(this.normalizedStyles.map((r) => [r.name, r]));
          t.registerPostFixer((r) => {
            let s = !1;
            for (const a of t.differ.getChanges())
              if (a.type == "insert" || a.type == "attribute" && a.attributeKey == "imageStyle") {
                let l = a.type == "insert" ? a.position.nodeAfter : a.range.start.nodeAfter;
                if (l && l.is("element", "paragraph") && l.childCount > 0 && (l = l.getChild(0)), !n.isImage(l))
                  continue;
                const d = l.getAttribute("imageStyle");
                if (!d)
                  continue;
                const h = i.get(d);
                h && h.modelElements.includes(l.name) || (r.removeAttribute("imageStyle", l), s = !0);
              }
            return s;
          });
        }
      }
      var Ef = b(5083), XE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Ef.Z, XE), Ef.Z.locals;
      class ex extends W {
        static get requires() {
          return [yf];
        }
        static get pluginName() {
          return "ImageStyleUI";
        }
        get localizedDefaultStylesTitles() {
          const e = this.editor.t;
          return { "Wrap text": e("Wrap text"), "Break text": e("Break text"), "In line": e("In line"), "Full size image": e("Full size image"), "Side image": e("Side image"), "Left aligned image": e("Left aligned image"), "Centered image": e("Centered image"), "Right aligned image": e("Right aligned image") };
        }
        init() {
          const e = this.editor.plugins, t = this.editor.config.get("image.toolbar") || [], n = xf(e.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
          for (const r of n)
            this._createButton(r);
          const i = xf([...t.filter(K), ...Nl.getDefaultDropdownDefinitions(e)], this.localizedDefaultStylesTitles);
          for (const r of i)
            this._createDropdown(r, n);
        }
        _createDropdown(e, t) {
          const n = this.editor.ui.componentFactory;
          n.add(e.name, (i) => {
            let r;
            const { defaultItem: s, items: a, title: l } = e, d = a.filter((_) => t.find(({ name: S }) => Sf(S) === _)).map((_) => {
              const S = n.create(_);
              return _ === s && (r = S), S;
            });
            a.length !== d.length && Nl.warnInvalidStyle({ dropdown: e });
            const h = wn(i, al), m = h.buttonView, f = m.arrowView;
            return Xr(h, d, { enableActiveItemFocusOnDropdownOpen: !0 }), m.set({ label: Df(l, r.label), class: null, tooltip: !0 }), f.unbind("label"), f.set({ label: l }), m.bind("icon").toMany(d, "isOn", (..._) => {
              const S = _.findIndex(eo);
              return S < 0 ? r.icon : d[S].icon;
            }), m.bind("label").toMany(d, "isOn", (..._) => {
              const S = _.findIndex(eo);
              return Df(l, S < 0 ? r.label : d[S].label);
            }), m.bind("isOn").toMany(d, "isOn", (..._) => _.some(eo)), m.bind("class").toMany(d, "isOn", (..._) => _.some(eo) ? "ck-splitbutton_flatten" : void 0), m.on("execute", () => {
              d.some(({ isOn: _ }) => _) ? h.isOpen = !h.isOpen : r.fire("execute");
            }), h.bind("isEnabled").toMany(d, "isEnabled", (..._) => _.some(eo)), this.listenTo(h, "execute", () => {
              this.editor.editing.view.focus();
            }), h;
          });
        }
        _createButton(e) {
          const t = e.name;
          this.editor.ui.componentFactory.add(Sf(t), (n) => {
            const i = this.editor.commands.get("imageStyle"), r = new je(n);
            return r.set({ label: e.title, icon: e.icon, tooltip: !0, isToggleable: !0 }), r.bind("isEnabled").to(i, "isEnabled"), r.bind("isOn").to(i, "value", (s) => s === t), r.on("execute", this._executeCommand.bind(this, t)), r;
          });
        }
        _executeCommand(e) {
          this.editor.execute("imageStyle", { value: e }), this.editor.editing.view.focus();
        }
      }
      function xf(o, e) {
        for (const t of o)
          e[t.title] && (t.title = e[t.title]);
        return o;
      }
      function Sf(o) {
        return `imageStyle:${o}`;
      }
      function Df(o, e) {
        return (o ? o + ": " : "") + e;
      }
      class tx extends W {
        static get pluginName() {
          return "IndentEditing";
        }
        init() {
          const e = this.editor;
          e.commands.add("indent", new Nu(e)), e.commands.add("outdent", new Nu(e));
        }
      }
      const Bf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>', Tf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
      class nx extends W {
        static get pluginName() {
          return "IndentUI";
        }
        init() {
          const e = this.editor, t = e.locale, n = e.t, i = t.uiLanguageDirection == "ltr" ? Bf : Tf, r = t.uiLanguageDirection == "ltr" ? Tf : Bf;
          this._defineButton("indent", n("Increase indent"), i), this._defineButton("outdent", n("Decrease indent"), r);
        }
        _defineButton(e, t, n) {
          const i = this.editor;
          i.ui.componentFactory.add(e, (r) => {
            const s = i.commands.get(e), a = new je(r);
            return a.set({ label: t, icon: n, tooltip: !0 }), a.bind("isEnabled").to(s, "isEnabled"), this.listenTo(a, "execute", () => {
              i.execute(e), i.editing.view.focus();
            }), a;
          });
        }
      }
      class fs extends be {
        constructor(e, t) {
          super(e), this._indentBehavior = t;
        }
        refresh() {
          const e = this.editor.model, t = it(e.document.selection.getSelectedBlocks());
          t && e.schema.checkAttribute(t, "blockIndent") ? this.isEnabled = this._indentBehavior.checkEnabled(t.getAttribute("blockIndent")) : this.isEnabled = !1;
        }
        execute() {
          const e = this.editor.model, t = function(n) {
            const i = n.document.selection, r = n.schema;
            return Array.from(i.getSelectedBlocks()).filter((s) => r.checkAttribute(s, "blockIndent"));
          }(e);
          e.change((n) => {
            for (const i of t) {
              const r = i.getAttribute("blockIndent"), s = this._indentBehavior.getNextIndent(r);
              s ? n.setAttribute("blockIndent", s, i) : n.removeAttribute("blockIndent", i);
            }
          });
        }
      }
      class If {
        constructor(e) {
          this.isForward = e.direction === "forward", this.offset = e.offset, this.unit = e.unit;
        }
        checkEnabled(e) {
          const t = parseFloat(e || "0");
          return this.isForward || t > 0;
        }
        getNextIndent(e) {
          const t = parseFloat(e || "0");
          if (!(!e || e.endsWith(this.unit)))
            return this.isForward ? this.offset + this.unit : void 0;
          const n = t + (this.isForward ? this.offset : -this.offset);
          return n > 0 ? n + this.unit : void 0;
        }
      }
      class Pf {
        constructor(e) {
          this.isForward = e.direction === "forward", this.classes = e.classes;
        }
        checkEnabled(e) {
          const t = this.classes.indexOf(e);
          return this.isForward ? t < this.classes.length - 1 : t >= 0;
        }
        getNextIndent(e) {
          const t = this.classes.indexOf(e), n = this.isForward ? 1 : -1;
          return this.classes[t + n];
        }
      }
      const ox = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"];
      class ix {
        constructor() {
          this._definitions = /* @__PURE__ */ new Set();
        }
        get length() {
          return this._definitions.size;
        }
        add(e) {
          Array.isArray(e) ? e.forEach((t) => this._definitions.add(t)) : this._definitions.add(e);
        }
        getDispatcher() {
          return (e) => {
            e.on("attribute:linkHref", (t, n, i) => {
              if (!i.consumable.test(n.item, "attribute:linkHref") || !n.item.is("selection") && !i.schema.isInline(n.item))
                return;
              const r = i.writer, s = r.document.selection;
              for (const a of this._definitions) {
                const l = r.createAttributeElement("a", a.attributes, { priority: 5 });
                a.classes && r.addClass(a.classes, l);
                for (const d in a.styles)
                  r.setStyle(d, a.styles[d], l);
                r.setCustomProperty("link", !0, l), a.callback(n.attributeNewValue) ? n.item.is("selection") ? r.wrap(s.getFirstRange(), l) : r.wrap(i.mapper.toViewRange(n.range), l) : r.unwrap(i.mapper.toViewRange(n.range), l);
              }
            }, { priority: "high" });
          };
        }
        getDispatcherForLinkedImage() {
          return (e) => {
            e.on("attribute:linkHref:imageBlock", (t, n, { writer: i, mapper: r }) => {
              const s = r.toViewElement(n.item), a = Array.from(s.getChildren()).find((l) => l.is("element", "a"));
              for (const l of this._definitions) {
                const d = pn(l.attributes);
                if (l.callback(n.attributeNewValue)) {
                  for (const [h, m] of d)
                    h === "class" ? i.addClass(m, a) : i.setAttribute(h, m, a);
                  l.classes && i.addClass(l.classes, a);
                  for (const h in l.styles)
                    i.setStyle(h, l.styles[h], a);
                } else {
                  for (const [h, m] of d)
                    h === "class" ? i.removeClass(m, a) : i.removeAttribute(h, a);
                  l.classes && i.removeClass(l.classes, a);
                  for (const h in l.styles)
                    i.removeStyle(h, a);
                }
              }
            });
          };
        }
      }
      const rx = function(o, e, t) {
        var n = o.length;
        return t = t === void 0 ? n : t, !e && t >= n ? o : Ku(o, e, t);
      };
      var sx = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
      const Of = function(o) {
        return sx.test(o);
      }, ax = function(o) {
        return o.split("");
      };
      var Rf = "\\ud800-\\udfff", lx = "[" + Rf + "]", Fl = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", $l = "\\ud83c[\\udffb-\\udfff]", zf = "[^" + Rf + "]", Mf = "(?:\\ud83c[\\udde6-\\uddff]){2}", Nf = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ff = "(?:" + Fl + "|" + $l + ")?", $f = "[\\ufe0e\\ufe0f]?", cx = $f + Ff + ("(?:\\u200d(?:" + [zf, Mf, Nf].join("|") + ")" + $f + Ff + ")*"), dx = "(?:" + [zf + Fl + "?", Fl, Mf, Nf, lx].join("|") + ")", ux = RegExp($l + "(?=" + $l + ")|" + dx + cx, "g");
      const hx = function(o) {
        return o.match(ux) || [];
      }, gx = function(o) {
        return Of(o) ? hx(o) : ax(o);
      }, mx = /* @__PURE__ */ function(o) {
        return function(e) {
          e = Ea(e);
          var t = Of(e) ? gx(e) : void 0, n = t ? t[0] : e.charAt(0), i = t ? rx(t, 1).join("") : e.slice(1);
          return n[o]() + i;
        };
      }("toUpperCase"), px = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, fx = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i, bx = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i, kx = /^((\w+:(\/{2,})?)|(\W))/i, Vl = "Ctrl+K";
      function Vf(o, { writer: e }) {
        const t = e.createAttributeElement("a", { href: o }, { priority: 5 });
        return e.setCustomProperty("link", !0, t), t;
      }
      function Lf(o) {
        const e = String(o);
        return function(t) {
          return !!t.replace(px, "").match(fx);
        }(e) ? e : "#";
      }
      function Ll(o, e) {
        return !!o && e.checkAttribute(o.name, "linkHref");
      }
      function jl(o, e) {
        const t = (n = o, bx.test(n) ? "mailto:" : e);
        var n;
        const i = !!t && !jf(o);
        return o && i ? t + o : o;
      }
      function jf(o) {
        return kx.test(o);
      }
      function Hf(o) {
        window.open(o, "_blank", "noopener");
      }
      class wx extends be {
        constructor() {
          super(...arguments), this.manualDecorators = new Ht(), this.automaticDecorators = new ix();
        }
        restoreManualDecoratorStates() {
          for (const e of this.manualDecorators)
            e.value = this._getDecoratorStateFromModel(e.id);
        }
        refresh() {
          const e = this.editor.model, t = e.document.selection, n = t.getSelectedElement() || it(t.getSelectedBlocks());
          Ll(n, e.schema) ? (this.value = n.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttribute(n, "linkHref")) : (this.value = t.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref"));
          for (const i of this.manualDecorators)
            i.value = this._getDecoratorStateFromModel(i.id);
        }
        execute(e, t = {}) {
          const n = this.editor.model, i = n.document.selection, r = [], s = [];
          for (const a in t)
            t[a] ? r.push(a) : s.push(a);
          n.change((a) => {
            if (i.isCollapsed) {
              const l = i.getFirstPosition();
              if (i.hasAttribute("linkHref")) {
                const d = Uf(i);
                let h = Ko(l, "linkHref", i.getAttribute("linkHref"), n);
                i.getAttribute("linkHref") === d && (h = this._updateLinkContent(n, a, h, e)), a.setAttribute("linkHref", e, h), r.forEach((m) => {
                  a.setAttribute(m, !0, h);
                }), s.forEach((m) => {
                  a.removeAttribute(m, h);
                }), a.setSelection(a.createPositionAfter(h.end.nodeBefore));
              } else if (e !== "") {
                const d = pn(i.getAttributes());
                d.set("linkHref", e), r.forEach((m) => {
                  d.set(m, !0);
                });
                const { end: h } = n.insertContent(a.createText(e, d), l);
                a.setSelection(h);
              }
              ["linkHref", ...r, ...s].forEach((d) => {
                a.removeSelectionAttribute(d);
              });
            } else {
              const l = n.schema.getValidRanges(i.getRanges(), "linkHref"), d = [];
              for (const m of i.getSelectedBlocks())
                n.schema.checkAttribute(m, "linkHref") && d.push(a.createRangeOn(m));
              const h = d.slice();
              for (const m of l)
                this._isRangeToUpdate(m, d) && h.push(m);
              for (const m of h) {
                let f = m;
                if (h.length === 1) {
                  const _ = Uf(i);
                  i.getAttribute("linkHref") === _ && (f = this._updateLinkContent(n, a, m, e), a.setSelection(a.createSelection(f)));
                }
                a.setAttribute("linkHref", e, f), r.forEach((_) => {
                  a.setAttribute(_, !0, f);
                }), s.forEach((_) => {
                  a.removeAttribute(_, f);
                });
              }
            }
          });
        }
        _getDecoratorStateFromModel(e) {
          const t = this.editor.model, n = t.document.selection, i = n.getSelectedElement();
          return Ll(i, t.schema) ? i.getAttribute(e) : n.getAttribute(e);
        }
        _isRangeToUpdate(e, t) {
          for (const n of t)
            if (n.containsRange(e))
              return !1;
          return !0;
        }
        _updateLinkContent(e, t, n, i) {
          const r = t.createText(i, { linkHref: i });
          return e.insertContent(r, n);
        }
      }
      function Uf(o) {
        if (o.isCollapsed) {
          const e = o.getFirstPosition();
          return e.textNode && e.textNode.data;
        }
        {
          const e = Array.from(o.getFirstRange().getItems());
          if (e.length > 1)
            return null;
          const t = e[0];
          return t.is("$text") || t.is("$textProxy") ? t.data : null;
        }
      }
      class vx extends be {
        refresh() {
          const e = this.editor.model, t = e.document.selection, n = t.getSelectedElement();
          Ll(n, e.schema) ? this.isEnabled = e.schema.checkAttribute(n, "linkHref") : this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref");
        }
        execute() {
          const e = this.editor, t = this.editor.model, n = t.document.selection, i = e.commands.get("link");
          t.change((r) => {
            const s = n.isCollapsed ? [Ko(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), t)] : t.schema.getValidRanges(n.getRanges(), "linkHref");
            for (const a of s)
              if (r.removeAttribute("linkHref", a), i)
                for (const l of i.manualDecorators)
                  r.removeAttribute(l.id, a);
          });
        }
      }
      class _x extends re() {
        constructor({ id: e, label: t, attributes: n, classes: i, styles: r, defaultValue: s }) {
          super(), this.id = e, this.set("value", void 0), this.defaultValue = s, this.label = t, this.attributes = n, this.classes = i, this.styles = r;
        }
        _createPattern() {
          return { attributes: this.attributes, classes: this.classes, styles: this.styles };
        }
      }
      var qf = b(9773), Ax = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(qf.Z, Ax), qf.Z.locals;
      var Cx = Object.defineProperty, Wf = Object.getOwnPropertySymbols, yx = Object.prototype.hasOwnProperty, Ex = Object.prototype.propertyIsEnumerable, Gf = (o, e, t) => e in o ? Cx(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, xx = (o, e) => {
        for (var t in e || (e = {}))
          yx.call(e, t) && Gf(o, t, e[t]);
        if (Wf)
          for (var t of Wf(e))
            Ex.call(e, t) && Gf(o, t, e[t]);
        return o;
      };
      const Kf = "automatic", Sx = /^(https?:)?\/\//;
      class Dx extends W {
        static get pluginName() {
          return "LinkEditing";
        }
        static get requires() {
          return [qm, Fm, vn];
        }
        constructor(e) {
          super(e), e.config.define("link", { addTargetToExternalLinks: !1 });
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: "linkHref" }), e.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: Vf }), e.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (n, i) => Vf(Lf(n), i) }), e.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: { href: !0 } }, model: { key: "linkHref", value: (n) => n.getAttribute("href") } }), e.commands.add("link", new wx(e)), e.commands.add("unlink", new vx(e));
          const t = function(n, i) {
            const r = { "Open in a new tab": n("Open in a new tab"), Downloadable: n("Downloadable") };
            return i.forEach((s) => ("label" in s && r[s.label] && (s.label = r[s.label]), s)), i;
          }(e.t, function(n) {
            const i = [];
            if (n)
              for (const [r, s] of Object.entries(n)) {
                const a = Object.assign({}, s, { id: `link${mx(r)}` });
                i.push(a);
              }
            return i;
          }(e.config.get("link.decorators")));
          this._enableAutomaticDecorators(t.filter((n) => n.mode === Kf)), this._enableManualDecorators(t.filter((n) => n.mode === "manual")), e.plugins.get(qm).registerAttribute("linkHref"), function(n, i, r, s) {
            const a = n.editing.view, l = /* @__PURE__ */ new Set();
            a.document.registerPostFixer((d) => {
              const h = n.model.document.selection;
              let m = !1;
              if (h.hasAttribute(i)) {
                const f = Ko(h.getFirstPosition(), i, h.getAttribute(i), n.model), _ = n.editing.mapper.toViewRange(f);
                for (const S of _.getItems())
                  S.is("element", r) && !S.hasClass(s) && (d.addClass(s, S), l.add(S), m = !0);
              }
              return m;
            }), n.conversion.for("editingDowncast").add((d) => {
              function h() {
                a.change((m) => {
                  for (const f of l.values())
                    m.removeClass(s, f), l.delete(f);
                });
              }
              d.on("insert", h, { priority: "highest" }), d.on("remove", h, { priority: "highest" }), d.on("attribute", h, { priority: "highest" }), d.on("selection", h, { priority: "highest" });
            });
          }(e, "linkHref", "a", "ck-link_selected"), this._enableLinkOpen(), this._enableInsertContentSelectionAttributesFixer(), this._enableClickingAfterLink(), this._enableTypingOverLink(), this._handleDeleteContentAfterLink(), this._enableClipboardIntegration();
        }
        _enableAutomaticDecorators(e) {
          const t = this.editor, n = t.commands.get("link").automaticDecorators;
          t.config.get("link.addTargetToExternalLinks") && n.add({ id: "linkIsExternal", mode: Kf, callback: (i) => !!i && Sx.test(i), attributes: { target: "_blank", rel: "noopener noreferrer" } }), n.add(e), n.length && t.conversion.for("downcast").add(n.getDispatcher());
        }
        _enableManualDecorators(e) {
          if (!e.length)
            return;
          const t = this.editor, n = t.commands.get("link").manualDecorators;
          e.forEach((i) => {
            t.model.schema.extend("$text", { allowAttributes: i.id });
            const r = new _x(i);
            n.add(r), t.conversion.for("downcast").attributeToElement({ model: r.id, view: (s, { writer: a, schema: l }, { item: d }) => {
              if ((d.is("selection") || l.isInline(d)) && s) {
                const h = a.createAttributeElement("a", r.attributes, { priority: 5 });
                r.classes && a.addClass(r.classes, h);
                for (const m in r.styles)
                  a.setStyle(m, r.styles[m], h);
                return a.setCustomProperty("link", !0, h), h;
              }
            } }), t.conversion.for("upcast").elementToAttribute({ view: xx({ name: "a" }, r._createPattern()), model: { key: r.id } });
          });
        }
        _enableLinkOpen() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "click", (n, i) => {
            if (!(k.isMac ? i.domEvent.metaKey : i.domEvent.ctrlKey))
              return;
            let r = i.domTarget;
            if (r.tagName.toLowerCase() != "a" && (r = r.closest("a")), !r)
              return;
            const s = r.getAttribute("href");
            s && (n.stop(), i.preventDefault(), Hf(s));
          }, { context: "$capture" }), this.listenTo(t, "keydown", (n, i) => {
            const r = e.commands.get("link").value;
            r && i.keyCode === Ce.enter && i.altKey && (n.stop(), Hf(r));
          });
        }
        _enableInsertContentSelectionAttributesFixer() {
          const e = this.editor.model, t = e.document.selection;
          this.listenTo(e, "insertContent", () => {
            const n = t.anchor.nodeBefore, i = t.anchor.nodeAfter;
            t.hasAttribute("linkHref") && n && n.hasAttribute("linkHref") && (i && i.hasAttribute("linkHref") || e.change((r) => {
              Hl(r, Ul(e.schema));
            }));
          }, { priority: "low" });
        }
        _enableClickingAfterLink() {
          const e = this.editor, t = e.model;
          e.editing.view.addObserver(il);
          let n = !1;
          this.listenTo(e.editing.view.document, "mousedown", () => {
            n = !0;
          }), this.listenTo(e.editing.view.document, "selectionChange", () => {
            if (!n)
              return;
            n = !1;
            const i = t.document.selection;
            if (!i.isCollapsed || !i.hasAttribute("linkHref"))
              return;
            const r = i.getFirstPosition(), s = Ko(r, "linkHref", i.getAttribute("linkHref"), t);
            (r.isTouching(s.start) || r.isTouching(s.end)) && t.change((a) => {
              Hl(a, Ul(t.schema));
            });
          });
        }
        _enableTypingOverLink() {
          const e = this.editor, t = e.editing.view;
          let n = null, i = !1;
          this.listenTo(t.document, "delete", () => {
            i = !0;
          }, { priority: "high" }), this.listenTo(e.model, "deleteContent", () => {
            const r = e.model.document.selection;
            r.isCollapsed || (i ? i = !1 : Zf(e) && function(s) {
              const a = s.document.selection, l = a.getFirstPosition(), d = a.getLastPosition(), h = l.nodeAfter;
              if (!h || !h.is("$text") || !h.hasAttribute("linkHref"))
                return !1;
              const m = d.textNode || d.nodeBefore;
              return h === m ? !0 : Ko(l, "linkHref", h.getAttribute("linkHref"), s).containsRange(s.createRange(l, d), !0);
            }(e.model) && (n = r.getAttributes()));
          }, { priority: "high" }), this.listenTo(e.model, "insertContent", (r, [s]) => {
            i = !1, Zf(e) && n && (e.model.change((a) => {
              for (const [l, d] of n)
                a.setAttribute(l, d, s);
            }), n = null);
          }, { priority: "high" });
        }
        _handleDeleteContentAfterLink() {
          const e = this.editor, t = e.model, n = t.document.selection, i = e.editing.view;
          let r = !1, s = !1;
          this.listenTo(i.document, "delete", (a, l) => {
            s = l.direction === "backward";
          }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
            r = !1;
            const a = n.getFirstPosition(), l = n.getAttribute("linkHref");
            if (!l)
              return;
            const d = Ko(a, "linkHref", l, t);
            r = d.containsPosition(a) || d.end.isEqual(a);
          }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
            s && (s = !1, r || e.model.enqueueChange((a) => {
              Hl(a, Ul(t.schema));
            }));
          }, { priority: "low" });
        }
        _enableClipboardIntegration() {
          const e = this.editor, t = e.model, n = this.editor.config.get("link.defaultProtocol");
          n && this.listenTo(e.plugins.get("ClipboardPipeline"), "contentInsertion", (i, r) => {
            t.change((s) => {
              const a = s.createRangeIn(r.content);
              for (const l of a.getItems())
                if (l.hasAttribute("linkHref")) {
                  const d = jl(l.getAttribute("linkHref"), n);
                  s.setAttribute("linkHref", d, l);
                }
            });
          });
        }
      }
      function Hl(o, e) {
        o.removeSelectionAttribute("linkHref");
        for (const t of e)
          o.removeSelectionAttribute(t);
      }
      function Zf(o) {
        return o.model.change((e) => e.batch).isTyping;
      }
      function Ul(o) {
        return o.getDefinition("$text").allowAttributes.filter((e) => e.startsWith("link"));
      }
      var Jf = b(7754), Bx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Jf.Z, Bx), Jf.Z.locals;
      class Tx extends _e {
        constructor(e, t) {
          super(e), this.focusTracker = new Jt(), this.keystrokes = new mn(), this._focusables = new Yn();
          const n = e.t;
          this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n("Save"), qe.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n("Cancel"), qe.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(t), this.children = this._createFormChildren(t.manualDecorators), this._focusCycler = new Si({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } });
          const i = ["ck", "ck-link-form", "ck-responsive-form"];
          t.manualDecorators.length && i.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({ tag: "form", attributes: { class: i, tabindex: "-1" }, children: this.children });
        }
        getDecoratorSwitchesState() {
          return Array.from(this._manualDecoratorSwitches).reduce((e, t) => (e[t.name] = t.isOn, e), {});
        }
        render() {
          super.render(), p({ view: this }), [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach((e) => {
            this._focusables.add(e), this.focusTracker.add(e.element);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createUrlInput() {
          const e = this.locale.t, t = new Du(this.locale, Qg);
          return t.label = e("Link URL"), t;
        }
        _createButton(e, t, n, i) {
          const r = new je(this.locale);
          return r.set({ label: e, icon: t, tooltip: !0 }), r.extendTemplate({ attributes: { class: n } }), i && r.delegate("execute").to(this, i), r;
        }
        _createManualDecoratorSwitches(e) {
          const t = this.createCollection();
          for (const n of e.manualDecorators) {
            const i = new Pr(this.locale);
            i.set({ name: n.id, label: n.label, withText: !0 }), i.bind("isOn").toMany([n, e], "value", (r, s) => s === void 0 && r === void 0 ? !!n.defaultValue : !!r), i.on("execute", () => {
              n.set("value", !i.isOn);
            }), t.add(i);
          }
          return t;
        }
        _createFormChildren(e) {
          const t = this.createCollection();
          if (t.add(this.urlInputView), e.length) {
            const n = new _e();
            n.setTemplate({ tag: "ul", children: this._manualDecoratorSwitches.map((i) => ({ tag: "li", children: [i], attributes: { class: ["ck", "ck-list__item"] } })), attributes: { class: ["ck", "ck-reset", "ck-list"] } }), t.add(n);
          }
          return t.add(this.saveButtonView), t.add(this.cancelButtonView), t;
        }
      }
      var Yf = b(2347), Ix = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Yf.Z, Ix), Yf.Z.locals;
      class Px extends _e {
        constructor(e) {
          super(e), this.focusTracker = new Jt(), this.keystrokes = new mn(), this._focusables = new Yn();
          const t = e.t;
          this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(t("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"), this.editButtonView = this._createButton(t("Edit link"), qe.pencil, "edit"), this.set("href", void 0), this._focusCycler = new Si({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1" }, children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView] });
        }
        render() {
          super.render(), [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach((e) => {
            this._focusables.add(e), this.focusTracker.add(e.element);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createButton(e, t, n) {
          const i = new je(this.locale);
          return i.set({ label: e, icon: t, tooltip: !0 }), i.delegate("execute").to(this, n), i;
        }
        _createPreviewButton() {
          const e = new je(this.locale), t = this.bindTemplate, n = this.t;
          return e.set({ withText: !0, tooltip: n("Open link in new tab") }), e.extendTemplate({ attributes: { class: ["ck", "ck-link-actions__preview"], href: t.to("href", (i) => i && Lf(i)), target: "_blank", rel: "noopener noreferrer" } }), e.bind("label").to(this, "href", (i) => i || n("This link has no URL")), e.bind("isEnabled").to(this, "href", (i) => !!i), e.template.tag = "a", e.template.eventListeners = {}, e;
        }
      }
      const hn = "link-ui";
      class Ox extends W {
        constructor() {
          super(...arguments), this.actionsView = null, this.formView = null;
        }
        static get requires() {
          return [rs];
        }
        static get pluginName() {
          return "LinkUI";
        }
        init() {
          const e = this.editor;
          e.editing.view.addObserver(N1), this._balloon = e.plugins.get(rs), this._createToolbarLinkButton(), this._enableBalloonActivators(), e.conversion.for("editingDowncast").markerToHighlight({ model: hn, view: { classes: ["ck-fake-link-selection"] } }), e.conversion.for("editingDowncast").markerToElement({ model: hn, view: { name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"] } });
        }
        destroy() {
          super.destroy(), this.formView && this.formView.destroy(), this.actionsView && this.actionsView.destroy();
        }
        _createViews() {
          this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._enableUserBalloonInteractions();
        }
        _createActionsView() {
          const e = this.editor, t = new Px(e.locale), n = e.commands.get("link"), i = e.commands.get("unlink");
          return t.bind("href").to(n, "value"), t.editButtonView.bind("isEnabled").to(n), t.unlinkButtonView.bind("isEnabled").to(i), this.listenTo(t, "edit", () => {
            this._addFormView();
          }), this.listenTo(t, "unlink", () => {
            e.execute("unlink"), this._hideUI();
          }), t.keystrokes.set("Esc", (r, s) => {
            this._hideUI(), s();
          }), t.keystrokes.set(Vl, (r, s) => {
            this._addFormView(), s();
          }), t;
        }
        _createFormView() {
          const e = this.editor, t = e.commands.get("link"), n = e.config.get("link.defaultProtocol"), i = new (C(Tx))(e.locale, t);
          return i.urlInputView.fieldView.bind("value").to(t, "value"), i.urlInputView.bind("isEnabled").to(t, "isEnabled"), i.saveButtonView.bind("isEnabled").to(t), this.listenTo(i, "submit", () => {
            const { value: r } = i.urlInputView.fieldView.element, s = jl(r, n);
            e.execute("link", s, i.getDecoratorSwitchesState()), this._closeFormView();
          }), this.listenTo(i, "cancel", () => {
            this._closeFormView();
          }), i.keystrokes.set("Esc", (r, s) => {
            this._closeFormView(), s();
          }), i;
        }
        _createToolbarLinkButton() {
          const e = this.editor, t = e.commands.get("link"), n = e.t;
          e.ui.componentFactory.add("link", (i) => {
            const r = new je(i);
            return r.isEnabled = !0, r.label = n("Link"), r.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', r.keystroke = Vl, r.tooltip = !0, r.isToggleable = !0, r.bind("isEnabled").to(t, "isEnabled"), r.bind("isOn").to(t, "value", (s) => !!s), this.listenTo(r, "execute", () => this._showUI(!0)), r;
          });
        }
        _enableBalloonActivators() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "click", () => {
            this._getSelectedLinkElement() && this._showUI();
          }), e.keystrokes.set(Vl, (n, i) => {
            i(), e.commands.get("link").isEnabled && this._showUI(!0);
          });
        }
        _enableUserBalloonInteractions() {
          this.editor.keystrokes.set("Tab", (e, t) => {
            this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), t());
          }, { priority: "high" }), this.editor.keystrokes.set("Esc", (e, t) => {
            this._isUIVisible && (this._hideUI(), t());
          }), v({ emitter: this.formView, activator: () => this._isUIInPanel, contextElements: () => [this._balloon.view.element], callback: () => this._hideUI() });
        }
        _addActionsView() {
          this.actionsView || this._createViews(), this._areActionsInPanel || this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() });
        }
        _addFormView() {
          if (this.formView || this._createViews(), this._isFormInPanel)
            return;
          const e = this.editor.commands.get("link");
          this.formView.disableCssTransitions(), this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions(), this.formView.urlInputView.fieldView.element.value = e.value || "";
        }
        _closeFormView() {
          const e = this.editor.commands.get("link");
          e.restoreManualDecoratorStates(), e.value !== void 0 ? this._removeFormView() : this._hideUI();
        }
        _removeFormView() {
          this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection());
        }
        _showUI(e = !1) {
          this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), e && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), e && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
        }
        _hideUI() {
          if (!this._isUIInPanel)
            return;
          const e = this.editor;
          this.stopListening(e.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), e.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection();
        }
        _startUpdatingUI() {
          const e = this.editor, t = e.editing.view.document;
          let n = this._getSelectedLinkElement(), i = s();
          const r = () => {
            const a = this._getSelectedLinkElement(), l = s();
            n && !a || !n && l !== i ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n = a, i = l;
          };
          function s() {
            return t.selection.focus.getAncestors().reverse().find((a) => a.is("element"));
          }
          this.listenTo(e.ui, "update", r), this.listenTo(this._balloon, "change:visibleView", r);
        }
        get _isFormInPanel() {
          return !!this.formView && this._balloon.hasView(this.formView);
        }
        get _areActionsInPanel() {
          return !!this.actionsView && this._balloon.hasView(this.actionsView);
        }
        get _areActionsVisible() {
          return !!this.actionsView && this._balloon.visibleView === this.actionsView;
        }
        get _isUIInPanel() {
          return this._isFormInPanel || this._areActionsInPanel;
        }
        get _isUIVisible() {
          const e = this._balloon.visibleView;
          return !!this.formView && e == this.formView || this._areActionsVisible;
        }
        _getBalloonPositionData() {
          const e = this.editor.editing.view, t = this.editor.model, n = e.document;
          let i;
          if (t.markers.has(hn)) {
            const r = Array.from(this.editor.editing.mapper.markerNameToElements(hn)), s = e.createRange(e.createPositionBefore(r[0]), e.createPositionAfter(r[r.length - 1]));
            i = e.domConverter.viewRangeToDom(s);
          } else
            i = () => {
              const r = this._getSelectedLinkElement();
              return r ? e.domConverter.mapViewToDom(r) : e.domConverter.viewRangeToDom(n.selection.getFirstRange());
            };
          return { target: i };
        }
        _getSelectedLinkElement() {
          const e = this.editor.editing.view, t = e.document.selection, n = t.getSelectedElement();
          if (t.isCollapsed || n && Je(n))
            return ql(t.getFirstPosition());
          {
            const i = t.getFirstRange().getTrimmed(), r = ql(i.start), s = ql(i.end);
            return r && r == s && e.createRangeIn(r).getTrimmed().isEqual(i) ? r : null;
          }
        }
        _showFakeVisualSelection() {
          const e = this.editor.model;
          e.change((t) => {
            const n = e.document.selection.getFirstRange();
            if (e.markers.has(hn))
              t.updateMarker(hn, { range: n });
            else if (n.start.isAtEnd) {
              const i = n.start.getLastMatchingPosition(({ item: r }) => !e.schema.isContent(r), { boundaries: n });
              t.addMarker(hn, { usingOperation: !1, affectsData: !1, range: t.createRange(i, n.end) });
            } else
              t.addMarker(hn, { usingOperation: !1, affectsData: !1, range: n });
          });
        }
        _hideFakeVisualSelection() {
          const e = this.editor.model;
          e.markers.has(hn) && e.change((t) => {
            t.removeMarker(hn);
          });
        }
      }
      function ql(o) {
        return o.getAncestors().find((e) => {
          return (t = e).is("attributeElement") && !!t.getCustomProperty("link");
          var t;
        }) || null;
      }
      const Rx = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i");
      class zx extends W {
        static get requires() {
          return [Wo];
        }
        static get pluginName() {
          return "AutoLink";
        }
        init() {
          const e = this.editor.model.document.selection;
          e.on("change:range", () => {
            this.isEnabled = !e.anchor.parent.is("element", "codeBlock");
          }), this._enableTypingHandling();
        }
        afterInit() {
          this._enableEnterHandling(), this._enableShiftEnterHandling();
        }
        _enableTypingHandling() {
          const e = this.editor, t = new Um(e.model, (n) => {
            if (!function(r) {
              return r.length > 4 && r[r.length - 1] === " " && r[r.length - 2] !== " ";
            }(n))
              return;
            const i = Qf(n.substr(0, n.length - 1));
            return i ? { url: i } : void 0;
          });
          t.on("matched:data", (n, i) => {
            const { batch: r, range: s, url: a } = i;
            if (!r.isTyping)
              return;
            const l = s.end.getShiftedBy(-1), d = l.getShiftedBy(-a.length), h = e.model.createRange(d, l);
            this._applyAutoLink(a, h);
          }), t.bind("isEnabled").to(this);
        }
        _enableEnterHandling() {
          const e = this.editor, t = e.model, n = e.commands.get("enter");
          n && n.on("execute", () => {
            const i = t.document.selection.getFirstPosition();
            if (!i.parent.previousSibling)
              return;
            const r = t.createRangeIn(i.parent.previousSibling);
            this._checkAndApplyAutoLinkOnRange(r);
          });
        }
        _enableShiftEnterHandling() {
          const e = this.editor, t = e.model, n = e.commands.get("shiftEnter");
          n && n.on("execute", () => {
            const i = t.document.selection.getFirstPosition(), r = t.createRange(t.createPositionAt(i.parent, 0), i.getShiftedBy(-1));
            this._checkAndApplyAutoLinkOnRange(r);
          });
        }
        _checkAndApplyAutoLinkOnRange(e) {
          const t = this.editor.model, { text: n, range: i } = Hm(e, t), r = Qf(n);
          if (r) {
            const s = t.createRange(i.end.getShiftedBy(-r.length), i.end);
            this._applyAutoLink(r, s);
          }
        }
        _applyAutoLink(e, t) {
          const n = this.editor.model, i = jl(e, this.editor.config.get("link.defaultProtocol"));
          this.isEnabled && function(r, s) {
            return s.schema.checkAttributeInSelection(s.createSelection(r), "linkHref");
          }(t, n) && jf(i) && !function(r) {
            const s = r.start.nodeAfter;
            return !!s && s.hasAttribute("linkHref");
          }(t) && this._persistAutoLink(i, t);
        }
        _persistAutoLink(e, t) {
          const n = this.editor.model, i = this.editor.plugins.get("Delete");
          n.enqueueChange((r) => {
            r.setAttribute("linkHref", e, t), n.enqueueChange(() => {
              i.requestUndoOnBackspace();
            });
          });
        }
      }
      function Qf(o) {
        const e = Rx.exec(o);
        return e ? e[2] : null;
      }
      var Xf = b(111), Mx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Xf.Z, Mx), Xf.Z.locals;
      var eb = b(5730), Nx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(eb.Z, Nx), eb.Z.locals;
      var tb = b(4564), Fx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(tb.Z, Fx), tb.Z.locals;
      function $x(o, e) {
        const t = e.mapper, n = e.writer, i = o.getAttribute("listType") == "numbered" ? "ol" : "ul", r = function(a) {
          const l = a.createContainerElement("li");
          return l.getFillerOffset = jx, l;
        }(n), s = n.createContainerElement(i, null);
        return n.insert(n.createPositionAt(s, 0), r), t.bindElements(o, r), r;
      }
      function nb(o, e, t, n) {
        const i = e.parent, r = t.mapper, s = t.writer;
        let a = r.toViewPosition(n.createPositionBefore(o));
        const l = ib(o.previousSibling, { sameIndent: !0, smallerIndent: !0, listIndent: o.getAttribute("listIndent") }), d = o.previousSibling;
        if (l && l.getAttribute("listIndent") == o.getAttribute("listIndent")) {
          const h = r.toViewElement(l);
          a = s.breakContainer(s.createPositionAfter(h));
        } else if (d && d.name == "listItem") {
          a = r.toViewPosition(n.createPositionAt(d, "end"));
          const h = r.findMappedViewAncestor(a), m = function(f) {
            for (const _ of f.getChildren())
              if (_.name == "ul" || _.name == "ol")
                return _;
            return null;
          }(h);
          a = m ? s.createPositionBefore(m) : s.createPositionAt(h, "end");
        } else
          a = r.toViewPosition(n.createPositionBefore(o));
        if (a = ob(a), s.insert(a, i), d && d.name == "listItem") {
          const h = r.toViewElement(d), m = s.createRange(s.createPositionAt(h, 0), a).getWalker({ ignoreElementEnd: !0 });
          for (const f of m)
            if (f.item.is("element", "li")) {
              const _ = s.breakContainer(s.createPositionBefore(f.item)), S = f.item.parent, B = s.createPositionAt(e, "end");
              qt(s, B.nodeBefore, B.nodeAfter), s.move(s.createRangeOn(S), B), m._position = _;
            }
        } else {
          const h = i.nextSibling;
          if (h && (h.is("element", "ul") || h.is("element", "ol"))) {
            let m = null;
            for (const f of h.getChildren()) {
              const _ = r.toModelElement(f);
              if (!(_ && _.getAttribute("listIndent") > o.getAttribute("listIndent")))
                break;
              m = f;
            }
            m && (s.breakContainer(s.createPositionAfter(m)), s.move(s.createRangeOn(m.parent), s.createPositionAt(e, "end")));
          }
        }
        qt(s, i, i.nextSibling), qt(s, i.previousSibling, i);
      }
      function qt(o, e, t) {
        return !e || !t || e.name != "ul" && e.name != "ol" || e.name != t.name || e.getAttribute("class") !== t.getAttribute("class") ? null : o.mergeContainers(o.createPositionAfter(e));
      }
      function ob(o) {
        return o.getLastMatchingPosition((e) => e.item.is("uiElement"));
      }
      function ib(o, e) {
        const t = !!e.sameIndent, n = !!e.smallerIndent, i = e.listIndent;
        let r = o;
        for (; r && r.name == "listItem"; ) {
          const s = r.getAttribute("listIndent");
          if (t && i == s || n && i > s)
            return r;
          r = e.direction === "forward" ? r.nextSibling : r.previousSibling;
        }
        return null;
      }
      function rb(o, e, t, n) {
        o.ui.componentFactory.add(e, (i) => {
          const r = o.commands.get(e), s = new je(i);
          return s.set({ label: t, icon: n, tooltip: !0, isToggleable: !0 }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), s.on("execute", () => {
            o.execute(e), o.editing.view.focus();
          }), s;
        });
      }
      function Wl(o, e) {
        const t = [], n = o.parent, i = { ignoreElementEnd: !1, startPosition: o, shallow: !0, direction: e }, r = n.getAttribute("listIndent"), s = [...new dn(i)].filter((a) => a.item.is("element")).map((a) => a.item);
        for (const a of s) {
          if (!a.is("element", "listItem") || a.getAttribute("listIndent") < r)
            break;
          if (!(a.getAttribute("listIndent") > r)) {
            if (a.getAttribute("listType") !== n.getAttribute("listType") || a.getAttribute("listStyle") !== n.getAttribute("listStyle") || a.getAttribute("listReversed") !== n.getAttribute("listReversed") || a.getAttribute("listStart") !== n.getAttribute("listStart"))
              break;
            e === "backward" ? t.unshift(a) : t.push(a);
          }
        }
        return t;
      }
      const Vx = ["disc", "circle", "square"], Lx = ["decimal", "decimal-leading-zero", "lower-roman", "upper-roman", "lower-latin", "upper-latin"];
      function jx() {
        const o = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
        return this.isEmpty || o ? 0 : eh.call(this);
      }
      class Hx extends W {
        static get pluginName() {
          return "ListUI";
        }
        init() {
          const e = this.editor.t;
          rb(this.editor, "numberedList", e("Numbered List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'), rb(this.editor, "bulletedList", e("Bulleted List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>');
        }
      }
      const Ux = [{ listStyle: "disc", typeAttribute: "disc", listType: "bulleted" }, { listStyle: "circle", typeAttribute: "circle", listType: "bulleted" }, { listStyle: "square", typeAttribute: "square", listType: "bulleted" }, { listStyle: "decimal", typeAttribute: "1", listType: "numbered" }, { listStyle: "decimal-leading-zero", typeAttribute: null, listType: "numbered" }, { listStyle: "lower-roman", typeAttribute: "i", listType: "numbered" }, { listStyle: "upper-roman", typeAttribute: "I", listType: "numbered" }, { listStyle: "lower-alpha", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-alpha", typeAttribute: "A", listType: "numbered" }, { listStyle: "lower-latin", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-latin", typeAttribute: "A", listType: "numbered" }];
      for (const { listStyle: o, typeAttribute: e, listType: t } of Ux)
        ;
      var sb = b(4721), qx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(sb.Z, qx), sb.Z.locals;
      var ab = b(6082), Wx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(ab.Z, Wx), ab.Z.locals;
      var lb = b(2417), Gx = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(lb.Z, Gx), lb.Z.locals;
      class cb extends be {
        constructor(e, t) {
          super(e), this._indentBy = t == "forward" ? 1 : -1;
        }
        refresh() {
          this.isEnabled = this._checkEnabled();
        }
        execute() {
          const e = this.editor.model, t = e.document;
          let n = Array.from(t.selection.getSelectedBlocks());
          e.change((i) => {
            const r = n[n.length - 1];
            let s = r.nextSibling;
            for (; s && s.name == "listItem" && s.getAttribute("listIndent") > r.getAttribute("listIndent"); )
              n.push(s), s = s.nextSibling;
            this._indentBy < 0 && (n = n.reverse());
            for (const a of n) {
              const l = a.getAttribute("listIndent") + this._indentBy;
              l < 0 ? i.rename(a, "paragraph") : i.setAttribute("listIndent", l, a);
            }
            this.fire("_executeCleanup", n);
          });
        }
        _checkEnabled() {
          const e = it(this.editor.model.document.selection.getSelectedBlocks());
          if (!e || !e.is("element", "listItem"))
            return !1;
          if (this._indentBy > 0) {
            const t = e.getAttribute("listIndent"), n = e.getAttribute("listType");
            let i = e.previousSibling;
            for (; i && i.is("element", "listItem") && i.getAttribute("listIndent") >= t; ) {
              if (i.getAttribute("listIndent") == t)
                return i.getAttribute("listType") == n;
              i = i.previousSibling;
            }
            return !1;
          }
          return !0;
        }
      }
      class db extends be {
        constructor(e, t) {
          super(e), this.type = t;
        }
        refresh() {
          this.value = this._getValue(), this.isEnabled = this._checkEnabled();
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document, i = Array.from(n.selection.getSelectedBlocks()).filter((s) => hb(s, t.schema)), r = e.forceValue !== void 0 ? !e.forceValue : this.value;
          t.change((s) => {
            if (r) {
              let a = i[i.length - 1].nextSibling, l = Number.POSITIVE_INFINITY, d = [];
              for (; a && a.name == "listItem" && a.getAttribute("listIndent") !== 0; ) {
                const h = a.getAttribute("listIndent");
                h < l && (l = h);
                const m = h - l;
                d.push({ element: a, listIndent: m }), a = a.nextSibling;
              }
              d = d.reverse();
              for (const h of d)
                s.setAttribute("listIndent", h.listIndent, h.element);
            }
            if (!r) {
              let a = Number.POSITIVE_INFINITY;
              for (const l of i)
                l.is("element", "listItem") && l.getAttribute("listIndent") < a && (a = l.getAttribute("listIndent"));
              a = a === 0 ? 1 : a, ub(i, !0, a), ub(i, !1, a);
            }
            for (const a of i.reverse())
              r && a.name == "listItem" ? s.rename(a, "paragraph") : r || a.name == "listItem" ? r || a.name != "listItem" || a.getAttribute("listType") == this.type || s.setAttribute("listType", this.type, a) : (s.setAttributes({ listType: this.type, listIndent: 0 }, a), s.rename(a, "listItem"));
            this.fire("_executeCleanup", i);
          });
        }
        _getValue() {
          const e = it(this.editor.model.document.selection.getSelectedBlocks());
          return !!e && e.is("element", "listItem") && e.getAttribute("listType") == this.type;
        }
        _checkEnabled() {
          if (this.value)
            return !0;
          const e = this.editor.model.document.selection, t = this.editor.model.schema, n = it(e.getSelectedBlocks());
          return !!n && hb(n, t);
        }
      }
      function ub(o, e, t) {
        const n = e ? o[0] : o[o.length - 1];
        if (n.is("element", "listItem")) {
          let i = n[e ? "previousSibling" : "nextSibling"], r = n.getAttribute("listIndent");
          for (; i && i.is("element", "listItem") && i.getAttribute("listIndent") >= t; )
            r > i.getAttribute("listIndent") && (r = i.getAttribute("listIndent")), i.getAttribute("listIndent") == r && o[e ? "unshift" : "push"](i), i = i[e ? "previousSibling" : "nextSibling"];
        }
      }
      function hb(o, e) {
        return e.checkChild(o.parent, "listItem") && !e.isObject(o);
      }
      class Kx extends W {
        static get pluginName() {
          return "ListUtils";
        }
        getListTypeFromListStyleType(e) {
          return function(t) {
            return Vx.includes(t) ? "bulleted" : Lx.includes(t) ? "numbered" : null;
          }(e);
        }
        getSelectedListItems(e) {
          return function(t) {
            let n = [...t.document.selection.getSelectedBlocks()].filter((i) => i.is("element", "listItem")).map((i) => {
              const r = t.change((s) => s.createPositionAt(i, 0));
              return [...Wl(r, "backward"), ...Wl(r, "forward")];
            }).flat();
            return n = [...new Set(n)], n;
          }(e);
        }
        getSiblingNodes(e, t) {
          return Wl(e, t);
        }
      }
      function gb(o) {
        return (e, t, n) => {
          const i = n.consumable;
          if (!i.test(t.item, "insert") || !i.test(t.item, "attribute:listType") || !i.test(t.item, "attribute:listIndent"))
            return;
          i.consume(t.item, "insert"), i.consume(t.item, "attribute:listType"), i.consume(t.item, "attribute:listIndent");
          const r = t.item;
          nb(r, $x(r, n), n, o);
        };
      }
      const Zx = (o, e, t) => {
        if (!t.consumable.test(e.item, o.name))
          return;
        const n = t.mapper.toViewElement(e.item), i = t.writer;
        i.breakContainer(i.createPositionBefore(n)), i.breakContainer(i.createPositionAfter(n));
        const r = n.parent, s = e.attributeNewValue == "numbered" ? "ol" : "ul";
        i.rename(s, r);
      }, Jx = (o, e, t) => {
        t.consumable.consume(e.item, o.name);
        const n = t.mapper.toViewElement(e.item).parent, i = t.writer;
        qt(i, n, n.nextSibling), qt(i, n.previousSibling, n);
      }, mb = (o, e, t) => {
        if (t.consumable.test(e.item, o.name) && e.item.name != "listItem") {
          let n = t.mapper.toViewPosition(e.range.start);
          const i = t.writer, r = [];
          for (; (n.parent.name == "ul" || n.parent.name == "ol") && (n = i.breakContainer(n), n.parent.name == "li"); ) {
            const s = n, a = i.createPositionAt(n.parent, "end");
            if (!s.isEqual(a)) {
              const l = i.remove(i.createRange(s, a));
              r.push(l);
            }
            n = i.createPositionAfter(n.parent);
          }
          if (r.length > 0) {
            for (let s = 0; s < r.length; s++) {
              const a = n.nodeBefore;
              if (n = i.insert(n, r[s]).end, s > 0) {
                const l = qt(i, a, a.nextSibling);
                l && l.parent == a && n.offset--;
              }
            }
            qt(i, n.nodeBefore, n.nodeAfter);
          }
        }
      }, Yx = (o, e, t) => {
        const n = t.mapper.toViewPosition(e.position), i = n.nodeBefore, r = n.nodeAfter;
        qt(t.writer, i, r);
      }, Qx = (o, e, t) => {
        if (t.consumable.consume(e.viewItem, { name: !0 })) {
          const n = t.writer, i = n.createElement("listItem"), r = function(l) {
            let d = 0, h = l.parent;
            for (; h; ) {
              if (h.is("element", "li"))
                d++;
              else {
                const m = h.previousSibling;
                m && m.is("element", "li") && d++;
              }
              h = h.parent;
            }
            return d;
          }(e.viewItem);
          n.setAttribute("listIndent", r, i);
          const s = e.viewItem.parent && e.viewItem.parent.name == "ol" ? "numbered" : "bulleted";
          if (n.setAttribute("listType", s, i), !t.safeInsert(i, e.modelCursor))
            return;
          const a = function(l, d, h) {
            const { writer: m, schema: f } = h;
            let _ = m.createPositionAfter(l);
            for (const S of d)
              if (S.name == "ul" || S.name == "ol")
                _ = h.convertItem(S, _).modelCursor;
              else {
                const B = h.convertItem(S, m.createPositionAt(l, "end")), T = B.modelRange.start.nodeAfter;
                T && T.is("element") && !f.checkChild(l, T.name) && (l = B.modelCursor.parent.is("element", "listItem") ? B.modelCursor.parent : tS(B.modelCursor), _ = m.createPositionAfter(l));
              }
            return _;
          }(i, e.viewItem.getChildren(), t);
          e.modelRange = n.createRange(e.modelCursor, a), t.updateConversionResult(i, e);
        }
      }, pb = (o, e, t) => {
        if (t.consumable.test(e.viewItem, { name: !0 })) {
          const n = Array.from(e.viewItem.getChildren());
          for (const i of n)
            !(i.is("element", "li") || Yo(i)) && i._remove();
        }
      }, Xx = (o, e, t) => {
        if (t.consumable.test(e.viewItem, { name: !0 })) {
          if (e.viewItem.childCount === 0)
            return;
          const n = [...e.viewItem.getChildren()];
          let i = !1;
          for (const r of n)
            i && !Yo(r) && r._remove(), Yo(r) && (i = !0);
        }
      };
      function fb(o) {
        return (e, t) => {
          if (t.isPhantom)
            return;
          const n = t.modelPosition.nodeBefore;
          if (n && n.is("element", "listItem")) {
            const i = t.mapper.toViewElement(n), r = i.getAncestors().find(Yo), s = o.createPositionAt(i, 0).getWalker();
            for (const a of s) {
              if (a.type == "elementStart" && a.item.is("element", "li")) {
                t.viewPosition = a.previousPosition;
                break;
              }
              if (a.type == "elementEnd" && a.item == r) {
                t.viewPosition = a.nextPosition;
                break;
              }
            }
          }
        };
      }
      const eS = function(o, [e, t]) {
        const n = this;
        let i, r = e.is("documentFragment") ? e.getChild(0) : e;
        if (i = t ? n.createSelection(t) : n.document.selection, r && r.is("element", "listItem")) {
          const s = i.getFirstPosition();
          let a = null;
          if (s.parent.is("element", "listItem") ? a = s.parent : s.nodeBefore && s.nodeBefore.is("element", "listItem") && (a = s.nodeBefore), a) {
            const l = a.getAttribute("listIndent");
            if (l > 0)
              for (; r && r.is("element", "listItem"); )
                r._setAttribute("listIndent", r.getAttribute("listIndent") + l), r = r.nextSibling;
          }
        }
      };
      function tS(o) {
        const e = new dn({ startPosition: o });
        let t;
        do
          t = e.next();
        while (!t.value.item.is("element", "listItem"));
        return t.value.item;
      }
      function bb(o, e, t, n, i, r) {
        const s = ib(e.nodeBefore, { sameIndent: !0, smallerIndent: !0, listIndent: o }), a = i.mapper, l = i.writer, d = s ? s.getAttribute("listIndent") : null;
        let h;
        if (s)
          if (d == o) {
            const m = a.toViewElement(s).parent;
            h = l.createPositionAfter(m);
          } else {
            const m = r.createPositionAt(s, "end");
            h = a.toViewPosition(m);
          }
        else
          h = t;
        h = ob(h);
        for (const m of [...n.getChildren()])
          Yo(m) && (h = l.move(l.createRangeOn(m), h).end, qt(l, m, m.nextSibling), qt(l, m.previousSibling, m));
      }
      function Yo(o) {
        return o.is("element", "ol") || o.is("element", "ul");
      }
      class nS extends W {
        static get pluginName() {
          return "ListEditing";
        }
        static get requires() {
          return [qi, Wo, Kx];
        }
        init() {
          const e = this.editor;
          e.model.schema.register("listItem", { inheritAllFrom: "$block", allowAttributes: ["listType", "listIndent"] });
          const t = e.data, n = e.editing;
          var i;
          e.model.document.registerPostFixer((s) => function(a, l) {
            const d = a.document.differ.getChanges(), h = /* @__PURE__ */ new Map();
            let m = !1;
            for (const B of d)
              if (B.type == "insert" && B.name == "listItem")
                f(B.position);
              else if (B.type == "insert" && B.name != "listItem") {
                if (B.name != "$text") {
                  const T = B.position.nodeAfter;
                  T.hasAttribute("listIndent") && (l.removeAttribute("listIndent", T), m = !0), T.hasAttribute("listType") && (l.removeAttribute("listType", T), m = !0), T.hasAttribute("listStyle") && (l.removeAttribute("listStyle", T), m = !0), T.hasAttribute("listReversed") && (l.removeAttribute("listReversed", T), m = !0), T.hasAttribute("listStart") && (l.removeAttribute("listStart", T), m = !0);
                  for (const R of Array.from(a.createRangeIn(T)).filter((N) => N.item.is("element", "listItem")))
                    f(R.previousPosition);
                }
                f(B.position.getShiftedBy(B.length));
              } else
                B.type == "remove" && B.name == "listItem" ? f(B.position) : (B.type == "attribute" && B.attributeKey == "listIndent" || B.type == "attribute" && B.attributeKey == "listType") && f(B.range.start);
            for (const B of h.values())
              _(B), S(B);
            return m;
            function f(B) {
              const T = B.nodeBefore;
              if (T && T.is("element", "listItem")) {
                let R = T;
                if (h.has(R))
                  return;
                for (let N = R.previousSibling; N && N.is("element", "listItem"); N = R.previousSibling)
                  if (R = N, h.has(R))
                    return;
                h.set(T, R);
              } else {
                const R = B.nodeAfter;
                R && R.is("element", "listItem") && h.set(R, R);
              }
            }
            function _(B) {
              let T = 0, R = null;
              for (; B && B.is("element", "listItem"); ) {
                const N = B.getAttribute("listIndent");
                if (N > T) {
                  let U;
                  R === null ? (R = N - T, U = T) : (R > N && (R = N), U = N - R), l.setAttribute("listIndent", U, B), m = !0;
                } else
                  R = null, T = B.getAttribute("listIndent") + 1;
                B = B.nextSibling;
              }
            }
            function S(B) {
              let T = [], R = null;
              for (; B && B.is("element", "listItem"); ) {
                const N = B.getAttribute("listIndent");
                if (R && R.getAttribute("listIndent") > N && (T = T.slice(0, N + 1)), N != 0)
                  if (T[N]) {
                    const U = T[N];
                    B.getAttribute("listType") != U && (l.setAttribute("listType", U, B), m = !0);
                  } else
                    T[N] = B.getAttribute("listType");
                R = B, B = B.nextSibling;
              }
            }
          }(e.model, s)), n.mapper.registerViewToModelLength("li", Gl), t.mapper.registerViewToModelLength("li", Gl), n.mapper.on("modelToViewPosition", fb(n.view)), n.mapper.on("viewToModelPosition", (i = e.model, (s, a) => {
            const l = a.viewPosition, d = l.parent, h = a.mapper;
            if (d.name == "ul" || d.name == "ol") {
              if (l.isAtEnd) {
                const m = h.toModelElement(l.nodeBefore), f = h.getModelLength(l.nodeBefore);
                a.modelPosition = i.createPositionBefore(m).getShiftedBy(f);
              } else {
                const m = h.toModelElement(l.nodeAfter);
                a.modelPosition = i.createPositionBefore(m);
              }
              s.stop();
            } else if (d.name == "li" && l.nodeBefore && (l.nodeBefore.name == "ul" || l.nodeBefore.name == "ol")) {
              const m = h.toModelElement(d);
              let f = 1, _ = l.nodeBefore;
              for (; _ && Yo(_); )
                f += h.getModelLength(_), _ = _.previousSibling;
              a.modelPosition = i.createPositionBefore(m).getShiftedBy(f), s.stop();
            }
          })), t.mapper.on("modelToViewPosition", fb(n.view)), e.conversion.for("editingDowncast").add((s) => {
            s.on("insert", mb, { priority: "high" }), s.on("insert:listItem", gb(e.model)), s.on("attribute:listType:listItem", Zx, { priority: "high" }), s.on("attribute:listType:listItem", Jx, { priority: "low" }), s.on("attribute:listIndent:listItem", /* @__PURE__ */ function(a) {
              return (l, d, h) => {
                if (!h.consumable.consume(d.item, "attribute:listIndent"))
                  return;
                const m = h.mapper.toViewElement(d.item), f = h.writer;
                f.breakContainer(f.createPositionBefore(m)), f.breakContainer(f.createPositionAfter(m));
                const _ = m.parent, S = _.previousSibling, B = f.createRangeOn(_);
                f.remove(B), S && S.nextSibling && qt(f, S, S.nextSibling), bb(d.attributeOldValue + 1, d.range.start, B.start, m, h, a), nb(d.item, m, h, a);
                for (const T of d.item.getChildren())
                  h.consumable.consume(T, "insert");
              };
            }(e.model)), s.on("remove:listItem", /* @__PURE__ */ function(a) {
              return (l, d, h) => {
                const m = h.mapper.toViewPosition(d.position).getLastMatchingPosition((R) => !R.item.is("element", "li")).nodeAfter, f = h.writer;
                f.breakContainer(f.createPositionBefore(m)), f.breakContainer(f.createPositionAfter(m));
                const _ = m.parent, S = _.previousSibling, B = f.createRangeOn(_), T = f.remove(B);
                S && S.nextSibling && qt(f, S, S.nextSibling), bb(h.mapper.toModelElement(m).getAttribute("listIndent") + 1, d.position, B.start, m, h, a);
                for (const R of f.createRangeIn(T).getItems())
                  h.mapper.unbindViewElement(R);
                l.stop();
              };
            }(e.model)), s.on("remove", Yx, { priority: "low" });
          }), e.conversion.for("dataDowncast").add((s) => {
            s.on("insert", mb, { priority: "high" }), s.on("insert:listItem", gb(e.model));
          }), e.conversion.for("upcast").add((s) => {
            s.on("element:ul", pb, { priority: "high" }), s.on("element:ol", pb, { priority: "high" }), s.on("element:li", Xx, { priority: "high" }), s.on("element:li", Qx);
          }), e.model.on("insertContent", eS, { priority: "high" }), e.commands.add("numberedList", new db(e, "numbered")), e.commands.add("bulletedList", new db(e, "bulleted")), e.commands.add("indentList", new cb(e, "forward")), e.commands.add("outdentList", new cb(e, "backward"));
          const r = n.view.document;
          this.listenTo(r, "enter", (s, a) => {
            const l = this.editor.model.document, d = l.selection.getLastPosition().parent;
            l.selection.isCollapsed && d.name == "listItem" && d.isEmpty && (this.editor.execute("outdentList"), a.preventDefault(), s.stop());
          }, { context: "li" }), this.listenTo(r, "delete", (s, a) => {
            if (a.direction !== "backward")
              return;
            const l = this.editor.model.document.selection;
            if (!l.isCollapsed)
              return;
            const d = l.getFirstPosition();
            if (!d.isAtStart)
              return;
            const h = d.parent;
            h.name === "listItem" && (h.previousSibling && h.previousSibling.name === "listItem" || (this.editor.execute("outdentList"), a.preventDefault(), s.stop()));
          }, { context: "li" }), this.listenTo(e.editing.view.document, "tab", (s, a) => {
            const l = a.shiftKey ? "outdentList" : "indentList";
            this.editor.commands.get(l).isEnabled && (e.execute(l), a.stopPropagation(), a.preventDefault(), s.stop());
          }, { context: "li" });
        }
        afterInit() {
          const e = this.editor.commands, t = e.get("indent"), n = e.get("outdent");
          t && t.registerChildCommand(e.get("indentList")), n && n.registerChildCommand(e.get("outdentList"));
        }
      }
      function Gl(o) {
        let e = 1;
        for (const t of o.getChildren())
          if (t.name == "ul" || t.name == "ol")
            for (const n of t.getChildren())
              e += Gl(n);
        return e;
      }
      Br("Ctrl+Enter");
      var kb = b(1199), oS = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(kb.Z, oS), kb.Z.locals;
      function tt(o, e, t, n, i = 1) {
        e != null && i != null && e > i ? n.setAttribute(o, e, t) : n.removeAttribute(o, t);
      }
      function co(o, e, t = {}) {
        const n = o.createElement("tableCell", t);
        return o.insertElement("paragraph", n), o.insert(n, e), n;
      }
      function Kl(o, e) {
        const t = e.parent.parent, n = parseInt(t.getAttribute("headingColumns") || "0"), { column: i } = o.getCellLocation(e);
        return !!n && i < n;
      }
      function iS() {
        return (o) => {
          o.on("element:table", (e, t, n) => {
            const i = t.viewItem;
            if (!n.consumable.test(i, { name: !0 }))
              return;
            const { rows: r, headingRows: s, headingColumns: a } = function(h) {
              let m, f = 0;
              const _ = [], S = [];
              let B;
              for (const T of Array.from(h.getChildren())) {
                if (T.name !== "tbody" && T.name !== "thead" && T.name !== "tfoot")
                  continue;
                T.name !== "thead" || B || (B = T);
                const R = Array.from(T.getChildren()).filter((N) => N.is("element", "tr"));
                for (const N of R)
                  if (B && T === B || T.name === "tbody" && Array.from(N.getChildren()).length && Array.from(N.getChildren()).every((U) => U.is("element", "th")))
                    f++, _.push(N);
                  else {
                    S.push(N);
                    const U = rS(N);
                    (!m || U < m) && (m = U);
                  }
              }
              return { headingRows: f, headingColumns: m || 0, rows: [..._, ...S] };
            }(i), l = {};
            a && (l.headingColumns = a), s && (l.headingRows = s);
            const d = n.writer.createElement("table", l);
            if (n.safeInsert(d, t.modelCursor)) {
              if (n.consumable.consume(i, { name: !0 }), r.forEach((h) => n.convertItem(h, n.writer.createPositionAt(d, "end"))), n.convertChildren(i, n.writer.createPositionAt(d, "end")), d.isEmpty) {
                const h = n.writer.createElement("tableRow");
                n.writer.insert(h, n.writer.createPositionAt(d, "end")), co(n.writer, n.writer.createPositionAt(h, "end"));
              }
              n.updateConversionResult(d, t);
            }
          });
        };
      }
      function wb(o) {
        return (e) => {
          e.on(`element:${o}`, (t, n, { writer: i }) => {
            if (!n.modelRange)
              return;
            const r = n.modelRange.start.nodeAfter, s = i.createPositionAt(r, 0);
            if (n.viewItem.isEmpty)
              return void i.insertElement("paragraph", s);
            const a = Array.from(r.getChildren());
            if (a.every((l) => l.is("element", "$marker"))) {
              const l = i.createElement("paragraph");
              i.insert(l, i.createPositionAt(r, 0));
              for (const d of a)
                i.move(i.createRangeOn(d), i.createPositionAt(l, "end"));
            }
          }, { priority: "low" });
        };
      }
      function rS(o) {
        let e = 0, t = 0;
        const n = Array.from(o.getChildren()).filter((i) => i.name === "th" || i.name === "td");
        for (; t < n.length && n[t].name === "th"; ) {
          const i = n[t];
          e += parseInt(i.getAttribute("colspan") || "1"), t++;
        }
        return e;
      }
      class Oe {
        constructor(e, t = {}) {
          this._table = e, this._startRow = t.row !== void 0 ? t.row : t.startRow || 0, this._endRow = t.row !== void 0 ? t.row : t.endRow, this._startColumn = t.column !== void 0 ? t.column : t.startColumn || 0, this._endColumn = t.column !== void 0 ? t.column : t.endColumn, this._includeAllSlots = !!t.includeAllSlots, this._skipRows = /* @__PURE__ */ new Set(), this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = /* @__PURE__ */ new Map(), this._nextCellAtColumn = -1;
        }
        [Symbol.iterator]() {
          return this;
        }
        next() {
          const e = this._table.getChild(this._rowIndex);
          if (!e || this._isOverEndRow())
            return { done: !0, value: void 0 };
          if (!e.is("element", "tableRow"))
            return this._rowIndex++, this.next();
          if (this._isOverEndColumn())
            return this._advanceToNextRow();
          let t = null;
          const n = this._getSpanned();
          if (n)
            this._includeAllSlots && !this._shouldSkipSlot() && (t = this._formatOutValue(n.cell, n.row, n.column));
          else {
            const i = e.getChild(this._cellIndex);
            if (!i)
              return this._advanceToNextRow();
            const r = parseInt(i.getAttribute("colspan") || "1"), s = parseInt(i.getAttribute("rowspan") || "1");
            (r > 1 || s > 1) && this._recordSpans(i, s, r), this._shouldSkipSlot() || (t = this._formatOutValue(i)), this._nextCellAtColumn = this._column + r;
          }
          return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, t || this.next();
        }
        skipRow(e) {
          this._skipRows.add(e);
        }
        _advanceToNextRow() {
          return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next();
        }
        _isOverEndRow() {
          return this._endRow !== void 0 && this._row > this._endRow;
        }
        _isOverEndColumn() {
          return this._endColumn !== void 0 && this._column > this._endColumn;
        }
        _formatOutValue(e, t = this._row, n = this._column) {
          return { done: !1, value: new sS(this, e, t, n) };
        }
        _shouldSkipSlot() {
          const e = this._skipRows.has(this._row), t = this._row < this._startRow, n = this._column < this._startColumn, i = this._endColumn !== void 0 && this._column > this._endColumn;
          return e || t || n || i;
        }
        _getSpanned() {
          const e = this._spannedCells.get(this._row);
          return e && e.get(this._column) || null;
        }
        _recordSpans(e, t, n) {
          const i = { cell: e, row: this._row, column: this._column };
          for (let r = this._row; r < this._row + t; r++)
            for (let s = this._column; s < this._column + n; s++)
              r == this._row && s == this._column || this._markSpannedCell(r, s, i);
        }
        _markSpannedCell(e, t, n) {
          this._spannedCells.has(e) || this._spannedCells.set(e, /* @__PURE__ */ new Map()), this._spannedCells.get(e).set(t, n);
        }
      }
      class sS {
        constructor(e, t, n, i) {
          this.cell = t, this.row = e._row, this.column = e._column, this.cellAnchorRow = n, this.cellAnchorColumn = i, this._cellIndex = e._cellIndex, this._rowIndex = e._rowIndex, this._table = e._table;
        }
        get isAnchor() {
          return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
        }
        get cellWidth() {
          return parseInt(this.cell.getAttribute("colspan") || "1");
        }
        get cellHeight() {
          return parseInt(this.cell.getAttribute("rowspan") || "1");
        }
        get rowIndex() {
          return this._rowIndex;
        }
        getPositionBefore() {
          return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
        }
      }
      function vb(o, e) {
        return (t, { writer: n }) => {
          const i = t.getAttribute("headingRows") || 0, r = n.createContainerElement("table", null, []), s = n.createContainerElement("figure", { class: "table" }, r);
          i > 0 && n.insert(n.createPositionAt(r, "end"), n.createContainerElement("thead", null, n.createSlot((a) => a.is("element", "tableRow") && a.index < i))), i < o.getRows(t) && n.insert(n.createPositionAt(r, "end"), n.createContainerElement("tbody", null, n.createSlot((a) => a.is("element", "tableRow") && a.index >= i)));
          for (const { positionOffset: a, filter: l } of e.additionalSlots)
            n.insert(n.createPositionAt(r, a), n.createSlot(l));
          return n.insert(n.createPositionAt(r, "after"), n.createSlot((a) => !a.is("element", "tableRow") && !e.additionalSlots.some(({ filter: l }) => l(a)))), e.asWidget ? function(a, l) {
            return l.setCustomProperty("table", !0, a), Sl(a, l, { hasSelectionHandle: !0 });
          }(s, n) : s;
        };
      }
      function _b(o = {}) {
        return (e, { writer: t }) => {
          const n = e.parent, i = n.parent, r = i.getChildIndex(n), s = new Oe(i, { row: r }), a = i.getAttribute("headingRows") || 0, l = i.getAttribute("headingColumns") || 0;
          let d = null;
          for (const h of s)
            if (h.cell == e) {
              const m = h.row < a || h.column < l ? "th" : "td";
              d = o.asWidget ? d2(t.createEditableElement(m), t) : t.createContainerElement(m);
              break;
            }
          return d;
        };
      }
      function Ab(o = {}) {
        return (e, { writer: t }) => {
          if (!e.parent.is("element", "tableCell") || !Cb(e))
            return null;
          if (o.asWidget)
            return t.createContainerElement("span", { class: "ck-table-bogus-paragraph" });
          {
            const n = t.createContainerElement("p");
            return t.setCustomProperty("dataPipeline:transparentRendering", !0, n), n;
          }
        };
      }
      function Cb(o) {
        return o.parent.childCount == 1 && !!o.getAttributeKeys().next().done;
      }
      class aS extends be {
        refresh() {
          const e = this.editor.model, t = e.document.selection, n = e.schema;
          this.isEnabled = function(i, r) {
            const s = i.getFirstPosition().parent, a = s === s.root ? s : s.parent;
            return r.checkChild(a, "table");
          }(t, n);
        }
        execute(e = {}) {
          const t = this.editor, n = t.model, i = t.plugins.get("TableUtils"), r = t.config.get("table.defaultHeadings.rows"), s = t.config.get("table.defaultHeadings.columns");
          e.headingRows === void 0 && r && (e.headingRows = r), e.headingColumns === void 0 && s && (e.headingColumns = s), n.change((a) => {
            const l = i.createTable(a, e);
            n.insertObject(l, null, null, { findOptimalPosition: "auto" }), a.setSelection(a.createPositionAt(l.getNodeByPath([0, 0, 0]), 0));
          });
        }
      }
      class yb extends be {
        constructor(e, t = {}) {
          super(e), this.order = t.order || "below";
        }
        refresh() {
          const e = this.editor.model.document.selection, t = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
          this.isEnabled = t;
        }
        execute() {
          const e = this.editor, t = e.model.document.selection, n = e.plugins.get("TableUtils"), i = this.order === "above", r = n.getSelectionAffectedTableCells(t), s = n.getRowIndexes(r), a = i ? s.first : s.last, l = r[0].findAncestor("table");
          n.insertRows(l, { at: i ? a : a + 1, copyStructureFromAbove: !i });
        }
      }
      class Eb extends be {
        constructor(e, t = {}) {
          super(e), this.order = t.order || "right";
        }
        refresh() {
          const e = this.editor.model.document.selection, t = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
          this.isEnabled = t;
        }
        execute() {
          const e = this.editor, t = e.model.document.selection, n = e.plugins.get("TableUtils"), i = this.order === "left", r = n.getSelectionAffectedTableCells(t), s = n.getColumnIndexes(r), a = i ? s.first : s.last, l = r[0].findAncestor("table");
          n.insertColumns(l, { columns: 1, at: i ? a : a + 1 });
        }
      }
      class xb extends be {
        constructor(e, t = {}) {
          super(e), this.direction = t.direction || "horizontally";
        }
        refresh() {
          const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.length === 1;
        }
        execute() {
          const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
          this.direction === "horizontally" ? e.splitCellHorizontally(t, 2) : e.splitCellVertically(t, 2);
        }
      }
      function Sb(o, e, t) {
        const { startRow: n, startColumn: i, endRow: r, endColumn: s } = e, a = t.createElement("table"), l = r - n + 1;
        for (let h = 0; h < l; h++)
          t.insertElement("tableRow", a, "end");
        const d = [...new Oe(o, { startRow: n, endRow: r, startColumn: i, endColumn: s, includeAllSlots: !0 })];
        for (const { row: h, column: m, cell: f, isAnchor: _, cellAnchorRow: S, cellAnchorColumn: B } of d) {
          const T = h - n, R = a.getChild(T);
          if (_) {
            const N = t.cloneElement(f);
            t.append(N, R), Pb(N, h, m, r, s, t);
          } else
            (S < n || B < i) && co(t, t.createPositionAt(R, "end"));
        }
        return function(h, m, f, _, S) {
          const B = parseInt(m.getAttribute("headingRows") || "0");
          B > 0 && tt("headingRows", B - f, h, S, 0);
          const T = parseInt(m.getAttribute("headingColumns") || "0");
          T > 0 && tt("headingColumns", T - _, h, S, 0);
        }(a, o, n, i, t), a;
      }
      function Db(o, e, t = 0) {
        const n = [], i = new Oe(o, { startRow: t, endRow: e - 1 });
        for (const r of i) {
          const { row: s, cellHeight: a } = r;
          s < e && e <= s + a - 1 && n.push(r);
        }
        return n;
      }
      function Bb(o, e, t) {
        const n = o.parent, i = n.parent, r = n.index, s = e - r, a = {}, l = parseInt(o.getAttribute("rowspan")) - s;
        l > 1 && (a.rowspan = l);
        const d = parseInt(o.getAttribute("colspan") || "1");
        d > 1 && (a.colspan = d);
        const h = r + s, m = [...new Oe(i, { startRow: r, endRow: h, includeAllSlots: !0 })];
        let f, _ = null;
        for (const S of m) {
          const { row: B, column: T, cell: R } = S;
          R === o && f === void 0 && (f = T), f !== void 0 && f === T && B === h && (_ = co(t, S.getPositionBefore(), a));
        }
        return tt("rowspan", s, o, t), _;
      }
      function Tb(o, e) {
        const t = [], n = new Oe(o);
        for (const i of n) {
          const { column: r, cellWidth: s } = i;
          r < e && e <= r + s - 1 && t.push(i);
        }
        return t;
      }
      function Ib(o, e, t, n) {
        const i = t - e, r = {}, s = parseInt(o.getAttribute("colspan")) - i;
        s > 1 && (r.colspan = s);
        const a = parseInt(o.getAttribute("rowspan") || "1");
        a > 1 && (r.rowspan = a);
        const l = co(n, n.createPositionAfter(o), r);
        return tt("colspan", i, o, n), l;
      }
      function Pb(o, e, t, n, i, r) {
        const s = parseInt(o.getAttribute("colspan") || "1"), a = parseInt(o.getAttribute("rowspan") || "1");
        t + s - 1 > i && tt("colspan", i - t + 1, o, r, 1), e + a - 1 > n && tt("rowspan", n - e + 1, o, r, 1);
      }
      function Zl(o, e) {
        const t = e.getColumns(o), n = new Array(t).fill(0);
        for (const { column: r } of new Oe(o))
          n[r]++;
        const i = n.reduce((r, s, a) => s ? r : [...r, a], []);
        if (i.length > 0) {
          const r = i[i.length - 1];
          return e.removeColumns(o, { at: r }), !0;
        }
        return !1;
      }
      function Jl(o, e) {
        const t = [], n = e.getRows(o);
        for (let i = 0; i < n; i++)
          o.getChild(i).isEmpty && t.push(i);
        if (t.length > 0) {
          const i = t[t.length - 1];
          return e.removeRows(o, { at: i }), !0;
        }
        return !1;
      }
      function Yl(o, e) {
        Zl(o, e) || Jl(o, e);
      }
      function Ob(o, e) {
        const t = Array.from(new Oe(o, { startColumn: e.firstColumn, endColumn: e.lastColumn, row: e.lastRow }));
        if (t.every(({ cellHeight: i }) => i === 1))
          return e.lastRow;
        const n = t[0].cellHeight - 1;
        return e.lastRow + n;
      }
      function Rb(o, e) {
        const t = Array.from(new Oe(o, { startRow: e.firstRow, endRow: e.lastRow, column: e.lastColumn }));
        if (t.every(({ cellWidth: i }) => i === 1))
          return e.lastColumn;
        const n = t[0].cellWidth - 1;
        return e.lastColumn + n;
      }
      class bs extends be {
        constructor(e, t) {
          super(e), this.direction = t.direction, this.isHorizontal = this.direction == "right" || this.direction == "left";
        }
        refresh() {
          const e = this._getMergeableCell();
          this.value = e, this.isEnabled = !!e;
        }
        execute() {
          const e = this.editor.model, t = e.document, n = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(t.selection)[0], i = this.value, r = this.direction;
          e.change((s) => {
            const a = r == "right" || r == "down", l = a ? n : i, d = a ? i : n, h = d.parent;
            (function(B, T, R) {
              zb(B) || (zb(T) && R.remove(R.createRangeIn(T)), R.move(R.createRangeIn(B), R.createPositionAt(T, "end"))), R.remove(B);
            })(d, l, s);
            const m = this.isHorizontal ? "colspan" : "rowspan", f = parseInt(n.getAttribute(m) || "1"), _ = parseInt(i.getAttribute(m) || "1");
            s.setAttribute(m, f + _, l), s.setSelection(s.createRangeIn(l));
            const S = this.editor.plugins.get("TableUtils");
            Yl(h.findAncestor("table"), S);
          });
        }
        _getMergeableCell() {
          const e = this.editor.model.document, t = this.editor.plugins.get("TableUtils"), n = t.getTableCellsContainingSelection(e.selection)[0];
          if (!n)
            return;
          const i = this.isHorizontal ? function(a, l, d) {
            const h = a.parent, m = h.parent, f = l == "right" ? a.nextSibling : a.previousSibling, _ = (m.getAttribute("headingColumns") || 0) > 0;
            if (!f)
              return;
            const S = l == "right" ? a : f, B = l == "right" ? f : a, { column: T } = d.getCellLocation(S), { column: R } = d.getCellLocation(B), N = parseInt(S.getAttribute("colspan") || "1"), U = Kl(d, S), ee = Kl(d, B);
            if (!(_ && U != ee))
              return T + N === R ? f : void 0;
          }(n, this.direction, t) : function(a, l, d) {
            const h = a.parent, m = h.parent, f = m.getChildIndex(h);
            if (l == "down" && f === d.getRows(m) - 1 || l == "up" && f === 0)
              return null;
            const _ = parseInt(a.getAttribute("rowspan") || "1"), S = m.getAttribute("headingRows") || 0, B = l == "down" && f + _ === S, T = l == "up" && f === S;
            if (S && (B || T))
              return null;
            const R = parseInt(a.getAttribute("rowspan") || "1"), N = l == "down" ? f + R : f, U = [...new Oe(m, { endRow: N })], ee = U.find((Te) => Te.cell === a), we = ee.column, Ge = U.find(({ row: Te, cellHeight: yn, column: Vt }) => Vt === we && (l == "down" ? Te === N : N === Te + yn));
            return Ge && Ge.cell ? Ge.cell : null;
          }(n, this.direction, t);
          if (!i)
            return;
          const r = this.isHorizontal ? "rowspan" : "colspan", s = parseInt(n.getAttribute(r) || "1");
          return parseInt(i.getAttribute(r) || "1") === s ? i : void 0;
        }
      }
      function zb(o) {
        const e = o.getChild(0);
        return o.childCount == 1 && e.is("element", "paragraph") && e.isEmpty;
      }
      class lS extends be {
        refresh() {
          const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), n = t[0];
          if (n) {
            const i = n.findAncestor("table"), r = e.getRows(i) - 1, s = e.getRowIndexes(t), a = s.first === 0 && s.last === r;
            this.isEnabled = !a;
          } else
            this.isEnabled = !1;
        }
        execute() {
          const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), i = t.getRowIndexes(n), r = n[0], s = r.findAncestor("table"), a = t.getCellLocation(r).column;
          e.change((l) => {
            const d = i.last - i.first + 1;
            t.removeRows(s, { at: i.first, rows: d });
            const h = function(m, f, _, S) {
              const B = m.getChild(Math.min(f, S - 1));
              let T = B.getChild(0), R = 0;
              for (const N of B.getChildren()) {
                if (R > _)
                  return T;
                T = N, R += parseInt(N.getAttribute("colspan") || "1");
              }
              return T;
            }(s, i.first, a, t.getRows(s));
            l.setSelection(l.createPositionAt(h, 0));
          });
        }
      }
      class cS extends be {
        refresh() {
          const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), n = t[0];
          if (n) {
            const i = n.findAncestor("table"), r = e.getColumns(i), { first: s, last: a } = e.getColumnIndexes(t);
            this.isEnabled = a - s < r - 1;
          } else
            this.isEnabled = !1;
        }
        execute() {
          const e = this.editor.plugins.get("TableUtils"), [t, n] = function(l, d) {
            const h = d.getSelectionAffectedTableCells(l), m = h[0], f = h.pop(), _ = [m, f];
            return m.isBefore(f) ? _ : _.reverse();
          }(this.editor.model.document.selection, e), i = t.parent.parent, r = [...new Oe(i)], s = { first: r.find((l) => l.cell === t).column, last: r.find((l) => l.cell === n).column }, a = function(l, d, h, m) {
            return parseInt(h.getAttribute("colspan") || "1") > 1 ? h : d.previousSibling || h.nextSibling ? h.nextSibling || d.previousSibling : m.first ? l.reverse().find(({ column: _ }) => _ < m.first).cell : l.reverse().find(({ column: _ }) => _ > m.last).cell;
          }(r, t, n, s);
          this.editor.model.change((l) => {
            const d = s.last - s.first + 1;
            e.removeColumns(i, { at: s.first, columns: d }), l.setSelection(l.createPositionAt(a, 0));
          });
        }
      }
      class dS extends be {
        refresh() {
          const e = this.editor.plugins.get("TableUtils"), t = this.editor.model, n = e.getSelectionAffectedTableCells(t.document.selection), i = n.length > 0;
          this.isEnabled = i, this.value = i && n.every((r) => this._isInHeading(r, r.parent.parent));
        }
        execute(e = {}) {
          if (e.forceValue === this.value)
            return;
          const t = this.editor.plugins.get("TableUtils"), n = this.editor.model, i = t.getSelectionAffectedTableCells(n.document.selection), r = i[0].findAncestor("table"), { first: s, last: a } = t.getRowIndexes(i), l = this.value ? s : a + 1, d = r.getAttribute("headingRows") || 0;
          n.change((h) => {
            if (l) {
              const m = Db(r, l, l > d ? d : 0);
              for (const { cell: f } of m)
                Bb(f, l, h);
            }
            tt("headingRows", l, r, h, 0);
          });
        }
        _isInHeading(e, t) {
          const n = parseInt(t.getAttribute("headingRows") || "0");
          return !!n && e.parent.index < n;
        }
      }
      class uS extends be {
        refresh() {
          const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), i = n.length > 0;
          this.isEnabled = i, this.value = i && n.every((r) => Kl(t, r));
        }
        execute(e = {}) {
          if (e.forceValue === this.value)
            return;
          const t = this.editor.plugins.get("TableUtils"), n = this.editor.model, i = t.getSelectionAffectedTableCells(n.document.selection), r = i[0].findAncestor("table"), { first: s, last: a } = t.getColumnIndexes(i), l = this.value ? s : a + 1;
          n.change((d) => {
            if (l) {
              const h = Tb(r, l);
              for (const { cell: m, column: f } of h)
                Ib(m, f, l, d);
            }
            tt("headingColumns", l, r, d, 0);
          });
        }
      }
      class wt extends W {
        static get pluginName() {
          return "TableUtils";
        }
        init() {
          this.decorate("insertColumns"), this.decorate("insertRows");
        }
        getCellLocation(e) {
          const t = e.parent, n = t.parent, i = n.getChildIndex(t), r = new Oe(n, { row: i });
          for (const { cell: s, row: a, column: l } of r)
            if (s === e)
              return { row: a, column: l };
        }
        createTable(e, t) {
          const n = e.createElement("table"), i = t.rows || 2, r = t.columns || 2;
          return Ql(e, n, 0, i, r), t.headingRows && tt("headingRows", Math.min(t.headingRows, i), n, e, 0), t.headingColumns && tt("headingColumns", Math.min(t.headingColumns, r), n, e, 0), n;
        }
        insertRows(e, t = {}) {
          const n = this.editor.model, i = t.at || 0, r = t.rows || 1, s = t.copyStructureFromAbove !== void 0, a = t.copyStructureFromAbove ? i - 1 : i, l = this.getRows(e), d = this.getColumns(e);
          if (i > l)
            throw new O("tableutils-insertrows-insert-out-of-range", this, { options: t });
          n.change((h) => {
            const m = e.getAttribute("headingRows") || 0;
            if (m > i && tt("headingRows", m + r, e, h, 0), !s && (i === 0 || i === l))
              return void Ql(h, e, i, r, d);
            const f = s ? Math.max(i, a) : i, _ = new Oe(e, { endRow: f }), S = new Array(d).fill(1);
            for (const { row: B, column: T, cellHeight: R, cellWidth: N, cell: U } of _) {
              const ee = B + R - 1, we = B <= a && a <= ee;
              B < i && i <= ee ? (h.setAttribute("rowspan", R + r, U), S[T] = -N) : s && we && (S[T] = N);
            }
            for (let B = 0; B < r; B++) {
              const T = h.createElement("tableRow");
              h.insert(T, e, i);
              for (let R = 0; R < S.length; R++) {
                const N = S[R], U = h.createPositionAt(T, "end");
                N > 0 && co(h, U, N > 1 ? { colspan: N } : void 0), R += Math.abs(N) - 1;
              }
            }
          });
        }
        insertColumns(e, t = {}) {
          const n = this.editor.model, i = t.at || 0, r = t.columns || 1;
          n.change((s) => {
            const a = e.getAttribute("headingColumns");
            i < a && s.setAttribute("headingColumns", a + r, e);
            const l = this.getColumns(e);
            if (i === 0 || l === i) {
              for (const h of e.getChildren())
                h.is("element", "tableRow") && Qo(r, s, s.createPositionAt(h, i ? "end" : 0));
              return;
            }
            const d = new Oe(e, { column: i, includeAllSlots: !0 });
            for (const h of d) {
              const { row: m, cell: f, cellAnchorColumn: _, cellAnchorRow: S, cellWidth: B, cellHeight: T } = h;
              if (_ < i) {
                s.setAttribute("colspan", B + r, f);
                const R = S + T - 1;
                for (let N = m; N <= R; N++)
                  d.skipRow(N);
              } else
                Qo(r, s, h.getPositionBefore());
            }
          });
        }
        removeRows(e, t) {
          const n = this.editor.model, i = t.rows || 1, r = this.getRows(e), s = t.at, a = s + i - 1;
          if (a > r - 1)
            throw new O("tableutils-removerows-row-index-out-of-range", this, { table: e, options: t });
          n.change((l) => {
            const d = { first: s, last: a }, { cellsToMove: h, cellsToTrim: m } = function(f, { first: _, last: S }) {
              const B = /* @__PURE__ */ new Map(), T = [];
              for (const { row: R, column: N, cellHeight: U, cell: ee } of new Oe(f, { endRow: S })) {
                const we = R + U - 1;
                if (R >= _ && R <= S && we > S) {
                  const Ge = U - (S - R + 1);
                  B.set(N, { cell: ee, rowspan: Ge });
                }
                if (R < _ && we >= _) {
                  let Ge;
                  Ge = we >= S ? S - _ + 1 : we - _ + 1, T.push({ cell: ee, rowspan: U - Ge });
                }
              }
              return { cellsToMove: B, cellsToTrim: T };
            }(e, d);
            h.size && function(f, _, S, B) {
              const T = new Oe(f, { includeAllSlots: !0, row: _ }), R = [...T], N = f.getChild(_);
              let U;
              for (const { column: ee, cell: we, isAnchor: Ge } of R)
                if (S.has(ee)) {
                  const { cell: Te, rowspan: yn } = S.get(ee), Vt = U ? B.createPositionAfter(U) : B.createPositionAt(N, 0);
                  B.move(B.createRangeOn(Te), Vt), tt("rowspan", yn, Te, B), U = Te;
                } else
                  Ge && (U = we);
            }(e, a + 1, h, l);
            for (let f = a; f >= s; f--)
              l.remove(e.getChild(f));
            for (const { rowspan: f, cell: _ } of m)
              tt("rowspan", f, _, l);
            (function(f, { first: _, last: S }, B) {
              const T = f.getAttribute("headingRows") || 0;
              _ < T && tt("headingRows", S < T ? T - (S - _ + 1) : _, f, B, 0);
            })(e, d, l), Zl(e, this) || Jl(e, this);
          });
        }
        removeColumns(e, t) {
          const n = this.editor.model, i = t.at, r = t.columns || 1, s = t.at + r - 1;
          n.change((a) => {
            (function(l, d, h) {
              const m = l.getAttribute("headingColumns") || 0;
              if (m && d.first < m) {
                const f = Math.min(m - 1, d.last) - d.first + 1;
                h.setAttribute("headingColumns", m - f, l);
              }
            })(e, { first: i, last: s }, a);
            for (let l = s; l >= i; l--)
              for (const { cell: d, column: h, cellWidth: m } of [...new Oe(e)])
                h <= l && m > 1 && h + m > l ? tt("colspan", m - 1, d, a) : h === l && a.remove(d);
            Jl(e, this) || Zl(e, this);
          });
        }
        splitCellVertically(e, t = 2) {
          const n = this.editor.model, i = e.parent.parent, r = parseInt(e.getAttribute("rowspan") || "1"), s = parseInt(e.getAttribute("colspan") || "1");
          n.change((a) => {
            if (s > 1) {
              const { newCellsSpan: l, updatedSpan: d } = Mb(s, t);
              tt("colspan", d, e, a);
              const h = {};
              l > 1 && (h.colspan = l), r > 1 && (h.rowspan = r), Qo(s > t ? t - 1 : s - 1, a, a.createPositionAfter(e), h);
            }
            if (s < t) {
              const l = t - s, d = [...new Oe(i)], { column: h } = d.find(({ cell: S }) => S === e), m = d.filter(({ cell: S, cellWidth: B, column: T }) => S !== e && T === h || T < h && T + B > h);
              for (const { cell: S, cellWidth: B } of m)
                a.setAttribute("colspan", B + l, S);
              const f = {};
              r > 1 && (f.rowspan = r), Qo(l, a, a.createPositionAfter(e), f);
              const _ = i.getAttribute("headingColumns") || 0;
              _ > h && tt("headingColumns", _ + l, i, a);
            }
          });
        }
        splitCellHorizontally(e, t = 2) {
          const n = this.editor.model, i = e.parent, r = i.parent, s = r.getChildIndex(i), a = parseInt(e.getAttribute("rowspan") || "1"), l = parseInt(e.getAttribute("colspan") || "1");
          n.change((d) => {
            if (a > 1) {
              const h = [...new Oe(r, { startRow: s, endRow: s + a - 1, includeAllSlots: !0 })], { newCellsSpan: m, updatedSpan: f } = Mb(a, t);
              tt("rowspan", f, e, d);
              const { column: _ } = h.find(({ cell: B }) => B === e), S = {};
              m > 1 && (S.rowspan = m), l > 1 && (S.colspan = l);
              for (const B of h) {
                const { column: T, row: R } = B;
                R >= s + f && T === _ && (R + s + f) % m == 0 && Qo(1, d, B.getPositionBefore(), S);
              }
            }
            if (a < t) {
              const h = t - a, m = [...new Oe(r, { startRow: 0, endRow: s })];
              for (const { cell: S, cellHeight: B, row: T } of m)
                if (S !== e && T + B > s) {
                  const R = B + h;
                  d.setAttribute("rowspan", R, S);
                }
              const f = {};
              l > 1 && (f.colspan = l), Ql(d, r, s + 1, h, 1, f);
              const _ = r.getAttribute("headingRows") || 0;
              _ > s && tt("headingRows", _ + h, r, d);
            }
          });
        }
        getColumns(e) {
          return [...e.getChild(0).getChildren()].reduce((t, n) => t + parseInt(n.getAttribute("colspan") || "1"), 0);
        }
        getRows(e) {
          return Array.from(e.getChildren()).reduce((t, n) => n.is("element", "tableRow") ? t + 1 : t, 0);
        }
        createTableWalker(e, t = {}) {
          return new Oe(e, t);
        }
        getSelectedTableCells(e) {
          const t = [];
          for (const n of this.sortRanges(e.getRanges())) {
            const i = n.getContainedElement();
            i && i.is("element", "tableCell") && t.push(i);
          }
          return t;
        }
        getTableCellsContainingSelection(e) {
          const t = [];
          for (const n of e.getRanges()) {
            const i = n.start.findAncestor("tableCell");
            i && t.push(i);
          }
          return t;
        }
        getSelectionAffectedTableCells(e) {
          const t = this.getSelectedTableCells(e);
          return t.length ? t : this.getTableCellsContainingSelection(e);
        }
        getRowIndexes(e) {
          const t = e.map((n) => n.parent.index);
          return this._getFirstLastIndexesObject(t);
        }
        getColumnIndexes(e) {
          const t = e[0].findAncestor("table"), n = [...new Oe(t)].filter((i) => e.includes(i.cell)).map((i) => i.column);
          return this._getFirstLastIndexesObject(n);
        }
        isSelectionRectangular(e) {
          if (e.length < 2 || !this._areCellInTheSameTableSection(e))
            return !1;
          const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
          let i = 0;
          for (const s of e) {
            const { row: a, column: l } = this.getCellLocation(s), d = parseInt(s.getAttribute("rowspan")) || 1, h = parseInt(s.getAttribute("colspan")) || 1;
            t.add(a), n.add(l), d > 1 && t.add(a + d - 1), h > 1 && n.add(l + h - 1), i += d * h;
          }
          return function(s, a) {
            const l = Array.from(s.values()), d = Array.from(a.values()), h = Math.max(...l), m = Math.min(...l), f = Math.max(...d), _ = Math.min(...d);
            return (h - m + 1) * (f - _ + 1);
          }(t, n) == i;
        }
        sortRanges(e) {
          return Array.from(e).sort(hS);
        }
        _getFirstLastIndexesObject(e) {
          const t = e.sort((n, i) => n - i);
          return { first: t[0], last: t[t.length - 1] };
        }
        _areCellInTheSameTableSection(e) {
          const t = e[0].findAncestor("table"), n = this.getRowIndexes(e), i = parseInt(t.getAttribute("headingRows")) || 0;
          if (!this._areIndexesInSameSection(n, i))
            return !1;
          const r = this.getColumnIndexes(e), s = parseInt(t.getAttribute("headingColumns")) || 0;
          return this._areIndexesInSameSection(r, s);
        }
        _areIndexesInSameSection({ first: e, last: t }, n) {
          return e < n == t < n;
        }
      }
      function Ql(o, e, t, n, i, r = {}) {
        for (let s = 0; s < n; s++) {
          const a = o.createElement("tableRow");
          o.insert(a, e, t), Qo(i, o, o.createPositionAt(a, "end"), r);
        }
      }
      function Qo(o, e, t, n = {}) {
        for (let i = 0; i < o; i++)
          co(e, t, n);
      }
      function Mb(o, e) {
        if (o < e)
          return { newCellsSpan: 1, updatedSpan: 1 };
        const t = Math.floor(o / e);
        return { newCellsSpan: t, updatedSpan: o - t * e + t };
      }
      function hS(o, e) {
        const t = o.start, n = e.start;
        return t.isBefore(n) ? -1 : 1;
      }
      class gS extends be {
        refresh() {
          const e = this.editor.plugins.get(wt), t = e.getSelectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.isSelectionRectangular(t);
        }
        execute() {
          const e = this.editor.model, t = this.editor.plugins.get(wt);
          e.change((n) => {
            const i = t.getSelectedTableCells(e.document.selection), r = i.shift(), { mergeWidth: s, mergeHeight: a } = function(l, d, h) {
              let m = 0, f = 0;
              for (const R of d) {
                const { row: N, column: U } = h.getCellLocation(R);
                m = Fb(R, U, m, "colspan"), f = Fb(R, N, f, "rowspan");
              }
              const { row: _, column: S } = h.getCellLocation(l), B = m - S, T = f - _;
              return { mergeWidth: B, mergeHeight: T };
            }(r, i, t);
            tt("colspan", s, r, n), tt("rowspan", a, r, n);
            for (const l of i)
              mS(l, r, n);
            Yl(r.findAncestor("table"), t), n.setSelection(r, "in");
          });
        }
      }
      function mS(o, e, t) {
        Nb(o) || (Nb(e) && t.remove(t.createRangeIn(e)), t.move(t.createRangeIn(o), t.createPositionAt(e, "end"))), t.remove(o);
      }
      function Nb(o) {
        const e = o.getChild(0);
        return o.childCount == 1 && e.is("element", "paragraph") && e.isEmpty;
      }
      function Fb(o, e, t, n) {
        const i = parseInt(o.getAttribute(n) || "1");
        return Math.max(t, e + i);
      }
      class pS extends be {
        constructor(e) {
          super(e), this.affectsData = !1;
        }
        refresh() {
          const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.length > 0;
        }
        execute() {
          const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), i = t.getRowIndexes(n), r = n[0].findAncestor("table"), s = [];
          for (let a = i.first; a <= i.last; a++)
            for (const l of r.getChild(a).getChildren())
              s.push(e.createRangeOn(l));
          e.change((a) => {
            a.setSelection(s);
          });
        }
      }
      class fS extends be {
        constructor(e) {
          super(e), this.affectsData = !1;
        }
        refresh() {
          const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.length > 0;
        }
        execute() {
          const e = this.editor.plugins.get("TableUtils"), t = this.editor.model, n = e.getSelectionAffectedTableCells(t.document.selection), i = n[0], r = n.pop(), s = i.findAncestor("table"), a = e.getCellLocation(i), l = e.getCellLocation(r), d = Math.min(a.column, l.column), h = Math.max(a.column, l.column), m = [];
          for (const f of new Oe(s, { startColumn: d, endColumn: h }))
            m.push(t.createRangeOn(f.cell));
          t.change((f) => {
            f.setSelection(m);
          });
        }
      }
      function bS(o) {
        o.document.registerPostFixer((e) => function(t, n) {
          const i = n.document.differ.getChanges();
          let r = !1;
          const s = /* @__PURE__ */ new Set();
          for (const a of i) {
            let l = null;
            a.type == "insert" && a.name == "table" && (l = a.position.nodeAfter), a.type != "insert" && a.type != "remove" || a.name != "tableRow" && a.name != "tableCell" || (l = a.position.findAncestor("table")), vS(a) && (l = a.range.start.findAncestor("table")), l && !s.has(l) && (r = kS(l, t) || r, r = wS(l, t) || r, s.add(l));
          }
          return r;
        }(e, o));
      }
      function kS(o, e) {
        let t = !1;
        const n = function(i) {
          const r = parseInt(i.getAttribute("headingRows") || "0"), s = Array.from(i.getChildren()).reduce((l, d) => d.is("element", "tableRow") ? l + 1 : l, 0), a = [];
          for (const { row: l, cell: d, cellHeight: h } of new Oe(i)) {
            if (h < 2)
              continue;
            const m = l < r ? r : s;
            if (l + h > m) {
              const f = m - l;
              a.push({ cell: d, rowspan: f });
            }
          }
          return a;
        }(o);
        if (n.length) {
          t = !0;
          for (const i of n)
            tt("rowspan", i.rowspan, i.cell, e, 1);
        }
        return t;
      }
      function wS(o, e) {
        let t = !1;
        const n = function(a) {
          const l = new Array(a.childCount).fill(0);
          for (const { rowIndex: d } of new Oe(a, { includeAllSlots: !0 }))
            l[d]++;
          return l;
        }(o), i = [];
        for (const [a, l] of n.entries())
          !l && o.getChild(a).is("element", "tableRow") && i.push(a);
        if (i.length) {
          t = !0;
          for (const a of i.reverse())
            e.remove(o.getChild(a)), n.splice(a, 1);
        }
        const r = n.filter((a, l) => o.getChild(l).is("element", "tableRow")), s = r[0];
        if (!r.every((a) => a === s)) {
          const a = r.reduce((l, d) => d > l ? d : l, 0);
          for (const [l, d] of r.entries()) {
            const h = a - d;
            if (h) {
              for (let m = 0; m < h; m++)
                co(e, e.createPositionAt(o.getChild(l), "end"));
              t = !0;
            }
          }
        }
        return t;
      }
      function vS(o) {
        if (o.type !== "attribute")
          return !1;
        const e = o.attributeKey;
        return e === "headingRows" || e === "colspan" || e === "rowspan";
      }
      function _S(o) {
        o.document.registerPostFixer((e) => function(t, n) {
          const i = n.document.differ.getChanges();
          let r = !1;
          for (const s of i)
            s.type == "insert" && s.name == "table" && (r = AS(s.position.nodeAfter, t) || r), s.type == "insert" && s.name == "tableRow" && (r = $b(s.position.nodeAfter, t) || r), s.type == "insert" && s.name == "tableCell" && (r = Xl(s.position.nodeAfter, t) || r), s.type != "remove" && s.type != "insert" || !CS(s) || (r = Xl(s.position.parent, t) || r);
          return r;
        }(e, o));
      }
      function AS(o, e) {
        let t = !1;
        for (const n of o.getChildren())
          n.is("element", "tableRow") && (t = $b(n, e) || t);
        return t;
      }
      function $b(o, e) {
        let t = !1;
        for (const n of o.getChildren())
          t = Xl(n, e) || t;
        return t;
      }
      function Xl(o, e) {
        if (o.childCount == 0)
          return e.insertElement("paragraph", o), !0;
        const t = Array.from(o.getChildren()).filter((n) => n.is("$text"));
        for (const n of t)
          e.wrap(e.createRangeOn(n), "paragraph");
        return !!t.length;
      }
      function CS(o) {
        return !!o.position.parent.is("element", "tableCell") && (o.type == "insert" && o.name == "$text" || o.type == "remove");
      }
      function yS(o, e) {
        if (!o.is("element", "paragraph"))
          return !1;
        const t = e.toViewElement(o);
        return !!t && Cb(o) !== t.is("element", "span");
      }
      var Vb = b(3881), ES = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Vb.Z, ES), Vb.Z.locals;
      class xS extends W {
        constructor(e) {
          super(e), this._additionalSlots = [];
        }
        static get pluginName() {
          return "TableEditing";
        }
        static get requires() {
          return [wt];
        }
        init() {
          const e = this.editor, t = e.model, n = t.schema, i = e.conversion, r = e.plugins.get(wt);
          n.register("table", { inheritAllFrom: "$blockObject", allowAttributes: ["headingRows", "headingColumns"] }), n.register("tableRow", { allowIn: "table", isLimit: !0 }), n.register("tableCell", { allowContentOf: "$container", allowIn: "tableRow", allowAttributes: ["colspan", "rowspan"], isLimit: !0, isSelectable: !0 }), i.for("upcast").add((s) => {
            s.on("element:figure", (a, l, d) => {
              if (!d.consumable.test(l.viewItem, { name: !0, classes: "table" }))
                return;
              const h = function(f) {
                for (const _ of f.getChildren())
                  if (_.is("element", "table"))
                    return _;
              }(l.viewItem);
              if (!h || !d.consumable.test(h, { name: !0 }))
                return;
              d.consumable.consume(l.viewItem, { name: !0, classes: "table" });
              const m = it(d.convertItem(h, l.modelCursor).modelRange.getItems());
              m ? (d.convertChildren(l.viewItem, d.writer.createPositionAt(m, "end")), d.updateConversionResult(m, l)) : d.consumable.revert(l.viewItem, { name: !0, classes: "table" });
            });
          }), i.for("upcast").add(iS()), i.for("editingDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: vb(r, { asWidget: !0, additionalSlots: this._additionalSlots }) }), i.for("dataDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: vb(r, { additionalSlots: this._additionalSlots }) }), i.for("upcast").elementToElement({ model: "tableRow", view: "tr" }), i.for("upcast").add((s) => {
            s.on("element:tr", (a, l) => {
              l.viewItem.isEmpty && l.modelCursor.index == 0 && a.stop();
            }, { priority: "high" });
          }), i.for("downcast").elementToElement({ model: "tableRow", view: (s, { writer: a }) => s.isEmpty ? a.createEmptyElement("tr") : a.createContainerElement("tr") }), i.for("upcast").elementToElement({ model: "tableCell", view: "td" }), i.for("upcast").elementToElement({ model: "tableCell", view: "th" }), i.for("upcast").add(wb("td")), i.for("upcast").add(wb("th")), i.for("editingDowncast").elementToElement({ model: "tableCell", view: _b({ asWidget: !0 }) }), i.for("dataDowncast").elementToElement({ model: "tableCell", view: _b() }), i.for("editingDowncast").elementToElement({ model: "paragraph", view: Ab({ asWidget: !0 }), converterPriority: "high" }), i.for("dataDowncast").elementToElement({ model: "paragraph", view: Ab(), converterPriority: "high" }), i.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" }), i.for("upcast").attributeToAttribute({ model: { key: "colspan", value: Lb("colspan") }, view: "colspan" }), i.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" }), i.for("upcast").attributeToAttribute({ model: { key: "rowspan", value: Lb("rowspan") }, view: "rowspan" }), e.config.define("table.defaultHeadings.rows", 0), e.config.define("table.defaultHeadings.columns", 0), e.commands.add("insertTable", new aS(e)), e.commands.add("insertTableRowAbove", new yb(e, { order: "above" })), e.commands.add("insertTableRowBelow", new yb(e, { order: "below" })), e.commands.add("insertTableColumnLeft", new Eb(e, { order: "left" })), e.commands.add("insertTableColumnRight", new Eb(e, { order: "right" })), e.commands.add("removeTableRow", new lS(e)), e.commands.add("removeTableColumn", new cS(e)), e.commands.add("splitTableCellVertically", new xb(e, { direction: "vertically" })), e.commands.add("splitTableCellHorizontally", new xb(e, { direction: "horizontally" })), e.commands.add("mergeTableCells", new gS(e)), e.commands.add("mergeTableCellRight", new bs(e, { direction: "right" })), e.commands.add("mergeTableCellLeft", new bs(e, { direction: "left" })), e.commands.add("mergeTableCellDown", new bs(e, { direction: "down" })), e.commands.add("mergeTableCellUp", new bs(e, { direction: "up" })), e.commands.add("setTableColumnHeader", new uS(e)), e.commands.add("setTableRowHeader", new dS(e)), e.commands.add("selectTableRow", new pS(e)), e.commands.add("selectTableColumn", new fS(e)), bS(t), _S(t), this.listenTo(t.document, "change:data", () => {
            (function(s, a) {
              const l = s.document.differ;
              for (const d of l.getChanges()) {
                let h, m = !1;
                if (d.type == "attribute") {
                  const B = d.range.start.nodeAfter;
                  if (!B || !B.is("element", "table") || d.attributeKey != "headingRows" && d.attributeKey != "headingColumns")
                    continue;
                  h = B, m = d.attributeKey == "headingRows";
                } else
                  d.name != "tableRow" && d.name != "tableCell" || (h = d.position.findAncestor("table"), m = d.name == "tableRow");
                if (!h)
                  continue;
                const f = h.getAttribute("headingRows") || 0, _ = h.getAttribute("headingColumns") || 0, S = new Oe(h);
                for (const B of S) {
                  const T = B.row < f || B.column < _ ? "th" : "td", R = a.mapper.toViewElement(B.cell);
                  R && R.is("element") && R.name != T && a.reconvertItem(m ? B.cell.parent : B.cell);
                }
              }
            })(t, e.editing), function(s, a) {
              const l = s.document.differ, d = /* @__PURE__ */ new Set();
              for (const h of l.getChanges()) {
                const m = h.type == "attribute" ? h.range.start.parent : h.position.parent;
                m.is("element", "tableCell") && d.add(m);
              }
              for (const h of d.values()) {
                const m = Array.from(h.getChildren()).filter((f) => yS(f, a.mapper));
                for (const f of m)
                  a.reconvertItem(f);
              }
            }(t, e.editing);
          });
        }
        registerAdditionalSlot(e) {
          this._additionalSlots.push(e);
        }
      }
      function Lb(o) {
        return (e) => {
          const t = parseInt(e.getAttribute(o));
          return Number.isNaN(t) || t <= 0 ? null : t;
        };
      }
      var jb = b(1613), SS = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(jb.Z, SS), jb.Z.locals;
      class DS extends _e {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.items = this._createGridCollection(), this.keystrokes = new mn(), this.focusTracker = new Jt(), this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (n, i) => `${i} × ${n}`), this.setTemplate({ tag: "div", attributes: { class: ["ck"] }, children: [{ tag: "div", attributes: { class: ["ck-insert-table-dropdown__grid"] }, on: { "mouseover@.ck-insert-table-dropdown-grid-box": t.to("boxover") }, children: this.items }, { tag: "div", attributes: { class: ["ck", "ck-insert-table-dropdown__label"], "aria-hidden": !0 }, children: [{ text: t.to("label") }] }], on: { mousedown: t.to((n) => {
            n.preventDefault();
          }), click: t.to(() => {
            this.fire("execute");
          }) } }), this.on("boxover", (n, i) => {
            const { row: r, column: s } = i.target.dataset;
            this.items.get(10 * (parseInt(r, 10) - 1) + (parseInt(s, 10) - 1)).focus();
          }), this.focusTracker.on("change:focusedElement", (n, i, r) => {
            if (!r)
              return;
            const { row: s, column: a } = r.dataset;
            this.set({ rows: parseInt(s), columns: parseInt(a) });
          }), this.on("change:columns", () => this._highlightGridBoxes()), this.on("change:rows", () => this._highlightGridBoxes());
        }
        render() {
          super.render(), function({ keystrokeHandler: e, focusTracker: t, gridItems: n, numberOfColumns: i, uiLanguageDirection: r }) {
            const s = typeof i == "number" ? () => i : i;
            function a(h) {
              return (m) => {
                const f = n.find((B) => B.element === t.focusedElement), _ = n.getIndex(f), S = h(_, n);
                n.get(S).focus(), m.stopPropagation(), m.preventDefault();
              };
            }
            function l(h, m) {
              return h === m - 1 ? 0 : h + 1;
            }
            function d(h, m) {
              return h === 0 ? m - 1 : h - 1;
            }
            e.set("arrowright", a((h, m) => r === "rtl" ? d(h, m.length) : l(h, m.length))), e.set("arrowleft", a((h, m) => r === "rtl" ? l(h, m.length) : d(h, m.length))), e.set("arrowup", a((h, m) => {
              let f = h - s();
              return f < 0 && (f = h + s() * Math.floor(m.length / s()), f > m.length - 1 && (f -= s())), f;
            })), e.set("arrowdown", a((h, m) => {
              let f = h + s();
              return f > m.length - 1 && (f = h % s()), f;
            }));
          }({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.items, numberOfColumns: 10, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection });
          for (const e of this.items)
            this.focusTracker.add(e.element);
          this.keystrokes.listenTo(this.element);
        }
        focus() {
          this.items.get(0).focus();
        }
        focusLast() {
          this.items.get(0).focus();
        }
        _highlightGridBoxes() {
          const e = this.rows, t = this.columns;
          this.items.map((n, i) => {
            const r = Math.floor(i / 10) < e && i % 10 < t;
            n.set("isOn", r);
          });
        }
        _createGridButton(e, t, n, i) {
          const r = new je(e);
          return r.set({ label: i, class: "ck-insert-table-dropdown-grid-box" }), r.extendTemplate({ attributes: { "data-row": t, "data-column": n } }), r;
        }
        _createGridCollection() {
          const e = [];
          for (let t = 0; t < 100; t++) {
            const n = Math.floor(t / 10), i = t % 10, r = `${n + 1} × ${i + 1}`;
            e.push(this._createGridButton(this.locale, n + 1, i + 1, r));
          }
          return this.createCollection(e);
        }
      }
      class BS extends W {
        static get pluginName() {
          return "TableUI";
        }
        init() {
          const e = this.editor, t = this.editor.t, n = e.locale.contentLanguageDirection === "ltr";
          e.ui.componentFactory.add("insertTable", (i) => {
            const r = e.commands.get("insertTable"), s = wn(i);
            let a;
            return s.bind("isEnabled").to(r), s.buttonView.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>', label: t("Insert table"), tooltip: !0 }), s.on("change:isOpen", () => {
              a || (a = new DS(i), s.panelView.children.add(a), a.delegate("execute").to(s), s.on("execute", () => {
                e.execute("insertTable", { rows: a.rows, columns: a.columns }), e.editing.view.focus();
              }));
            }), s;
          }), e.ui.componentFactory.add("tableColumn", (i) => {
            const r = [{ type: "switchbutton", model: { commandName: "setTableColumnHeader", label: t("Header column"), bindIsOn: !0 } }, { type: "separator" }, { type: "button", model: { commandName: n ? "insertTableColumnLeft" : "insertTableColumnRight", label: t("Insert column left") } }, { type: "button", model: { commandName: n ? "insertTableColumnRight" : "insertTableColumnLeft", label: t("Insert column right") } }, { type: "button", model: { commandName: "removeTableColumn", label: t("Delete column") } }, { type: "button", model: { commandName: "selectTableColumn", label: t("Select column") } }];
            return this._prepareDropdown(t("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', r, i);
          }), e.ui.componentFactory.add("tableRow", (i) => {
            const r = [{ type: "switchbutton", model: { commandName: "setTableRowHeader", label: t("Header row"), bindIsOn: !0 } }, { type: "separator" }, { type: "button", model: { commandName: "insertTableRowAbove", label: t("Insert row above") } }, { type: "button", model: { commandName: "insertTableRowBelow", label: t("Insert row below") } }, { type: "button", model: { commandName: "removeTableRow", label: t("Delete row") } }, { type: "button", model: { commandName: "selectTableRow", label: t("Select row") } }];
            return this._prepareDropdown(t("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', r, i);
          }), e.ui.componentFactory.add("mergeTableCells", (i) => {
            const r = [{ type: "button", model: { commandName: "mergeTableCellUp", label: t("Merge cell up") } }, { type: "button", model: { commandName: n ? "mergeTableCellRight" : "mergeTableCellLeft", label: t("Merge cell right") } }, { type: "button", model: { commandName: "mergeTableCellDown", label: t("Merge cell down") } }, { type: "button", model: { commandName: n ? "mergeTableCellLeft" : "mergeTableCellRight", label: t("Merge cell left") } }, { type: "separator" }, { type: "button", model: { commandName: "splitTableCellVertically", label: t("Split cell vertically") } }, { type: "button", model: { commandName: "splitTableCellHorizontally", label: t("Split cell horizontally") } }];
            return this._prepareMergeSplitButtonDropdown(t("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', r, i);
          });
        }
        _prepareDropdown(e, t, n, i) {
          const r = this.editor, s = wn(i), a = this._fillDropdownWithListOptions(s, n);
          return s.buttonView.set({ label: e, icon: t, tooltip: !0 }), s.bind("isEnabled").toMany(a, "isEnabled", (...l) => l.some((d) => d)), this.listenTo(s, "execute", (l) => {
            r.execute(l.source.commandName), l.source instanceof Pr || r.editing.view.focus();
          }), s;
        }
        _prepareMergeSplitButtonDropdown(e, t, n, i) {
          const r = this.editor, s = wn(i, al), a = "mergeTableCells", l = r.commands.get(a), d = this._fillDropdownWithListOptions(s, n);
          return s.buttonView.set({ label: e, icon: t, tooltip: !0, isEnabled: !0 }), s.bind("isEnabled").toMany([l, ...d], "isEnabled", (...h) => h.some((m) => m)), this.listenTo(s.buttonView, "execute", () => {
            r.execute(a), r.editing.view.focus();
          }), this.listenTo(s, "execute", (h) => {
            r.execute(h.source.commandName), r.editing.view.focus();
          }), s;
        }
        _fillDropdownWithListOptions(e, t) {
          const n = this.editor, i = [], r = new Ht();
          for (const s of t)
            TS(s, n, i, r);
          return ll(e, r), i;
        }
      }
      function TS(o, e, t, n) {
        if (o.type === "button" || o.type === "switchbutton") {
          const i = o.model = new vl(o.model), { commandName: r, bindIsOn: s } = o.model, a = e.commands.get(r);
          t.push(a), i.set({ commandName: r }), i.bind("isEnabled").to(a), s && i.bind("isOn").to(a, "value"), i.set({ withText: !0 });
        }
        n.add(o);
      }
      var Hb = b(6945), IS = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Hb.Z, IS), Hb.Z.locals;
      class uo extends W {
        static get pluginName() {
          return "TableSelection";
        }
        static get requires() {
          return [wt, wt];
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view;
          this.listenTo(t, "deleteContent", (i, r) => this._handleDeleteContent(i, r), { priority: "high" }), this.listenTo(n.document, "insertText", (i, r) => this._handleInsertTextEvent(i, r), { priority: "high" }), this._defineSelectionConverter(), this._enablePluginDisabling();
        }
        getSelectedTableCells() {
          const e = this.editor.plugins.get(wt), t = this.editor.model.document.selection, n = e.getSelectedTableCells(t);
          return n.length == 0 ? null : n;
        }
        getSelectionAsFragment() {
          const e = this.editor.plugins.get(wt), t = this.getSelectedTableCells();
          return t ? this.editor.model.change((n) => {
            const i = n.createDocumentFragment(), { first: r, last: s } = e.getColumnIndexes(t), { first: a, last: l } = e.getRowIndexes(t), d = t[0].findAncestor("table");
            let h = l, m = s;
            if (e.isSelectionRectangular(t)) {
              const _ = { firstColumn: r, lastColumn: s, firstRow: a, lastRow: l };
              h = Ob(d, _), m = Rb(d, _);
            }
            const f = Sb(d, { startRow: a, startColumn: r, endRow: h, endColumn: m }, n);
            return n.insert(f, i, 0), i;
          }) : null;
        }
        setCellSelection(e, t) {
          const n = this._getCellsToSelect(e, t);
          this.editor.model.change((i) => {
            i.setSelection(n.cells.map((r) => i.createRangeOn(r)), { backward: n.backward });
          });
        }
        getFocusCell() {
          const e = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
          return e && e.is("element", "tableCell") ? e : null;
        }
        getAnchorCell() {
          const e = it(this.editor.model.document.selection.getRanges()).getContainedElement();
          return e && e.is("element", "tableCell") ? e : null;
        }
        _defineSelectionConverter() {
          const e = this.editor, t = /* @__PURE__ */ new Set();
          e.conversion.for("editingDowncast").add((n) => n.on("selection", (i, r, s) => {
            const a = s.writer;
            (function(h) {
              for (const m of t)
                h.removeClass("ck-editor__editable_selected", m);
              t.clear();
            })(a);
            const l = this.getSelectedTableCells();
            if (!l)
              return;
            for (const h of l) {
              const m = s.mapper.toViewElement(h);
              a.addClass("ck-editor__editable_selected", m), t.add(m);
            }
            const d = s.mapper.toViewElement(l[l.length - 1]);
            a.setSelection(d, 0);
          }, { priority: "lowest" }));
        }
        _enablePluginDisabling() {
          const e = this.editor;
          this.on("change:isEnabled", () => {
            if (!this.isEnabled) {
              const t = this.getSelectedTableCells();
              if (!t)
                return;
              e.model.change((n) => {
                const i = n.createPositionAt(t[0], 0), r = e.model.schema.getNearestSelectionRange(i);
                n.setSelection(r);
              });
            }
          });
        }
        _handleDeleteContent(e, t) {
          const n = this.editor.plugins.get(wt), i = t[0], r = t[1], s = this.editor.model, a = !r || r.direction == "backward", l = n.getSelectedTableCells(i);
          l.length && (e.stop(), s.change((d) => {
            const h = l[a ? l.length - 1 : 0];
            s.change((f) => {
              for (const _ of l)
                s.deleteContent(f.createSelection(_, "in"));
            });
            const m = s.schema.getNearestSelectionRange(d.createPositionAt(h, 0));
            i.is("documentSelection") ? d.setSelection(m) : i.setTo(m);
          }));
        }
        _handleInsertTextEvent(e, t) {
          const n = this.editor, i = this.getSelectedTableCells();
          if (!i)
            return;
          const r = n.editing.view, s = n.editing.mapper, a = i.map((l) => r.createRangeOn(s.toViewElement(l)));
          t.selection = r.createSelection(a);
        }
        _getCellsToSelect(e, t) {
          const n = this.editor.plugins.get("TableUtils"), i = n.getCellLocation(e), r = n.getCellLocation(t), s = Math.min(i.row, r.row), a = Math.max(i.row, r.row), l = Math.min(i.column, r.column), d = Math.max(i.column, r.column), h = new Array(a - s + 1).fill(null).map(() => []), m = { startRow: s, endRow: a, startColumn: l, endColumn: d };
          for (const { row: S, cell: B } of new Oe(e.findAncestor("table"), m))
            h[S - s].push(B);
          const f = r.row < i.row, _ = r.column < i.column;
          return f && h.reverse(), _ && h.forEach((S) => S.reverse()), { cells: h.flat(), backward: f || _ };
        }
      }
      class PS extends W {
        static get pluginName() {
          return "TableClipboard";
        }
        static get requires() {
          return [uo, wt];
        }
        init() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "copy", (n, i) => this._onCopyCut(n, i)), this.listenTo(t, "cut", (n, i) => this._onCopyCut(n, i)), this.listenTo(e.model, "insertContent", (n, [i, r]) => this._onInsertContent(n, i, r), { priority: "high" }), this.decorate("_replaceTableSlotCell");
        }
        _onCopyCut(e, t) {
          const n = this.editor.plugins.get(uo);
          if (!n.getSelectedTableCells() || e.name == "cut" && !this.editor.model.canEditAt(this.editor.model.document.selection))
            return;
          t.preventDefault(), e.stop();
          const i = this.editor.data, r = this.editor.editing.view.document, s = i.toView(n.getSelectionAsFragment());
          r.fire("clipboardOutput", { dataTransfer: t.dataTransfer, content: s, method: e.name });
        }
        _onInsertContent(e, t, n) {
          if (n && !n.is("documentSelection"))
            return;
          const i = this.editor.model, r = this.editor.plugins.get(wt);
          let s = this.getTableIfOnlyTableInContent(t, i);
          if (!s)
            return;
          const a = r.getSelectionAffectedTableCells(i.document.selection);
          a.length ? (e.stop(), i.change((l) => {
            const d = { width: r.getColumns(s), height: r.getRows(s) }, h = function(T, R, N, U) {
              const ee = T[0].findAncestor("table"), we = U.getColumnIndexes(T), Ge = U.getRowIndexes(T), Te = { firstColumn: we.first, lastColumn: we.last, firstRow: Ge.first, lastRow: Ge.last }, yn = T.length === 1;
              return yn && (Te.lastRow += R.height - 1, Te.lastColumn += R.width - 1, function(Vt, Cs, po, Fn) {
                const ni = Fn.getColumns(Vt), oi = Fn.getRows(Vt);
                po > ni && Fn.insertColumns(Vt, { at: ni, columns: po - ni }), Cs > oi && Fn.insertRows(Vt, { at: oi, rows: Cs - oi });
              }(ee, Te.lastRow + 1, Te.lastColumn + 1, U)), yn || !U.isSelectionRectangular(T) ? function(Vt, Cs, po) {
                const { firstRow: Fn, lastRow: ni, firstColumn: oi, lastColumn: yk } = Cs, Ek = { first: Fn, last: ni }, xk = { first: oi, last: yk };
                tc(Vt, oi, Ek, po), tc(Vt, yk + 1, Ek, po), ec(Vt, Fn, xk, po), ec(Vt, ni + 1, xk, po, Fn);
              }(ee, Te, N) : (Te.lastRow = Ob(ee, Te), Te.lastColumn = Rb(ee, Te)), Te;
            }(a, d, l, r), m = h.lastRow - h.firstRow + 1, f = h.lastColumn - h.firstColumn + 1, _ = { startRow: 0, startColumn: 0, endRow: Math.min(m, d.height) - 1, endColumn: Math.min(f, d.width) - 1 };
            s = Sb(s, _, l);
            const S = a[0].findAncestor("table"), B = this._replaceSelectedCellsWithPasted(s, d, S, h, l);
            if (this.editor.plugins.get("TableSelection").isEnabled) {
              const T = r.sortRanges(B.map((R) => l.createRangeOn(R)));
              l.setSelection(T);
            } else
              l.setSelection(B[0], 0);
          })) : Yl(s, r);
        }
        _replaceSelectedCellsWithPasted(e, t, n, i, r) {
          const { width: s, height: a } = t, l = function(T, R, N) {
            const U = new Array(N).fill(null).map(() => new Array(R).fill(null));
            for (const { column: ee, row: we, cell: Ge } of new Oe(T))
              U[we][ee] = Ge;
            return U;
          }(e, s, a), d = [...new Oe(n, { startRow: i.firstRow, endRow: i.lastRow, startColumn: i.firstColumn, endColumn: i.lastColumn, includeAllSlots: !0 })], h = [];
          let m;
          for (const T of d) {
            const { row: R, column: N } = T;
            N === i.firstColumn && (m = T.getPositionBefore());
            const U = R - i.firstRow, ee = N - i.firstColumn, we = l[U % a][ee % s], Ge = we ? r.cloneElement(we) : null, Te = this._replaceTableSlotCell(T, Ge, m, r);
            Te && (Pb(Te, R, N, i.lastRow, i.lastColumn, r), h.push(Te), m = r.createPositionAfter(Te));
          }
          const f = parseInt(n.getAttribute("headingRows") || "0"), _ = parseInt(n.getAttribute("headingColumns") || "0"), S = i.firstRow < f && f <= i.lastRow, B = i.firstColumn < _ && _ <= i.lastColumn;
          if (S) {
            const T = ec(n, f, { first: i.firstColumn, last: i.lastColumn }, r, i.firstRow);
            h.push(...T);
          }
          if (B) {
            const T = tc(n, _, { first: i.firstRow, last: i.lastRow }, r);
            h.push(...T);
          }
          return h;
        }
        _replaceTableSlotCell(e, t, n, i) {
          const { cell: r, isAnchor: s } = e;
          return s && i.remove(r), t ? (i.insert(t, n), t) : null;
        }
        getTableIfOnlyTableInContent(e, t) {
          if (!e.is("documentFragment") && !e.is("element"))
            return null;
          if (e.is("element", "table"))
            return e;
          if (e.childCount == 1 && e.getChild(0).is("element", "table"))
            return e.getChild(0);
          const n = t.createRangeIn(e);
          for (const i of n.getItems())
            if (i.is("element", "table")) {
              const r = t.createRange(n.start, t.createPositionBefore(i));
              if (t.hasContent(r, { ignoreWhitespaces: !0 }))
                return null;
              const s = t.createRange(t.createPositionAfter(i), n.end);
              return t.hasContent(s, { ignoreWhitespaces: !0 }) ? null : i;
            }
          return null;
        }
      }
      function ec(o, e, t, n, i = 0) {
        if (!(e < 1))
          return Db(o, e, i).filter(({ column: r, cellWidth: s }) => Ub(r, s, t)).map(({ cell: r }) => Bb(r, e, n));
      }
      function tc(o, e, t, n) {
        if (!(e < 1))
          return Tb(o, e).filter(({ row: i, cellHeight: r }) => Ub(i, r, t)).map(({ cell: i, column: r }) => Ib(i, r, e, n));
      }
      function Ub(o, e, t) {
        const n = o + e - 1, { first: i, last: r } = t;
        return o >= i && o <= r || o < i && n >= i;
      }
      class OS extends W {
        static get pluginName() {
          return "TableKeyboard";
        }
        static get requires() {
          return [uo, wt];
        }
        init() {
          const e = this.editor.editing.view.document;
          this.listenTo(e, "arrowKey", (...t) => this._onArrowKey(...t), { context: "table" }), this.listenTo(e, "tab", (...t) => this._handleTabOnSelectedTable(...t), { context: "figure" }), this.listenTo(e, "tab", (...t) => this._handleTab(...t), { context: ["th", "td"] });
        }
        _handleTabOnSelectedTable(e, t) {
          const n = this.editor, i = n.model.document.selection.getSelectedElement();
          i && i.is("element", "table") && (t.preventDefault(), t.stopPropagation(), e.stop(), n.model.change((r) => {
            r.setSelection(r.createRangeIn(i.getChild(0).getChild(0)));
          }));
        }
        _handleTab(e, t) {
          const n = this.editor, i = this.editor.plugins.get(wt), r = this.editor.plugins.get("TableSelection"), s = n.model.document.selection, a = !t.shiftKey;
          let l = i.getTableCellsContainingSelection(s)[0];
          if (l || (l = r.getFocusCell()), !l)
            return;
          t.preventDefault(), t.stopPropagation(), e.stop();
          const d = l.parent, h = d.parent, m = h.getChildIndex(d), f = d.getChildIndex(l), _ = f === 0;
          if (!a && _ && m === 0)
            return void n.model.change((R) => {
              R.setSelection(R.createRangeOn(h));
            });
          const S = f === d.childCount - 1, B = m === i.getRows(h) - 1;
          if (a && B && S && (n.execute("insertTableRowBelow"), m === i.getRows(h) - 1))
            return void n.model.change((R) => {
              R.setSelection(R.createRangeOn(h));
            });
          let T;
          if (a && S)
            T = h.getChild(m + 1).getChild(0);
          else if (!a && _) {
            const R = h.getChild(m - 1);
            T = R.getChild(R.childCount - 1);
          } else
            T = d.getChild(f + (a ? 1 : -1));
          n.model.change((R) => {
            R.setSelection(R.createRangeIn(T));
          });
        }
        _onArrowKey(e, t) {
          const n = this.editor, i = ga(t.keyCode, n.locale.contentLanguageDirection);
          this._handleArrowKeys(i, t.shiftKey) && (t.preventDefault(), t.stopPropagation(), e.stop());
        }
        _handleArrowKeys(e, t) {
          const n = this.editor.plugins.get(wt), i = this.editor.plugins.get("TableSelection"), r = this.editor.model, s = r.document.selection, a = ["right", "down"].includes(e), l = n.getSelectedTableCells(s);
          if (l.length) {
            let h;
            return h = t ? i.getFocusCell() : a ? l[l.length - 1] : l[0], this._navigateFromCellInDirection(h, e, t), !0;
          }
          const d = s.focus.findAncestor("tableCell");
          if (!d)
            return !1;
          if (!s.isCollapsed)
            if (t) {
              if (s.isBackward == a && !s.containsEntireContent(d))
                return !1;
            } else {
              const h = s.getSelectedElement();
              if (!h || !r.schema.isObject(h))
                return !1;
            }
          return !!this._isSelectionAtCellEdge(s, d, a) && (this._navigateFromCellInDirection(d, e, t), !0);
        }
        _isSelectionAtCellEdge(e, t, n) {
          const i = this.editor.model, r = this.editor.model.schema, s = n ? e.getLastPosition() : e.getFirstPosition();
          if (!r.getLimitElement(s).is("element", "tableCell"))
            return i.createPositionAt(t, n ? "end" : 0).isTouching(s);
          const a = i.createSelection(s);
          return i.modifySelection(a, { direction: n ? "forward" : "backward" }), s.isEqual(a.focus);
        }
        _navigateFromCellInDirection(e, t, n = !1) {
          const i = this.editor.model, r = e.findAncestor("table"), s = [...new Oe(r, { includeAllSlots: !0 })], { row: a, column: l } = s[s.length - 1], d = s.find(({ cell: B }) => B == e);
          let { row: h, column: m } = d;
          switch (t) {
            case "left":
              m--;
              break;
            case "up":
              h--;
              break;
            case "right":
              m += d.cellWidth;
              break;
            case "down":
              h += d.cellHeight;
          }
          if (h < 0 || h > a || m < 0 && h <= 0 || m > l && h >= a)
            return void i.change((B) => {
              B.setSelection(B.createRangeOn(r));
            });
          m < 0 ? (m = n ? 0 : l, h--) : m > l && (m = n ? l : 0, h++);
          const f = s.find((B) => B.row == h && B.column == m).cell, _ = ["right", "down"].includes(t), S = this.editor.plugins.get("TableSelection");
          if (n && S.isEnabled) {
            const B = S.getAnchorCell() || e;
            S.setCellSelection(B, f);
          } else {
            const B = i.createPositionAt(f, _ ? 0 : "end");
            i.change((T) => {
              T.setSelection(B);
            });
          }
        }
      }
      class RS extends Pn {
        constructor() {
          super(...arguments), this.domEventType = ["mousemove", "mouseleave"];
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
      }
      class zS extends W {
        static get pluginName() {
          return "TableMouse";
        }
        static get requires() {
          return [uo, wt];
        }
        init() {
          this.editor.editing.view.addObserver(RS), this._enableShiftClickSelection(), this._enableMouseDragSelection();
        }
        _enableShiftClickSelection() {
          const e = this.editor, t = e.plugins.get(wt);
          let n = !1;
          const i = e.plugins.get(uo);
          this.listenTo(e.editing.view.document, "mousedown", (r, s) => {
            const a = e.model.document.selection;
            if (!this.isEnabled || !i.isEnabled || !s.domEvent.shiftKey)
              return;
            const l = i.getAnchorCell() || t.getTableCellsContainingSelection(a)[0];
            if (!l)
              return;
            const d = this._getModelTableCellFromDomEvent(s);
            d && qb(l, d) && (n = !0, i.setCellSelection(l, d), s.preventDefault());
          }), this.listenTo(e.editing.view.document, "mouseup", () => {
            n = !1;
          }), this.listenTo(e.editing.view.document, "selectionChange", (r) => {
            n && r.stop();
          }, { priority: "highest" });
        }
        _enableMouseDragSelection() {
          const e = this.editor;
          let t, n, i = !1, r = !1;
          const s = e.plugins.get(uo);
          this.listenTo(e.editing.view.document, "mousedown", (a, l) => {
            this.isEnabled && s.isEnabled && (l.domEvent.shiftKey || l.domEvent.ctrlKey || l.domEvent.altKey || (t = this._getModelTableCellFromDomEvent(l)));
          }), this.listenTo(e.editing.view.document, "mousemove", (a, l) => {
            if (!l.domEvent.buttons || !t)
              return;
            const d = this._getModelTableCellFromDomEvent(l);
            d && qb(t, d) && (n = d, i || n == t || (i = !0)), i && (r = !0, s.setCellSelection(t, n), l.preventDefault());
          }), this.listenTo(e.editing.view.document, "mouseup", () => {
            i = !1, r = !1, t = null, n = null;
          }), this.listenTo(e.editing.view.document, "selectionChange", (a) => {
            r && a.stop();
          }, { priority: "highest" });
        }
        _getModelTableCellFromDomEvent(e) {
          const t = e.target, n = this.editor.editing.view.createPositionAt(t, 0);
          return this.editor.editing.mapper.toModelPosition(n).parent.findAncestor("tableCell", { includeSelf: !0 });
        }
      }
      function qb(o, e) {
        return o.parent.parent == e.parent.parent;
      }
      var Wb = b(6306), MS = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Wb.Z, MS), Wb.Z.locals;
      function NS(o) {
        const e = o.getSelectedElement();
        return e && Gb(e) ? e : null;
      }
      function FS(o) {
        const e = o.getFirstPosition();
        if (!e)
          return null;
        let t = e.parent;
        for (; t; ) {
          if (t.is("element") && Gb(t))
            return t;
          t = t.parent;
        }
        return null;
      }
      function Gb(o) {
        return !!o.getCustomProperty("table") && Je(o);
      }
      var Kb = b(7368), $S = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Kb.Z, $S), Kb.Z.locals;
      var Zb = b(9247), VS = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Zb.Z, VS), Zb.Z.locals;
      var Jb = b(4070), LS = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Jb.Z, LS), Jb.Z.locals;
      var Yb = b(6237), jS = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Yb.Z, jS), Yb.Z.locals;
      var Qb = b(5087), HS = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Qb.Z, HS), Qb.Z.locals;
      const ho = Tt.defaultPositions;
      ho.northArrowSouth, ho.northArrowSouthWest, ho.northArrowSouthEast, ho.southArrowNorth, ho.southArrowNorthWest, ho.southArrowNorthEast, ho.viewportStickyNorth;
      var Xb = b(7341), US = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Xb.Z, US), Xb.Z.locals;
      var ek = b(2128), qS = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(ek.Z, qS), ek.Z.locals;
      var tk = b(4101), WS = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(tk.Z, WS), tk.Z.locals;
      var GS = Object.defineProperty, nk = Object.getOwnPropertySymbols, KS = Object.prototype.hasOwnProperty, ZS = Object.prototype.propertyIsEnumerable, ok = (o, e, t) => e in o ? GS(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, ik = (o, e) => {
        for (var t in e || (e = {}))
          KS.call(e, t) && ok(o, t, e[t]);
        if (nk)
          for (var t of nk(e))
            ZS.call(e, t) && ok(o, t, e[t]);
        return o;
      };
      const JS = { autoRefresh: !0 }, rk = 36e5;
      class nc extends re() {
        constructor(e, t = {}) {
          if (super(), !e)
            throw new O("token-missing-token-url", this);
          t.initValue && this._validateTokenValue(t.initValue), this.set("value", t.initValue), this._refresh = typeof e == "function" ? e : () => {
            return n = e, new Promise((i, r) => {
              const s = new XMLHttpRequest();
              s.open("GET", n), s.addEventListener("load", () => {
                const a = s.status, l = s.response;
                return a < 200 || a > 299 ? r(new O("token-cannot-download-new-token", null)) : i(l);
              }), s.addEventListener("error", () => r(new Error("Network Error"))), s.addEventListener("abort", () => r(new Error("Abort"))), s.send();
            });
            var n;
          }, this._options = ik(ik({}, JS), t);
        }
        init() {
          return new Promise((e, t) => {
            this.value ? (this._options.autoRefresh && this._registerRefreshTokenTimeout(), e(this)) : this.refreshToken().then(e).catch(t);
          });
        }
        refreshToken() {
          return this._refresh().then((e) => (this._validateTokenValue(e), this.set("value", e), this._options.autoRefresh && this._registerRefreshTokenTimeout(), this));
        }
        destroy() {
          clearTimeout(this._tokenRefreshTimeout);
        }
        _validateTokenValue(e) {
          const t = typeof e == "string", n = !/^".*"$/.test(e), i = t && e.split(".").length === 3;
          if (!n || !i)
            throw new O("token-not-in-jwt-format", this);
        }
        _registerRefreshTokenTimeout() {
          const e = this._getTokenRefreshTimeoutTime();
          clearTimeout(this._tokenRefreshTimeout), this._tokenRefreshTimeout = setTimeout(() => {
            this.refreshToken();
          }, e);
        }
        _getTokenRefreshTimeoutTime() {
          try {
            const [, e] = this.value.split("."), { exp: t } = JSON.parse(atob(e));
            return t ? Math.floor((1e3 * t - Date.now()) / 2) : rk;
          } catch {
            return rk;
          }
        }
        static create(e, t = {}) {
          return new nc(e, t).init();
        }
      }
      const oc = /^data:(\S*?);base64,/;
      class YS extends Se() {
        constructor(e, t, n) {
          if (super(), !e)
            throw new O("fileuploader-missing-file", null);
          if (!t)
            throw new O("fileuploader-missing-token", null);
          if (!n)
            throw new O("fileuploader-missing-api-address", null);
          this.file = function(i) {
            if (typeof i != "string")
              return !1;
            const r = i.match(oc);
            return !(!r || !r.length);
          }(e) ? function(i, r = 512) {
            try {
              const s = i.match(oc)[1], a = atob(i.replace(oc, "")), l = [];
              for (let d = 0; d < a.length; d += r) {
                const h = a.slice(d, d + r), m = new Array(h.length);
                for (let f = 0; f < h.length; f++)
                  m[f] = h.charCodeAt(f);
                l.push(new Uint8Array(m));
              }
              return new Blob(l, { type: s });
            } catch {
              throw new O("fileuploader-decoding-image-data-error", null);
            }
          }(e) : e, this._token = t, this._apiAddress = n;
        }
        onProgress(e) {
          return this.on("progress", (t, n) => e(n)), this;
        }
        onError(e) {
          return this.once("error", (t, n) => e(n)), this;
        }
        abort() {
          this.xhr.abort();
        }
        send() {
          return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest();
        }
        _prepareRequest() {
          const e = new XMLHttpRequest();
          e.open("POST", this._apiAddress), e.setRequestHeader("Authorization", this._token.value), e.responseType = "json", this.xhr = e;
        }
        _attachXHRListeners() {
          const e = this.xhr, t = (n) => () => this.fire("error", n);
          e.addEventListener("error", t("Network Error")), e.addEventListener("abort", t("Abort")), e.upload && e.upload.addEventListener("progress", (n) => {
            n.lengthComputable && this.fire("progress", { total: n.total, uploaded: n.loaded });
          }), e.addEventListener("load", () => {
            const n = e.status, i = e.response;
            if (n < 200 || n > 299)
              return this.fire("error", i.message || i.error);
          });
        }
        _sendRequest() {
          const e = new FormData(), t = this.xhr;
          return e.append("file", this.file), new Promise((n, i) => {
            t.addEventListener("load", () => {
              const r = t.status, s = t.response;
              return r < 200 || r > 299 ? s.message ? i(new O("fileuploader-uploading-data-failed", this, { message: s.message })) : i(s.error) : n(s);
            }), t.addEventListener("error", () => i(new Error("Network Error"))), t.addEventListener("abort", () => i(new Error("Abort"))), t.send(e);
          });
        }
      }
      class QS {
        constructor(e, t) {
          if (!e)
            throw new O("uploadgateway-missing-token", null);
          if (!t)
            throw new O("uploadgateway-missing-api-address", null);
          this._token = e, this._apiAddress = t;
        }
        upload(e) {
          return new YS(e, this._token, this._apiAddress);
        }
      }
      class XS extends Or {
        static get pluginName() {
          return "CloudServicesCore";
        }
        createToken(e, t) {
          return new nc(e, t);
        }
        createUploadGateway(e, t) {
          return new QS(e, t);
        }
      }
      var sk = (o, e, t) => new Promise((n, i) => {
        var r = (l) => {
          try {
            a(t.next(l));
          } catch (d) {
            i(d);
          }
        }, s = (l) => {
          try {
            a(t.throw(l));
          } catch (d) {
            i(d);
          }
        }, a = (l) => l.done ? n(l.value) : Promise.resolve(l.value).then(r, s);
        a((t = t.apply(o, e)).next());
      });
      const ic = ["left", "right", "center", "justify"];
      function ak(o) {
        return ic.includes(o);
      }
      function lk(o, e) {
        return e.contentLanguageDirection == "rtl" ? o === "right" : o === "left";
      }
      function ck(o) {
        const e = o.map((n) => {
          let i;
          return i = typeof n == "string" ? { name: n } : n, i;
        }).filter((n) => {
          const i = ic.includes(n.name);
          return i || oe("alignment-config-name-not-recognized", { option: n }), i;
        }), t = e.filter((n) => !!n.className).length;
        if (t && t < e.length)
          throw new O("alignment-config-classnames-are-missing", { configuredOptions: o });
        return e.forEach((n, i, r) => {
          const s = r.slice(i + 1);
          if (s.some((a) => a.name == n.name))
            throw new O("alignment-config-name-already-defined", { option: n, configuredOptions: o });
          if (n.className && s.some((a) => a.className == n.className))
            throw new O("alignment-config-classname-already-defined", { option: n, configuredOptions: o });
        }), e;
      }
      const rc = "alignment";
      class e5 extends be {
        refresh() {
          const e = this.editor.locale, t = it(this.editor.model.document.selection.getSelectedBlocks());
          this.isEnabled = !!t && this._canBeAligned(t), this.isEnabled && t.hasAttribute("alignment") ? this.value = t.getAttribute("alignment") : this.value = e.contentLanguageDirection === "rtl" ? "right" : "left";
        }
        execute(e = {}) {
          const t = this.editor, n = t.locale, i = t.model, r = i.document, s = e.value;
          i.change((a) => {
            const l = Array.from(r.selection.getSelectedBlocks()).filter((h) => this._canBeAligned(h)), d = l[0].getAttribute("alignment");
            lk(s, n) || d === s || !s ? function(h, m) {
              for (const f of h)
                m.removeAttribute(rc, f);
            }(l, a) : function(h, m, f) {
              for (const _ of h)
                m.setAttribute(rc, f, _);
            }(l, a, s);
          });
        }
        _canBeAligned(e) {
          return this.editor.model.schema.checkAttribute(e, rc);
        }
      }
      class t5 extends W {
        static get pluginName() {
          return "AlignmentEditing";
        }
        constructor(e) {
          super(e), e.config.define("alignment", { options: ic.map((t) => ({ name: t })) });
        }
        init() {
          const e = this.editor, t = e.locale, n = e.model.schema, i = ck(e.config.get("alignment.options")).filter((l) => ak(l.name) && !lk(l.name, t)), r = i.some((l) => !!l.className);
          n.extend("$block", { allowAttributes: "alignment" }), e.model.schema.setAttributeProperties("alignment", { isFormatting: !0 }), r ? e.conversion.attributeToAttribute(function(l) {
            const d = {};
            for (const m of l)
              d[m.name] = { key: "class", value: m.className };
            return { model: { key: "alignment", values: l.map((m) => m.name) }, view: d };
          }(i)) : e.conversion.for("downcast").attributeToAttribute(function(l) {
            const d = {};
            for (const { name: m } of l)
              d[m] = { key: "style", value: { "text-align": m } };
            return { model: { key: "alignment", values: l.map((m) => m.name) }, view: d };
          }(i));
          const s = function(l) {
            const d = [];
            for (const { name: h } of l)
              d.push({ view: { key: "style", value: { "text-align": h } }, model: { key: "alignment", value: h } });
            return d;
          }(i);
          for (const l of s)
            e.conversion.for("upcast").attributeToAttribute(l);
          const a = function(l) {
            const d = [];
            for (const { name: h } of l)
              d.push({ view: { key: "align", value: h }, model: { key: "alignment", value: h } });
            return d;
          }(i);
          for (const l of a)
            e.conversion.for("upcast").attributeToAttribute(l);
          e.commands.add("alignment", new e5(e));
        }
      }
      const ks = /* @__PURE__ */ new Map([["left", qe.alignLeft], ["right", qe.alignRight], ["center", qe.alignCenter], ["justify", qe.alignJustify]]);
      class n5 extends W {
        get localizedOptionTitles() {
          const e = this.editor.t;
          return { left: e("Align left"), right: e("Align right"), center: e("Align center"), justify: e("Justify") };
        }
        static get pluginName() {
          return "AlignmentUI";
        }
        init() {
          const e = this.editor, t = e.ui.componentFactory, n = e.t, i = ck(e.config.get("alignment.options"));
          i.map((r) => r.name).filter(ak).forEach((r) => this._addButton(r)), t.add("alignment", (r) => {
            const s = wn(r);
            Xr(s, () => i.map((d) => t.create(`alignment:${d.name}`)), { enableActiveItemFocusOnDropdownOpen: !0, isVertical: !0, ariaLabel: n("Text alignment toolbar") }), s.buttonView.set({ label: n("Text alignment"), tooltip: !0 }), s.extendTemplate({ attributes: { class: "ck-alignment-dropdown" } });
            const a = r.contentLanguageDirection === "rtl" ? ks.get("right") : ks.get("left"), l = e.commands.get("alignment");
            return s.buttonView.bind("icon").to(l, "value", (d) => ks.get(d) || a), s.bind("isEnabled").to(l, "isEnabled"), this.listenTo(s, "execute", () => {
              e.editing.view.focus();
            }), s;
          });
        }
        _addButton(e) {
          const t = this.editor;
          t.ui.componentFactory.add(`alignment:${e}`, (n) => {
            const i = t.commands.get("alignment"), r = new je(n);
            return r.set({ label: this.localizedOptionTitles[e], icon: ks.get(e), tooltip: !0, isToggleable: !0 }), r.bind("isEnabled").to(i), r.bind("isOn").to(i, "value", (s) => s === e), this.listenTo(r, "execute", () => {
              t.execute("alignment", { value: e }), t.editing.view.focus();
            }), r;
          });
        }
      }
      function o5(o) {
        const e = [{ name: "address", isVoid: !1 }, { name: "article", isVoid: !1 }, { name: "aside", isVoid: !1 }, { name: "blockquote", isVoid: !1 }, { name: "br", isVoid: !0 }, { name: "details", isVoid: !1 }, { name: "dialog", isVoid: !1 }, { name: "dd", isVoid: !1 }, { name: "div", isVoid: !1 }, { name: "dl", isVoid: !1 }, { name: "dt", isVoid: !1 }, { name: "fieldset", isVoid: !1 }, { name: "figcaption", isVoid: !1 }, { name: "figure", isVoid: !1 }, { name: "footer", isVoid: !1 }, { name: "form", isVoid: !1 }, { name: "h1", isVoid: !1 }, { name: "h2", isVoid: !1 }, { name: "h3", isVoid: !1 }, { name: "h4", isVoid: !1 }, { name: "h5", isVoid: !1 }, { name: "h6", isVoid: !1 }, { name: "header", isVoid: !1 }, { name: "hgroup", isVoid: !1 }, { name: "hr", isVoid: !0 }, { name: "input", isVoid: !0 }, { name: "li", isVoid: !1 }, { name: "main", isVoid: !1 }, { name: "nav", isVoid: !1 }, { name: "ol", isVoid: !1 }, { name: "p", isVoid: !1 }, { name: "section", isVoid: !1 }, { name: "table", isVoid: !1 }, { name: "tbody", isVoid: !1 }, { name: "td", isVoid: !1 }, { name: "textarea", isVoid: !1 }, { name: "th", isVoid: !1 }, { name: "thead", isVoid: !1 }, { name: "tr", isVoid: !1 }, { name: "ul", isVoid: !1 }], t = e.map((r) => r.name).join("|"), n = o.replace(new RegExp(`</?(${t})( .*?)?>`, "g"), `
$&
`).split(`
`);
        let i = 0;
        return n.filter((r) => r.length).map((r) => function(s, a) {
          return a.some((l) => !l.isVoid && !!new RegExp(`<${l.name}( .*?)?>`).test(s));
        }(r, e) ? sc(r, i++) : function(s, a) {
          return a.some((l) => new RegExp(`</${l.name}>`).test(s));
        }(r, e) ? sc(r, --i) : sc(r, i)).join(`
`);
      }
      function sc(o, e, t = "    ") {
        return `${t.repeat(Math.max(0, e))}${o}`;
      }
      var dk = b(2896), i5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(dk.Z, i5), dk.Z.locals;
      const uk = "SourceEditingMode";
      function r5(o) {
        return function(e) {
          return e.startsWith("<");
        }(o) ? o5(o) : o;
      }
      const ac = "removeFormat";
      class s5 extends W {
        static get pluginName() {
          return "RemoveFormatUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(ac, (n) => {
            const i = e.commands.get(ac), r = new je(n);
            return r.set({ label: t("Remove Format"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>', tooltip: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(ac), e.editing.view.focus();
            }), r;
          });
        }
      }
      class a5 extends be {
        refresh() {
          const e = this.editor.model;
          this.isEnabled = !!it(this._getFormattingItems(e.document.selection, e.schema));
        }
        execute() {
          const e = this.editor.model, t = e.schema;
          e.change((n) => {
            for (const i of this._getFormattingItems(e.document.selection, t))
              if (i.is("selection"))
                for (const r of this._getFormattingAttributes(i, t))
                  n.removeSelectionAttribute(r);
              else {
                const r = n.createRangeOn(i);
                for (const s of this._getFormattingAttributes(i, t))
                  n.removeAttribute(s, r);
              }
          });
        }
        *_getFormattingItems(e, t) {
          const n = (i) => !!it(this._getFormattingAttributes(i, t));
          for (const i of e.getRanges())
            for (const r of i.getItems())
              !t.isBlock(r) && n(r) && (yield r);
          for (const i of e.getSelectedBlocks())
            n(i) && (yield i);
          n(e) && (yield e);
        }
        *_getFormattingAttributes(e, t) {
          for (const [n] of e.getAttributes()) {
            const i = t.getAttributeProperties(n);
            i && i.isFormatting && (yield n);
          }
        }
      }
      class l5 extends W {
        static get pluginName() {
          return "RemoveFormatEditing";
        }
        init() {
          const e = this.editor;
          e.commands.add("removeFormat", new a5(e));
        }
      }
      var c5 = Object.defineProperty, hk = Object.getOwnPropertySymbols, d5 = Object.prototype.hasOwnProperty, u5 = Object.prototype.propertyIsEnumerable, gk = (o, e, t) => e in o ? c5(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, mk = (o, e) => {
        for (var t in e || (e = {}))
          d5.call(e, t) && gk(o, t, e[t]);
        if (hk)
          for (var t of hk(e))
            u5.call(e, t) && gk(o, t, e[t]);
        return o;
      };
      function go(o, e, t, n) {
        e && function(i, r, s) {
          if (r.attributes)
            for (const [a] of Object.entries(r.attributes))
              i.removeAttribute(a, s);
          if (r.styles)
            for (const a of Object.keys(r.styles))
              i.removeStyle(a, s);
          r.classes && i.removeClass(r.classes, s);
        }(o, e, n), t && Nn(o, t, n);
      }
      function Nn(o, e, t) {
        if (e.attributes)
          for (const [n, i] of Object.entries(e.attributes))
            o.setAttribute(n, i, t);
        e.styles && o.setStyle(e.styles, t), e.classes && o.addClass(e.classes, t);
      }
      function h5(o, e) {
        const t = Rn(o);
        let n = "attributes";
        for (n in e)
          t[n] = n == "classes" ? Array.from(/* @__PURE__ */ new Set([...o[n] || [], ...e[n]])) : mk(mk({}, o[n]), e[n]);
        return t;
      }
      function mo(o, e, t, n, i) {
        const r = e.getAttribute(t), s = {};
        for (const a of ["attributes", "styles", "classes"]) {
          if (a != n) {
            r && r[a] && (s[a] = r[a]);
            continue;
          }
          if (n == "classes") {
            const d = new Set(r && r.classes || []);
            i(d), d.size && (s[a] = Array.from(d));
            continue;
          }
          const l = new Map(Object.entries(r && r[a] || {}));
          i(l), l.size && (s[a] = Object.fromEntries(l));
        }
        Object.keys(s).length ? e.is("documentSelection") ? o.setSelectionAttribute(t, s) : o.setAttribute(t, s, e) : r && (e.is("documentSelection") ? o.removeSelectionAttribute(t) : o.removeAttribute(t, e));
      }
      function lc({ model: o }) {
        return (e, t) => t.writer.createElement(o, { htmlContent: e.getCustomProperty("$rawContent") });
      }
      function g5(o, { view: e, isInline: t }) {
        const n = o.t;
        return (i, { writer: r }) => {
          const s = n("HTML object"), a = ws(e, i, r), l = i.getAttribute("htmlAttributes");
          return r.addClass("html-object-embed__content", a), l && Nn(r, l, a), Sl(r.createContainerElement(t ? "span" : "div", { class: "html-object-embed", "data-html-object-embed-label": s }, a), r, { label: s });
        };
      }
      function ws(o, e, t) {
        return t.createRawElement(o, null, (n, i) => {
          i.setContentOf(n, e.getAttribute("htmlContent"));
        });
      }
      function m5({ priority: o, view: e }) {
        return (t, n) => {
          if (!t)
            return;
          const { writer: i } = n, r = i.createAttributeElement(e, null, { priority: o });
          return Nn(i, t, r), r;
        };
      }
      function Ki({ view: o }, e) {
        return (t) => {
          t.on(`element:${o}`, (n, i, r) => {
            if (!i.modelRange || i.modelRange.isCollapsed)
              return;
            const s = e.processViewAttributes(i.viewItem, r);
            s && r.writer.setAttribute("htmlAttributes", s, i.modelRange);
          }, { priority: "low" });
        };
      }
      function Zi({ model: o }) {
        return (e) => {
          e.on(`attribute:htmlAttributes:${o}`, (t, n, i) => {
            if (!i.consumable.consume(n.item, t.name))
              return;
            const { attributeOldValue: r, attributeNewValue: s } = n;
            go(i.writer, r, s, i.mapper.toViewElement(n.item));
          });
        };
      }
      const p5 = [{ model: "codeBlock", view: "pre" }, { model: "paragraph", view: "p" }, { model: "blockQuote", view: "blockquote" }, { model: "listItem", view: "li" }, { model: "pageBreak", view: "div" }, { model: "rawHtml", view: "div" }, { model: "table", view: "table" }, { model: "tableRow", view: "tr" }, { model: "tableCell", view: "td" }, { model: "tableCell", view: "th" }, { model: "tableColumnGroup", view: "colgroup" }, { model: "tableColumn", view: "col" }, { model: "caption", view: "caption" }, { model: "caption", view: "figcaption" }, { model: "imageBlock", view: "img" }, { model: "imageInline", view: "img" }, { model: "htmlP", view: "p", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlBlockquote", view: "blockquote", modelSchema: { inheritAllFrom: "$container" } }, { model: "htmlTable", view: "table", modelSchema: { allowWhere: "$block", isBlock: !0 } }, { model: "htmlTbody", view: "tbody", modelSchema: { allowIn: "htmlTable", isBlock: !1 } }, { model: "htmlThead", view: "thead", modelSchema: { allowIn: "htmlTable", isBlock: !1 } }, { model: "htmlTfoot", view: "tfoot", modelSchema: { allowIn: "htmlTable", isBlock: !1 } }, { model: "htmlCaption", view: "caption", modelSchema: { allowIn: "htmlTable", allowChildren: "$text", isBlock: !1 } }, { model: "htmlColgroup", view: "colgroup", modelSchema: { allowIn: "htmlTable", allowChildren: "col", isBlock: !1 } }, { model: "htmlCol", view: "col", modelSchema: { allowIn: "htmlColgroup", isBlock: !1 } }, { model: "htmlTr", view: "tr", modelSchema: { allowIn: ["htmlTable", "htmlThead", "htmlTbody"], isLimit: !0 } }, { model: "htmlTd", view: "td", modelSchema: { allowIn: "htmlTr", allowContentOf: "$container", isLimit: !0, isBlock: !1 } }, { model: "htmlTh", view: "th", modelSchema: { allowIn: "htmlTr", allowContentOf: "$container", isLimit: !0, isBlock: !1 } }, { model: "htmlFigure", view: "figure", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlFigcaption", view: "figcaption", modelSchema: { allowIn: "htmlFigure", allowChildren: "$text", isBlock: !1 } }, { model: "htmlAddress", view: "address", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlAside", view: "aside", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlMain", view: "main", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlDetails", view: "details", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlSummary", view: "summary", modelSchema: { allowChildren: "$text", allowIn: "htmlDetails", isBlock: !1 } }, { model: "htmlDiv", view: "div", paragraphLikeModel: "htmlDivParagraph", modelSchema: { inheritAllFrom: "$container" } }, { model: "htmlFieldset", view: "fieldset", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlLegend", view: "legend", modelSchema: { allowIn: "htmlFieldset", allowChildren: "$text" } }, { model: "htmlHeader", view: "header", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlFooter", view: "footer", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlForm", view: "form", modelSchema: { inheritAllFrom: "$container", isBlock: !0 } }, { model: "htmlHgroup", view: "hgroup", modelSchema: { allowChildren: ["htmlH1", "htmlH2", "htmlH3", "htmlH4", "htmlH5", "htmlH6"], isBlock: !1 } }, { model: "htmlH1", view: "h1", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH2", view: "h2", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH3", view: "h3", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH4", view: "h4", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH5", view: "h5", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH6", view: "h6", modelSchema: { inheritAllFrom: "$block" } }, { model: "$htmlList", modelSchema: { allowWhere: "$container", allowChildren: ["$htmlList", "htmlLi"], isBlock: !1 } }, { model: "htmlDir", view: "dir", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlMenu", view: "menu", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlUl", view: "ul", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlOl", view: "ol", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlLi", view: "li", modelSchema: { allowIn: "$htmlList", allowChildren: "$text", isBlock: !1 } }, { model: "htmlPre", view: "pre", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlArticle", view: "article", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlSection", view: "section", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlNav", view: "nav", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlDivDl", view: "div", modelSchema: { allowChildren: ["htmlDt", "htmlDd"], allowIn: "htmlDl" } }, { model: "htmlDl", view: "dl", modelSchema: { allowWhere: "$container", allowChildren: ["htmlDt", "htmlDd", "htmlDivDl"], isBlock: !1 } }, { model: "htmlDt", view: "dt", modelSchema: { allowChildren: "$block", isBlock: !1 } }, { model: "htmlDd", view: "dd", modelSchema: { allowChildren: "$block", isBlock: !1 } }, { model: "htmlCenter", view: "center", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }], f5 = [{ model: "htmlLiAttributes", view: "li", appliesToBlock: !0 }, { model: "htmlListAttributes", view: "ol", appliesToBlock: !0 }, { model: "htmlListAttributes", view: "ul", appliesToBlock: !0 }, { model: "htmlFigureAttributes", view: "figure", appliesToBlock: "table" }, { model: "htmlTheadAttributes", view: "thead", appliesToBlock: "table" }, { model: "htmlTbodyAttributes", view: "tbody", appliesToBlock: "table" }, { model: "htmlFigureAttributes", view: "figure", appliesToBlock: "imageBlock" }, { model: "htmlAcronym", view: "acronym", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlTt", view: "tt", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlFont", view: "font", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlTime", view: "time", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlVar", view: "var", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlBig", view: "big", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSmall", view: "small", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSamp", view: "samp", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlQ", view: "q", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlOutput", view: "output", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlKbd", view: "kbd", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlBdi", view: "bdi", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlBdo", view: "bdo", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlAbbr", view: "abbr", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlA", view: "a", priority: 5, coupledAttribute: "linkHref", attributeProperties: { copyOnEnter: !0 } }, { model: "htmlStrong", view: "strong", coupledAttribute: "bold", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlB", view: "b", coupledAttribute: "bold", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlI", view: "i", coupledAttribute: "italic", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlEm", view: "em", coupledAttribute: "italic", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlS", view: "s", coupledAttribute: "strikethrough", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlDel", view: "del", coupledAttribute: "strikethrough", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlIns", view: "ins", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlU", view: "u", coupledAttribute: "underline", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSub", view: "sub", coupledAttribute: "subscript", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSup", view: "sup", coupledAttribute: "superscript", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlCode", view: "code", coupledAttribute: "code", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlMark", view: "mark", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSpan", view: "span", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlCite", view: "cite", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlLabel", view: "label", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlDfn", view: "dfn", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlObject", view: "object", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlIframe", view: "iframe", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlInput", view: "input", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlButton", view: "button", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlTextarea", view: "textarea", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlSelect", view: "select", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlVideo", view: "video", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlEmbed", view: "embed", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlOembed", view: "oembed", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlAudio", view: "audio", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlImg", view: "img", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlCanvas", view: "canvas", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlMeter", view: "meter", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlProgress", view: "progress", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlScript", view: "script", modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 } }, { model: "htmlStyle", view: "style", modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 } }, { model: "htmlCustomElement", view: "$customElement", modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 } }], b5 = Ta(function(o, e, t, n) {
        Zu(o, e, t, n);
      });
      var k5 = Object.defineProperty, w5 = Object.defineProperties, v5 = Object.getOwnPropertyDescriptors, pk = Object.getOwnPropertySymbols, _5 = Object.prototype.hasOwnProperty, A5 = Object.prototype.propertyIsEnumerable, fk = (o, e, t) => e in o ? k5(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, vs = (o, e) => {
        for (var t in e || (e = {}))
          _5.call(e, t) && fk(o, t, e[t]);
        if (pk)
          for (var t of pk(e))
            A5.call(e, t) && fk(o, t, e[t]);
        return o;
      }, _s = (o, e) => w5(o, v5(e));
      class Xo extends W {
        constructor() {
          super(...arguments), this._definitions = [];
        }
        static get pluginName() {
          return "DataSchema";
        }
        init() {
          for (const e of p5)
            this.registerBlockElement(e);
          for (const e of f5)
            this.registerInlineElement(e);
        }
        registerBlockElement(e) {
          this._definitions.push(_s(vs({}, e), { isBlock: !0 }));
        }
        registerInlineElement(e) {
          this._definitions.push(_s(vs({}, e), { isInline: !0 }));
        }
        extendBlockElement(e) {
          this._extendDefinition(_s(vs({}, e), { isBlock: !0 }));
        }
        extendInlineElement(e) {
          this._extendDefinition(_s(vs({}, e), { isInline: !0 }));
        }
        getDefinitionsForView(e, t = !1) {
          const n = /* @__PURE__ */ new Set();
          for (const i of this._getMatchingViewDefinitions(e)) {
            if (t)
              for (const r of this._getReferences(i.model))
                n.add(r);
            n.add(i);
          }
          return n;
        }
        getDefinitionsForModel(e) {
          return this._definitions.filter((t) => t.model == e);
        }
        _getMatchingViewDefinitions(e) {
          return this._definitions.filter((t) => t.view && function(n, i) {
            return typeof n == "string" ? n === i : n instanceof RegExp ? n.test(i) : !1;
          }(e, t.view));
        }
        *_getReferences(e) {
          const t = ["inheritAllFrom", "inheritTypesFrom", "allowWhere", "allowContentOf", "allowAttributesOf"], n = this._definitions.filter((i) => i.model == e);
          for (const { modelSchema: i } of n)
            if (i)
              for (const r of t)
                for (const s of Xe(i[r] || [])) {
                  const a = this._definitions.filter((l) => l.model == s);
                  for (const l of a)
                    s !== e && (yield* this._getReferences(l.model), yield l);
                }
        }
        _extendDefinition(e) {
          const t = Array.from(this._definitions.entries()).filter(([, n]) => n.model == e.model);
          if (t.length != 0)
            for (const [n, i] of t)
              this._definitions[n] = b5({}, i, e, (r, s) => Array.isArray(r) ? r.concat(s) : void 0);
          else
            this._definitions.push(e);
        }
      }
      const C5 = function(o, e, t, n) {
        for (var i = o.length, r = t + (n ? 1 : -1); n ? r-- : ++r < i; )
          if (e(o[r], r, o))
            return r;
        return -1;
      }, y5 = function(o) {
        return o != o;
      }, E5 = function(o, e, t) {
        for (var n = t - 1, i = o.length; ++n < i; )
          if (o[n] === e)
            return n;
        return -1;
      }, x5 = function(o, e, t) {
        return e == e ? E5(o, e, t) : C5(o, y5, t);
      }, S5 = function(o, e, t, n) {
        for (var i = t - 1, r = o.length; ++i < r; )
          if (n(o[i], e))
            return i;
        return -1;
      };
      var bk = Array.prototype.splice;
      const D5 = function(o, e, t, n) {
        var i = n ? S5 : x5, r = -1, s = e.length, a = o;
        for (o === e && (e = Xs(e)), t && (a = Uu(o, _r(t))); ++r < s; )
          for (var l = 0, d = e[r], h = t ? t(d) : d; (l = i(a, h, l, n)) > -1; )
            a !== o && bk.call(a, l, 1), bk.call(o, l, 1);
        return o;
      }, B5 = Yu(function(o, e) {
        return o && o.length && e && e.length ? D5(o, e) : o;
      });
      var kk = b(5049), T5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(kk.Z, T5), kk.Z.locals;
      class st extends W {
        constructor(e) {
          super(e), this._dataSchema = e.plugins.get("DataSchema"), this._allowedAttributes = new No(), this._disallowedAttributes = new No(), this._allowedElements = /* @__PURE__ */ new Set(), this._disallowedElements = /* @__PURE__ */ new Set(), this._dataInitialized = !1, this._coupledAttributes = null, this._registerElementsAfterInit(), this._registerElementHandlers(), this._registerModelPostFixer();
        }
        static get pluginName() {
          return "DataFilter";
        }
        static get requires() {
          return [Xo, Wi];
        }
        loadAllowedConfig(e) {
          for (const t of e) {
            const n = t.name || /[\s\S]+/, i = _k(t);
            this.allowElement(n), i.forEach((r) => this.allowAttributes(r));
          }
        }
        loadDisallowedConfig(e) {
          for (const t of e) {
            const n = t.name || /[\s\S]+/, i = _k(t);
            i.length == 0 ? this.disallowElement(n) : i.forEach((r) => this.disallowAttributes(r));
          }
        }
        allowElement(e) {
          for (const t of this._dataSchema.getDefinitionsForView(e, !0))
            this._addAllowedElement(t), this._coupledAttributes = null;
        }
        disallowElement(e) {
          for (const t of this._dataSchema.getDefinitionsForView(e, !1))
            this._disallowedElements.add(t.view);
        }
        allowAttributes(e) {
          this._allowedAttributes.add(e);
        }
        disallowAttributes(e) {
          this._disallowedAttributes.add(e);
        }
        processViewAttributes(e, t) {
          return wk(e, t, this._disallowedAttributes), wk(e, t, this._allowedAttributes);
        }
        _addAllowedElement(e) {
          if (!this._allowedElements.has(e)) {
            if (this._allowedElements.add(e), "appliesToBlock" in e && typeof e.appliesToBlock == "string")
              for (const t of this._dataSchema.getDefinitionsForModel(e.appliesToBlock))
                t.isBlock && this._addAllowedElement(t);
            this._dataInitialized && this.editor.data.once("set", () => {
              this._fireRegisterEvent(e);
            }, { priority: se.get("highest") + 1 });
          }
        }
        _registerElementsAfterInit() {
          this.editor.data.on("init", () => {
            this._dataInitialized = !0;
            for (const e of this._allowedElements)
              this._fireRegisterEvent(e);
          }, { priority: se.get("highest") + 1 });
        }
        _registerElementHandlers() {
          this.on("register", (e, t) => {
            const n = this.editor.model.schema;
            if (t.isObject && !n.isRegistered(t.model))
              this._registerObjectElement(t);
            else if (t.isBlock)
              this._registerBlockElement(t);
            else {
              if (!t.isInline)
                throw new O("data-filter-invalid-definition", null, t);
              this._registerInlineElement(t);
            }
            e.stop();
          }, { priority: "lowest" });
        }
        _registerModelPostFixer() {
          const e = this.editor.model;
          e.document.registerPostFixer((t) => {
            const n = e.document.differ.getChanges();
            let i = !1;
            const r = this._getCoupledAttributesMap();
            for (const s of n) {
              if (s.type != "attribute" || s.attributeNewValue !== null)
                continue;
              const a = r.get(s.attributeKey);
              if (a)
                for (const { item: l } of s.range.getWalker({ shallow: !0 }))
                  for (const d of a)
                    l.hasAttribute(d) && (t.removeAttribute(d, l), i = !0);
            }
            return i;
          });
        }
        _getCoupledAttributesMap() {
          if (this._coupledAttributes)
            return this._coupledAttributes;
          this._coupledAttributes = /* @__PURE__ */ new Map();
          for (const e of this._allowedElements)
            if (e.coupledAttribute && e.model) {
              const t = this._coupledAttributes.get(e.coupledAttribute);
              t ? t.push(e.model) : this._coupledAttributes.set(e.coupledAttribute, [e.model]);
            }
          return this._coupledAttributes;
        }
        _fireRegisterEvent(e) {
          e.view && this._disallowedElements.has(e.view) || this.fire(e.view ? `register:${e.view}` : "register", e);
        }
        _registerObjectElement(e) {
          const t = this.editor, n = t.model.schema, i = t.conversion, { view: r, model: s } = e;
          n.register(s, e.modelSchema), r && (n.extend(e.model, { allowAttributes: ["htmlAttributes", "htmlContent"] }), t.data.registerRawContentMatcher({ name: r }), i.for("upcast").elementToElement({ view: r, model: lc(e), converterPriority: se.get("low") + 1 }), i.for("upcast").add(Ki(e, this)), i.for("editingDowncast").elementToStructure({ model: { name: s, attributes: ["htmlAttributes"] }, view: g5(t, e) }), i.for("dataDowncast").elementToElement({ model: s, view: (a, { writer: l }) => ws(r, a, l) }), i.for("dataDowncast").add(Zi(e)));
        }
        _registerBlockElement(e) {
          const t = this.editor, n = t.model.schema, i = t.conversion, { view: r, model: s } = e;
          if (!n.isRegistered(e.model)) {
            if (n.register(e.model, e.modelSchema), !r)
              return;
            i.for("upcast").elementToElement({ model: s, view: r, converterPriority: se.get("low") + 1 }), i.for("downcast").elementToElement({ model: s, view: r });
          }
          r && (n.extend(e.model, { allowAttributes: "htmlAttributes" }), i.for("upcast").add(Ki(e, this)), i.for("downcast").add(Zi(e)));
        }
        _registerInlineElement(e) {
          const t = this.editor, n = t.model.schema, i = t.conversion, r = e.model;
          e.appliesToBlock || (n.extend("$text", { allowAttributes: r }), e.attributeProperties && n.setAttributeProperties(r, e.attributeProperties), i.for("upcast").add(function({ view: s, model: a }, l) {
            return (d) => {
              d.on(`element:${s}`, (h, m, f) => {
                let _ = l.processViewAttributes(m.viewItem, f);
                if (_ || f.consumable.test(m.viewItem, { name: !0 })) {
                  _ = _ || {}, f.consumable.consume(m.viewItem, { name: !0 }), m.modelRange || (m = Object.assign(m, f.convertChildren(m.viewItem, m.modelCursor)));
                  for (const S of m.modelRange.getItems())
                    if (f.schema.checkAttribute(S, a)) {
                      const B = h5(_, S.getAttribute(a) || {});
                      f.writer.setAttribute(a, B, S);
                    }
                }
              }, { priority: "low" });
            };
          }(e, this)), i.for("downcast").attributeToElement({ model: r, view: m5(e) }));
        }
      }
      function wk(o, e, t) {
        const n = function(l, { consumable: d }, h) {
          const m = h.matchAll(l) || [], f = [];
          for (const _ of m)
            I5(d, l, _), delete _.match.name, d.consume(l, _.match), f.push(_);
          return f;
        }(o, e, t), { attributes: i, styles: r, classes: s } = function(l) {
          const d = { attributes: /* @__PURE__ */ new Set(), classes: /* @__PURE__ */ new Set(), styles: /* @__PURE__ */ new Set() };
          for (const h of l)
            for (const m in d)
              (h.match[m] || []).forEach((f) => d[m].add(f));
          return d;
        }(n), a = {};
        if (i.size)
          for (const l of i)
            Jd(l) || i.delete(l);
        return i.size && (a.attributes = vk(i, (l) => o.getAttribute(l))), r.size && (a.styles = vk(r, (l) => o.getStyle(l))), s.size && (a.classes = Array.from(s)), Object.keys(a).length ? a : null;
      }
      function I5(o, e, t) {
        for (const n of ["attributes", "classes", "styles"]) {
          const i = t.match[n];
          if (i)
            for (const r of Array.from(i))
              o.test(e, { [n]: [r] }) || B5(i, r);
        }
      }
      function vk(o, e) {
        const t = {};
        for (const n of o)
          e(n) !== void 0 && (t[n] = e(n));
        return t;
      }
      function cc(o, e) {
        const { name: t } = o, n = o[e];
        return xt(n) ? Object.entries(n).map(([i, r]) => ({ name: t, [e]: { [i]: r } })) : Array.isArray(n) ? n.map((i) => ({ name: t, [e]: [i] })) : [o];
      }
      function _k(o) {
        const { name: e, attributes: t, classes: n, styles: i } = o, r = [];
        return t && r.push(...cc({ name: e, attributes: t }, "attributes")), n && r.push(...cc({ name: e, classes: n }, "classes")), i && r.push(...cc({ name: e, styles: i }, "styles")), r;
      }
      class P5 extends W {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "CodeBlockElementSupport";
        }
        init() {
          if (!this.editor.plugins.has("CodeBlockEditing"))
            return;
          const e = this.editor.plugins.get(st);
          e.on("register:pre", (t, n) => {
            if (n.model !== "codeBlock")
              return;
            const i = this.editor, r = i.model.schema, s = i.conversion;
            r.extend("codeBlock", { allowAttributes: ["htmlAttributes", "htmlContentAttributes"] }), s.for("upcast").add(/* @__PURE__ */ function(a) {
              return (l) => {
                l.on("element:code", (d, h, m) => {
                  const f = h.viewItem, _ = f.parent;
                  function S(B, T) {
                    const R = a.processViewAttributes(B, m);
                    R && m.writer.setAttribute(T, R, h.modelRange);
                  }
                  _ && _.is("element", "pre") && (S(_, "htmlAttributes"), S(f, "htmlContentAttributes"));
                }, { priority: "low" });
              };
            }(e)), s.for("downcast").add((a) => {
              a.on("attribute:htmlAttributes:codeBlock", (l, d, h) => {
                if (!h.consumable.consume(d.item, l.name))
                  return;
                const { attributeOldValue: m, attributeNewValue: f } = d, _ = h.mapper.toViewElement(d.item).parent;
                go(h.writer, m, f, _);
              }), a.on("attribute:htmlContentAttributes:codeBlock", (l, d, h) => {
                if (!h.consumable.consume(d.item, l.name))
                  return;
                const { attributeOldValue: m, attributeNewValue: f } = d, _ = h.mapper.toViewElement(d.item);
                go(h.writer, m, f, _);
              });
            }), t.stop();
          });
        }
      }
      class O5 extends W {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "DualContentModelElementSupport";
        }
        init() {
          this.editor.plugins.get(st).on("register", (e, t) => {
            const n = t, i = this.editor, r = i.model.schema, s = i.conversion;
            if (!n.paragraphLikeModel || r.isRegistered(n.model) || r.isRegistered(n.paragraphLikeModel))
              return;
            const a = { model: n.paragraphLikeModel, view: n.view };
            r.register(n.model, n.modelSchema), r.register(a.model, { inheritAllFrom: "$block" }), s.for("upcast").elementToElement({ view: n.view, model: (l, { writer: d }) => this._hasBlockContent(l) ? d.createElement(n.model) : d.createElement(a.model), converterPriority: se.get("low") + 0.5 }), s.for("downcast").elementToElement({ view: n.view, model: n.model }), this._addAttributeConversion(n), s.for("downcast").elementToElement({ view: a.view, model: a.model }), this._addAttributeConversion(a), e.stop();
          });
        }
        _hasBlockContent(e) {
          const t = this.editor.editing.view, n = t.domConverter.blockElements;
          for (const i of t.createRangeIn(e).getItems())
            if (i.is("element") && n.includes(i.name))
              return !0;
          return !1;
        }
        _addAttributeConversion(e) {
          const t = this.editor, n = t.conversion, i = t.plugins.get(st);
          t.model.schema.extend(e.model, { allowAttributes: "htmlAttributes" }), n.for("upcast").add(Ki(e, i)), n.for("downcast").add(Zi(e));
        }
      }
      class R5 extends W {
        static get requires() {
          return [Xo, qi];
        }
        static get pluginName() {
          return "HeadingElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("HeadingEditing"))
            return;
          const t = e.config.get("heading.options");
          this.registerHeadingElements(e, t), this.removeClassesOnEnter(e, t);
        }
        registerHeadingElements(e, t) {
          const n = e.plugins.get(Xo), i = [];
          for (const r of t)
            "model" in r && "view" in r && (n.registerBlockElement({ view: r.view, model: r.model }), i.push(r.model));
          n.extendBlockElement({ model: "htmlHgroup", modelSchema: { allowChildren: i } });
        }
        removeClassesOnEnter(e, t) {
          const n = e.commands.get("enter");
          this.listenTo(n, "afterExecute", (i, r) => {
            const s = e.model.document.selection.getFirstPosition().parent;
            t.some((a) => s.is("element", a.model)) && s.childCount === 0 && mo(r.writer, s, "htmlAttributes", "classes", (a) => a.clear());
          });
        }
      }
      function As(o, e, t) {
        const n = o.createRangeOn(e);
        for (const { item: i } of n.getWalker())
          if (i.is("element", t))
            return i;
      }
      class z5 extends W {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "ImageElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("ImageInlineEditing") && !e.plugins.has("ImageBlockEditing"))
            return;
          const t = e.model.schema, n = e.conversion, i = e.plugins.get(st);
          i.on("register:figure", () => {
            n.for("upcast").add(/* @__PURE__ */ function(r) {
              return (s) => {
                s.on("element:figure", (a, l, d) => {
                  const h = l.viewItem;
                  if (!l.modelRange || !h.hasClass("image"))
                    return;
                  const m = r.processViewAttributes(h, d);
                  m && d.writer.setAttribute("htmlFigureAttributes", m, l.modelRange);
                }, { priority: "low" });
              };
            }(i));
          }), i.on("register:img", (r, s) => {
            s.model !== "imageBlock" && s.model !== "imageInline" || (t.isRegistered("imageBlock") && t.extend("imageBlock", { allowAttributes: ["htmlAttributes", "htmlFigureAttributes", "htmlLinkAttributes"] }), t.isRegistered("imageInline") && t.extend("imageInline", { allowAttributes: ["htmlA", "htmlAttributes"] }), n.for("upcast").add(/* @__PURE__ */ function(a) {
              return (l) => {
                l.on("element:img", (d, h, m) => {
                  if (!h.modelRange)
                    return;
                  const f = h.viewItem, _ = f.parent;
                  function S(T, R) {
                    const N = a.processViewAttributes(T, m);
                    N && m.writer.setAttribute(R, N, h.modelRange);
                  }
                  function B(T) {
                    h.modelRange && h.modelRange.getContainedElement().is("element", "imageBlock") && S(T, "htmlLinkAttributes");
                  }
                  S(f, "htmlAttributes"), _.is("element", "a") && B(_);
                }, { priority: "low" });
              };
            }(i)), n.for("downcast").add((a) => {
              function l(h) {
                a.on(`attribute:${h}:imageInline`, (m, f, _) => {
                  if (!_.consumable.consume(f.item, m.name))
                    return;
                  const { attributeOldValue: S, attributeNewValue: B } = f, T = _.mapper.toViewElement(f.item);
                  go(_.writer, S, B, T);
                }, { priority: "low" });
              }
              function d(h, m) {
                a.on(`attribute:${m}:imageBlock`, (f, _, S) => {
                  if (!S.consumable.test(_.item, f.name))
                    return;
                  const { attributeOldValue: B, attributeNewValue: T } = _, R = S.mapper.toViewElement(_.item), N = As(S.writer, R, h);
                  N && (go(S.writer, B, T, N), S.consumable.consume(_.item, f.name));
                }, { priority: "low" }), h === "a" && a.on("attribute:linkHref:imageBlock", (f, _, S) => {
                  if (!S.consumable.consume(_.item, "attribute:htmlLinkAttributes:imageBlock"))
                    return;
                  const B = S.mapper.toViewElement(_.item), T = As(S.writer, B, "a");
                  Nn(S.writer, _.item.getAttribute("htmlLinkAttributes"), T);
                }, { priority: "low" });
              }
              l("htmlAttributes"), d("img", "htmlAttributes"), d("figure", "htmlFigureAttributes"), d("a", "htmlLinkAttributes");
            }), r.stop());
          });
        }
      }
      class M5 extends W {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "MediaEmbedElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("MediaEmbed") || e.config.get("mediaEmbed.previewsInData"))
            return;
          const t = e.model.schema, n = e.conversion, i = this.editor.plugins.get(st), r = this.editor.plugins.get(Xo), s = e.config.get("mediaEmbed.elementName");
          r.registerBlockElement({ model: "media", view: s }), i.on("register:figure", () => {
            n.for("upcast").add(/* @__PURE__ */ function(a) {
              return (l) => {
                l.on("element:figure", (d, h, m) => {
                  const f = h.viewItem;
                  if (!h.modelRange || !f.hasClass("media"))
                    return;
                  const _ = a.processViewAttributes(f, m);
                  _ && m.writer.setAttribute("htmlFigureAttributes", _, h.modelRange);
                }, { priority: "low" });
              };
            }(i));
          }), i.on(`register:${s}`, (a, l) => {
            l.model === "media" && (t.extend("media", { allowAttributes: ["htmlAttributes", "htmlFigureAttributes"] }), n.for("upcast").add(/* @__PURE__ */ function(d, h) {
              const m = (f, _, S) => {
                function B(T, R) {
                  const N = d.processViewAttributes(T, S);
                  N && S.writer.setAttribute(R, N, _.modelRange);
                }
                B(_.viewItem, "htmlAttributes");
              };
              return (f) => {
                f.on(`element:${h}`, m, { priority: "low" });
              };
            }(i, s)), n.for("dataDowncast").add(/* @__PURE__ */ function(d) {
              return (h) => {
                function m(f, _) {
                  h.on(`attribute:${_}:media`, (S, B, T) => {
                    if (!T.consumable.consume(B.item, S.name))
                      return;
                    const { attributeOldValue: R, attributeNewValue: N } = B, U = T.mapper.toViewElement(B.item), ee = As(T.writer, U, f);
                    go(T.writer, R, N, ee);
                  });
                }
                m(d, "htmlAttributes"), m("figure", "htmlFigureAttributes");
              };
            }(s)), a.stop());
          });
        }
      }
      class N5 extends W {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "ScriptElementSupport";
        }
        init() {
          const e = this.editor.plugins.get(st);
          e.on("register:script", (t, n) => {
            const i = this.editor, r = i.model.schema, s = i.conversion;
            r.register("htmlScript", n.modelSchema), r.extend("htmlScript", { allowAttributes: ["htmlAttributes", "htmlContent"], isContent: !0 }), i.data.registerRawContentMatcher({ name: "script" }), s.for("upcast").elementToElement({ view: "script", model: lc(n) }), s.for("upcast").add(Ki(n, e)), s.for("downcast").elementToElement({ model: "htmlScript", view: (a, { writer: l }) => ws("script", a, l) }), s.for("downcast").add(Zi(n)), t.stop();
          });
        }
      }
      class F5 extends W {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "TableElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("TableEditing"))
            return;
          const t = e.model.schema, n = e.conversion, i = e.plugins.get(st), r = e.plugins.get("TableUtils");
          i.on("register:figure", () => {
            n.for("upcast").add(/* @__PURE__ */ function(s) {
              return (a) => {
                a.on("element:figure", (l, d, h) => {
                  const m = d.viewItem;
                  if (!d.modelRange || !m.hasClass("table"))
                    return;
                  const f = s.processViewAttributes(m, h);
                  f && h.writer.setAttribute("htmlFigureAttributes", f, d.modelRange);
                }, { priority: "low" });
              };
            }(i));
          }), i.on("register:table", (s, a) => {
            a.model === "table" && (t.extend("table", { allowAttributes: ["htmlAttributes", "htmlFigureAttributes", "htmlTheadAttributes", "htmlTbodyAttributes"] }), n.for("upcast").add(/* @__PURE__ */ function(l) {
              return (d) => {
                d.on("element:table", (h, m, f) => {
                  if (!m.modelRange)
                    return;
                  const _ = m.viewItem;
                  S(_, "htmlAttributes");
                  for (const B of _.getChildren())
                    B.is("element", "thead") && S(B, "htmlTheadAttributes"), B.is("element", "tbody") && S(B, "htmlTbodyAttributes");
                  function S(B, T) {
                    const R = l.processViewAttributes(B, f);
                    R && f.writer.setAttribute(T, R, m.modelRange);
                  }
                }, { priority: "low" });
              };
            }(i)), n.for("downcast").add((l) => {
              function d(h, m) {
                l.on(`attribute:${m}:table`, (f, _, S) => {
                  if (!S.consumable.test(_.item, f.name))
                    return;
                  const B = S.mapper.toViewElement(_.item), T = As(S.writer, B, h);
                  T && (S.consumable.consume(_.item, f.name), go(S.writer, _.attributeOldValue, _.attributeNewValue, T));
                });
              }
              d("table", "htmlAttributes"), d("figure", "htmlFigureAttributes"), d("thead", "htmlTheadAttributes"), d("tbody", "htmlTbodyAttributes");
            }), e.model.document.registerPostFixer(/* @__PURE__ */ function(l, d) {
              return (h) => {
                const m = l.document.differ.getChanges();
                let f = !1;
                for (const _ of m) {
                  if (_.type != "attribute" || _.attributeKey != "headingRows")
                    continue;
                  const S = _.range.start.nodeAfter, B = S.getAttribute("htmlTheadAttributes"), T = S.getAttribute("htmlTbodyAttributes");
                  B && !_.attributeNewValue ? (h.removeAttribute("htmlTheadAttributes", S), f = !0) : T && _.attributeNewValue == d.getRows(S) && (h.removeAttribute("htmlTbodyAttributes", S), f = !0);
                }
                return f;
              };
            }(e.model, r)), s.stop());
          });
        }
      }
      class $5 extends W {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "StyleElementSupport";
        }
        init() {
          const e = this.editor.plugins.get(st);
          e.on("register:style", (t, n) => {
            const i = this.editor, r = i.model.schema, s = i.conversion;
            r.register("htmlStyle", n.modelSchema), r.extend("htmlStyle", { allowAttributes: ["htmlAttributes", "htmlContent"], isContent: !0 }), i.data.registerRawContentMatcher({ name: "style" }), s.for("upcast").elementToElement({ view: "style", model: lc(n) }), s.for("upcast").add(Ki(n, e)), s.for("downcast").elementToElement({ model: "htmlStyle", view: (a, { writer: l }) => ws("style", a, l) }), s.for("downcast").add(Zi(n)), t.stop();
          });
        }
      }
      class V5 extends W {
        static get requires() {
          return [st];
        }
        static get pluginName() {
          return "DocumentListElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("DocumentListEditing"))
            return;
          const t = e.model.schema, n = e.conversion, i = e.plugins.get(st), r = e.plugins.get("DocumentListEditing");
          r.registerDowncastStrategy({ scope: "item", attributeName: "htmlLiAttributes", setAttributeOnDowncast(s, a, l) {
            Nn(s, a, l);
          } }), r.registerDowncastStrategy({ scope: "list", attributeName: "htmlListAttributes", setAttributeOnDowncast(s, a, l) {
            Nn(s, a, l);
          } }), i.on("register", (s, a) => {
            ["ul", "ol", "li"].includes(a.view) && (s.stop(), t.checkAttribute("$block", "htmlListAttributes") || (t.extend("$block", { allowAttributes: ["htmlListAttributes", "htmlLiAttributes"] }), t.extend("$blockObject", { allowAttributes: ["htmlListAttributes", "htmlLiAttributes"] }), t.extend("$container", { allowAttributes: ["htmlListAttributes", "htmlLiAttributes"] }), n.for("upcast").add((l) => {
              l.on("element:ul", dc("htmlListAttributes", i), { priority: "low" }), l.on("element:ol", dc("htmlListAttributes", i), { priority: "low" }), l.on("element:li", dc("htmlLiAttributes", i), { priority: "low" });
            })));
          }), r.on("postFixer", (s, { listNodes: a, writer: l }) => {
            const d = [];
            for (const { node: h, previous: m } of a) {
              if (!m)
                continue;
              const f = h.getAttribute("listIndent"), _ = m.getAttribute("listIndent");
              let S = null;
              if (f > _ ? d[_] = m : f < _ ? (S = d[f], d.length = f) : S = m, S) {
                if (S.getAttribute("listType") == h.getAttribute("listType")) {
                  const B = S.getAttribute("htmlListAttributes");
                  Kr(h.getAttribute("htmlListAttributes"), B) || (l.setAttribute("htmlListAttributes", B, h), s.return = !0);
                }
                if (S.getAttribute("listItemId") == h.getAttribute("listItemId")) {
                  const B = S.getAttribute("htmlLiAttributes");
                  Kr(h.getAttribute("htmlLiAttributes"), B) || (l.setAttribute("htmlLiAttributes", B, h), s.return = !0);
                }
              }
            }
          });
        }
        afterInit() {
          const e = this.editor;
          if (!e.commands.get("indentList"))
            return;
          const t = e.commands.get("indentList");
          this.listenTo(t, "afterExecute", (n, i) => {
            e.model.change((r) => {
              for (const s of i)
                r.setAttribute("htmlListAttributes", {}, s);
            });
          });
        }
      }
      function dc(o, e) {
        return (t, n, i) => {
          const r = n.viewItem;
          n.modelRange || Object.assign(n, i.convertChildren(n.viewItem, n.modelCursor));
          const s = e.processViewAttributes(r, i);
          for (const a of n.modelRange.getItems({ shallow: !0 }))
            a.hasAttribute("listItemId") && (a.hasAttribute(o) || i.writer.setAttribute(o, s || {}, a));
        };
      }
      class L5 extends W {
        static get requires() {
          return [st, Xo];
        }
        static get pluginName() {
          return "CustomElementSupport";
        }
        init() {
          const e = this.editor.plugins.get(st), t = this.editor.plugins.get(Xo);
          e.on("register:$customElement", (n, i) => {
            n.stop();
            const r = this.editor, s = r.model.schema, a = r.conversion, l = r.editing.view.domConverter.unsafeElements, d = r.data.htmlProcessor.domConverter.preElements;
            s.register(i.model, i.modelSchema), s.extend(i.model, { allowAttributes: ["htmlElementName", "htmlAttributes", "htmlContent"], isContent: !0 }), a.for("upcast").elementToElement({ view: /.*/, model: (h, m) => {
              if (h.name == "$comment" || !function(T) {
                try {
                  document.createElement(T);
                } catch {
                  return !1;
                }
                return !0;
              }(h.name) || t.getDefinitionsForView(h.name).size)
                return null;
              l.includes(h.name) || l.push(h.name), d.includes(h.name) || d.push(h.name);
              const f = m.writer.createElement(i.model, { htmlElementName: h.name }), _ = e.processViewAttributes(h, m);
              _ && m.writer.setAttribute("htmlAttributes", _, f);
              const S = new Jr(h.document).createDocumentFragment(h), B = r.data.processor.toData(S);
              m.writer.setAttribute("htmlContent", B, f);
              for (const { item: T } of r.editing.view.createRangeIn(h))
                m.consumable.consume(T, { name: !0 });
              return f;
            }, converterPriority: "low" }), a.for("editingDowncast").elementToElement({ model: { name: i.model, attributes: ["htmlElementName", "htmlAttributes", "htmlContent"] }, view: (h, { writer: m }) => {
              const f = h.getAttribute("htmlElementName"), _ = m.createRawElement(f);
              return h.hasAttribute("htmlAttributes") && Nn(m, h.getAttribute("htmlAttributes"), _), _;
            } }), a.for("dataDowncast").elementToElement({ model: { name: i.model, attributes: ["htmlElementName", "htmlAttributes", "htmlContent"] }, view: (h, { writer: m }) => {
              const f = h.getAttribute("htmlElementName"), _ = h.getAttribute("htmlContent"), S = m.createRawElement(f, null, (B, T) => {
                T.setContentOf(B, _);
                const R = B.firstChild;
                for (R.remove(); R.firstChild; )
                  B.appendChild(R.firstChild);
              });
              return h.hasAttribute("htmlAttributes") && Nn(m, h.getAttribute("htmlAttributes"), S), S;
            } });
          });
        }
      }
      function* ei(o, e, t) {
        if (e)
          if (!(Symbol.iterator in e) && e.is("documentSelection") && e.isCollapsed)
            o.schema.checkAttributeInSelection(e, t) && (yield e);
          else
            for (const n of function(i, r, s) {
              return !(Symbol.iterator in r) && (r.is("node") || r.is("$text") || r.is("$textProxy")) ? i.schema.checkAttribute(r, s) ? [i.createRangeOn(r)] : [] : i.schema.getValidRanges(i.createSelection(r).getRanges(), s);
            }(o, e, t))
              yield* n.getItems({ shallow: !0 });
      }
      var ti = (o, e, t) => new Promise((n, i) => {
        var r = (l) => {
          try {
            a(t.next(l));
          } catch (d) {
            i(d);
          }
        }, s = (l) => {
          try {
            a(t.throw(l));
          } catch (d) {
            i(d);
          }
        }, a = (l) => l.done ? n(l.value) : Promise.resolve(l.value).then(r, s);
        a((t = t.apply(o, e)).next());
      });
      function Ak(o, e) {
        let t = new URL(o);
        if (e && Object.keys(e).length > 0) {
          const n = new URLSearchParams();
          for (const [i, r] of Object.entries(e))
            if (Array.isArray(r))
              for (const s of r)
                n.append(i, s);
            else
              n.append(i, r);
          t.search = n.toString();
        }
        return t.toString();
      }
      class j5 {
        constructor(e, t) {
          this.loader = e, this.api_url = t;
        }
        _getUploadUrl(e, t) {
          return ti(this, null, function* () {
            const n = yield fetch(this.api_url + "/vi/skey", { credentials: "include" }).catch((a) => {
              t(a);
            }), i = yield n.json(), r = { fileName: e.name, mimeType: e.type || "application/octet-stream", size: e.size.toString(), skey: i }, s = yield fetch(Ak(this.api_url + "/vi/file/getUploadURL", r), { method: "POST", credentials: "include" }).catch((a) => {
              t(a);
            });
            return this.loader.uploaded = 10, s;
          });
        }
        fileUpload(e, t, n) {
          return ti(this, null, function* () {
            yield fetch(t.values.uploadUrl, { mode: "no-cors", method: "POST", body: e }).catch((l) => {
              n(l);
            }), this.loader.uploaded = 50;
            const i = yield fetch(this.api_url + "/vi/skey", { credentials: "include" }).catch((l) => {
              n(l);
            }), r = yield i.json(), s = { key: t.values.uploadKey, node: void 0, skelType: "leaf", skey: r }, a = yield fetch(Ak(this.api_url + "/vi/file/add", s), { method: "POST", credentials: "include" }).catch((l) => {
              n(l);
            });
            return this.loader.uploaded = 75, a;
          });
        }
        upload() {
          return ti(this, null, function* () {
            return this.loader.uploadTotal = 100, this.loader.uploaded = 0, this.loader.file.then((e) => ti(this, null, function* () {
              return new Promise((t, n) => {
                this._getUploadUrl(e, n).then((i) => ti(this, null, function* () {
                  const r = yield i.json();
                  this.fileUpload(e, r, n).then((s) => ti(this, null, function* () {
                    const a = yield s.json();
                    this.loader.uploaded = 100, t({ default: this.api_url + a.values.downloadUrl });
                  }));
                }));
              });
            }));
          });
        }
        abort() {
          this.xhr && this.xhr.abort();
        }
      }
      var Ck = b(2245), H5 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      Q()(Ck.Z, H5), Ck.Z.locals;
      class uc extends ss {
      }
      uc.builtinPlugins = [class extends W {
        static get requires() {
          return [A2, qi, S2, o2, Gy, N2];
        }
        static get pluginName() {
          return "Essentials";
        }
      }, class extends W {
        static get requires() {
          return [An];
        }
        static get pluginName() {
          return "CKFinderUploadAdapter";
        }
        init() {
          const o = this.editor.config.get("ckfinder.uploadUrl");
          o && (this.editor.plugins.get(An).createUploadAdapter = (e) => new j2(e, o, this.editor.t));
        }
      }, class extends Or {
        constructor() {
          super(...arguments), this.token = null, this._tokens = /* @__PURE__ */ new Map();
        }
        static get pluginName() {
          return "CloudServices";
        }
        static get requires() {
          return [XS];
        }
        init() {
          return sk(this, null, function* () {
            const o = this.context.config.get("cloudServices") || {};
            for (const [t, n] of Object.entries(o))
              this[t] = n;
            if (!this.tokenUrl)
              return void (this.token = null);
            const e = this.context.plugins.get("CloudServicesCore");
            this.token = yield e.createToken(this.tokenUrl).init(), this._tokens.set(this.tokenUrl, this.token);
          });
        }
        registerTokenUrl(o) {
          return sk(this, null, function* () {
            if (this._tokens.has(o))
              return this.getTokenFor(o);
            const e = this.context.plugins.get("CloudServicesCore"), t = yield e.createToken(o).init();
            return this._tokens.set(o, t), t;
          });
        }
        getTokenFor(o) {
          const e = this._tokens.get(o);
          if (!e)
            throw new O("cloudservices-token-not-registered", this);
          return e;
        }
        destroy() {
          super.destroy();
          for (const o of this._tokens.values())
            o.destroy();
        }
      }, class extends W {
        static get requires() {
          return [H2, U2];
        }
        static get pluginName() {
          return "Bold";
        }
      }, class extends W {
        static get requires() {
          return [W2, G2];
        }
        static get pluginName() {
          return "Italic";
        }
      }, class extends W {
        static get requires() {
          return [Y2, X2];
        }
        static get pluginName() {
          return "BlockQuote";
        }
      }, class extends W {
        static get pluginName() {
          return "EasyImage";
        }
        static get requires() {
          return [eE, "ImageUpload"];
        }
        init() {
          const o = this.editor;
          o.plugins.has("ImageBlockEditing") || o.plugins.has("ImageInlineEditing") || oe("easy-image-image-feature-missing", o);
        }
      }, class extends W {
        static get requires() {
          return [rE, aE];
        }
        static get pluginName() {
          return "Heading";
        }
      }, class extends W {
        static get requires() {
          return [EE, SE];
        }
        static get pluginName() {
          return "Image";
        }
      }, class extends W {
        static get requires() {
          return [yf, ex];
        }
        static get pluginName() {
          return "ImageStyle";
        }
      }, class extends W {
        static get requires() {
          return [us, Cn];
        }
        static get pluginName() {
          return "ImageToolbar";
        }
        afterInit() {
          const o = this.editor, e = o.t, t = o.plugins.get(us), n = o.plugins.get("ImageUtils");
          var i;
          t.register("image", { ariaLabel: e("Image toolbar"), items: (i = o.config.get("image.toolbar") || [], i.map((r) => K(r) ? r.name : r)), getRelatedElement: (r) => n.getClosestSelectedImageWidget(r) });
        }
      }, class extends W {
        static get pluginName() {
          return "ImageUpload";
        }
        static get requires() {
          return [LE, TE, RE];
        }
      }, class extends W {
        constructor(o) {
          super(o), this._resizeUnit = o.config.get("image.resizeUnit");
        }
        static get requires() {
          return [WE];
        }
        static get pluginName() {
          return "ImageResizeButtons";
        }
        init() {
          const o = this.editor, e = o.config.get("image.resizeOptions"), t = o.commands.get("resizeImage");
          this.bind("isEnabled").to(t);
          for (const n of e)
            this._registerImageResizeButton(n);
          this._registerImageResizeDropdown(e);
        }
        _registerImageResizeButton(o) {
          const e = this.editor, { name: t, value: n, icon: i } = o, r = n ? n + this._resizeUnit : null;
          e.ui.componentFactory.add(t, (s) => {
            const a = new je(s), l = e.commands.get("resizeImage"), d = this._getOptionLabelValue(o, !0);
            if (!Rl[i])
              throw new O("imageresizebuttons-missing-icon", e, o);
            return a.set({ label: d, icon: Rl[i], tooltip: d, isToggleable: !0 }), a.bind("isEnabled").to(this), a.bind("isOn").to(l, "value", uf(r)), this.listenTo(a, "execute", () => {
              e.execute("resizeImage", { width: r });
            }), a;
          });
        }
        _registerImageResizeDropdown(o) {
          const e = this.editor, t = e.t, n = o.find((r) => !r.value), i = (r) => {
            const s = e.commands.get("resizeImage"), a = wn(r, Pu), l = a.buttonView, d = t("Resize image");
            return l.set({ tooltip: d, commandValue: n.value, icon: Rl.medium, isToggleable: !0, label: this._getOptionLabelValue(n), withText: !0, class: "ck-resize-image-button", ariaLabel: d, ariaLabelledBy: void 0 }), l.bind("label").to(s, "value", (h) => h && h.width ? h.width : this._getOptionLabelValue(n)), a.bind("isEnabled").to(this), ll(a, () => this._getResizeDropdownListItemDefinitions(o, s), { ariaLabel: t("Image resize list"), role: "menu" }), this.listenTo(a, "execute", (h) => {
              e.execute(h.source.commandName, { width: h.source.commandValue }), e.editing.view.focus();
            }), a;
          };
          e.ui.componentFactory.add("resizeImage", i), e.ui.componentFactory.add("imageResize", i);
        }
        _getOptionLabelValue(o, e = !1) {
          const t = this.editor.t;
          return o.label ? o.label : e ? o.value ? t("Resize image to %0", o.value + this._resizeUnit) : t("Resize image to the original size") : o.value ? o.value + this._resizeUnit : t("Original");
        }
        _getResizeDropdownListItemDefinitions(o, e) {
          const t = new Ht();
          return o.map((n) => {
            const i = n.value ? n.value + this._resizeUnit : null, r = { type: "button", model: new vl({ commandName: "resizeImage", commandValue: i, label: this._getOptionLabelValue(n), role: "menuitemradio", withText: !0, icon: null }) };
            r.model.bind("isOn").to(e, "value", uf(i)), t.add(r);
          }), t;
        }
      }, class extends W {
        static get pluginName() {
          return "Indent";
        }
        static get requires() {
          return [tx, nx];
        }
      }, class extends W {
        constructor(o) {
          super(o), o.config.define("indentBlock", { offset: 40, unit: "px" });
        }
        static get pluginName() {
          return "IndentBlock";
        }
        init() {
          const o = this.editor, e = o.config.get("indentBlock");
          e.classes && e.classes.length ? (this._setupConversionUsingClasses(e.classes), o.commands.add("indentBlock", new fs(o, new Pf({ direction: "forward", classes: e.classes }))), o.commands.add("outdentBlock", new fs(o, new Pf({ direction: "backward", classes: e.classes })))) : (o.data.addStyleProcessorRules(V1), this._setupConversionUsingOffset(), o.commands.add("indentBlock", new fs(o, new If({ direction: "forward", offset: e.offset, unit: e.unit }))), o.commands.add("outdentBlock", new fs(o, new If({ direction: "backward", offset: e.offset, unit: e.unit }))));
        }
        afterInit() {
          const o = this.editor, e = o.model.schema, t = o.commands.get("indent"), n = o.commands.get("outdent"), i = o.config.get("heading.options");
          (i && i.map((r) => r.model) || ox).forEach((r) => {
            e.isRegistered(r) && e.extend(r, { allowAttributes: "blockIndent" });
          }), e.setAttributeProperties("blockIndent", { isFormatting: !0 }), t.registerChildCommand(o.commands.get("indentBlock")), n.registerChildCommand(o.commands.get("outdentBlock"));
        }
        _setupConversionUsingOffset() {
          const o = this.editor.conversion, e = this.editor.locale.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left";
          o.for("upcast").attributeToAttribute({ view: { styles: { [e]: /[\s\S]+/ } }, model: { key: "blockIndent", value: (t) => t.getStyle(e) } }), o.for("downcast").attributeToAttribute({ model: "blockIndent", view: (t) => ({ key: "style", value: { [e]: t } }) });
        }
        _setupConversionUsingClasses(o) {
          const e = { model: { key: "blockIndent", values: [] }, view: {} };
          for (const t of o)
            e.model.values.push(t), e.view[t] = { key: "class", value: [t] };
          this.editor.conversion.attributeToAttribute(e);
        }
      }, class extends W {
        static get requires() {
          return [Dx, Ox, zx];
        }
        static get pluginName() {
          return "Link";
        }
      }, class extends W {
        static get requires() {
          return [nS, Hx];
        }
        static get pluginName() {
          return "List";
        }
      }, Pl, class extends W {
        static get requires() {
          return [xS, BS, uo, zS, OS, PS, Wi];
        }
        static get pluginName() {
          return "Table";
        }
      }, class extends W {
        static get requires() {
          return [us];
        }
        static get pluginName() {
          return "TableToolbar";
        }
        afterInit() {
          const o = this.editor, e = o.t, t = o.plugins.get(us), n = o.config.get("table.contentToolbar"), i = o.config.get("table.tableToolbar");
          n && t.register("tableContent", { ariaLabel: e("Table toolbar"), items: n, getRelatedElement: FS }), i && t.register("table", { ariaLabel: e("Table toolbar"), items: i, getRelatedElement: NS });
        }
      }, class extends W {
        static get requires() {
          return ["Delete", "Input"];
        }
        static get pluginName() {
          return "TextTransformation";
        }
        constructor(o) {
          super(o), o.config.define("typing", { transformations: { include: Jy } });
        }
        init() {
          const o = this.editor.model.document.selection;
          o.on("change:range", () => {
            this.isEnabled = !o.anchor.parent.is("element", "codeBlock");
          }), this._enableTransformationWatchers();
        }
        _enableTransformationWatchers() {
          const o = this.editor, e = o.model, t = o.plugins.get("Delete"), n = function(r) {
            const s = r.extra || [], a = r.remove || [], l = (d) => !a.includes(d);
            return function(d) {
              const h = /* @__PURE__ */ new Set();
              for (const m of d)
                if (typeof m == "string" && Km[m])
                  for (const f of Km[m])
                    h.add(f);
                else
                  h.add(m);
              return Array.from(h);
            }(r.include.concat(s).filter(l)).filter(l).map((d) => typeof d == "string" && Gm[d] ? Gm[d] : d).filter((d) => typeof d == "object").map((d) => ({ from: Yy(d.from), to: Qy(d.to) }));
          }(o.config.get("typing.transformations")), i = new Um(o.model, (r) => {
            for (const s of n)
              if (s.from.test(r))
                return { normalizedTransformation: s };
          });
          i.on("matched:data", (r, s) => {
            if (!s.batch.isTyping)
              return;
            const { from: a, to: l } = s.normalizedTransformation, d = a.exec(s.text), h = l(d.slice(1)), m = s.range;
            let f = d.index;
            e.enqueueChange((_) => {
              for (let S = 1; S < d.length; S++) {
                const B = d[S], T = h[S - 1];
                if (T == null) {
                  f += B.length;
                  continue;
                }
                const R = m.start.getShiftedBy(f), N = e.createRange(R, R.getShiftedBy(B.length)), U = Xy(R);
                e.insertContent(_.createText(T, U), N), f += T.length;
              }
              e.enqueueChange(() => {
                t.requestUndoOnBackspace();
              });
            });
          }), i.bind("isEnabled").to(this);
        }
      }, class extends W {
        static get requires() {
          return [K2, Z2];
        }
        static get pluginName() {
          return "Underline";
        }
      }, class extends W {
        static get requires() {
          return [t5, n5];
        }
        static get pluginName() {
          return "Alignment";
        }
      }, class extends W {
        constructor(o) {
          super(o), this.set("isSourceEditingMode", !1), this._elementReplacer = new Yc(), this._replacedRoots = /* @__PURE__ */ new Map(), this._dataFromRoots = /* @__PURE__ */ new Map();
        }
        static get pluginName() {
          return "SourceEditing";
        }
        static get requires() {
          return [Qr];
        }
        init() {
          const o = this.editor;
          o.t, o.ui.componentFactory.add("sourceEditing", (e) => {
            const t = new je(e);
            return t.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 0 5 4.5v15.003h-16V0h11zM3 1.5v3.25l-1.497 1-.003 8 1.5 1v3.254L7.685 18l-.001 1.504H17.5V8.002L16 9.428l-.004-4.22-4.222-3.692L3 1.5z"/><path d="M4.06 6.64a.75.75 0 0 1 .958 1.15l-.085.07L2.29 9.75l2.646 1.89c.302.216.4.62.232.951l-.058.095a.75.75 0 0 1-.951.232l-.095-.058-3.5-2.5V9.14l3.496-2.5zm4.194 6.22a.75.75 0 0 1-.958-1.149l.085-.07 2.643-1.89-2.646-1.89a.75.75 0 0 1-.232-.952l.058-.095a.75.75 0 0 1 .95-.232l.096.058 3.5 2.5v1.22l-3.496 2.5zm7.644-.836 2.122 2.122-5.825 5.809-2.125-.005.003-2.116zm2.539-1.847 1.414 1.414a.5.5 0 0 1 0 .707l-1.06 1.06-2.122-2.12 1.061-1.061a.5.5 0 0 1 .707 0z"/></svg>', tooltip: !0, withText: !0, class: "ck-source-editing-button" }), t.bind("isOn").to(this, "isSourceEditingMode"), t.bind("isEnabled").to(this, "isEnabled", o, "isReadOnly", o.plugins.get(Qr), "hasAny", (n, i, r) => !!n && !i && !r), this.listenTo(t, "execute", () => {
              this.isSourceEditingMode = !this.isSourceEditingMode;
            }), t;
          }), this._isAllowedToHandleSourceEditingMode() && (this.on("change:isSourceEditingMode", (e, t, n) => {
            n ? (this._showSourceEditing(), this._disableCommands()) : (this._hideSourceEditing(), this._enableCommands());
          }), this.on("change:isEnabled", (e, t, n) => this._handleReadOnlyMode(!n)), this.listenTo(o, "change:isReadOnly", (e, t, n) => this._handleReadOnlyMode(n))), o.data.on("get", () => {
            this.isSourceEditingMode && this.updateEditorData();
          }, { priority: "high" });
        }
        afterInit() {
          const o = this.editor;
          ["RealTimeCollaborativeEditing", "CommentsEditing", "TrackChangesEditing", "RevisionHistory"].some((e) => o.plugins.has(e)) && console.warn("You initialized the editor with the source editing feature and at least one of the collaboration features. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the collaboration features."), o.plugins.has("RestrictedEditingModeEditing") && console.warn("You initialized the editor with the source editing feature and restricted editing feature. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the restricted editing feature.");
        }
        updateEditorData() {
          const o = this.editor, e = {};
          for (const [t, n] of this._replacedRoots) {
            const i = this._dataFromRoots.get(t), r = n.dataset.value;
            i !== r && (e[t] = r);
          }
          Object.keys(e).length && o.data.set(e, { batchType: { isUndoable: !0 } });
        }
        _showSourceEditing() {
          const o = this.editor, e = o.editing.view, t = o.model;
          t.change((n) => {
            n.setSelection(null), n.removeSelectionAttribute(t.document.selection.getAttributeKeys());
          });
          for (const [n, i] of e.domRoots) {
            const r = r5(o.data.get({ rootName: n })), s = js(i.ownerDocument, "textarea", { rows: "1", "aria-label": "Source code editing area" }), a = js(i.ownerDocument, "div", { class: "ck-source-editing-area", "data-value": r }, [s]);
            s.value = r, s.setSelectionRange(0, 0), s.addEventListener("input", () => {
              a.dataset.value = s.value, o.ui.update();
            }), e.change((l) => {
              const d = e.document.getRoot(n);
              l.addClass("ck-hidden", d);
            }), o.ui.setEditableElement("sourceEditing:" + n, s), this._replacedRoots.set(n, a), this._elementReplacer.replace(i, a), this._dataFromRoots.set(n, r);
          }
          this._focusSourceEditing();
        }
        _hideSourceEditing() {
          const o = this.editor.editing.view;
          this.updateEditorData(), o.change((e) => {
            for (const [t] of this._replacedRoots)
              e.removeClass("ck-hidden", o.document.getRoot(t));
          }), this._elementReplacer.restore(), this._replacedRoots.clear(), this._dataFromRoots.clear(), o.focus();
        }
        _focusSourceEditing() {
          const o = this.editor, [e] = this._replacedRoots.values(), t = e.querySelector("textarea");
          o.editing.view.document.isFocused = !1, t.focus();
        }
        _disableCommands() {
          const o = this.editor;
          for (const e of o.commands.commands())
            e.forceDisabled(uk);
        }
        _enableCommands() {
          const o = this.editor;
          for (const e of o.commands.commands())
            e.clearForceDisabled(uk);
        }
        _handleReadOnlyMode(o) {
          if (this.isSourceEditingMode)
            for (const [, e] of this._replacedRoots)
              e.querySelector("textarea").readOnly = o;
        }
        _isAllowedToHandleSourceEditingMode() {
          const o = this.editor.ui.view.editable;
          return o && !o.hasExternalElement;
        }
      }, class extends W {
        static get requires() {
          return [l5, s5];
        }
        static get pluginName() {
          return "RemoveFormat";
        }
      }, class extends W {
        static get pluginName() {
          return "GeneralHtmlSupport";
        }
        static get requires() {
          return [st, P5, O5, R5, z5, M5, N5, F5, $5, V5, L5];
        }
        init() {
          const o = this.editor, e = o.plugins.get(st);
          e.loadAllowedConfig(o.config.get("htmlSupport.allow") || []), e.loadDisallowedConfig(o.config.get("htmlSupport.disallow") || []);
        }
        getGhsAttributeNameForElement(o) {
          const e = this.editor.plugins.get("DataSchema"), t = Array.from(e.getDefinitionsForView(o, !1)), n = t.find((i) => i.isInline && !t[0].isObject);
          return n ? n.model : "htmlAttributes";
        }
        addModelHtmlClass(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ei(n, t, i))
              mo(r, s, i, "classes", (a) => {
                for (const l of Xe(e))
                  a.add(l);
              });
          });
        }
        removeModelHtmlClass(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ei(n, t, i))
              mo(r, s, i, "classes", (a) => {
                for (const l of Xe(e))
                  a.delete(l);
              });
          });
        }
        setModelHtmlAttributes(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ei(n, t, i))
              mo(r, s, i, "attributes", (a) => {
                for (const [l, d] of Object.entries(e))
                  a.set(l, d);
              });
          });
        }
        removeModelHtmlAttributes(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ei(n, t, i))
              mo(r, s, i, "attributes", (a) => {
                for (const l of Xe(e))
                  a.delete(l);
              });
          });
        }
        setModelHtmlStyles(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ei(n, t, i))
              mo(r, s, i, "styles", (a) => {
                for (const [l, d] of Object.entries(e))
                  a.set(l, d);
              });
          });
        }
        removeModelHtmlStyles(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of ei(n, t, i))
              mo(r, s, i, "styles", (a) => {
                for (const l of Xe(e))
                  a.delete(l);
              });
          });
        }
      }], uc.defaultConfig = { extraPlugins: [function(o) {
        o.plugins.get("FileRepository").createUploadAdapter = (e) => new j5(e, o.config.get("viur_api_url"));
      }, function(o) {
        o.conversion.attributeToElement({ model: "bold", view: "b", upcastAlso: [(e) => {
          const t = e.getStyle("font-weight");
          return t && (t == "bold" || Number(t) >= 600) ? { name: !0, styles: ["font-weight"] } : null;
        }] });
      }], toolbar: { items: ["heading", "|", "bold", "italic", "underline", "|", "alignment", "numberedList", "bulletedList", "blockQuote", "|", "indent", "outdent", "|", "link", "insertTable", "imageUpload", "|", "undo", "redo", "RemoveFormat", "sourceEditing"] }, image: { toolbar: ["imageStyle:inline", "imageStyle:block", "imageStyle:side", "|", "resizeImage:50", "resizeImage:75", "resizeImage:original", "imageTextAlternative"], resizeOptions: [{ name: "resizeImage:original", value: null, icon: "original" }, { name: "resizeImage:50", value: "50", icon: "medium" }, { name: "resizeImage:75", value: "75", icon: "large" }] }, table: { contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"] }, heading: { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h1", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h2", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h3", title: "Heading 3", class: "ck-heading_heading3" }, { model: "heading4", view: "h4", title: "Heading 4", class: "ck-heading_heading4" }, { model: "heading5", view: "h5", title: "Heading 5", class: "ck-heading_heading5" }, { model: "heading6", view: "h6", title: "Heading 6", class: "ck-heading_heading6" }] }, alignment: { options: [{ name: "left", className: "viur-txt-align--left" }, { name: "right", className: "viur-txt-align--right" }, { name: "center", className: "viur-txt-align--center" }, { name: "justify", className: "viur-txt-align--justify" }] }, indentBlock: { classes: ["viur-txt-indent--1", "viur-txt-indent--2", "viur-txt-indent--3", "viur-txt-indent--4", "viur-txt-indent--5", "viur-txt-indent--6", "viur-txt-indent--7", "viur-txt-indent--8", "viur-txt-indent--9", "viur-txt-indent--10"] }, htmlSupport: { allow: [{ name: "a", attributes: { target: !0, rel: !0 } }] }, language: "de", viur_api_url: "http://localhost:8080" };
    })(), x = x.default;
  })());
})(Os, Os.exports);
var p7 = Os.exports;
const xw = /* @__PURE__ */ m7(p7), f7 = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({
      value: "",
      editorConfig: {},
      editor: ce(() => xw)
    });
    function b(C) {
      u.emit("change", c.name, w.value, c.lang, c.index);
    }
    function x(C) {
      w.value = C.target.value, u.emit("change", c.name, w.value, c.lang, c.index);
    }
    lt(() => {
      c.value !== null && (w.value = c.value), u.emit("change", c.name, c.value, c.lang, c.index);
    });
    function v(C) {
      C.editing.view.change((p) => {
        p.setStyle("min-height", "250px", C.editing.view.document.getRoot());
      });
    }
    return ui(
      () => c.value,
      (C, p) => {
        w.value = C;
      }
    ), {
      state: w,
      ClassicEditor: xw,
      boneState: g,
      changeEvent: b,
      onReady: v,
      changeEventTextarea: x
    };
  }
}), b7 = ["disabled", "value"];
function k7(c, u, g, w, b, x) {
  var C, p;
  const v = hi("ckeditor");
  return c.state.editor ? (H(), G(Ve, { key: 0 }, [
    c.boneState.bonestructure.validHtml ? (H(), yt(v, {
      key: 0,
      modelValue: c.state.value,
      "onUpdate:modelValue": u[0] || (u[0] = (D) => c.state.value = D),
      editor: c.state.editor,
      config: c.state.editorConfig,
      disabled: (C = c.boneState) == null ? void 0 : C.readonly,
      onReady: c.onReady,
      onInput: c.changeEvent
    }, null, 8, ["modelValue", "editor", "config", "disabled", "onReady", "onInput"])) : (H(), G("sl-textarea", {
      key: 1,
      disabled: (p = c.boneState) == null ? void 0 : p.readonly,
      value: c.value,
      onInput: u[1] || (u[1] = (...D) => c.changeEventTextarea && c.changeEventTextarea(...D))
    }, null, 40, b7))
  ], 64)) : Ee("", !0);
}
const Sw = /* @__PURE__ */ Ae(f7, [["render", k7]]), w7 = Ye({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({
      valueLat: null,
      valueLng: null
    });
    function b() {
      u.emit("change", c.name, [w.valueLat, w.valueLng], c.lang, c.index);
    }
    return lt(() => {
      try {
        w.valueLat = c.value[0], w.valueLng = c.value[1];
      } catch {
      }
      u.emit("change", c.name, [w.valueLat, w.valueLng], c.lang, c.index);
    }), {
      state: w,
      boneState: g,
      changeEvent: b
    };
  }
}), v7 = ["name", "min", "max", "disabled"], _7 = ["name", "min", "max", "disabled"];
function A7(c, u, g, w, b, x) {
  return H(), G(Ve, null, [
    gt(I("sl-input", {
      "onUpdate:modelValue": u[0] || (u[0] = (v) => c.state.valueLat = v),
      index: "lat",
      type: "number",
      name: c.name,
      min: c.boneState.bonestructure.boundslat[0],
      max: c.boneState.bonestructure.boundslat[1],
      disabled: c.boneState.readonly,
      "value-as-number": "",
      step: "0.000001",
      onSlChange: u[1] || (u[1] = (...v) => c.changeEvent && c.changeEvent(...v)),
      placeholder: "Lat"
    }, null, 40, v7), [
      [Ct, c.state.valueLat]
    ]),
    gt(I("sl-input", {
      "onUpdate:modelValue": u[2] || (u[2] = (v) => c.state.valueLng = v),
      index: "lng",
      type: "number",
      name: c.name,
      min: c.boneState.bonestructure.boundslat[0],
      max: c.boneState.bonestructure.boundslat[1],
      disabled: c.boneState.readonly,
      "value-as-number": "",
      step: "0.000001",
      onSlChange: u[3] || (u[3] = (...v) => c.changeEvent && c.changeEvent(...v)),
      placeholder: "Long"
    }, null, 40, _7), [
      [Ct, c.state.valueLng]
    ])
  ], 64);
}
const Dw = /* @__PURE__ */ Ae(w7, [["render", A7], ["__scopeId", "data-v-7bc31020"]]), C7 = Ye({
  props: {
    name: String,
    value: Object,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = me({
      counter: 0,
      debounce: null
    }), b = Be("addMultipleEntry"), x = Be("removeMultipleEntries");
    function v() {
      w.counter += 1;
      let p = 200;
      w.counter > 1 && (p = 500), w.debounce && clearTimeout(w.debounce), w.debounce = setTimeout(() => {
        for (let D = w.counter; D--; )
          b(c.lang);
        w.counter = 0;
      }, p);
    }
    function C() {
      let p = 200;
      w.debounce && clearTimeout(w.debounce), w.debounce = setTimeout(() => {
        x(c.lang);
      }, p);
    }
    return lt(() => {
      (!c.value || c.value.length === 0) && u.emit("change", c.name, [], c.lang);
    }), {
      state: w,
      boneState: g,
      handleAdd: v,
      handleRemove: C,
      removeMultipleEntries: x
    };
  }
}), C0 = (c) => (dt("data-v-63e75dee"), c = c(), ut(), c), y7 = { class: "actionbar" }, E7 = ["title"], x7 = /* @__PURE__ */ C0(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), S7 = [
  x7
], D7 = ["title"], B7 = /* @__PURE__ */ C0(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  name: "plus-lg"
}, null, -1));
function T7(c, u, g, w, b, x) {
  return H(), G("div", y7, [
    c.boneState.multiple && !c.readonly ? (H(), G("sl-button", {
      key: 0,
      variant: "danger",
      title: c.$t("bone.del"),
      outline: "",
      class: "delete-btn",
      onClick: u[0] || (u[0] = (v) => c.handleRemove(c.lang))
    }, S7, 8, E7)) : Ee("", !0),
    c.boneState.multiple && !c.readonly ? (H(), G("sl-button", {
      key: 1,
      variant: "success",
      title: c.$t("bone.add"),
      outline: "",
      class: "add-btn",
      onClick: u[1] || (u[1] = (v) => c.handleAdd(c.lang))
    }, [
      B7,
      ie(" " + ge(c.$t("bone.add")) + " ", 1),
      c.state.counter > 1 ? (H(), G(Ve, { key: 0 }, [
        ie("(" + ge(c.state.counter) + ")", 1)
      ], 64)) : Ee("", !0)
    ], 8, D7)) : Ee("", !0)
  ]);
}
const I7 = /* @__PURE__ */ Ae(C7, [["render", T7], ["__scopeId", "data-v-63e75dee"]]), P7 = Ye({
  props: {
    name: String,
    value: Object,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = Be("addMultipleEntry"), b = Be("formatString"), x = null, v = me({
      skels: {},
      hasUsing: ce(() => g == null ? void 0 : g.bonestructure.using)
    });
    function C(p) {
      let D = "";
      return g.bonestructure.type === "relational.tree.leaf.file" ? D = "skelType=leaf&" : g.bonestructure.type === "relational.tree.node.file" && (D = "skelType=node&"), he.get(
        `/json/${g.bonestructure.module}/list?${D}limit=99`
      ).then(async (y) => {
        var k;
        const A = await y.json();
        return v.skels = A.skellist.reduce((E, P) => (E[P.key] = P, E), {}), (k = A.skellist) == null ? void 0 : k.map((E) => ({ text: b(g.bonestructure.format, { dest: E }), value: E.key, data: E }));
      });
    }
    return lt(() => {
      (!c.value || c.value.length === 0) && u.emit("change", c.name, [], c.lang);
    }), {
      state: v,
      boneState: g,
      addMultipleEntry: w,
      removeMultipleEntries: x,
      getList: C
    };
  }
}), y0 = (c) => (dt("data-v-eeea51c6"), c = c(), ut(), c), O7 = { class: "actionbar" }, R7 = ["title"], z7 = /* @__PURE__ */ y0(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), M7 = [
  z7
], N7 = ["source"], F7 = ["title"], $7 = /* @__PURE__ */ y0(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  name: "plus-lg"
}, null, -1));
function V7(c, u, g, w, b, x) {
  return H(), G("div", O7, [
    c.boneState.multiple && !c.readonly ? (H(), G("sl-button", {
      key: 0,
      variant: "danger",
      title: c.$t("bone.del"),
      outline: "",
      class: "delete-btn",
      onClick: u[0] || (u[0] = (v) => c.openSelector())
    }, M7, 8, R7)) : Ee("", !0),
    I("sl-combobox", {
      source: c.getList,
      hoist: "",
      onSlItemSelect: u[1] || (u[1] = (v) => {
        var C;
        return c.addMultipleEntry(c.lang, {
          dest: (C = c.state.skels) == null ? void 0 : C[v.detail.item.value],
          rel: c.state.hasUsing ? void 0 : null
        });
      })
    }, null, 40, N7),
    c.boneState.multiple && !c.readonly ? (H(), G("sl-button", {
      key: 1,
      variant: "success",
      title: c.$t("bone.add"),
      outline: "",
      class: "add-btn",
      onClick: u[2] || (u[2] = (v) => c.addMultipleEntry(c.lang))
    }, [
      $7,
      ie(" " + ge(c.$t("bone.list")), 1)
    ], 8, F7)) : Ee("", !0)
  ]);
}
const L7 = /* @__PURE__ */ Ae(P7, [["render", V7], ["__scopeId", "data-v-eeea51c6"]]), j7 = Ye({
  props: {
    name: String,
    value: Object,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(c, u) {
    const g = Be("boneState"), w = Be("addMultipleEntry");
    Be("formatString");
    const b = null, x = en(), v = me({
      skels: {},
      uploadinput: null,
      loading: !1,
      droparea: !1,
      hasUsing: ce(() => g == null ? void 0 : g.bonestructure.using)
    });
    function C(y) {
      const A = {
        fileName: y.name,
        mimeType: y.type || "application/octet-stream",
        size: y.size.toString()
      };
      return new Promise((k, E) => {
        he.securePost("/json/file/getUploadURL", { dataObj: A }).then(async (P) => {
          let z = await P.json();
          console.log(z), he.post(z.values.uploadUrl, { dataObj: y, mode: "no-cors" }).then(async (M) => {
            const F = {
              key: z.values.uploadKey,
              node: void 0,
              skelType: "leaf"
            };
            he.securePost("/json/file/add", { dataObj: F }).then(async (V) => {
              let j = await V.json();
              j.action === "addSuccess" ? k(j.values) : E(j);
            }).catch((V) => {
              E(V);
            });
          }).catch((M) => {
            E(M);
          });
        }).catch((P) => {
          E(P);
        });
      });
    }
    async function p(y) {
      v.loading = !0;
      for (let A of y.target.files) {
        let k = await C(A), E = null;
        v.hasUsing && (E = void 0), w(c.lang, { dest: k, rel: E });
      }
      v.loading = !1;
    }
    async function D(y) {
      v.loading = !0, v.droparea = !1;
      for (let A of y.dataTransfer.files) {
        let k = await C(A), E = null;
        v.hasUsing && (E = void 0), w(c.lang, { dest: k, rel: E });
      }
      v.loading = !1;
    }
    return lt(() => {
      (!c.value || c.value.length === 0) && u.emit("change", c.name, [], c.lang);
    }), {
      state: v,
      boneState: g,
      addMultipleEntry: w,
      removeMultipleEntries: b,
      uploadFile: C,
      uploadinput: x,
      handleUpload: p,
      handleDrop: D
    };
  }
}), Kc = (c) => (dt("data-v-34f8f5a4"), c = c(), ut(), c), H7 = ["title"], U7 = /* @__PURE__ */ Kc(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), q7 = [
  U7
], W7 = {
  key: 1,
  class: "droparea"
}, G7 = ["multiple"], K7 = ["title"], Z7 = /* @__PURE__ */ Kc(() => /* @__PURE__ */ I("sl-icon", {
  slot: "prefix",
  name: "plus-lg"
}, null, -1)), J7 = [
  Z7
], Y7 = ["title"], Q7 = /* @__PURE__ */ Kc(() => /* @__PURE__ */ I("sl-icon", { name: "upload" }, null, -1)), X7 = {
  key: 0,
  slot: "suffix"
};
function e6(c, u, g, w, b, x) {
  return H(), G("div", {
    class: "actionbar",
    onDragover: u[4] || (u[4] = Hn((v) => c.state.droparea = !0, ["prevent"])),
    onDragleave: u[5] || (u[5] = (v) => c.state.droparea = !1),
    onDrop: u[6] || (u[6] = Hn((...v) => c.handleDrop && c.handleDrop(...v), ["prevent"]))
  }, [
    c.boneState.multiple && !c.readonly ? (H(), G("sl-button", {
      key: 0,
      variant: "danger",
      title: c.$t("bone.del"),
      outline: "",
      class: "delete-btn",
      onClick: u[0] || (u[0] = (v) => c.openSelector())
    }, q7, 8, H7)) : Ee("", !0),
    c.state.droparea ? (H(), G("div", W7, " Dateien hier hinziehen ")) : Ee("", !0),
    I("input", {
      ref: "uploadinput",
      hidden: "",
      type: "file",
      multiple: c.boneState.multiple,
      onChange: u[1] || (u[1] = (...v) => c.handleUpload && c.handleUpload(...v))
    }, null, 40, G7),
    c.boneState.multiple && !c.readonly ? (H(), G("sl-button", {
      key: 2,
      outline: "",
      title: c.$t("bone.list"),
      class: "add-btn",
      onClick: u[2] || (u[2] = (v) => c.addMultipleEntry(c.lang))
    }, J7, 8, K7)) : Ee("", !0),
    c.boneState.multiple && !c.readonly ? (H(), G("sl-button", {
      key: 3,
      variant: "success",
      outline: "",
      title: c.$t("bone.upload"),
      class: "upload-btn",
      onClick: u[3] || (u[3] = (v) => c.uploadinput.click())
    }, [
      Q7,
      ie(" " + ge(c.$t("bone.upload")) + " ", 1),
      c.state.loading ? (H(), G("sl-spinner", X7)) : Ee("", !0)
    ], 8, Y7)) : Ee("", !0)
  ], 32);
}
const t6 = /* @__PURE__ */ Ae(j7, [["render", e6], ["__scopeId", "data-v-34f8f5a4"]]), n6 = ur("boneStore", () => {
  const c = me({
    additionalBones: Xt({}),
    defaultBones: Xt({
      rawBone: gw,
      keyBone: mw,
      stringBone: pw,
      emailBone: fw,
      dateBone: bw,
      booleanBone: ww,
      selectBone: kw,
      passwordBone: vw,
      recordBone: _w,
      numericBone: Cw,
      colorBone: Aw,
      relationalBone: yw,
      jsonBone: UO,
      fileBone: Ew,
      textBone: Sw,
      spatialBone: Dw
    }),
    actionbars: Xt({
      "relational.tree.leaf.file.file": t6,
      "relational.": L7
    }),
    multibones: Xt(["select", "select."])
  });
  function u(v, C) {
    c.additionalBones[v] = C;
  }
  function g() {
    let v = c.defaultBones;
    for (const [C, p] of Object.entries(c.additionalBones))
      v.add(p);
    return v;
  }
  function w(v) {
    if (Object.keys(c.additionalBones).includes(v))
      return c.additionalBones[v];
    {
      let C = v.split("."), p = Object.entries(c.additionalBones).filter(
        (D) => D[0].startsWith(C[0] + ".")
      );
      if (p.length > 0) {
        p.sort((D, y) => y.length - D.length);
        for (let D of p)
          if (v.startsWith(D[0]))
            return c.additionalBones[D[0]];
      }
    }
    return v === "date" ? bw : v === "key" ? mw : v === "str.email" ? fw : v === "str" || v.startsWith("str.") ? pw : v === "select" || v.startsWith("select.") ? kw : v === "bool" ? ww : v === "password" ? vw : v === "record" ? _w : v === "numeric" || v.startsWith("numeric.") ? Cw : v === "relational.tree.leaf.file.file" ? Ew : v === "relational" || v.startsWith("relational.") ? yw : v === "color" ? Aw : v === "text" ? Sw : v === "spatial" ? Dw : gw;
  }
  function b(v, C) {
    c.actionbars[v] = C;
  }
  function x(v) {
    if (Object.keys(c.actionbars).includes(v))
      return c.actionbars[v];
    {
      let C = v.split("."), p = Object.entries(c.actionbars).filter(
        (D) => D[0].startsWith(C[0] + ".")
      );
      if (p.length > 0) {
        p.sort((D, y) => y.length - D.length);
        for (let D of p)
          if (v.startsWith(D[0]))
            return c.actionbars[D[0]];
      }
    }
    return I7;
  }
  return {
    state: c,
    addBoneWidget: u,
    getBoneWidget: w,
    importWidgets: g,
    addBoneActionbar: b,
    getBoneActionbar: x
  };
});
function zc(c) {
  return n6().getBoneWidget(c);
}
const E0 = (c) => (dt("data-v-0e672e2f"), c = c(), ut(), c), o6 = /* @__PURE__ */ E0(() => /* @__PURE__ */ I("h2", { class: "viur-shop-form-headline headline" }, "Nutzterdaten", -1)), i6 = /* @__PURE__ */ E0(() => /* @__PURE__ */ I("h2", { class: "viur-shop-form-headline headline" }, "Lieferadresse", -1)), r6 = {
  __name: "UserInformation",
  props: {
    mode: { type: String, default: "form" }
  },
  setup(c) {
    const u = Wt(), g = me({
      formValues: {},
      requiredFieldsFilled: ce(() => {
        if (g.isCustomAdress)
          return Object.keys(g.formValues).includes("city") && Object.keys(g.formValues).includes("street") && Object.keys(g.formValues).includes("billing.city") && Object.keys(g.formValues).includes("billing.street") && Object.keys(g.formValues).includes("email") && Object.keys(g.formValues).includes("firstname") && Object.keys(g.formValues).includes("lastname");
        if (!g.isCustomAdress)
          return Object.keys(g.formValues).includes("city") && Object.keys(g.formValues).includes("street") && Object.keys(g.formValues).includes("email") && Object.keys(g.formValues).includes("firstname") && Object.keys(g.formValues).includes("lastname");
      }),
      isCustomAdress: !1,
      addSkel: null,
      errors: {}
    });
    function w(x, v) {
      for (const [C, p] of Object.entries(v.value[0]))
        g.formValues[C] = p;
    }
    function b(x) {
      let v = {};
      return x.forEach((C) => {
        let p = C[0], D = C[1];
        v[p] = D;
      }), v;
    }
    return ui(g.formValues, (x) => {
      Object.entries(x).forEach(([v, C]) => {
        C === "" && delete g.formValues[v];
      });
    }), yo(async () => {
      await u.getAdressStructure(), g.addSkel = u.state.structure.address;
    }), (x, v) => {
      const C = hi("bone");
      return H(), G(Ve, null, [
        o6,
        I("div", null, [
          (H(!0), G(Ve, null, kt(g.addSkel, (p) => (H(), G(Ve, {
            key: p[0]
          }, [
            p[1].visible && p[1].params.group === "Customer Info" ? (H(), yt(C, {
              key: 0,
              is: le(zc)(p[1].type),
              name: p[0],
              structure: b(g.addSkel),
              errors: g.errors[p[0]] ? g.errors[p[0]] : [],
              skel: g.formValues,
              onChange: (D) => w(p[0], D),
              class: "viur-shop-form-grid-w-2"
            }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : Ee("", !0)
          ], 64))), 128))
        ]),
        i6,
        I("div", null, [
          (H(!0), G(Ve, null, kt(g.addSkel, (p) => (H(), G(Ve, {
            key: p[0]
          }, [
            p[1].visible && p[1].params.group !== "Customer Info" ? (H(), yt(C, {
              key: 0,
              is: le(zc)(p[1].type),
              name: p[0],
              structure: b(g.addSkel),
              errors: g.errors[p[0]] ? g.errors[p[0]] : [],
              skel: g.formValues,
              onChange: (D) => w(p[0], D)
            }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : Ee("", !0)
          ], 64))), 128))
        ])
      ], 64);
    };
  }
}, s6 = /* @__PURE__ */ Ae(r6, [["__scopeId", "data-v-0e672e2f"]]), a6 = {}, Vs = (c) => (dt("data-v-36ccc280"), c = c(), ut(), c), l6 = { class: "bind" }, c6 = /* @__PURE__ */ Vs(() => /* @__PURE__ */ I("h1", { class: "headline" }, "Vielen Dank für Ihre Bestellung", -1)), d6 = /* @__PURE__ */ Vs(() => /* @__PURE__ */ I("br", null, null, -1)), u6 = /* @__PURE__ */ Vs(() => /* @__PURE__ */ I("p", { class: "paragraph" }, [
  /* @__PURE__ */ I("strong", null, "Ihre Bestellnummer:"),
  /* @__PURE__ */ ie(" 123345670 ")
], -1)), h6 = /* @__PURE__ */ Vs(() => /* @__PURE__ */ I("p", { class: "paragraph" }, [
  /* @__PURE__ */ ie(" Wir haben Ihre Bestellung erhalten und werden diese schenllstmöglich bearbeiten."),
  /* @__PURE__ */ I("br"),
  /* @__PURE__ */ ie(" Sie erhalten in wenigen Minuten eine Bestätigung per E-Mail. "),
  /* @__PURE__ */ I("div", { class: "btn-wrap" }, [
    /* @__PURE__ */ I("sl-button", { size: "medium" }, " Zur Startseite "),
    /* @__PURE__ */ I("sl-button", {
      variant: "primary",
      size: "medium"
    }, " Weiter Einkaufen ")
  ])
], -1)), g6 = [
  c6,
  d6,
  u6,
  h6
];
function m6(c, u) {
  return H(), G("div", l6, g6);
}
const p6 = /* @__PURE__ */ Ae(a6, [["render", m6], ["__scopeId", "data-v-36ccc280"]]), f6 = {};
function b6(c, u) {
  return " HALLO ";
}
const U6 = /* @__PURE__ */ Ae(f6, [["render", b6]]), k6 = (c) => (dt("data-v-1a569d30"), c = c(), ut(), c), w6 = { class: "bind viur-shop-wrap" }, v6 = ["panel", "disabled"], _6 = { class: "viur-shop-order-step" }, A6 = ["name", "library"], C6 = { class: "viur-shop-order-status-text" }, y6 = {
  key: 0,
  name: "chevron-right",
  class: "viur-shop-order-tab-check"
}, E6 = ["name"], x6 = /* @__PURE__ */ k6(() => /* @__PURE__ */ I("div", {
  class: "viur-shop-sidebar",
  id: "order_sidebar"
}, null, -1)), S6 = {
  __name: "OrderView",
  props: {
    tabs: {
      type: Object,
      required: !0
    }
  },
  emits: ["tabChange"],
  setup(c, { emit: u }) {
    const g = c, w = u, b = me({
      tabNames: ce(() => x(g.tabs))
    });
    function x(C) {
      let p = [], D = [];
      for (const y in C)
        C[y].position ? p.push([y, C[y].position]) : p.push([y, 0]);
      return p.sort((y, A) => y[1] - A[1]), p.forEach((y) => {
        D.push(y[0]);
      }), D;
    }
    function v(C) {
      w("tabChange", C);
    }
    return (C, p) => (H(), G("div", w6, [
      I("sl-tab-group", {
        class: "viur-shop-order-tab",
        noScrollControls: "",
        onSlTabShow: v
      }, [
        (H(!0), G(Ve, null, kt(b.tabNames, (D, y) => (H(), G("sl-tab", {
          slot: "nav",
          panel: D,
          key: D,
          disabled: c.tabs[D].disabled
        }, [
          I("div", _6, [
            I("sl-icon", {
              name: c.tabs[D].icon.name,
              library: c.tabs[D].icon.library
            }, null, 8, A6),
            I("div", C6, ge(y + 1) + ". " + ge(c.tabs[D].displayName), 1)
          ]),
          y < b.tabNames.length - 1 ? (H(), G("sl-icon", y6)) : Ee("", !0)
        ], 8, v6))), 128)),
        (H(!0), G(Ve, null, kt(b.tabNames, (D) => (H(), G("sl-tab-panel", {
          name: D,
          key: D
        }, [
          (H(), yt(Ow(c.tabs[D].component), Rw({ ref_for: !0 }, c.tabs[D].props ? c.tabs[D].props : ""), null, 16))
        ], 8, E6))), 128))
      ], 32),
      x6
    ]));
  }
}, D6 = /* @__PURE__ */ Ae(S6, [["__scopeId", "data-v-1a569d30"]]), B6 = {
  __name: "ExampleUsage",
  setup(c) {
    const u = Wt(), g = me({
      tabs: {
        cart: {
          component: Xt(Mw),
          props: { sidebar: !0, mode: "basket" },
          displayName: "Warenkorb",
          icon: { name: "cart", library: "hsk" },
          position: 2,
          disabled: !1,
          atShow: null,
          atHide: null
        },
        confirm: {
          component: Xt(v0),
          props: {},
          displayName: "Bestellung prüfen",
          icon: { name: "order-check", library: "hsk" },
          position: 5,
          disabled: !1,
          atShow: null,
          atHide: null
        },
        order: {
          component: Xt(w0),
          props: {
            listHandler: aD("categorystore", {
              module: "variante",
              params: { type: "hk", limit: 10 }
            })
          },
          displayName: "Artikel Bestellen",
          icon: { name: "cart-add", library: "hsk" },
          position: 1,
          disabled: !1,
          atShow: null,
          atHide: null
        },
        orderComplete: {
          component: Xt(p6),
          props: {},
          displayName: "Bestellung Abgeschlossen",
          icon: { name: "order-confirmed", library: "hsk" },
          position: 6,
          disabled: !0,
          atShow: null,
          atHide: null
        },
        userInfo: {
          component: Xt(s6),
          props: {},
          displayName: "Daten Eingeben",
          icon: { name: "user", library: "hsk" },
          position: 3,
          disabled: !1,
          atShow: null,
          atHide: null
        },
        userInfoMulti: {
          component: Xt(z4),
          props: {},
          displayName: "Daten Eingeben (Multi)",
          icon: { name: "user", library: "hsk" },
          position: 4,
          disabled: !1,
          atShow: null,
          atHide: null
        }
      }
    });
    function w(b) {
      (b == null ? void 0 : b.detail.name) === "confirm" && (g.tabs.orderComplete.disabled = !1);
    }
    return yo(async () => {
      await u.getAdressStructure();
    }), (b, x) => (H(), yt(D6, {
      tabs: g.tabs,
      onTabChange: w
    }, null, 8, ["tabs"]));
  }
}, T6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: B6
}, Symbol.toStringTag, { value: "Module" })), I6 = Ye({
  props: {},
  components: {},
  setup(c, u) {
    const g = e0();
    return { state: me({}), route: g };
  }
}), P6 = { class: "home" };
function O6(c, u, g, w, b, x) {
  return H(), G("div", P6, "View " + ge(c.route.path) + " is missing.", 1);
}
const R6 = /* @__PURE__ */ Ae(I6, [["render", O6]]), z6 = [
  {
    path: "/:pathMatch(.*)*",
    name: "view_missing",
    component: R6
  },
  {
    path: "/shop/category/:identifier",
    name: "CategoryView",
    component: () => Promise.resolve().then(() => X3)
  },
  {
    path: "/shop/item/:item",
    name: "itemView",
    component: () => Promise.resolve().then(() => L3)
  },
  {
    path: "/shop/cart/view",
    name: "CartView",
    component: () => Promise.resolve().then(() => fB)
  },
  {
    path: "/shop/order/",
    name: "OrderView",
    component: () => Promise.resolve().then(() => T6)
  },
  {
    path: "/shop/order/confirm",
    name: "ConfirmView",
    component: () => Promise.resolve().then(() => DP)
  }
];
function q6(c, u = !1) {
  let g = [];
  return u ? g = c : g = c.concat(z6), UT({
    // @ts-ignore
    history: tT("/"),
    routes: g
  });
}
export {
  Mw as CartView,
  H6 as CategoryList,
  w0 as CategoryView,
  v0 as ConfirmView,
  B6 as ExampleUsage,
  n0 as ItemCard,
  k0 as ItemView,
  p6 as OrderComplete,
  U6 as OrderTabHeader,
  D6 as OrderView,
  e4 as ShippingAdress,
  z4 as UserInfoMulti,
  s6 as UserInformation,
  q6 as createRouterInstance,
  Wt as useCartStore
};
