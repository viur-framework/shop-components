var W2 = Object.defineProperty;
var K2 = (h, C, _) => C in h ? W2(h, C, { enumerable: !0, configurable: !0, writable: !0, value: _ }) : h[C] = _;
var eb = (h, C, _) => K2(h, typeof C != "symbol" ? C + "" : C, _);
import { reactive as he, computed as ie, useCssVars as G2, openBlock as L, createBlock as Ue, Transition as Z2, withCtx as Cr, createElementBlock as $, createElementVNode as F, createCommentVNode as oe, pushScopeId as rt, popScopeId as st, Fragment as re, createTextVNode as ue, toDisplayString as Ae, onBeforeMount as jn, withDirectives as hn, vModelText as ri, ref as Dt, renderList as Je, createVNode as yr, unref as wt, Teleport as J2, resolveDynamicComponent as Nn, mergeProps as Y2, normalizeClass as yo, vShow as dl, defineComponent as Ve, inject as Se, onMounted as Qe, readonly as Q2, getCurrentScope as X2, onScopeDispose as ex, watchEffect as Sr, watch as Eo, getCurrentInstance as tx, resolveComponent as Ln, withModifiers as Er, shallowRef as Xt, renderSlot as Ab, provide as Ar, withKeys as al } from "vue";
import { Request as nx } from "@viur/vue-utils";
import { defineStore as hl } from "pinia";
import { ViURShopClient as ox } from "@viur/viur-shop-client";
import "vue-router";
const ke = (h, C) => {
  const _ = h.__vccOpts || h;
  for (const [O, D] of C)
    _[O] = D;
  return _;
}, gl = {
  props: {
    size: {
      type: String,
      default: "2"
    },
    active: {
      type: Boolean,
      default: !0
    },
    logo: {
      default: "logo-cube.svg",
      type: String
    },
    color: {
      default: "var(--sl-color-primary-500)",
      type: String
    }
  },
  setup(h, C) {
    const _ = he({
      trackWidth: ie(() => `${h.size / 30}rem`),
      outerSize: ie(() => `calc(${h.size}rem + ${_.trackWidth})`),
      spinnerSize: ie(() => `${h.size}rem`),
      logoSize: ie(() => `calc(${h.size}rem - ${_.trackWidth} * 10)`),
      shadow: ie(() => `0px 0px ${h.size / 6}rem 0 color-mix(in hsl, var(--sl-color-neutral-1000), 80% transparent)`)
    });
    return { state: _ };
  }
}, tb = () => {
  G2((h) => ({
    "93747d92": h.state.outerSize,
    "284424e5": h.state.shadow,
    "6485ca5e": h.state.logoSize,
    "5d833915": h.state.spinnerSize,
    d5b3feca: h.color,
    "2050b700": h.state.trackWidth
  }));
}, nb = gl.setup;
gl.setup = nb ? (h, C) => (tb(), nb(h, C)) : tb;
const ix = (h) => (rt("data-v-46c45785"), h = h(), st(), h), rx = {
  key: 0,
  class: "loading"
}, sx = /* @__PURE__ */ ix(() => /* @__PURE__ */ F("sl-spinner", { class: "loader" }, null, -1)), ax = { class: "logo" }, lx = ["src"];
function cx(h, C, _, O, D, M) {
  return L(), Ue(Z2, null, {
    default: Cr(() => [
      _.active ? (L(), $("div", rx, [
        sx,
        F("div", ax, [
          F("sl-icon", { src: _.logo }, null, 8, lx)
        ])
      ])) : oe("", !0)
    ]),
    _: 1
  });
}
const dx = /* @__PURE__ */ ke(gl, [["render", cx], ["__scopeId", "data-v-46c45785"]]), ai = hl("cartstore", () => {
  const h = new ox({
    host_url: window.location.origin === "http://localhost:8081" ? "http://localhost:8080" : window.location.origin
  }), C = he({
    basketRootNode: {},
    whishlistRootNodes: [],
    children: {},
    structure: { address: {}, cart: {} }
  });
  async function _() {
    await D();
  }
  async function O(x) {
    return await h.cart_list({ cart_key: x });
  }
  async function D() {
    (await h.cart_list()).forEach((v) => {
      v.is_root_node && (v.cart_type === "basket" ? C.basketRootNode = v : C.whishlistRootNodes.push(v));
    });
  }
  async function M(x, v) {
    let f = await h.article_add({
      article_key: x,
      parent_cart_key: v
    });
    console.log("addToCart", f);
  }
  async function k(x, v) {
    let f = await h.article_view({
      article_key: x,
      parent_cart_key: v
    });
    console.log("getArticleView", f);
  }
  async function S(x, v) {
    let f = await h.article_remove({
      article_key: x,
      parent_cart_key: v
    });
    console.log("remove Resp", f);
  }
  async function m(x, v, f) {
    let A = await h.article_update({
      article_key: x,
      parent_cart_key: v,
      quantity: f,
      quantity_mode: "replace"
    });
    console.log("update Resp", A);
  }
  async function E() {
    let x = await h.address_structure();
    C.structure.address = x.addSkel, console.log("adress add", C.structure.address);
  }
  return {
    state: C,
    addToCart: M,
    getArticleView: k,
    removeItem: S,
    updateItem: m,
    init: _,
    getAdressStructure: E,
    getChildren: O
  };
}), ux = {
  __name: "CartNode",
  props: {
    node: { type: Object, required: !0 }
  },
  setup(h) {
    return he({}), (C, _) => (L(), $(re, null, [
      ue(" cartnode "),
      F("pre", null, Ae(h.node.name), 1)
    ], 64));
  }
}, li = (h) => (rt("data-v-0e24135f"), h = h(), st(), h), hx = {
  horizontal: "",
  class: "viur-shop-cart-card"
}, gx = ["src"], mx = {
  class: "viur-shop-cart-card-header",
  slot: "header"
}, px = { class: "viur-shop-cart-card-headline headline" }, fx = { class: "viur-shop-cart-card-body-row" }, bx = { class: "viur-shop-cart-card-body-info" }, kx = /* @__PURE__ */ li(() => /* @__PURE__ */ F("div", { class: "viur-shop-cart-card-descr" }, [
  /* @__PURE__ */ ue(" Version: 900x900x2000 "),
  /* @__PURE__ */ F("br"),
  /* @__PURE__ */ ue(" Farbe: Chromoptik "),
  /* @__PURE__ */ F("br"),
  /* @__PURE__ */ ue(" Glasart: Klar hell mit Edelglasbeschichtung"),
  /* @__PURE__ */ F("br"),
  /* @__PURE__ */ ue(" Anschlag: Beidseitig variabel"),
  /* @__PURE__ */ F("br"),
  /* @__PURE__ */ ue(" Griff: Stangengriff Exklusiv (56) ")
], -1)), wx = { class: "viur-shop-cart-card-body-footer" }, Ax = /* @__PURE__ */ li(() => /* @__PURE__ */ F("sl-button", {
  size: "small",
  outline: "",
  class: "viur-shop-cart-card-add-to-favourites-btn",
  variant: "primary",
  title: "Add to favourites"
}, [
  /* @__PURE__ */ F("sl-icon", {
    name: "heart",
    slot: "prefix"
  })
], -1)), _x = /* @__PURE__ */ li(() => /* @__PURE__ */ F("sl-icon", {
  name: "trash",
  slot: "prefix"
}, null, -1)), vx = [
  _x
], Cx = { class: "viur-shop-cart-card-body-amount" }, yx = {
  class: "viur-shop-cart-card-price-wrap",
  slot: "footer"
}, Ex = /* @__PURE__ */ li(() => /* @__PURE__ */ F("div", { class: "viur-shop-cart-card-price-label" }, "Preis", -1)), xx = { class: "viur-shop-cart-card-price" }, Sx = /* @__PURE__ */ li(() => /* @__PURE__ */ F("div", { class: "viur-shop-cart-card-small-print" }, "Brutto / Stk.", -1)), Dx = {
  __name: "CartLeaf",
  props: {
    leaf: { type: Object, required: !0 },
    node: { type: Object, required: !0 }
  },
  emits: ["updateItem", "removeItem"],
  setup(h, { emit: C }) {
    const _ = h, O = C, D = he({
      leaf: {}
    });
    function M(m) {
      return m !== void 0 ? nx.downloadUrlFor(m) : "https://images.unsplash.com/photo-1559209172-0ff8f6d49ff7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=80";
    }
    function k(m, E, x, v) {
      O("updateItem", {
        item: m,
        articleKey: E,
        node: x,
        quantity: v
      });
    }
    function S(m, E, x) {
      O("removeItem", { item: m, articleKey: E, node: x });
    }
    return jn(() => {
      D.leaf = _.leaf;
    }), (m, E) => (L(), $(re, null, [
      ue(" cartleafe "),
      F("sl-card", hx, [
        F("img", {
          class: "viur-shop-cart-card-img",
          slot: "image",
          src: M(D.leaf.shop_image ? D.leaf.shop_image : void 0)
        }, null, 8, gx),
        F("div", mx, [
          F("h4", px, Ae(D.leaf.shop_name) + " | " + Ae(h.leaf.shop_art_no_or_gtin), 1)
        ]),
        F("div", fx, [
          F("div", bx, [
            kx,
            F("div", wx, [
              Ax,
              F("sl-button", {
                size: "small",
                outline: "",
                class: "viur-shop-cart-card-delete-btn",
                variant: "primary",
                title: "Remove from cart",
                onClick: E[0] || (E[0] = (x) => S(D.leaf, D.leaf.article.dest.key, h.node))
              }, vx)
            ])
          ]),
          F("div", Cx, [
            hn(F("sl-input", {
              class: "amount-input",
              type: "number",
              label: "Anzahl",
              placeholder: "Number",
              min: "0",
              "onUpdate:modelValue": E[1] || (E[1] = (x) => D.leaf.quantity = x),
              onInput: E[2] || (E[2] = (x) => k(
                D.leaf,
                D.leaf.article.dest.key,
                h.node,
                D.leaf.quantity
              ))
            }, null, 544), [
              [ri, D.leaf.quantity]
            ])
          ]),
          F("div", yx, [
            Ex,
            F("div", xx, Ae(D.leaf.price.retail) + " € ", 1),
            Sx
          ])
        ])
      ])
    ], 64));
  }
}, Bx = /* @__PURE__ */ ke(Dx, [["__scopeId", "data-v-0e24135f"]]), Lt = (h) => (rt("data-v-39d35665"), h = h(), st(), h), Tx = { key: 0 }, Ix = /* @__PURE__ */ Lt(() => /* @__PURE__ */ F("p", null, "Möchten Sie den Artikel wirklich aus dem Warenkorb entfernen?", -1)), Px = {
  class: "footer-wrap",
  slot: "footer"
}, Rx = { key: 0 }, Ox = /* @__PURE__ */ Lt(() => /* @__PURE__ */ F("h2", { class: "viur-shop-cart-sidebar-headline headline" }, "Zusammenfassung", -1)), zx = /* @__PURE__ */ Lt(() => /* @__PURE__ */ F("br", null, null, -1)), Mx = /* @__PURE__ */ Lt(() => /* @__PURE__ */ F("sl-input", { label: "Rabattcode eingeben" }, null, -1)), Fx = /* @__PURE__ */ Lt(() => /* @__PURE__ */ F("br", null, null, -1)), Nx = { class: "viur-shop-cart-sidebar-info-line" }, Vx = /* @__PURE__ */ Lt(() => /* @__PURE__ */ F("span", null, "Zwischensumme", -1)), Lx = /* @__PURE__ */ Lt(() => /* @__PURE__ */ F("div", { class: "viur-shop-cart-sidebar-info-line" }, [
  /* @__PURE__ */ F("span", null, "Rabatt"),
  /* @__PURE__ */ ue(" 0 € ")
], -1)), jx = /* @__PURE__ */ Lt(() => /* @__PURE__ */ F("div", { class: "viur-shop-cart-sidebar-info-line" }, [
  /* @__PURE__ */ F("span", null, "Versandkosten"),
  /* @__PURE__ */ ue(" 0 € ")
], -1)), $x = { class: "viur-shop-cart-sidebar-info-line total" }, Hx = /* @__PURE__ */ Lt(() => /* @__PURE__ */ F("span", null, "Gesamt:", -1)), qx = /* @__PURE__ */ Lt(() => /* @__PURE__ */ F("div", { class: "viur-shop-cart-sidebar-btn-wrap" }, [
  /* @__PURE__ */ F("sl-button", {
    variant: "info",
    size: "small"
  }, " Jetzt Bestellen "),
  /* @__PURE__ */ F("sl-button", {
    size: "small",
    variant: "primary"
  }, [
    /* @__PURE__ */ F("sl-icon", {
      name: "paypal",
      slot: "prefix"
    }),
    /* @__PURE__ */ ue(" Paypal ")
  ])
], -1)), Ux = {
  __name: "CartView",
  props: {
    mode: { type: String, default: "basket" },
    cartKey: { type: String, required: !0 },
    sidebar: { type: Boolean, default: !0 }
  },
  setup(h) {
    const C = h, _ = ai(), O = Dt(null), D = he({
      itemsIsInit: ie(() => !0),
      images: {},
      currentItem: {},
      currentNode: {},
      nodes: [],
      leaves: {}
    });
    ie(() => C.mode === "basket" ? _.state.basket : C.cartKey);
    async function M() {
      await _.updateItem(
        D.currentItem.article.dest.key,
        D.currentNode.key,
        0
      ), await E(), O.value.hide();
    }
    async function k(v) {
      console.log("updateItem :", v), v.quantity === 0 ? (O.value.show(), D.currentItem = v.item, D.currentNode = v.node) : (await _.updateItem(v.articleKey, v.node.key, v.quantity), await _.init());
    }
    function S(v) {
      console.log("removeItem :", v), O.value.show(), D.currentItem = v.item, D.currentNode = v.node;
    }
    async function m() {
      D.leaves[D.currentNode.key].forEach((v) => {
        v.key === D.currentItem.key && (v.quantity = 1);
      }), D.currentItem = {}, D.currentNode = {};
    }
    async function E() {
      D.nodes = [], D.leaves = {}, await _.init(), await x();
    }
    async function x(v = C.cartKey) {
      console.log("debug getChildren parentKey from comp: ", v);
      const f = await _.getChildren(v);
      console.log("getChildren children: ", f), f.forEach(async (A) => {
        A.skel_type === "node" ? (D.nodes.push(A), await x(A.key)) : (Object.keys(D.leaves).includes(v) || (D.leaves[v] = []), D.leaves[v].push(A));
      });
    }
    return jn(async () => {
      await _.init(), await x(), C.mode === "basket" && D.nodes.push(_.state.basketRootNode), console.log("state.nodes test", D.nodes), console.log("state.leaves", D.leaves);
    }), (v, f) => h.cartKey.length ? (L(), $(re, { key: 1 }, [
      F("sl-dialog", {
        ref_key: "confirm",
        ref: O,
        onSlHide: m
      }, [
        Ix,
        F("div", Px, [
          F("sl-button", {
            variant: "danger",
            onClick: f[0] || (f[0] = (A) => O.value.hide()),
            size: "medium"
          }, " Abbrechen "),
          F("sl-button", {
            variant: "success",
            onClick: M,
            size: "medium"
          }, " Aus Warenkorb entfernen ")
        ])
      ], 544),
      (L(!0), $(re, null, Je(D.nodes, (A) => (L(), $("div", null, [
        Object.keys(D.leaves).includes(A.key) ? (L(), $(re, { key: 0 }, [
          yr(ux, { node: A }, null, 8, ["node"]),
          (L(!0), $(re, null, Je(D.leaves[A.key], (P) => (L(), Ue(Bx, {
            key: P.key,
            leaf: P,
            node: A,
            onRemoveItem: S,
            onUpdateItem: k
          }, null, 8, ["leaf", "node"]))), 128))
        ], 64)) : oe("", !0)
      ]))), 256)),
      h.sidebar ? (L(), $("div", Rx, [
        Ox,
        zx,
        Mx,
        Fx,
        F("div", Nx, [
          Vx,
          ue(" --> " + Ae(h.mode === "basket" ? wt(_).state.basketRootNode.total : wt(_).state.whishlistRootNodes[h.cartKey].total) + " € ", 1)
        ]),
        Lx,
        jx,
        F("div", $x, [
          Hx,
          ue(" " + Ae(h.mode === "basket" ? wt(_).state.basketRootNode.total : wt(_).state.whishlistRootNodes[h.cartKey].total) + " € ", 1)
        ]),
        qx
      ])) : oe("", !0)
    ], 64)) : (L(), $("sl-spinner", Tx));
  }
}, _b = /* @__PURE__ */ ke(Ux, [["__scopeId", "data-v-39d35665"]]), gn = (h) => (rt("data-v-b7b745be"), h = h(), st(), h), Wx = {
  key: 1,
  class: "list"
}, Kx = /* @__PURE__ */ gn(() => /* @__PURE__ */ F("h2", { class: "viur-shop-cart-headline headline" }, "Bestellung prüfen", -1)), Gx = /* @__PURE__ */ gn(() => /* @__PURE__ */ F("br", null, null, -1)), Zx = /* @__PURE__ */ gn(() => /* @__PURE__ */ F("div", { class: "viur-shop-cart-address-wrap" }, [
  /* @__PURE__ */ F("div", { class: "viur-shop-cart-address" }, [
    /* @__PURE__ */ F("div", { class: "viur-shop-cart-address-headline" }, [
      /* @__PURE__ */ ue(" Versandadresse "),
      /* @__PURE__ */ F("sl-button", {
        outline: "",
        size: "small"
      }, [
        /* @__PURE__ */ F("sl-icon", {
          name: "pencil",
          slot: "prefix"
        })
      ])
    ]),
    /* @__PURE__ */ ue(" Roland Brose"),
    /* @__PURE__ */ F("br"),
    /* @__PURE__ */ ue(" Speicherstraße 33"),
    /* @__PURE__ */ F("br"),
    /* @__PURE__ */ ue(" 44147 Dortmund, DE"),
    /* @__PURE__ */ F("br"),
    /* @__PURE__ */ F("br"),
    /* @__PURE__ */ ue(" rb@mausbrand.de"),
    /* @__PURE__ */ F("br"),
    /* @__PURE__ */ ue(" 0231 21 34 68 90 ")
  ]),
  /* @__PURE__ */ F("div", { class: "viur-shop-cart-address" }, [
    /* @__PURE__ */ F("div", { class: "viur-shop-cart-address-headline" }, [
      /* @__PURE__ */ ue(" Rechnungsadresse "),
      /* @__PURE__ */ F("sl-button", {
        outline: "",
        size: "small"
      }, [
        /* @__PURE__ */ F("sl-icon", {
          name: "pencil",
          slot: "prefix"
        })
      ])
    ]),
    /* @__PURE__ */ ue(" Roland Brose"),
    /* @__PURE__ */ F("br"),
    /* @__PURE__ */ ue(" Speicherstraße 33"),
    /* @__PURE__ */ F("br"),
    /* @__PURE__ */ ue(" 44147 Dortmund, DE"),
    /* @__PURE__ */ F("br"),
    /* @__PURE__ */ F("br"),
    /* @__PURE__ */ ue(" rb@mausbrand.de"),
    /* @__PURE__ */ F("br"),
    /* @__PURE__ */ ue(" 0231 21 34 68 90 ")
  ])
], -1)), Jx = /* @__PURE__ */ gn(() => /* @__PURE__ */ F("div", { class: "viur-shop-cart-payment" }, [
  /* @__PURE__ */ F("div", { class: "viur-shop-cart-payment-method" }, [
    /* @__PURE__ */ F("span", null, "Zahlungsmethode:"),
    /* @__PURE__ */ ue(" Paypal ")
  ]),
  /* @__PURE__ */ F("sl-button", {
    outline: "",
    size: "small"
  }, [
    /* @__PURE__ */ F("sl-icon", {
      name: "pencil",
      slot: "prefix"
    })
  ])
], -1)), Yx = /* @__PURE__ */ gn(() => /* @__PURE__ */ F("h2", { class: "viur-shop-cart-headline headline" }, "Warenkorb", -1)), Qx = /* @__PURE__ */ gn(() => /* @__PURE__ */ F("br", null, null, -1)), Xx = /* @__PURE__ */ gn(() => /* @__PURE__ */ F("h2", { class: "viur-shop-cart-sidebar-headline headline" }, "Jetzt Bestellen", -1)), e5 = /* @__PURE__ */ gn(() => /* @__PURE__ */ F("br", null, null, -1)), t5 = { class: "viur-shop-cart-sidebar-btn-wrap" }, n5 = ["variant", "disabled"], o5 = {
  __name: "ConfirmView",
  setup(h) {
    const C = ai(), _ = he({
      cartIsInit: ie(() => !0),
      itemsIsInit: ie(() => {
        var D;
        return !!((D = C.state) != null && D.carts[C.state.basket].items);
      }),
      images: {},
      showOrderButton: !1
    });
    function O(D) {
      D.target.checked && (_.showOrderButton = !0), D.target.checked || (_.showOrderButton = !1);
    }
    return jn(async () => {
      await C.init();
    }), (D, M) => _.cartIsInit ? (L(), $("div", Wx, [
      Kx,
      Gx,
      Zx,
      Jx,
      Yx,
      Qx,
      (L(), Ue(J2, { to: "#order_sidebar" }, [
        Xx,
        e5,
        F("sl-checkbox", { onSlChange: O }, " Ich akzeptiere die geltenden AGBs und Datenschutzbestimmungen ", 32),
        F("div", t5, [
          F("sl-button", {
            variant: _.showOrderButton ? "info" : "disabled",
            size: "small",
            disabled: !_.showOrderButton
          }, " Zahlungspflichtig bestellen ", 8, n5)
        ])
      ]))
    ])) : (L(), Ue(dx, { key: 0 }));
  }
}, vb = /* @__PURE__ */ ke(o5, [["__scopeId", "data-v-b7b745be"]]), i5 = (h) => (rt("data-v-61488015"), h = h(), st(), h), r5 = { class: "bind viur-shop-wrap" }, s5 = ["panel", "disabled"], a5 = { class: "viur-shop-order-step" }, l5 = ["name", "library"], c5 = { class: "viur-shop-order-status-text" }, d5 = {
  key: 0,
  name: "chevron-right",
  class: "viur-shop-order-tab-check"
}, u5 = ["name"], h5 = ["onClick"], g5 = ["onClick"], m5 = /* @__PURE__ */ i5(() => /* @__PURE__ */ F("div", {
  class: "viur-shop-sidebar",
  id: "order_sidebar"
}, null, -1)), p5 = {
  __name: "OrderView",
  props: {
    tabs: {
      type: Object,
      required: !0
    }
  },
  emits: ["tabChange"],
  setup(h, { emit: C }) {
    const _ = h, O = C, D = he({
      tabNames: ie(() => k(_.tabs)),
      isFirstTab: (x) => x === 0
    }), M = Dt(null);
    function k(x) {
      let v = [], f = [];
      for (const A in x)
        x[A].position ? v.push([A, x[A].position]) : v.push([A, 0]);
      return v.sort((A, P) => A[1] - P[1]), v.forEach((A) => {
        f.push(A[0]);
      }), f;
    }
    function S(x) {
      O("tabChange", x);
    }
    function m(x) {
      M.value.show(x);
    }
    function E(x) {
      M.value.show(x);
    }
    return (x, v) => (L(), $("div", r5, [
      F("sl-tab-group", {
        class: "viur-shop-order-tab",
        noScrollControls: "",
        onSlTabShow: S,
        ref_key: "tabGroup",
        ref: M
      }, [
        (L(!0), $(re, null, Je(D.tabNames, (f, A) => (L(), $("sl-tab", {
          slot: "nav",
          panel: f,
          key: f,
          disabled: h.tabs[f].disabled
        }, [
          F("div", a5, [
            F("sl-icon", {
              name: h.tabs[f].icon.name,
              library: h.tabs[f].icon.library
            }, null, 8, l5),
            F("div", c5, Ae(A + 1) + ". " + Ae(h.tabs[f].displayName), 1)
          ]),
          A < D.tabNames.length - 1 ? (L(), $("sl-icon", d5)) : oe("", !0)
        ], 8, s5))), 128)),
        (L(!0), $(re, null, Je(D.tabNames, (f, A) => (L(), $("sl-tab-panel", {
          name: f,
          key: f
        }, [
          (L(), Ue(Nn(h.tabs[f].component), Y2({ ref_for: !0 }, h.tabs[f].props ? h.tabs[f].props : ""), null, 16)),
          A !== D.tabNames.length - 1 ? (L(), $("div", {
            key: 0,
            class: yo(["viur-shop-form-footer", { "flex-end": D.isFirstTab(A) }])
          }, [
            hn(F("sl-button", {
              type: "submit",
              onClick: (P) => m(D.tabNames[A - 1])
            }, " Zurück ", 8, h5), [
              [dl, A !== 0]
            ]),
            F("sl-button", {
              type: "submit",
              variant: "primary",
              onClick: (P) => E(D.tabNames[A + 1])
            }, " Weiter ", 8, g5)
          ], 2)) : oe("", !0)
        ], 8, u5))), 128))
      ], 544),
      m5
    ]));
  }
}, f5 = /* @__PURE__ */ ke(p5, [["__scopeId", "data-v-61488015"]]), b5 = {}, Dr = (h) => (rt("data-v-36ccc280"), h = h(), st(), h), k5 = { class: "bind" }, w5 = /* @__PURE__ */ Dr(() => /* @__PURE__ */ F("h1", { class: "headline" }, "Vielen Dank für Ihre Bestellung", -1)), A5 = /* @__PURE__ */ Dr(() => /* @__PURE__ */ F("br", null, null, -1)), _5 = /* @__PURE__ */ Dr(() => /* @__PURE__ */ F("p", { class: "paragraph" }, [
  /* @__PURE__ */ F("strong", null, "Ihre Bestellnummer:"),
  /* @__PURE__ */ ue(" 123345670 ")
], -1)), v5 = /* @__PURE__ */ Dr(() => /* @__PURE__ */ F("p", { class: "paragraph" }, [
  /* @__PURE__ */ ue(" Wir haben Ihre Bestellung erhalten und werden diese schenllstmöglich bearbeiten."),
  /* @__PURE__ */ F("br"),
  /* @__PURE__ */ ue(" Sie erhalten in wenigen Minuten eine Bestätigung per E-Mail. "),
  /* @__PURE__ */ F("div", { class: "btn-wrap" }, [
    /* @__PURE__ */ F("sl-button", { size: "medium" }, " Zur Startseite "),
    /* @__PURE__ */ F("sl-button", {
      variant: "primary",
      size: "medium"
    }, " Weiter Einkaufen ")
  ])
], -1)), C5 = [
  w5,
  A5,
  _5,
  v5
];
function y5(h, C) {
  return L(), $("div", k5, C5);
}
const E5 = /* @__PURE__ */ ke(b5, [["render", y5], ["__scopeId", "data-v-36ccc280"]]), x5 = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({});
    function D(M) {
      C.emit("change", h.name, M.target.value, h.lang, h.index);
    }
    return Qe(() => {
      C.emit("change", h.name, h.value, h.lang, h.index);
    }), {
      state: O,
      boneState: _,
      changeEvent: D
    };
  }
}), S5 = ["disabled", "value"], D5 = ["disabled", "value"];
function B5(h, C, _, O, D, M) {
  var k, S;
  return h.boneState.bonestructure.type === "raw.json" ? (L(), $("sl-textarea", {
    key: 0,
    disabled: (k = h.boneState) == null ? void 0 : k.readonly,
    value: JSON.stringify(h.value),
    onInput: C[0] || (C[0] = (...m) => h.changeEvent && h.changeEvent(...m))
  }, null, 40, S5)) : (L(), $("sl-textarea", {
    key: 1,
    disabled: (S = h.boneState) == null ? void 0 : S.readonly,
    value: h.value,
    onInput: C[1] || (C[1] = (...m) => h.changeEvent && h.changeEvent(...m))
  }, null, 40, D5));
}
const ul = /* @__PURE__ */ ke(x5, [["render", B5], ["__scopeId", "data-v-0ebe5f0b"]]), T5 = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = he({});
    function O(D) {
      C.emit("change", h.name, D.target.value, h.lang, h.index);
    }
    return Qe(() => {
      C.emit("change", h.name, h.value, h.lang, h.index);
    }), {
      state: _,
      changeEvent: O
    };
  }
}), I5 = ["value"];
function P5(h, C, _, O, D, M) {
  return L(), $("sl-input", {
    disabled: "",
    value: h.value,
    onSlChange: C[0] || (C[0] = (...k) => h.changeEvent && h.changeEvent(...k))
  }, null, 40, I5);
}
const ob = /* @__PURE__ */ ke(T5, [["render", P5], ["__scopeId", "data-v-b45a1311"]]);
function R5(h) {
  return X2() ? (ex(h), !0) : !1;
}
function O5(h) {
  return typeof h == "function" ? h() : wt(h);
}
const z5 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
function Br(h, C, _ = {}) {
  const {
    immediate: O = !0
  } = _, D = Dt(!1);
  let M = null;
  function k() {
    M && (clearTimeout(M), M = null);
  }
  function S() {
    D.value = !1, k();
  }
  function m(...E) {
    k(), D.value = !0, M = setTimeout(() => {
      D.value = !1, M = null, h(...E);
    }, O5(C));
  }
  return O && (D.value = !0, z5 && m()), R5(S), {
    isPending: Q2(D),
    start: m,
    stop: S
  };
}
class M5 {
  static objectEmpty(C) {
    return Object.keys(C).length === 0 && C.constructor === Object;
  }
  static getDescr(C, _) {
    try {
      return C.values.filter((O) => O[0] === _)[0][1];
    } catch {
      return "-";
    }
  }
  static unescape(C) {
    return C || (C = ""), String(C).replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&#40;/g, "(").replace(/&#41;/g, ")").replace(/&#61;/g, "=").replace(/&#039;/g, "'").replace(/&#040;/g, "(").replace(/&#041;/g, ")").replace(/&#061;/g, "=");
  }
  static formatString(C, _) {
    function O(k) {
      let S = [], m = [], E = /\$\((.*?)\)/g;
      for (; m; ) {
        if (m = E.exec(k), !m) {
          m = !1;
          continue;
        }
        S.push(m[1]);
      }
      return S;
    }
    let D = O(C), M = [];
    Array.isArray(_) || (_ = [_]);
    for (let k of _) {
      let S = C;
      for (let m of D) {
        let E = m.split("."), x = k;
        for (let v of E)
          x && x !== "-" && v in x && x[v] ? x = x[v] : x = "-";
        x = this.unescape(x), S = S.replace("$(" + m + ")", x);
      }
      M.push(S);
    }
    return M.join(", ");
  }
}
const F5 = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({
      value: ie(() => h.value)
    }), D = Dt(null);
    function M(k) {
      C.emit("change", h.name, k.target.value, h.lang, h.index);
    }
    return Sr(() => {
      if (h.autofocus && D.value && D.value !== null && D !== null) {
        const { start: k } = Br(() => {
          D.value.focus();
        }, 600);
        k();
      }
    }), Qe(() => {
      C.emit("change", h.name, h.value, h.lang, h.index);
    }), {
      state: O,
      Utils: M5,
      boneState: _,
      changeEvent: M,
      stringBone: D
    };
  }
}), N5 = ["disabled", "value", "required"];
function V5(h, C, _, O, D, M) {
  return L(), $("sl-input", {
    ref: "stringBone",
    disabled: h.boneState.readonly,
    value: h.Utils.unescape(h.value),
    required: h.boneState.bonestructure.required,
    onSlChange: C[0] || (C[0] = (...k) => h.changeEvent && h.changeEvent(...k)),
    onKeyup: C[1] || (C[1] = (...k) => h.changeEvent && h.changeEvent(...k))
  }, null, 40, N5);
}
const ib = /* @__PURE__ */ ke(F5, [["render", V5], ["__scopeId", "data-v-1ccbacc0"]]), L5 = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({}), D = Dt(null);
    function M(k) {
      C.emit("change", h.name, k.target.value, h.lang, h.index);
    }
    return Sr(() => {
      if (h.autofocus && D.value && D.value !== null && D !== null) {
        const { start: k } = Br(() => {
          D.value.focus();
        }, 600);
        k();
      }
    }), Qe(() => {
      C.emit("change", h.name, h.value, h.lang, h.index);
    }), {
      state: O,
      boneState: _,
      changeEvent: M,
      emailBone: D
    };
  }
}), j5 = ["disabled", "value"];
function $5(h, C, _, O, D, M) {
  return L(), $("sl-input", {
    ref: "emailBone",
    disabled: h.boneState.readonly,
    type: "email",
    value: h.value,
    onSlChange: C[0] || (C[0] = (...k) => h.changeEvent && h.changeEvent(...k))
  }, null, 40, j5);
}
const rb = /* @__PURE__ */ ke(L5, [["render", $5], ["__scopeId", "data-v-4328e024"]]), H5 = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({
      value: ie(() => {
        var k;
        let M = h.value;
        return _.bonestructure.time ? M = (k = h.value) == null ? void 0 : k.split("+")[0] : h.value && (M = new Date(h.value).toISOString().substr(0, 10)), M;
      }),
      typeString: ie(() => {
        let M = "datetime-local";
        return _.bonestructure.time || (M = "date"), M;
      })
    });
    function D(M) {
      C.emit("change", h.name, M.target.value, h.lang, h.index);
    }
    return Qe(() => {
      C.emit("change", h.name, h.value, h.lang, h.index);
    }), {
      state: O,
      boneState: _,
      changeEvent: D
    };
  }
}), q5 = ["disabled", "type", "value"];
function U5(h, C, _, O, D, M) {
  return L(), $("sl-input", {
    disabled: h.boneState.readonly,
    type: h.state.typeString,
    value: h.state.value,
    onSlChange: C[0] || (C[0] = (...k) => h.changeEvent && h.changeEvent(...k))
  }, null, 40, q5);
}
const sb = /* @__PURE__ */ ke(H5, [["render", U5], ["__scopeId", "data-v-f1b8af8c"]]), W5 = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: null,
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({
      value: ie(() => {
        let k = h.value;
        return Array.isArray(h.value) ? (_.bonestructure.values instanceof Array ? k = k.filter((S) => _.bonestructure.values.map((m) => m[0].toString()).includes(S)) : k = k.filter(
          (S) => Object.keys(_.bonestructure.values).map((m) => m.toString()).includes(S)
        ), k.map((S) => S.toString())) : h.value ? h.value.toString() : "";
      })
    });
    function D() {
      if (Array.isArray(_.bonestructure.values))
        return _.bonestructure.values;
      {
        let k = [];
        for (const [S, m] of Object.entries(_.bonestructure.values))
          k.push([S, m]);
        return k;
      }
    }
    function M(k) {
      C.emit("change", h.name, k.target.value, h.lang, h.index), W;
    }
    return Qe(() => {
      C.emit("change", h.name, O.value, h.lang, h.index);
    }), {
      state: O,
      boneState: _,
      changeEvent: M,
      convertObjToList: D
    };
  }
}), K5 = ["disabled", "value", "multiple"], G5 = ["value"];
function Z5(h, C, _, O, D, M) {
  return L(), $("sl-select", {
    disabled: h.boneState.readonly,
    value: h.state.value,
    hoist: "",
    multiple: h.boneState.bonestructure.multiple,
    "max-options-visible": "0",
    clearable: "",
    onSlChange: C[0] || (C[0] = (...k) => h.changeEvent && h.changeEvent(...k))
  }, [
    (L(!0), $(re, null, Je(h.convertObjToList(), (k) => (L(), $("sl-option", {
      key: k[0],
      value: k[0]
    }, Ae(k[1]), 9, G5))), 128))
  ], 40, K5);
}
const ab = /* @__PURE__ */ ke(W5, [["render", Z5], ["__scopeId", "data-v-5a38b97f"]]), J5 = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({
      value: ie(() => ![!1, null, void 0, ""].includes(h.value))
    });
    function D(M) {
      C.emit("change", h.name, M.target.checked, h.lang, h.index);
    }
    return Qe(() => {
      let M = h.value;
      M || (M = !1), C.emit("change", h.name, M, h.lang, h.index);
    }), {
      state: O,
      boneState: _,
      changeEvent: D
    };
  }
}), Y5 = ["disabled", "checked"];
function Q5(h, C, _, O, D, M) {
  return L(), $("sl-switch", {
    disabled: h.boneState.readonly,
    checked: h.state.value,
    onSlChange: C[0] || (C[0] = (...k) => h.changeEvent && h.changeEvent(...k))
  }, null, 40, Y5);
}
const lb = /* @__PURE__ */ ke(J5, [["render", Q5], ["__scopeId", "data-v-363598c8"]]), X5 = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({
      value1: "",
      value2: null,
      equal: !1,
      passwordInfo: [],
      requiredPasswordInfo: []
    }), D = Dt(null);
    function M(S) {
      O.value1 === O.value2 ? O.equal = !0 : O.equal = !1, k(O.value1), O.requiredPasswordInfo.length === 0 && O.passwordInfo.length - O.requiredPasswordInfo.length <= _.bonestructure.test_threshold ? C.emit("change", h.name, O.value1, h.lang, h.index, !0) : C.emit("change", h.name, O.value1, h.lang, h.index, !1);
    }
    Qe(() => {
      C.emit("change", h.name, h.value, h.lang, h.index);
    });
    function k(S) {
      O.passwordInfo = [], O.requiredPasswordInfo = [];
      for (const m of _.bonestructure.tests)
        new RegExp(m[0]).test(S) || (m[2] ? O.requiredPasswordInfo.push(m[1]) : O.passwordInfo.push(m[1]));
      O.equal || O.requiredPasswordInfo.push("Die eingegebenen Passwörter stimmen nicht überein."), O.value1 || O.requiredPasswordInfo.push("Das eingegebene Passwort ist leer.");
    }
    return Sr(() => {
      if (h.autofocus && D.value && D.value !== null && D !== null) {
        const { start: S } = Br(() => {
          D.value.focus();
        }, 600);
        S();
      }
    }), Eo(
      () => h.value,
      (S, m) => {
        O.value1 = S;
      }
    ), {
      state: O,
      boneState: _,
      changeEvent: M,
      passwordBone: D
    };
  }
}), eS = ["disabled"], tS = ["name"], nS = ["name"], oS = { class: "errors" };
function iS(h, C, _, O, D, M) {
  return L(), $(re, null, [
    hn(F("sl-input", {
      ref: "passwordBone",
      "onUpdate:modelValue": C[0] || (C[0] = (k) => h.state.value1 = k),
      disabled: h.boneState.readonly,
      class: yo({ "has-check": !h.boneState.readonly }),
      type: "password",
      clearable: "",
      "password-toggle": "true",
      onSlChange: C[1] || (C[1] = (...k) => h.changeEvent && h.changeEvent(...k)),
      onSlClear: C[2] || (C[2] = (k) => h.state.value1 = ""),
      onKeyup: C[3] || (C[3] = (...k) => h.changeEvent && h.changeEvent(...k))
    }, [
      F("sl-icon", {
        slot: "suffix",
        name: h.state.equal && h.state.value1.length ? "check" : "x"
      }, null, 8, tS)
    ], 42, eS), [
      [ri, h.state.value1]
    ]),
    h.boneState.readonly ? oe("", !0) : hn((L(), $("sl-input", {
      key: 0,
      "onUpdate:modelValue": C[4] || (C[4] = (k) => h.state.value2 = k),
      class: "password-check",
      type: "password",
      clearable: "",
      "password-toggle": "true",
      onSlChange: C[5] || (C[5] = (...k) => h.changeEvent && h.changeEvent(...k)),
      onSlClear: C[6] || (C[6] = (k) => h.state.value2 = ""),
      onKeyup: C[7] || (C[7] = (...k) => h.changeEvent && h.changeEvent(...k))
    }, [
      F("sl-icon", {
        slot: "suffix",
        name: h.state.equal && h.state.value1.length ? "check" : "x"
      }, null, 8, nS)
    ], 544)), [
      [ri, h.state.value2]
    ]),
    F("ul", oS, [
      (L(!0), $(re, null, Je(h.state.passwordInfo, (k, S) => (L(), $("li", { key: S }, Ae(k), 1))), 128)),
      (L(!0), $(re, null, Je(h.state.requiredPasswordInfo, (k, S) => (L(), $("li", {
        key: S,
        class: "requiredInfo"
      }, Ae(k), 1))), 128))
    ])
  ], 64);
}
const cb = /* @__PURE__ */ ke(X5, [["render", iS], ["__scopeId", "data-v-0ccf18c0"]]), rS = Ve({
  props: {
    name: String,
    value: null,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({
      value: ie(() => h.value),
      structure: ie(() => k(_.bonestructure.using)),
      globalRegistration: !1,
      formGroups: ie(() => {
        var E, x;
        let S = { default: { name: "Allgemein", bones: [], groupVisible: !1, groupOpen: !0 } };
        for (const [v, f] of Object.entries(O.structure)) {
          let A = "default", P = O.structure[v], B = (E = O.value) == null ? void 0 : E[v];
          (x = f == null ? void 0 : f.params) != null && x.category && (A = f.params.category.toLowerCase()), Object.keys(S).includes(A) ? S[A].bones.push({
            boneName: v,
            boneStructure: P,
            boneValue: B
          }) : S[A] = {
            name: f.params.category,
            bones: [
              {
                boneName: v,
                boneStructure: P,
                boneValue: B
              }
            ]
          }, P.visible === !0 && (S[A].groupVisible = !0);
        }
        let m = {};
        return Object.keys(S).sort().forEach(function(v) {
          m[v] = S[v];
        }), m;
      })
    });
    function D(S) {
      C.emit("change", S);
    }
    Qe(() => {
      tx().appContext.components.Bone ? O.globalRegistration = !0 : O.globalRegistration = !1, C.emit("change", h.name, h.value, h.lang, h.index);
    });
    function M(S) {
      console.log(S);
    }
    function k(S) {
      if (Array.isArray(S)) {
        let m = {};
        for (const E in S)
          m[S[E][0]] = S[E][1];
        return m;
      } else
        return S;
    }
    return {
      state: O,
      boneState: _,
      getBoneWidget: Vn,
      structureToDict: k,
      changeEvent: D,
      updateValue: M
    };
  }
}), sS = {
  key: 0,
  open: "",
  variant: "danger"
}, aS = {
  key: 1,
  class: "form"
}, lS = ["summary", "open"];
function cS(h, C, _, O, D, M) {
  const k = Ln("bone");
  return h.state.globalRegistration ? (L(), $("div", aS, [
    (L(!0), $(re, null, Je(h.state.formGroups, (S, m) => hn((L(), $("sl-details", {
      key: m,
      summary: S.name,
      open: S.groupOpen
    }, [
      (L(!0), $(re, null, Je(S.bones, (E) => hn((L(), Ue(k, {
        key: E.name,
        is: h.getBoneWidget(h.state.structure[E.boneName].type),
        name: E.boneName,
        structure: h.state.structure,
        skel: h.state.value,
        errors: h.boneState.errors,
        readonly: h.boneState.bonestructure.readonly ? !0 : void 0,
        onChangeInternal: h.changeEvent
      }, null, 8, ["is", "name", "structure", "skel", "errors", "readonly", "onChangeInternal"])), [
        [dl, h.state.structure[E.boneName].visible]
      ])), 128))
    ], 8, lS)), [
      [dl, S.groupVisible]
    ])), 128))
  ])) : (L(), $("sl-alert", sS, " In Order to use this Bone register the bone component globally in your main file "));
}
const Cb = /* @__PURE__ */ ke(rS, [["render", cS], ["__scopeId", "data-v-e6fcfbca"]]), dS = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: null,
    index: Number,
    lang: String
  },
  components: { Wrapper_nested: Cb },
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({
      value: {},
      index: ie(() => h.index),
      lang: ie(() => h.lang)
    });
    function D(M) {
      var S;
      (S = O.value) != null && S[M.name] || (O.value ? O.value[M.name] = null : O.value = { [M.name]: null });
      let k = O.value[M.name];
      M.lang ? (k === null && (k = {}), Object.keys(k).includes(M.lang) && M.index !== null ? k[M.lang][M.index] = M.value : k[M.lang] = M.value) : M.index !== null ? (k === null && (k = []), k[M.index] = M.value) : k = M.value, O.value[M.name] = k, C.emit("change", h.name, O.value, h.lang, h.index, !0);
    }
    return Qe(() => {
      C.emit("change", h.name, h.value, h.lang, h.index);
    }), {
      state: O,
      boneState: _,
      changeEvent: D
    };
  }
});
function uS(h, C, _, O, D, M) {
  const k = Ln("Wrapper_nested");
  return L(), Ue(k, {
    value: h.value,
    name: h.name,
    index: h.state.index,
    disabled: h.boneState.bonestructure.readonly,
    onChange: h.changeEvent
  }, null, 8, ["value", "name", "index", "disabled", "onChange"]);
}
const db = /* @__PURE__ */ ke(dS, [["render", uS], ["__scopeId", "data-v-84a761ce"]]), hS = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({});
    function D(M) {
      C.emit("change", h.name, M.target.value, h.lang, h.index);
    }
    return Qe(() => {
      C.emit("change", h.name, h.value, h.lang, h.index);
    }), {
      state: O,
      boneState: _,
      changeEvent: D
    };
  }
}), gS = ["disabled", "value"];
function mS(h, C, _, O, D, M) {
  return L(), $("sl-color-picker", {
    disabled: h.boneState.readonly,
    value: h.value,
    onSlChange: C[0] || (C[0] = (...k) => h.changeEvent && h.changeEvent(...k))
  }, null, 40, gS);
}
const ub = /* @__PURE__ */ ke(hS, [["render", mS], ["__scopeId", "data-v-534b9149"]]), pS = Ve({
  inheritAttrs: !1,
  emits: { change: null },
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    autofocus: Boolean
  },
  components: {},
  setup(h, C) {
    const _ = Se("boneState"), O = he({
      minAmount: ie(() => _.bonestructure.minAmount),
      maxAmount: ie(() => _.bonestructure.maxAmount),
      precision: ie(() => {
        if (_.bonestructure.precision > 1)
          return parseFloat(`0.${"0".repeat(_.bonestructure.precision - 1)}1`);
      })
    }), D = Dt(null);
    function M(k) {
      C.emit("change", h.name, k.target.value, h.lang, h.index);
    }
    return Sr(() => {
      if (h.autofocus && D.value && D.value !== null && D !== null) {
        const { start: k } = Br(() => {
          D.value.focus();
        }, 600);
        k();
      }
    }), Qe(() => {
      C.emit("change", h.name, h.value, h.lang, h.index);
    }), {
      state: O,
      boneState: _,
      changeEvent: M,
      numericBone: D
    };
  }
}), fS = ["disabled", "value", "min", "max", "step"], bS = { class: "info" }, kS = { key: 0 }, wS = { key: 1 }, AS = { key: 2 };
function _S(h, C, _, O, D, M) {
  return L(), $(re, null, [
    F("sl-input", {
      ref: "numericBone",
      type: "number",
      disabled: h.boneState.readonly,
      value: h.value,
      min: h.state.minAmount,
      max: h.state.maxAmount,
      step: h.state.precision,
      onSlChange: C[0] || (C[0] = (...k) => h.changeEvent && h.changeEvent(...k)),
      onKeyup: C[1] || (C[1] = (...k) => h.changeEvent && h.changeEvent(...k))
    }, null, 40, fS),
    F("ul", bS, [
      h.state.minAmount !== -9223372036854776e3 && h.state.minAmount ? (L(), $("li", kS, Ae(h.$t("bones.numeric.min", { val: h.state.minAmount })), 1)) : oe("", !0),
      h.state.maxAmount !== 9223372036854776e3 && h.state.maxAmount ? (L(), $("li", wS, Ae(h.$t("bones.numeric.max", { val: h.state.maxAmount })), 1)) : oe("", !0),
      h.state.precision ? (L(), $("li", AS, Ae(h.$t("bones.numeric.precision", { val: h.boneState.bonestructure.precision })), 1)) : oe("", !0)
    ])
  ], 64);
}
const hb = /* @__PURE__ */ ke(pS, [["render", _S], ["__scopeId", "data-v-03d5b399"]]);
var Ye = { VITE_API_URL: "", BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
class _r extends Error {
  constructor(C, _, O, D) {
    super(O || _), arguments.length >= 4 && D && Object.assign(this, D), this.statusText = _, this.statusCode = C, this.response = D;
  }
}
let ll = null;
function Fn() {
  return ll || (ll = hl("requestStore", () => {
    const h = he({ sKeys: /* @__PURE__ */ new Set() });
    function C() {
      h.sKeys = /* @__PURE__ */ new Set();
    }
    return {
      state: h,
      $reset: C
    };
  })), ll();
}
class Be {
  static resetState() {
    Fn().$reset(), Fn().$dispose();
  }
  static buildUrl(C) {
    return C && !(C.startsWith("http://") || C.startsWith("https://") || C.startsWith("//")) && (C = window.location.origin + C), C;
  }
  static post(C, { dataObj: _ = null, callback: O = null, failedCallback: D = null, abortController: M = null, headers: k = null, mode: S = null } = {}) {
    function m() {
      if (_ instanceof FormData)
        return _;
      const x = new FormData();
      for (const v in _)
        if (Array.isArray(_[v]))
          for (let f of _[v])
            x.append(v, f);
        else
          x.append(v, _[v]);
      return x;
    }
    let E = si.post(Be.buildUrl(C), m(), null, k, M, S);
    return E.then(function(x) {
      O && O(x.data);
    }).catch(function(x) {
      D && D(x);
    }), E;
  }
  static async getBatchSkeys(C = 30, _ = Ye.VITE_DEFAULT_RENDERER || "json") {
    await Be.get(`/${_}/skey`, {
      dataObj: { amount: C }
    }).then(async (O) => {
      let D = await O.json();
      Array.isArray(D) || (D = [D]), Fn().state.sKeys = new Set(D);
    });
  }
  static async securePost(C, {
    dataObj: _ = null,
    callback: O = null,
    failedCallback: D = null,
    abortController: M = null,
    renderer: k = Ye.VITE_DEFAULT_RENDERER || "json",
    headers: S = null,
    mode: m = null,
    amount: E = 30
  } = {}) {
    let x = null;
    Fn().state.sKeys.size === 0 && await Be.getBatchSkeys(E);
    const v = [...Fn().state.sKeys][0];
    return _ instanceof FormData ? (_.append("skey", v), Fn().state.sKeys.delete(v)) : (_ || (_ = {}), _.skey = v, Fn().state.sKeys.delete(v)), x = Be.post(C, {
      dataObj: _,
      callback: O,
      abortController: M,
      headers: S,
      mode: m
    }), x;
  }
  static get(C, {
    dataObj: _ = null,
    callback: O = null,
    failedCallback: D = null,
    cached: M = !1,
    clearCache: k = !1,
    abortController: S = null,
    headers: m = null,
    mode: E = null,
    //          milli  sec  min  Std  Tage
    cacheTime: x = 1e3 * 60 * 60 * 24 * 1
  } = {}) {
    let v = si.get(Be.buildUrl(C), _, k, m, S, E);
    return v.then(function(f) {
      O && O(f.data);
    }).catch(function(f) {
      D && D(f);
    }), v;
  }
  static list(C, {
    dataObj: _ = null,
    callback: O = null,
    failedCallback: D = null,
    group: M = null,
    abortController: k = null,
    renderer: S = (Ye == null ? void 0 : Ye.VITE_DEFAULT_RENDERER) || "json"
  } = {}) {
    let m = `/${S}/${C}/list`;
    return M && (m += `/${M}`), Be.get(m, {
      dataObj: _,
      callback: O,
      failedCallback: D,
      abortController: k
    });
  }
  static getStructure(C, {
    dataObj: _ = null,
    callback: O = null,
    failedCallback: D = null,
    group: M = null,
    abortController: k = null,
    renderer: S = (Ye == null ? void 0 : Ye.VITE_DEFAULT_RENDERER) || "json"
  } = {}) {
    C = C.replace(/\//g, ".");
    let m = `/${S}/getStructure/${C}`;
    return M && (m += `/${M}`), Be.get(m, {
      dataObj: _,
      callback: O,
      failedCallback: D,
      abortController: k
    });
  }
  static view(C, _, {
    dataObj: O = null,
    callback: D = null,
    failedCallback: M = null,
    group: k = null,
    abortController: S = null,
    renderer: m = (Ye == null ? void 0 : Ye.VITE_DEFAULT_RENDERER) || "json"
  } = {}) {
    let E = `/${m}/${C}/view/${_}`;
    return k && (E = `/${m}/${C}/view/${k}/${_}`), Be.get(E, {
      dataObj: O,
      callback: D,
      failedCallback: M,
      abortController: S
    });
  }
  static add(C, {
    dataObj: _ = null,
    callback: O = null,
    failedCallback: D = null,
    group: M = null,
    abortController: k = null,
    renderer: S = (Ye == null ? void 0 : Ye.VITE_DEFAULT_RENDERER) || "json"
  } = {}) {
    let m = `/${S}/${C}/add`;
    return M && (m = `/${S}/${C}/add/${M}`), Be.securePost(m, {
      dataObj: _,
      callback: O,
      failedCallback: D,
      abortController: k
    });
  }
  static edit(C, _, {
    dataObj: O = null,
    callback: D = null,
    failedCallback: M = null,
    group: k = null,
    abortController: S = null,
    renderer: m = (Ye == null ? void 0 : Ye.VITE_DEFAULT_RENDERER) || "json"
  } = {}) {
    let E = `/${m}/${C}/edit/${_}`;
    return k && (E = `/${m}/${C}/edit/${k}/${_}`), Be.securePost(E, {
      dataObj: O,
      callback: D,
      failedCallback: M,
      abortController: S
    });
  }
  static delete(C, _, {
    dataObj: O = null,
    callback: D = null,
    failedCallback: M = null,
    group: k = null,
    abortController: S = null,
    renderer: m = (Ye == null ? void 0 : Ye.VITE_DEFAULT_RENDERER) || "json"
  } = {}) {
    let E = `/${m}/${C}/delete/${_}`;
    return k && (E = `/${m}/${C}/delete/${k}/${_}`), Be.securePost(E, {
      dataObj: O,
      callback: D,
      failedCallback: M,
      abortController: S,
      amount: 1
    });
  }
  static downloadUrlFor(C, _ = !1) {
    return C && "dest" in C ? _ && "thumbnail" in C.dest ? Be.buildUrl(C.dest.thumbnail) : "downloadUrl" in C.dest ? Be.buildUrl(C.dest.downloadUrl) : Be.buildUrl(null) : Be.buildUrl(C);
  }
  static uploadFile(C, _ = void 0) {
    const O = {
      fileName: C.name,
      mimeType: C.type || "application/octet-stream",
      size: C.size.toString(),
      node: _
    };
    return new Promise((D, M) => {
      Be.securePost("/vi/file/getUploadURL", { dataObj: O }).then(async (k) => {
        let S = await k.json();
        fetch(S.values.uploadUrl, {
          body: C,
          method: "POST",
          mode: "no-cors"
        }).then(async (m) => {
          const E = {
            key: S.values.uploadKey,
            skelType: "leaf"
          };
          Be.securePost("/vi/file/add", { dataObj: E }).then(async (x) => {
            let v = await x.json();
            v.action === "addSuccess" ? D(v.values) : M(v);
          }).catch((x) => {
            M(x);
          });
        }).catch((m) => {
          M(m);
        });
      }).catch((k) => {
        M(k);
      });
    });
  }
}
class si {
  constructor() {
    eb(this, "withCredentials", !0);
  }
  static buildOptions(C, _ = null, O = null, D = null, M = null) {
    let k = { method: C };
    return k.credentials = "include", k.headers = {
      Accept: "application/json, text/plain, */*"
    }, O && (k.headers = { ...k.headers, ...O }), _ && (k.body = _), D && (k.signal = D.signal), M && (k.mode = M), k;
  }
  static get(C, _ = null, O = null, D = null, M = null, k = null) {
    function S(m, E) {
      let x = new URL(m);
      if (E && Object.keys(E).length > 0) {
        const v = new URLSearchParams();
        for (const [f, A] of Object.entries(E))
          if (Array.isArray(A))
            for (const P of A)
              v.append(f, P);
          else
            v.append(f, A);
        x.search = v.toString();
      }
      return x.toString();
    }
    return fetch(S(C, _), si.buildOptions("GET", null, D, M, k)).then(async (m) => {
      if (m.ok)
        return m;
      {
        const E = `${m.status} ${m.statusText}: ${m.headers ? m.headers.get("x-error-descr") : ""}`;
        return Promise.reject(new _r(m.status, m.statusText, E, m));
      }
    }).catch((m) => {
      if (m instanceof TypeError) {
        const x = `503 ${m.message}: ${m.headers ? m.headers.get("x-error-descr") : ""}`;
        return Promise.reject(new _r(503, m.message, x, m));
      }
      if (m instanceof DOMException && m.name == "AbortError") {
        const x = `${m.code} ${m.name}: ${m.headers ? m.headers.get("x-error-descr") : ""}`;
        return Promise.reject(new _r(m.code, m.name, x, { url: C }));
      }
      const E = `${m.statusCode} ${m.statusText}: ${m.headers ? m.headers.get("x-error-descr") : ""}`;
      return Promise.reject(new _r(m.statusCode, m.statusText, E, m.response));
    });
  }
  static post(C, _ = null, O = null, D = null, M = null, k = null) {
    return fetch(C, si.buildOptions("POST", _, D, M, k));
  }
}
var vS = { VITE_API_URL: "", BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const CS = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: { Wrapper_nested: Cb },
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = Se("formatString"), D = he({
      format: ie(() => _ == null ? void 0 : _.bonestructure.format),
      skellistdata: null,
      selection: null
    });
    function M(m) {
      let E = "";
      return _.bonestructure.type === "relational.tree.leaf.file" ? E = "skelType=leaf&" : _.bonestructure.type === "relational.tree.node.file" && (E = "skelType=node&"), Be.get(
        `/${vS.VITE_DEFAULT_RENDERER || "vi"}/${_.bonestructure.module}/list?${E}limit=99`
      ).then(async (x) => {
        var f;
        const v = await x.json();
        D.skellistdata = {};
        for (let A of v.skellist)
          D.skellistdata[A.key] = A;
        return (f = v.skellist) == null ? void 0 : f.map((A) => ({ text: O(_.bonestructure.format, { dest: A }), value: A.key, data: A }));
      });
    }
    function k(m) {
      D.selection = { dest: D.skellistdata[m.detail.item.value] }, C.emit("change", h.name, D.selection, h.lang, h.index);
    }
    function S(m) {
      var x;
      D.selection || (D.selection = {}), (x = D.selection.rel) != null && x[m.name] || (D.selection.rel ? D.selection.rel[m.name] = null : D.selection.rel = { [m.name]: null });
      let E = D.selection.rel[m.name];
      m.lang ? (E === null && (E = {}), Object.keys(E).includes(m.lang) && m.index !== null ? E[m.lang][m.index] = m.value : E[m.lang] = m.value) : m.index !== null ? (E === null && (E = []), E[m.index] = m.value) : E = m.value, Object.keys(D.selection).includes("rel") && D.selection.rel ? D.selection.rel[m.name] = E : D.selection.rel = { [m.name]: E }, Object.keys(D.selection).includes("dest") && C.emit("change", h.name, D.selection, h.lang, h.index);
    }
    return Qe(() => {
      D.selection = h.value, C.emit("change", h.name, h.value, h.lang, h.index);
    }), {
      state: D,
      boneState: _,
      formatString: O,
      changeEvent: k,
      changeEventNested: S,
      getList: M
    };
  }
}), yS = (h) => (rt("data-v-61dd72e0"), h = h(), st(), h), ES = { class: "record" }, xS = { class: "single-entry" }, SS = ["value"], DS = ["disabled", "source"], BS = ["title"], TS = /* @__PURE__ */ yS(() => /* @__PURE__ */ F("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), IS = [
  TS
];
function PS(h, C, _, O, D, M) {
  var S, m;
  const k = Ln("Wrapper_nested");
  return L(), $("div", ES, [
    F("div", xS, [
      h.state.selection ? (L(), $("sl-input", {
        key: 0,
        disabled: !0,
        value: h.value ? h.formatString(h.state.format, h.state.selection) : ""
      }, null, 8, SS)) : (L(), $("sl-combobox", {
        key: 1,
        disabled: h.boneState.readonly,
        source: h.getList,
        hoist: "",
        onSlItemSelect: C[0] || (C[0] = (...E) => h.changeEvent && h.changeEvent(...E))
      }, null, 40, DS)),
      !h.boneState.multiple && !h.boneState.isEmpty ? (L(), $("sl-button", {
        key: 2,
        variant: "danger",
        outline: "",
        title: h.$t("bone.del"),
        class: "delete-btn square-btn",
        onClick: C[1] || (C[1] = () => {
          h.$emit("change", h.name, "", h.lang, h.index), h.state.selection = null;
        })
      }, IS, 8, BS)) : oe("", !0)
    ]),
    (S = h.boneState) != null && S.bonestructure.using ? (L(), Ue(k, {
      key: 0,
      value: (m = h.value) == null ? void 0 : m.rel,
      name: h.name,
      index: h.index,
      disabled: h.boneState.bonestructure.readonly,
      onChange: h.changeEventNested
    }, null, 8, ["value", "name", "index", "disabled", "onChange"])) : oe("", !0)
  ]);
}
const gb = /* @__PURE__ */ ke(CS, [["render", PS], ["__scopeId", "data-v-61dd72e0"]]), RS = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({});
    function D(M, k) {
      C.emit("change", h.name, M, h.lang, h.index);
    }
    return Qe(() => {
      C.emit("change", h.name, h.value, h.lang, h.index);
    }), {
      state: O,
      boneState: _,
      changeEvent: D
    };
  }
}), OS = { class: "box" };
function zS(h, C, _, O, D, M) {
  return L(), $("div", OS, Ae(h.value), 1);
}
const MS = /* @__PURE__ */ ke(RS, [["render", zS], ["__scopeId", "data-v-343aca69"]]);
var mb = { VITE_API_URL: "", BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const FS = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = Dt(), D = he({
      loading: !1,
      droparea: !1,
      previewopen: !1
    });
    Qe(() => {
      C.emit("change", h.name, h.value, h.lang, h.index);
    });
    function M() {
      console.log(Be.downloadUrlFor(h.value)), window.open(Be.downloadUrlFor(h.value));
    }
    function k() {
      return Be.downloadUrlFor(h.value, !1);
    }
    function S(x) {
      const v = {
        fileName: x.name,
        mimeType: x.type || "application/octet-stream",
        size: x.size.toString()
      };
      return new Promise((f, A) => {
        Be.securePost(`/${mb.VITE_DEFAULT_RENDERER || "vi"}/file/getUploadURL`, { dataObj: v }).then(async (P) => {
          let B = await P.json();
          fetch(B.values.uploadUrl, {
            body: x,
            method: "POST",
            mode: "no-cors"
          }).then(async (R) => {
            const N = {
              key: B.values.uploadKey,
              node: void 0,
              skelType: "leaf"
            };
            Be.securePost(`/${mb.VITE_DEFAULT_RENDERER || "vi"}/file/add`, { dataObj: N }).then(async (j) => {
              let q = await j.json();
              q.action === "addSuccess" ? f(q.values) : A(q);
            }).catch((j) => {
              A(j);
            });
          }).catch((R) => {
            A(R);
          });
        }).catch((P) => {
          A(P);
        });
      });
    }
    async function m(x) {
      D.loading = !0;
      for (let v of x.target.files) {
        let f = await S(v);
        O.value.value = null, C.emit("change", h.name, { dest: f, rel: null }, h.lang, h.index);
      }
      D.loading = !1;
    }
    async function E(x) {
      D.loading = !0, D.droparea = !1;
      for (let v of x.dataTransfer.files) {
        let f = await S(v);
        O.value.value = null, C.emit("change", h.name, { dest: f, rel: null }, h.lang, h.index);
        break;
      }
      D.loading = !1;
    }
    return {
      state: D,
      boneState: _,
      downloadFile: M,
      createBackgroundImage: k,
      handleUpload: m,
      uploadinput: O,
      handleDrop: E
    };
  }
}), Tr = (h) => (rt("data-v-91086308"), h = h(), st(), h), NS = {
  key: 0,
  class: "loader"
}, VS = /* @__PURE__ */ Tr(() => /* @__PURE__ */ F("sl-spinner", { slot: "suffix" }, null, -1)), LS = [
  VS
], jS = {
  key: 1,
  class: "droparea"
}, $S = ["title"], HS = /* @__PURE__ */ Tr(() => /* @__PURE__ */ F("sl-icon", { name: "upload" }, null, -1)), qS = [
  HS
], US = ["multiple"], WS = ["title"], KS = /* @__PURE__ */ Tr(() => /* @__PURE__ */ F("sl-icon", {
  slot: "prefix",
  name: "download"
}, null, -1)), GS = [
  KS
], ZS = { class: "box" }, JS = ["src"], YS = ["label", "open"], QS = ["src"], XS = {
  key: 1,
  class: "preview"
}, eD = {
  key: 0,
  name: "file-earmark"
}, tD = { key: 2 }, nD = ["title"], oD = /* @__PURE__ */ Tr(() => /* @__PURE__ */ F("sl-icon", { name: "x-lg" }, null, -1)), iD = [
  oD
];
function rD(h, C, _, O, D, M) {
  var k, S, m, E, x, v, f, A, P, B;
  return L(), $("div", {
    class: "file-wrapper",
    onDragover: C[5] || (C[5] = Er((R) => h.state.droparea = !0, ["prevent"])),
    onDragleave: C[6] || (C[6] = (R) => h.state.droparea = !1),
    onDrop: C[7] || (C[7] = Er((...R) => h.handleDrop && h.handleDrop(...R), ["prevent"]))
  }, [
    h.state.loading ? (L(), $("div", NS, LS)) : oe("", !0),
    h.state.droparea ? (L(), $("div", jS, " Dateien hier hinziehen ")) : oe("", !0),
    !h.boneState.readonly && (!h.value || h.state.loading) ? (L(), $("sl-button", {
      key: 2,
      title: h.$t("bone.upload"),
      outline: "",
      class: "upload-btn",
      onClick: C[0] || (C[0] = (R) => h.uploadinput.click())
    }, qS, 8, $S)) : oe("", !0),
    F("input", {
      ref: "uploadinput",
      hidden: "",
      type: "file",
      multiple: h.boneState.multiple,
      onChange: C[1] || (C[1] = (...R) => h.handleUpload && h.handleUpload(...R))
    }, null, 40, US),
    h.value ? (L(), $("sl-button", {
      key: 3,
      title: h.$t("bone.download"),
      onClick: C[2] || (C[2] = (...R) => h.downloadFile && h.downloadFile(...R))
    }, GS, 8, WS)) : oe("", !0),
    F("div", ZS, [
      (S = (k = h.value) == null ? void 0 : k.dest) != null && S.mimetype.includes("image") ? (L(), $("div", {
        key: 0,
        class: "preview has-preview",
        onClick: C[3] || (C[3] = (R) => h.state.previewopen = !h.state.previewopen)
      }, [
        F("img", {
          class: "preview-img",
          src: h.createBackgroundImage(),
          alt: ""
        }, null, 8, JS),
        F("sl-dialog", {
          label: decodeURIComponent((E = (m = h.value) == null ? void 0 : m.dest) == null ? void 0 : E.name),
          class: "preview-overlay",
          open: h.state.previewopen
        }, [
          F("img", {
            src: h.createBackgroundImage(),
            alt: ""
          }, null, 8, QS)
        ], 8, YS)
      ])) : (L(), $("div", XS, [
        (v = (x = h.value) == null ? void 0 : x.dest) != null && v.name ? (L(), $("sl-icon", eD)) : oe("", !0)
      ])),
      (A = (f = h.value) == null ? void 0 : f.dest) != null && A.name ? (L(), $("div", tD, Ae(decodeURIComponent((B = (P = h.value) == null ? void 0 : P.dest) == null ? void 0 : B.name)), 1)) : oe("", !0)
    ]),
    h.boneState.multiple ? oe("", !0) : (L(), $("sl-button", {
      key: 4,
      variant: "danger",
      outline: "",
      title: h.$t("bone.del"),
      class: "delete-btn",
      onClick: C[4] || (C[4] = (R) => h.$emit("change", h.name, "", h.lang, h.index))
    }, iD, 8, nD))
  ], 32);
}
const pb = /* @__PURE__ */ ke(FS, [["render", rD], ["__scopeId", "data-v-91086308"]]);
var vr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function sD(h) {
  return h && h.__esModule && Object.prototype.hasOwnProperty.call(h, "default") ? h.default : h;
}
var xr = { exports: {} };
xr.exports;
(function(h, C) {
  (function(_) {
    const O = _.de = _.de || {};
    O.dictionary = Object.assign(O.dictionary || {}, { "%0 of %1": "%0 von %1", "Align cell text to the bottom": "Zellentext unten ausrichten", "Align cell text to the center": "Zellentext zentriert ausrichten", "Align cell text to the left": "Zellentext linksbündig ausrichten", "Align cell text to the middle": "Zellentext mittig ausrichten", "Align cell text to the right": "Zellentext rechtsbündig ausrichten", "Align cell text to the top": "Zellentext oben ausrichten", "Align center": "Zentriert", "Align left": "Linksbündig", "Align right": "Rechtsbündig", "Align table to the left": "Tabelle links ausrichten", "Align table to the right": "Tabelle rechts ausrichten", Alignment: "Ausrichtung", Aquamarine: "Aquamarinblau", Background: "Hintergrund", Black: "Schwarz", "Block quote": "Blockzitat", Blue: "Blau", Bold: "Fett", Border: "Rahmen", "Break text": "Bild teilt Text", "Bulleted List": "Aufzählungsliste", "Bulleted list styles toolbar": "Darstellung der ungeordneten Liste", Cancel: "Abbrechen", "Cannot upload file:": "Die Datei kann nicht hochgeladen werden:", "Caption for image: %0": "Bildunterschrift: %0", "Caption for the image": "Bildunterschrift", "Cell properties": "Zelleneigenschaften", "Center table": "Tabelle zentrieren", "Centered image": "Zentriertes Bild", "Change image text alternative": "Alternativtext ändern", "Choose heading": "Überschrift auswählen", Circle: "Leerer Kreis", Code: "Code", Color: "Farbe", "Color picker": "Farbwähler", Column: "Spalte", Dashed: "Gestrichelt", Decimal: "Dezimalzahlen", "Decimal with leading zero": "Dezimalzahlen mit vorangestellten Nullen", "Decrease indent": "Einzug verkleinern", "Delete column": "Spalte löschen", "Delete row": "Zeile löschen", "Dim grey": "Dunkelgrau", Dimensions: "Größe", Disc: "Gefüllter Kreis", Dotted: "Gepunktet", Double: "Doppelt", Downloadable: "Herunterladbar", "Dropdown toolbar": "Dropdown-Liste Werkzeugleiste", "Edit block": "Absatz bearbeiten", "Edit link": "Link bearbeiten", "Editor block content toolbar": "Editor Blockinhalt-Toolbar", "Editor contextual toolbar": "Editor kontextuelle Toolbar", "Editor editing area: %0": "Bearbeitungsbereich des Editors: %0", "Editor toolbar": "Editor Werkzeugleiste", "Enter image caption": "Bildunterschrift eingeben", "Enter table caption": "Tabellenüberschrift eingeben", "Full size image": "Bild in voller Größe", Green: "Grün", Grey: "Grau", Groove: "Eingeritzt", "Header column": "Kopfspalte", "Header row": "Kopfzeile", Heading: "Überschrift", "Heading 1": "Überschrift 1", "Heading 2": "Überschrift 2", "Heading 3": "Überschrift 3", "Heading 4": "Überschrift 4", "Heading 5": "Überschrift 5", "Heading 6": "Überschrift 6", Height: "Höhe", HEX: "", "Horizontal text alignment toolbar": "Werkzeugleiste für die horizontale Zellentext-Ausrichtung", "HTML object": "HTML-Objekt", "Image resize list": "Bildgrößen-Liste", "Image toolbar": "Bild Werkzeugleiste", "image widget": "Bild-Steuerelement", "In line": "Text in Zeile", "Increase indent": "Einzug vergrößern", Insert: "Einfügen", "Insert column left": "Spalte links einfügen", "Insert column right": "Spalte rechts einfügen", "Insert image": "Bild einfügen", "Insert image via URL": "Bild von URL einfügen", "Insert paragraph after block": "Absatz nach Block einfügen", "Insert paragraph before block": "Absatz vor Block einfügen", "Insert row above": "Zeile oben einfügen", "Insert row below": "Zeile unten einfügen", "Insert table": "Tabelle einfügen", Inset: "Eingelassen", Italic: "Kursiv", Justify: "Blocksatz", "Justify cell text": "Zellentext als Blocksatz ausrichten", "Left aligned image": "Linksbündiges Bild", "Light blue": "Hellblau", "Light green": "Hellgrün", "Light grey": "Hellgrau", Link: "Link", "Link image": "Bild verlinken", "Link URL": "Link Adresse", "List properties": "Listeneigenschaften", "Lower-latin": "Kleingeschriebene lateinische Buchstaben", "Lower–roman": "Kleingeschriebene römische Zahlen", "Merge cell down": "Zelle unten verbinden", "Merge cell left": "Zelle links verbinden", "Merge cell right": "Zelle rechts verbinden", "Merge cell up": "Zelle verbinden", "Merge cells": "Zellen verbinden", Next: "Nächste", None: "Kein Rahmen", "Numbered List": "Nummerierte Liste", "Numbered list styles toolbar": "Darstellung der geordneten Liste", "Open in a new tab": "In neuem Tab öffnen", "Open link in new tab": "Link im neuen Tab öffnen", Orange: "Orange", Original: "Original", Outset: "Geprägt", Padding: "Innenabstand", Paragraph: "Absatz", "Press Enter to type after or press Shift + Enter to type before the widget": "Drücken Sie die Eingabetaste, um nach dem Widget zu tippen oder Shift + Eingabetaste, um vor dem Widget zu tippen.", Previous: "vorherige", Purple: "Violett", Red: "Rot", Redo: "Wiederherstellen", "Remove color": "Farbe entfernen", "Remove Format": "Formatierung entfernen", "Resize image": "Bildgröße ändern", "Resize image to %0": "Bildgröße ändern in %0", "Resize image to the original size": "Bild in Originalgröße ändern", "Restore default": "Standard wiederherstellen", "Reversed order": "Umgekehrte Reihenfolge", "Rich Text Editor": "Rich Text Editor", Ridge: "Hervorgehoben", "Right aligned image": "Rechtsbündiges Bild", Row: "Zeile", Save: "Speichern", "Select all": "Alles auswählen", "Select column": "Spalte auswählen", "Select row": "Zeile auswählen", "Show more items": "Mehr anzeigen", "Side image": "Seitenbild", Solid: "Durchgezogen", "Split cell horizontally": "Zelle horizontal teilen", "Split cell vertically": "Zelle vertikal teilen", Square: "Quadrat", "Start at": "Beginnen mit", "Start index must be greater than 0.": "Der Startwert muss größer als 0 sein.", Strikethrough: "Durchgestrichen", Style: "Rahmenart", Subscript: "Tiefgestellt", Superscript: "Hochgestellt", "Table alignment toolbar": "Werkzeugleiste für die Tabellen-Ausrichtung", "Table cell text alignment": "Ausrichtung des Zellentextes", "Table properties": "Tabelleneigenschaften", "Table toolbar": "Tabelle Werkzeugleiste", "Text alignment": "Textausrichtung", "Text alignment toolbar": "Text-Ausrichtung Toolbar", "Text alternative": "Alternativtext", 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': "Die Farbe ist ungültig. Probieren Sie „#FF0000“ oder „rgb(255,0,0)“ oder „red“.", 'The value is invalid. Try "10px" or "2em" or simply "2".': "Der Wert ist ungültig. Probieren Sie „10px“ oder „2em“ oder „2“.", "This link has no URL": "Dieser Link hat keine Adresse", "To-do List": "Aufgabenliste", "Toggle caption off": "Tabellenüberschrift deaktivieren", "Toggle caption on": "Tabellenüberschrift aktivieren", "Toggle the circle list style": "Leeren Kreis einstellen", "Toggle the decimal list style": "Dezimalzahlen einstellen", "Toggle the decimal with leading zero list style": "Dezimalzahlen mit vorangestellten Nullen einstellen", "Toggle the disc list style": "Gefüllten Kreis einstellen", "Toggle the lower–latin list style": "Kleingeschriebene lateinische Buchstaben einstellen", "Toggle the lower–roman list style": "Kleingeschriebene römische Zahlen einstellen", "Toggle the square list style": "Quadrat einstellen", "Toggle the upper–latin list style": "Großgeschriebene lateinische Buchstaben einstellen", "Toggle the upper–roman list style": "Großgeschriebene römische Zahlen einstellen", Turquoise: "Türkis", "Type or paste your content here.": "Hier Inhalt einfügen.", "Type your title": "Titel eingeben", Underline: "Unterstrichen", Undo: "Rückgängig", Unlink: "Link entfernen", Update: "Aktualisieren", "Update image URL": "Bild-URL aktualisieren", "Upload failed": "Hochladen fehlgeschlagen", "Upload in progress": "Upload läuft", "Upper-latin": "Großgeschriebene lateinische Buchstaben", "Upper-roman": "Großgeschriebene römische Zahlen", "Vertical text alignment toolbar": "Werkzeugleiste für die vertikale Zellentext-Ausrichtung", White: "Weiß", "Widget toolbar": "Widget Werkzeugleiste", Width: "Breite", "Wrap text": "Text umfließt Bild", Yellow: "Gelb" }), O.getPluralForm = function(D) {
      return D != 1;
    };
  })(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})), /*!
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md.
   */
  function(_, O) {
    h.exports = O();
  }(self, () => (() => {
    var _ = { 4959: (k, S, m) => {
      const E = m(1103), x = {};
      for (const f of Object.keys(E)) x[E[f]] = f;
      const v = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
      k.exports = v;
      for (const f of Object.keys(v)) {
        if (!("channels" in v[f])) throw new Error("missing channels property: " + f);
        if (!("labels" in v[f])) throw new Error("missing channel labels property: " + f);
        if (v[f].labels.length !== v[f].channels) throw new Error("channel and label counts mismatch: " + f);
        const { channels: A, labels: P } = v[f];
        delete v[f].channels, delete v[f].labels, Object.defineProperty(v[f], "channels", { value: A }), Object.defineProperty(v[f], "labels", { value: P });
      }
      v.rgb.hsl = function(f) {
        const A = f[0] / 255, P = f[1] / 255, B = f[2] / 255, R = Math.min(A, P, B), N = Math.max(A, P, B), j = N - R;
        let q, Z;
        N === R ? q = 0 : A === N ? q = (P - B) / j : P === N ? q = 2 + (B - A) / j : B === N && (q = 4 + (A - P) / j), q = Math.min(60 * q, 360), q < 0 && (q += 360);
        const Q = (R + N) / 2;
        return Z = N === R ? 0 : Q <= 0.5 ? j / (N + R) : j / (2 - N - R), [q, 100 * Z, 100 * Q];
      }, v.rgb.hsv = function(f) {
        let A, P, B, R, N;
        const j = f[0] / 255, q = f[1] / 255, Z = f[2] / 255, Q = Math.max(j, q, Z), se = Q - Math.min(j, q, Z), Y = function(ne) {
          return (Q - ne) / 6 / se + 0.5;
        };
        return se === 0 ? (R = 0, N = 0) : (N = se / Q, A = Y(j), P = Y(q), B = Y(Z), j === Q ? R = B - P : q === Q ? R = 0.3333333333333333 + A - B : Z === Q && (R = 0.6666666666666666 + P - A), R < 0 ? R += 1 : R > 1 && (R -= 1)), [360 * R, 100 * N, 100 * Q];
      }, v.rgb.hwb = function(f) {
        const A = f[0], P = f[1];
        let B = f[2];
        const R = v.rgb.hsl(f)[0], N = 1 / 255 * Math.min(A, Math.min(P, B));
        return B = 1 - 0.00392156862745098 * Math.max(A, Math.max(P, B)), [R, 100 * N, 100 * B];
      }, v.rgb.cmyk = function(f) {
        const A = f[0] / 255, P = f[1] / 255, B = f[2] / 255, R = Math.min(1 - A, 1 - P, 1 - B);
        return [100 * ((1 - A - R) / (1 - R) || 0), 100 * ((1 - P - R) / (1 - R) || 0), 100 * ((1 - B - R) / (1 - R) || 0), 100 * R];
      }, v.rgb.keyword = function(f) {
        const A = x[f];
        if (A) return A;
        let P, B = 1 / 0;
        for (const j of Object.keys(E)) {
          const q = E[j], Z = (N = q, ((R = f)[0] - N[0]) ** 2 + (R[1] - N[1]) ** 2 + (R[2] - N[2]) ** 2);
          Z < B && (B = Z, P = j);
        }
        var R, N;
        return P;
      }, v.keyword.rgb = function(f) {
        return E[f];
      }, v.rgb.xyz = function(f) {
        let A = f[0] / 255, P = f[1] / 255, B = f[2] / 255;
        return A = A > 0.04045 ? ((A + 0.055) / 1.055) ** 2.4 : A / 12.92, P = P > 0.04045 ? ((P + 0.055) / 1.055) ** 2.4 : P / 12.92, B = B > 0.04045 ? ((B + 0.055) / 1.055) ** 2.4 : B / 12.92, [100 * (0.4124 * A + 0.3576 * P + 0.1805 * B), 100 * (0.2126 * A + 0.7152 * P + 0.0722 * B), 100 * (0.0193 * A + 0.1192 * P + 0.9505 * B)];
      }, v.rgb.lab = function(f) {
        const A = v.rgb.xyz(f);
        let P = A[0], B = A[1], R = A[2];
        return P /= 95.047, B /= 100, R /= 108.883, P = P > 8856e-6 ? P ** 0.3333333333333333 : 7.787 * P + 0.13793103448275862, B = B > 8856e-6 ? B ** 0.3333333333333333 : 7.787 * B + 0.13793103448275862, R = R > 8856e-6 ? R ** 0.3333333333333333 : 7.787 * R + 0.13793103448275862, [116 * B - 16, 500 * (P - B), 200 * (B - R)];
      }, v.hsl.rgb = function(f) {
        const A = f[0] / 360, P = f[1] / 100, B = f[2] / 100;
        let R, N, j;
        if (P === 0) return j = 255 * B, [j, j, j];
        R = B < 0.5 ? B * (1 + P) : B + P - B * P;
        const q = 2 * B - R, Z = [0, 0, 0];
        for (let Q = 0; Q < 3; Q++) N = A + 0.3333333333333333 * -(Q - 1), N < 0 && N++, N > 1 && N--, j = 6 * N < 1 ? q + 6 * (R - q) * N : 2 * N < 1 ? R : 3 * N < 2 ? q + (R - q) * (0.6666666666666666 - N) * 6 : q, Z[Q] = 255 * j;
        return Z;
      }, v.hsl.hsv = function(f) {
        const A = f[0];
        let P = f[1] / 100, B = f[2] / 100, R = P;
        const N = Math.max(B, 0.01);
        return B *= 2, P *= B <= 1 ? B : 2 - B, R *= N <= 1 ? N : 2 - N, [A, 100 * (B === 0 ? 2 * R / (N + R) : 2 * P / (B + P)), 100 * ((B + P) / 2)];
      }, v.hsv.rgb = function(f) {
        const A = f[0] / 60, P = f[1] / 100;
        let B = f[2] / 100;
        const R = Math.floor(A) % 6, N = A - Math.floor(A), j = 255 * B * (1 - P), q = 255 * B * (1 - P * N), Z = 255 * B * (1 - P * (1 - N));
        switch (B *= 255, R) {
          case 0:
            return [B, Z, j];
          case 1:
            return [q, B, j];
          case 2:
            return [j, B, Z];
          case 3:
            return [j, q, B];
          case 4:
            return [Z, j, B];
          case 5:
            return [B, j, q];
        }
      }, v.hsv.hsl = function(f) {
        const A = f[0], P = f[1] / 100, B = f[2] / 100, R = Math.max(B, 0.01);
        let N, j;
        j = (2 - P) * B;
        const q = (2 - P) * R;
        return N = P * R, N /= q <= 1 ? q : 2 - q, N = N || 0, j /= 2, [A, 100 * N, 100 * j];
      }, v.hwb.rgb = function(f) {
        const A = f[0] / 360;
        let P = f[1] / 100, B = f[2] / 100;
        const R = P + B;
        let N;
        R > 1 && (P /= R, B /= R);
        const j = Math.floor(6 * A), q = 1 - B;
        N = 6 * A - j, 1 & j && (N = 1 - N);
        const Z = P + N * (q - P);
        let Q, se, Y;
        switch (j) {
          default:
          case 6:
          case 0:
            Q = q, se = Z, Y = P;
            break;
          case 1:
            Q = Z, se = q, Y = P;
            break;
          case 2:
            Q = P, se = q, Y = Z;
            break;
          case 3:
            Q = P, se = Z, Y = q;
            break;
          case 4:
            Q = Z, se = P, Y = q;
            break;
          case 5:
            Q = q, se = P, Y = Z;
        }
        return [255 * Q, 255 * se, 255 * Y];
      }, v.cmyk.rgb = function(f) {
        const A = f[0] / 100, P = f[1] / 100, B = f[2] / 100, R = f[3] / 100;
        return [255 * (1 - Math.min(1, A * (1 - R) + R)), 255 * (1 - Math.min(1, P * (1 - R) + R)), 255 * (1 - Math.min(1, B * (1 - R) + R))];
      }, v.xyz.rgb = function(f) {
        const A = f[0] / 100, P = f[1] / 100, B = f[2] / 100;
        let R, N, j;
        return R = 3.2406 * A + -1.5372 * P + -0.4986 * B, N = -0.9689 * A + 1.8758 * P + 0.0415 * B, j = 0.0557 * A + -0.204 * P + 1.057 * B, R = R > 31308e-7 ? 1.055 * R ** 0.4166666666666667 - 0.055 : 12.92 * R, N = N > 31308e-7 ? 1.055 * N ** 0.4166666666666667 - 0.055 : 12.92 * N, j = j > 31308e-7 ? 1.055 * j ** 0.4166666666666667 - 0.055 : 12.92 * j, R = Math.min(Math.max(0, R), 1), N = Math.min(Math.max(0, N), 1), j = Math.min(Math.max(0, j), 1), [255 * R, 255 * N, 255 * j];
      }, v.xyz.lab = function(f) {
        let A = f[0], P = f[1], B = f[2];
        return A /= 95.047, P /= 100, B /= 108.883, A = A > 8856e-6 ? A ** 0.3333333333333333 : 7.787 * A + 0.13793103448275862, P = P > 8856e-6 ? P ** 0.3333333333333333 : 7.787 * P + 0.13793103448275862, B = B > 8856e-6 ? B ** 0.3333333333333333 : 7.787 * B + 0.13793103448275862, [116 * P - 16, 500 * (A - P), 200 * (P - B)];
      }, v.lab.xyz = function(f) {
        let A, P, B;
        P = (f[0] + 16) / 116, A = f[1] / 500 + P, B = P - f[2] / 200;
        const R = P ** 3, N = A ** 3, j = B ** 3;
        return P = R > 8856e-6 ? R : (P - 0.13793103448275862) / 7.787, A = N > 8856e-6 ? N : (A - 0.13793103448275862) / 7.787, B = j > 8856e-6 ? j : (B - 0.13793103448275862) / 7.787, A *= 95.047, P *= 100, B *= 108.883, [A, P, B];
      }, v.lab.lch = function(f) {
        const A = f[0], P = f[1], B = f[2];
        let R;
        return R = 360 * Math.atan2(B, P) / 2 / Math.PI, R < 0 && (R += 360), [A, Math.sqrt(P * P + B * B), R];
      }, v.lch.lab = function(f) {
        const A = f[0], P = f[1], B = f[2] / 360 * 2 * Math.PI;
        return [A, P * Math.cos(B), P * Math.sin(B)];
      }, v.rgb.ansi16 = function(f, A = null) {
        const [P, B, R] = f;
        let N = A === null ? v.rgb.hsv(f)[2] : A;
        if (N = Math.round(N / 50), N === 0) return 30;
        let j = 30 + (Math.round(R / 255) << 2 | Math.round(B / 255) << 1 | Math.round(P / 255));
        return N === 2 && (j += 60), j;
      }, v.hsv.ansi16 = function(f) {
        return v.rgb.ansi16(v.hsv.rgb(f), f[2]);
      }, v.rgb.ansi256 = function(f) {
        const A = f[0], P = f[1], B = f[2];
        return A === P && P === B ? A < 8 ? 16 : A > 248 ? 231 : Math.round((A - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(A / 255 * 5) + 6 * Math.round(P / 255 * 5) + Math.round(B / 255 * 5);
      }, v.ansi16.rgb = function(f) {
        let A = f % 10;
        if (A === 0 || A === 7) return f > 50 && (A += 3.5), A = A / 10.5 * 255, [A, A, A];
        const P = 0.5 * (1 + ~~(f > 50));
        return [(1 & A) * P * 255, (A >> 1 & 1) * P * 255, (A >> 2 & 1) * P * 255];
      }, v.ansi256.rgb = function(f) {
        if (f >= 232) {
          const P = 10 * (f - 232) + 8;
          return [P, P, P];
        }
        let A;
        return f -= 16, [Math.floor(f / 36) / 5 * 255, Math.floor((A = f % 36) / 6) / 5 * 255, A % 6 / 5 * 255];
      }, v.rgb.hex = function(f) {
        const A = (((255 & Math.round(f[0])) << 16) + ((255 & Math.round(f[1])) << 8) + (255 & Math.round(f[2]))).toString(16).toUpperCase();
        return "000000".substring(A.length) + A;
      }, v.hex.rgb = function(f) {
        const A = f.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!A) return [0, 0, 0];
        let P = A[0];
        A[0].length === 3 && (P = P.split("").map((R) => R + R).join(""));
        const B = parseInt(P, 16);
        return [B >> 16 & 255, B >> 8 & 255, 255 & B];
      }, v.rgb.hcg = function(f) {
        const A = f[0] / 255, P = f[1] / 255, B = f[2] / 255, R = Math.max(Math.max(A, P), B), N = Math.min(Math.min(A, P), B), j = R - N;
        let q, Z;
        return q = j < 1 ? N / (1 - j) : 0, Z = j <= 0 ? 0 : R === A ? (P - B) / j % 6 : R === P ? 2 + (B - A) / j : 4 + (A - P) / j, Z /= 6, Z %= 1, [360 * Z, 100 * j, 100 * q];
      }, v.hsl.hcg = function(f) {
        const A = f[1] / 100, P = f[2] / 100, B = P < 0.5 ? 2 * A * P : 2 * A * (1 - P);
        let R = 0;
        return B < 1 && (R = (P - 0.5 * B) / (1 - B)), [f[0], 100 * B, 100 * R];
      }, v.hsv.hcg = function(f) {
        const A = f[1] / 100, P = f[2] / 100, B = A * P;
        let R = 0;
        return B < 1 && (R = (P - B) / (1 - B)), [f[0], 100 * B, 100 * R];
      }, v.hcg.rgb = function(f) {
        const A = f[0] / 360, P = f[1] / 100, B = f[2] / 100;
        if (P === 0) return [255 * B, 255 * B, 255 * B];
        const R = [0, 0, 0], N = A % 1 * 6, j = N % 1, q = 1 - j;
        let Z = 0;
        switch (Math.floor(N)) {
          case 0:
            R[0] = 1, R[1] = j, R[2] = 0;
            break;
          case 1:
            R[0] = q, R[1] = 1, R[2] = 0;
            break;
          case 2:
            R[0] = 0, R[1] = 1, R[2] = j;
            break;
          case 3:
            R[0] = 0, R[1] = q, R[2] = 1;
            break;
          case 4:
            R[0] = j, R[1] = 0, R[2] = 1;
            break;
          default:
            R[0] = 1, R[1] = 0, R[2] = q;
        }
        return Z = (1 - P) * B, [255 * (P * R[0] + Z), 255 * (P * R[1] + Z), 255 * (P * R[2] + Z)];
      }, v.hcg.hsv = function(f) {
        const A = f[1] / 100, P = A + f[2] / 100 * (1 - A);
        let B = 0;
        return P > 0 && (B = A / P), [f[0], 100 * B, 100 * P];
      }, v.hcg.hsl = function(f) {
        const A = f[1] / 100, P = f[2] / 100 * (1 - A) + 0.5 * A;
        let B = 0;
        return P > 0 && P < 0.5 ? B = A / (2 * P) : P >= 0.5 && P < 1 && (B = A / (2 * (1 - P))), [f[0], 100 * B, 100 * P];
      }, v.hcg.hwb = function(f) {
        const A = f[1] / 100, P = A + f[2] / 100 * (1 - A);
        return [f[0], 100 * (P - A), 100 * (1 - P)];
      }, v.hwb.hcg = function(f) {
        const A = f[1] / 100, P = 1 - f[2] / 100, B = P - A;
        let R = 0;
        return B < 1 && (R = (P - B) / (1 - B)), [f[0], 100 * B, 100 * R];
      }, v.apple.rgb = function(f) {
        return [f[0] / 65535 * 255, f[1] / 65535 * 255, f[2] / 65535 * 255];
      }, v.rgb.apple = function(f) {
        return [f[0] / 255 * 65535, f[1] / 255 * 65535, f[2] / 255 * 65535];
      }, v.gray.rgb = function(f) {
        return [f[0] / 100 * 255, f[0] / 100 * 255, f[0] / 100 * 255];
      }, v.gray.hsl = function(f) {
        return [0, 0, f[0]];
      }, v.gray.hsv = v.gray.hsl, v.gray.hwb = function(f) {
        return [0, 100, f[0]];
      }, v.gray.cmyk = function(f) {
        return [0, 0, 0, f[0]];
      }, v.gray.lab = function(f) {
        return [f[0], 0, 0];
      }, v.gray.hex = function(f) {
        const A = 255 & Math.round(f[0] / 100 * 255), P = ((A << 16) + (A << 8) + A).toString(16).toUpperCase();
        return "000000".substring(P.length) + P;
      }, v.rgb.gray = function(f) {
        return [(f[0] + f[1] + f[2]) / 3 / 255 * 100];
      };
    }, 841: (k, S, m) => {
      const E = m(4959), x = m(9325), v = {};
      Object.keys(E).forEach((f) => {
        v[f] = {}, Object.defineProperty(v[f], "channels", { value: E[f].channels }), Object.defineProperty(v[f], "labels", { value: E[f].labels });
        const A = x(f);
        Object.keys(A).forEach((P) => {
          const B = A[P];
          v[f][P] = function(R) {
            const N = function(...j) {
              const q = j[0];
              if (q == null) return q;
              q.length > 1 && (j = q);
              const Z = R(j);
              if (typeof Z == "object") for (let Q = Z.length, se = 0; se < Q; se++) Z[se] = Math.round(Z[se]);
              return Z;
            };
            return "conversion" in R && (N.conversion = R.conversion), N;
          }(B), v[f][P].raw = function(R) {
            const N = function(...j) {
              const q = j[0];
              return q == null ? q : (q.length > 1 && (j = q), R(j));
            };
            return "conversion" in R && (N.conversion = R.conversion), N;
          }(B);
        });
      }), k.exports = v;
    }, 9325: (k, S, m) => {
      const E = m(4959);
      function x(A) {
        const P = function() {
          const R = {}, N = Object.keys(E);
          for (let j = N.length, q = 0; q < j; q++) R[N[q]] = { distance: -1, parent: null };
          return R;
        }(), B = [A];
        for (P[A].distance = 0; B.length; ) {
          const R = B.pop(), N = Object.keys(E[R]);
          for (let j = N.length, q = 0; q < j; q++) {
            const Z = N[q], Q = P[Z];
            Q.distance === -1 && (Q.distance = P[R].distance + 1, Q.parent = R, B.unshift(Z));
          }
        }
        return P;
      }
      function v(A, P) {
        return function(B) {
          return P(A(B));
        };
      }
      function f(A, P) {
        const B = [P[A].parent, A];
        let R = E[P[A].parent][A], N = P[A].parent;
        for (; P[N].parent; ) B.unshift(P[N].parent), R = v(E[P[N].parent][N], R), N = P[N].parent;
        return R.conversion = B, R;
      }
      k.exports = function(A) {
        const P = x(A), B = {}, R = Object.keys(P);
        for (let N = R.length, j = 0; j < N; j++) {
          const q = R[j];
          P[q].parent !== null && (B[q] = f(q, P));
        }
        return B;
      };
    }, 1103: (k) => {
      k.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
    }, 8603: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}", "", { version: 3, sources: ["webpack://./../ckeditor5-basic-styles/theme/code.css"], names: [], mappings: "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content code {
	background-color: hsla(0, 0%, 78%, 0.3);
	padding: .15em;
	border-radius: 2px;
}

.ck.ck-editor__editable .ck-code_selected  {
	background-color: hsla(0, 0%, 78%, 0.5);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 3062: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", { version: 3, sources: ["webpack://./../ckeditor5-block-quote/theme/blockquote.css"], names: [], mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content blockquote {
	/* See #12 */
	overflow: hidden;

	/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */
	padding-right: 1.5em;
	padding-left: 1.5em;

	margin-left: 0;
	margin-right: 0;
	font-style: italic;
	border-left: solid 5px hsl(0, 0%, 80%);
}

.ck-content[dir="rtl"] blockquote {
	border-left: 0;
	border-right: solid 5px hsl(0, 0%, 80%);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 903: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}', "", { version: 3, sources: ["webpack://./../ckeditor5-clipboard/theme/clipboard.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"], names: [], mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CChCA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		display: inline;
		position: relative;
		pointer-events: none;

		& span {
			position: absolute;
			width: 0;
		}
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		& > .ck-widget__selection-handle {
			display: none;
		}

		& > .ck-widget__type-around {
			display: none;
		}
	}
}

.ck.ck-clipboard-drop-target-line {
	position: absolute;
	pointer-events: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-clipboard-drop-target-dot-width: 12px;
	--ck-clipboard-drop-target-dot-height: 8px;
	--ck-clipboard-drop-target-color: var(--ck-color-focus-border)
}

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		& span {
			bottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			border: 1px solid var(--ck-clipboard-drop-target-color);
			background: var(--ck-clipboard-drop-target-color);
			margin-left: -1px;

			/* The triangle above the marker */
			&::after {
				content: "";
				width: 0;
				height: 0;

				display: block;
				position: absolute;
				left: 50%;
				top: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);

				transform: translateX(-50%);
				border-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;
				border-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));
				border-style: solid;
			}
		}
	}

	/*
	 * Styles of the widget that it a drop target.
	 */
	& .ck-widget.ck-clipboard-drop-target-range {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		zoom: 0.6;
		outline: none !important;
	}
}

.ck.ck-clipboard-drop-target-line {
	height: 0;
	border: 1px solid var(--ck-clipboard-drop-target-color);
	background: var(--ck-clipboard-drop-target-color);
	margin-top: -1px;
}
`], sourceRoot: "" }]);
      const A = f;
    }, 3143: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", { version: 3, sources: ["webpack://./../ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor {
	/* All the elements within \`.ck-editor\` are positioned relatively to it.
	 If any element needs to be positioned with respect to the <body>, etc.,
	 it must land outside of the \`.ck-editor\` in DOM. */
	position: relative;

	& .ck-editor__top .ck-sticky-panel .ck-toolbar {
		/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */
		z-index: var(--ck-z-modal);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

.ck.ck-editor__top {
	& .ck-sticky-panel {
		& .ck-toolbar {
			@mixin ck-rounded-corners {
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}

			border-bottom-width: 0;
		}

		& .ck-sticky-panel__content_sticky .ck-toolbar {
			border-bottom-width: 1px;

			@mixin ck-rounded-corners {
				border-radius: 0;
			}
		}
	}
}

/* Note: Use ck-editor__main to make sure these styles don't apply to other editor types */
.ck.ck-editor__main > .ck-editor__editable {
	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */
	background: var(--ck-color-base-background);

	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	&:not(.ck-focused) {
		border-color: var(--ck-color-base-border);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 4717: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}", "", { version: 3, sources: ["webpack://./../ckeditor5-engine/theme/placeholder.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"], names: [], mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* See ckeditor/ckeditor5#936. */
.ck.ck-placeholder,
.ck .ck-placeholder {
	position: relative;

	&::before {
		position: absolute;
		left: 0;
		right: 0;
		content: attr(data-placeholder);

		/* See ckeditor/ckeditor5#469. */
		pointer-events: none;
	}
}

/* See ckeditor/ckeditor5#1987. */
.ck.ck-read-only .ck-placeholder {
	&::before {
		display: none;
	}
}

/*
 * Rules for the \`ck-placeholder\` are loaded before the rules for \`ck-reset_all\` in the base CKEditor 5 DLL build.
 * This fix overwrites the incorrectly set \`position: static\` from \`ck-reset_all\`.
 * See https://github.com/ckeditor/ckeditor5/issues/11418.
 */
.ck.ck-reset_all .ck-placeholder {
	position: relative;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* See ckeditor/ckeditor5#936. */
.ck.ck-placeholder, .ck .ck-placeholder {
	&::before {
		cursor: text;
		color: var(--ck-color-engine-placeholder-text);
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 9315: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-engine/theme/renderer.css"], names: [], mappings: "AAMA,qDACC,YACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Elements marked by the Renderer as hidden should be invisible in the editor. */
.ck.ck-editor__editable span[data-ck-unsafe-element] {
	display: none;
}
`], sourceRoot: "" }]);
      const A = f;
    }, 8733: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", { version: 3, sources: ["webpack://./../ckeditor5-heading/theme/heading.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"], names: [], mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-heading_heading1 {
	font-size: 20px;
}

.ck.ck-heading_heading2 {
	font-size: 17px;
}

.ck.ck-heading_heading3 {
	font-size: 14px;
}

.ck[class*="ck-heading_heading"] {
	font-weight: bold;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Resize dropdown's button label. */
.ck.ck-dropdown.ck-heading-dropdown {
	& .ck-dropdown__button .ck-button__label {
		width: 8em;
	}

	& .ck-dropdown__panel .ck-list__item {
		min-width: 18em;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 5049: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ":root{--ck-html-object-embed-unfocused-outline-width:1px}.ck-widget.html-object-embed{background-color:var(--ck-color-base-foreground);font-size:var(--ck-font-size-base);min-width:calc(76px + var(--ck-spacing-standard));padding:var(--ck-spacing-small);padding-top:calc(var(--ck-font-size-tiny) + var(--ck-spacing-large))}.ck-widget.html-object-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.html-object-embed:before{background:#999;border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);content:attr(data-html-object-embed-label);font-family:var(--ck-font-face);font-size:var(--ck-font-size-tiny);font-style:normal;font-weight:400;left:var(--ck-spacing-standard);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);position:absolute;top:0;transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck-widget.html-object-embed .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck-widget.html-object-embed .html-object-embed__content{pointer-events:none}div.ck-widget.html-object-embed{margin:1em auto}span.ck-widget.html-object-embed{display:inline-block}", "", { version: 3, sources: ["webpack://./../ckeditor5-html-support/theme/datafilter.css"], names: [], mappings: "AAKA,MACC,kDACD,CAEA,6BAEC,gDAAiD,CADjD,kCAAmC,CAKnC,iDAAkD,CAHlD,+BAAgC,CAEhC,oEAgCD,CA7BC,kEACC,wGACD,CAEA,oCAOC,eAA4B,CAG5B,iEAAkE,CAClE,qCAAsC,CAPtC,0CAA2C,CAS3C,+BAAgC,CADhC,kCAAmC,CAVnC,iBAAkB,CADlB,eAAmB,CAKnB,+BAAgC,CAGhC,yIAA0I,CAN1I,iBAAkB,CAElB,KAAM,CAGN,0GAMD,CAGA,2HACC,gBACD,CAEA,yDAEC,mBACD,CAGD,gCACC,eACD,CAEA,iCACC,oBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-html-object-embed-unfocused-outline-width: 1px;
}

.ck-widget.html-object-embed {
	font-size: var(--ck-font-size-base);
	background-color: var(--ck-color-base-foreground);
	padding: var(--ck-spacing-small);
	/* Leave space for label */
	padding-top: calc(var(--ck-font-size-tiny) + var(--ck-spacing-large));
	min-width: calc(76px + var(--ck-spacing-standard));

	&:not(.ck-widget_selected):not(:hover) {
		outline: var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border);
	}

	&::before {
		font-weight: normal;
		font-style: normal;
		position: absolute;
		content: attr(data-html-object-embed-label);
		top: 0;
		left: var(--ck-spacing-standard);
		background: hsl(0deg 0% 60%);
		transition: background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);
		padding: calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);
		border-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);
		color: var(--ck-color-base-background);
		font-size: var(--ck-font-size-tiny);
		font-family: var(--ck-font-face);
	}

	/* Make space for label. */
	& .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before {
		margin-left: 50px;
	}

	& .html-object-embed__content {
		/* Disable user interaction with embed content */
		pointer-events: none;
	}
}

div.ck-widget.html-object-embed {
	margin: 1em auto;
}

span.ck-widget.html-object-embed {
	display: inline-block;
}

`], sourceRoot: "" }]);
      const A = f;
    }, 3508: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/image.css"], names: [], mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content {
	& .image {
		display: table;
		clear: both;
		text-align: center;

		/* Make sure there is some space between the content and the image. Center image by default. */
		/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	 	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
		margin: 0.9em auto;

		/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */
		min-width: 50px;

		& img {
			/* Prevent unnecessary margins caused by line-height (see #44). */
			display: block;

			/* Center the image if its width is smaller than the content's width. */
			margin: 0 auto;

			/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */
			max-width: 100%;

			/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */
			min-width: 100%
		}
	}

	& .image-inline {
		/*
		 * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).
		 * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.
		 * This strange behavior does not happen with inline-flex.
		 */
		display: inline-flex;

		/* While being resized, don't allow the image to exceed the width of the editing root. */
		max-width: 100%;

		/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */
		align-items: flex-start;

		/* When the picture is present it must act as a flex container to let the img resize properly */
		& picture {
			display: flex;
		}

		/* When the picture is present, it must act like a resizable img. */
		& picture,
		& img {
			/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */
			flex-grow: 1;
			flex-shrink: 1;

			/* Prevents overflowing the editing root boundaries when an inline image is very wide. */
			max-width: 100%;
		}
	}
}

.ck.ck-editor__editable {
	/*
	 * Inhertit the content styles padding of the <figcaption> in case the integration overrides \`text-align: center\`
	 * of \`.image\` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native
	 * caret does, and not at the edge of <figcaption>.
	 */
	& .image > figcaption.ck-placeholder::before {
		padding-left: inherit;
		padding-right: inherit;

		/*
		 * Make sure the image caption placeholder doesn't overflow the placeholder area.
		 * See https://github.com/ckeditor/ckeditor5/issues/9162.
		 */
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}


	/*
	 * Make sure the selected inline image always stays on top of its siblings.
	 * See https://github.com/ckeditor/ckeditor5/issues/9108.
	 */
	& .image.ck-widget_selected {
		z-index: 1;
	}

	& .image-inline.ck-widget_selected {
		z-index: 1;

		/*
		 * Make sure the native browser selection style is not displayed.
		 * Inline image widgets have their own styles for the selected state and
		 * leaving this up to the browser is asking for a visual collision.
		 */
		& ::selection {
			display: none;
		}
	}

	/* The inline image nested in the table should have its original size if not resized.
	See https://github.com/ckeditor/ckeditor5/issues/9117. */
	& td,
	& th {
		& .image-inline img {
			max-width: none;
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 2640: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imagecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-image-caption-background: hsl(0, 0%, 97%);
	--ck-color-image-caption-text: hsl(0, 0%, 20%);
	--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);
}

/* Content styles */
.ck-content .image > figcaption {
	display: table-caption;
	caption-side: bottom;
	word-break: break-word;
	color: var(--ck-color-image-caption-text);
	background-color: var(--ck-color-image-caption-background);
	padding: .6em;
	font-size: .75em;
	outline-offset: -1px;
}

/* Editing styles */
.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {
	animation: ck-image-caption-highlight .6s ease-out;
}

@keyframes ck-image-caption-highlight {
	0% {
		background-color: var(--ck-color-image-caption-highligted-background);
	}

	100% {
		background-color: var(--ck-color-image-caption-background);
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 3535: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-image-insert__panel{padding:var(--ck-spacing-large)}.ck.ck-image-insert__ck-finder-button{border:1px solid #ccc;border-radius:var(--ck-border-radius);display:block;margin:var(--ck-spacing-standard) auto;width:100%}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{border:none;margin:0;padding:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageinsert.css"], names: [], mappings: "AAKA,2BACC,+BACD,CAEA,sCAIC,qBAAiC,CACjC,qCAAsC,CAJtC,aAAc,CAEd,sCAAuC,CADvC,UAID,CAGA,oDAGC,WAAY,CADZ,QAAS,CADT,SAGD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-image-insert__panel {
	padding: var(--ck-spacing-large);
}

.ck.ck-image-insert__ck-finder-button {
	display: block;
	width: 100%;
	margin: var(--ck-spacing-standard) auto;
	border: 1px solid hsl(0, 0%, 80%);
	border-radius: var(--ck-border-radius);
}

/* https://github.com/ckeditor/ckeditor5/issues/7986 */
.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {
	padding: 0;
	margin: 0;
	border: none;
}
`], sourceRoot: "" }]);
      const A = f;
    }, 1568: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageinsertformrowview.css"], names: [], mappings: "AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-image-insert-form {
	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}
}

.ck.ck-form__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		flex-grow: 1;
	}

	&.ck-image-insert-form__action-row {
		margin-top: var(--ck-spacing-standard);

		& .ck-button-save,
		& .ck-button-cancel {
			justify-content: center;
		}

		& .ck-button .ck-button__label {
			color: var(--ck-color-text);
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 6270: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageresize.css"], names: [], mappings: "AAKA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .image.image_resized {
	max-width: 100%;
	/*
	The \`<figure>\` element for resized images must not use \`display:table\` as browsers do not support \`max-width\` for it well.
	See https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.
	Fortunately, since we control the width, there is no risk that the image will look bad.
	*/
	display: block;
	box-sizing: border-box;

	& img {
		/* For resized images it is the \`<figure>\` element that determines the image width. */
		width: 100%;
	}

	& > figcaption {
		/* The \`<figure>\` element uses \`display:block\`, so \`<figcaption>\` also has to. */
		display: block;
	}
}

.ck.ck-editor__editable {
	/* The resized inline image nested in the table should respect its parent size.
	See https://github.com/ckeditor/ckeditor5/issues/9117. */
	& td,
	& th {
		& .image-inline.image_resized img {
			max-width: 100%;
		}
	}
}

[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {
	margin-right: var(--ck-spacing-standard);
}

[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {
	margin-left: var(--ck-spacing-standard);
}

.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {
	width: 4em;
}
`], sourceRoot: "" }]);
      const A = f;
    }, 5083: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imagestyle.css"], names: [], mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-image-style-spacing: 1.5em;
	--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);
}

.ck-content {
	/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback
	confirming successful application of the style if image width exceeds the editor's size.
	See https://github.com/ckeditor/ckeditor5/issues/9342 */
	& .image-style-block-align-left,
	& .image-style-block-align-right {
		max-width: calc(100% - var(--ck-image-style-spacing));
	}

	/* Allows displaying multiple floating images in the same line.
	See https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */
	& .image-style-align-left,
	& .image-style-align-right {
		clear: none;
	}

	& .image-style-side {
		float: right;
		margin-left: var(--ck-image-style-spacing);
		max-width: 50%;
	}

	& .image-style-align-left {
		float: left;
		margin-right: var(--ck-image-style-spacing);
	}

	& .image-style-align-center {
		margin-left: auto;
		margin-right: auto;
	}

	& .image-style-align-right {
		float: right;
		margin-left: var(--ck-image-style-spacing);
	}

	& .image-style-block-align-right {
		margin-right: 0;
		margin-left: auto;
	}

	& .image-style-block-align-left {
		margin-left: 0;
		margin-right: auto;
	}

	/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */
	& p + .image-style-align-left,
	& p + .image-style-align-right,
	& p + .image-style-side {
		margin-top: 0;
	}

	& .image-inline {
		&.image-style-align-left,
		&.image-style-align-right {
			margin-top: var(--ck-inline-image-style-spacing);
			margin-bottom: var(--ck-inline-image-style-spacing);
		}

		&.image-style-align-left {
			margin-right: var(--ck-inline-image-style-spacing);
		}

		&.image-style-align-right {
			margin-left: var(--ck-inline-image-style-spacing);
		}
	}
}

.ck.ck-splitbutton {
	/* The button should display as a regular drop-down if the action button
	is forced to fire the same action as the arrow button. */
	&.ck-splitbutton_flatten {
		&:hover,
		&.ck-splitbutton_open {
			& > .ck-splitbutton__action:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {
				background-color: var(--ck-color-button-on-background);

				&::after {
					display: none;
				}
			}
		}

		&.ck-splitbutton_open:hover {
			& > .ck-splitbutton__action:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {
				background-color: var(--ck-color-button-on-hover-background);
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 4036: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadicon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"], names: [], mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-image-upload-complete-icon {
	display: block;
	position: absolute;

	/*
	 * Smaller images should have the icon closer to the border.
	 * Match the icon position with the linked image indicator brought by the link image feature.
	 */
	top: min(var(--ck-spacing-medium), 6%);
	right: min(var(--ck-spacing-medium), 6%);
	border-radius: 50%;
	z-index: 1;

	&::after {
		content: "";
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-image-upload-icon: hsl(0, 0%, 100%);
	--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);

	/* Match the icon size with the linked image indicator brought by the link image feature. */
	--ck-image-upload-icon-size: 20;
	--ck-image-upload-icon-width: 2px;
	--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);
}

.ck-image-upload-complete-icon {
	opacity: 0;
	background: var(--ck-color-image-upload-icon-background);
	animation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;
	animation-fill-mode: forwards, forwards;
	animation-duration: 500ms, 500ms;

	/* To make animation scalable. */
	font-size: calc(1px * var(--ck-image-upload-icon-size));

	/* Hide completed upload icon after 3 seconds. */
	animation-delay: 0ms, 3000ms;

	/*
	 * Use CSS math to simulate container queries.
	 * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things
	 */
	overflow: hidden;
	width: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));
	height: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));

	/* This is check icon element made from border-width mixed with animations. */
	&::after {
		/* Because of border transformation we need to "hard code" left position. */
		left: 25%;

		top: 50%;
		opacity: 0;
		height: 0;
		width: 0;

		transform: scaleX(-1) rotate(135deg);
		transform-origin: left top;
		border-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);
		border-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);

		animation-name: ck-upload-complete-icon-check;
		animation-duration: 500ms;
		animation-delay: 500ms;
		animation-fill-mode: forwards;

		/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */
		box-sizing: border-box;
	}
}

@keyframes ck-upload-complete-icon-show {
	from {
		opacity: 0;
	}

	to {
		opacity: 1;
	}
}

@keyframes ck-upload-complete-icon-hide {
	from {
		opacity: 1;
	}

	to {
		opacity: 0;
	}
}

@keyframes ck-upload-complete-icon-check {
	0% {
		opacity: 1;
		width: 0;
		height: 0;
	}
	33% {
		width: 0.3em;
		height: 0;
	}
	100% {
		opacity: 1;
		width: 0.3em;
		height: 0.45em;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 3773: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadloader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"], names: [], mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-upload-placeholder-loader {
	position: absolute;
	display: flex;
	align-items: center;
	justify-content: center;
	top: 0;
	left: 0;

	&::before {
		content: '';
		position: relative;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);
	--ck-upload-placeholder-loader-size: 32px;
	--ck-upload-placeholder-image-aspect-ratio: 2.8;
}

.ck .ck-image-upload-placeholder {
	/* We need to control the full width of the SVG gray background. */
	width: 100%;
	margin: 0;

	&.image-inline {
		width: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );
	}

	& img {
		/*
		 * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.
		 * There's nothing special about this number except that it should make the image placeholder look like
		 * a real image during this short period after the upload started and before the image was read from the
		 * file system (and a rich preview was loaded).
		 */
		aspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);
	}
}

.ck .ck-upload-placeholder-loader {
	width: 100%;
	height: 100%;

	&::before {
		width: var(--ck-upload-placeholder-loader-size);
		height: var(--ck-upload-placeholder-loader-size);
		border-radius: 50%;
		border-top: 3px solid var(--ck-color-upload-placeholder-loader);
		border-right: 2px solid transparent;
		animation: ck-upload-placeholder-loader 1s linear infinite;
	}
}

@keyframes ck-upload-placeholder-loader {
	to {
		transform: rotate( 360deg );
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 3689: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadprogress.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"], names: [], mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& .image,
	& .image-inline {
		position: relative;
	}

	/* Upload progress bar. */
	& .image .ck-progress-bar,
	& .image-inline .ck-progress-bar {
		position: absolute;
		top: 0;
		left: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& .image,
	& .image-inline {
		/* Showing animation. */
		&.ck-appear {
			animation: fadeIn 700ms;
		}
	}

	/* Upload progress bar. */
	& .image .ck-progress-bar,
	& .image-inline .ck-progress-bar {
		height: 2px;
		width: 0;
		background: var(--ck-color-upload-bar-background);
		transition: width 100ms;
	}
}

@keyframes fadeIn {
	from { opacity: 0; }
	to   { opacity: 1; }
}
`], sourceRoot: "" }]);
      const A = f;
    }, 1905: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/textalternativeform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-text-alternative-form {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;

	& .ck-labeled-field-view {
		display: inline-block;
	}

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 9773: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/link.css"], names: [], mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Class added to span element surrounding currently selected link. */
.ck .ck-link_selected {
	background: var(--ck-color-link-selected-background);

	/* Give linked inline images some outline to let the user know they are also part of the link. */
	& span.image-inline {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);
	}
}

/*
 * Classes used by the "fake visual selection" displayed in the content when an input
 * in the link UI has focus (the browser does not render the native selection in this state).
 */
.ck .ck-fake-link-selection {
	background: var(--ck-color-link-fake-selection);
}

/* A collapsed fake visual selection. */
.ck .ck-fake-link-selection_collapsed {
	height: 100%;
	border-right: 1px solid var(--ck-color-base-text);
	margin-right: -1px;
	outline: solid 1px hsla(0, 0%, 100%, .5);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 2347: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkactions.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"], names: [], mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;

	& .ck-link-actions__preview {
		display: inline-block;

		& .ck-button__label {
			overflow: hidden;
		}
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-link-actions__preview {
			flex-basis: 100%;
		}

		& .ck-button:not(.ck-link-actions__preview) {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	& .ck-button.ck-link-actions__preview {
		padding-left: 0;
		padding-right: 0;

		& .ck-button__label {
			padding: 0 var(--ck-spacing-medium);
			color: var(--ck-color-link-default);
			text-overflow: ellipsis;
			cursor: pointer;

			/* Match the box model of the link editor form's input so the balloon
			does not change width when moving between actions and the form. */
			max-width: var(--ck-input-width);
			min-width: 3em;
			text-align: center;

			&:hover {
				text-decoration: underline;
			}
		}

		&,
		&:hover,
		&:focus,
		&:active {
			background: none;
		}

		&:active {
			box-shadow: none;
		}

		&:focus {
			& .ck-button__label {
				text-decoration: underline;
			}
		}
	}

	@mixin ck-dir ltr {
		& .ck-button:not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-button:not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		& .ck-button.ck-link-actions__preview {
			margin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;

			& .ck-button__label {
				min-width: 0;
				max-width: 100%;
			}
		}

		& .ck-button:not(.ck-link-actions__preview) {
			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 7754: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"], names: [], mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-form {
	display: flex;

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}

/*
 * Style link form differently when manual decorators are available.
 * See: https://github.com/ckeditor/ckeditor5-link/issues/186.
 */
.ck.ck-link-form_layout-vertical {
	display: block;

	/*
	 * Whether the form is in the responsive mode or not, if there are decorator buttons
	 * keep the top margin of action buttons medium.
	 */
	& .ck-button {
		&.ck-button-save,
		&.ck-button-cancel {
			margin-top: var(--ck-spacing-medium);
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

/*
 * Style link form differently when manual decorators are available.
 * See: https://github.com/ckeditor/ckeditor5-link/issues/186.
 */
.ck.ck-link-form_layout-vertical {
	padding: 0;
	min-width: var(--ck-input-width);

	& .ck-labeled-field-view {
		margin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);

		& .ck-input-text {
			min-width: 0;
			width: 100%;
		}
	}

	& > .ck-button {
		padding: var(--ck-spacing-standard);
		margin: 0;
		width: 50%;
		border-radius: 0;

		&:not(:focus) {
			border-top: 1px solid var(--ck-color-base-border);
		}

		@mixin ck-dir ltr {
			margin-left: 0;
		}

		@mixin ck-dir rtl {
			margin-left: 0;

			&:last-of-type {
				border-right: 1px solid var(--ck-color-base-border);
			}
		}
	}

	/* Using additional \`.ck\` class for stronger CSS specificity than \`.ck.ck-link-form > :not(:first-child)\`. */
	& .ck.ck-list {
		margin: var(--ck-spacing-standard) var(--ck-spacing-large);

		& .ck-button.ck-switchbutton {
			padding: 0;
			width: 100%;

			&:hover {
				background: none;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 111: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}', "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkimage.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css"], names: [], mappings: "AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,83BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	/* Linked image indicator */
	& figure.image > a,
	& a span.image-inline {
		&::after {
			display: block;
			position: absolute;
		}
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Match the icon size with the upload indicator brought by the image upload feature. */
	--ck-link-image-indicator-icon-size: 20;
	--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);
}

.ck.ck-editor__editable {
	/* Linked image indicator */
	& figure.image > a,
	& a span.image-inline {
		&::after {
			content: "";

			/*
			 * Smaller images should have the icon closer to the border.
			 * Match the icon position with the upload indicator brought by the image upload feature.
			 */
			top: min(var(--ck-spacing-medium), 6%);
			right: min(var(--ck-spacing-medium), 6%);

			background-color: hsla(0, 0%, 0%, .4);
			background-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");
			background-size: 14px;
			background-repeat: no-repeat;
			background-position: center;
			border-radius: 100%;

			/*
			* Use CSS math to simulate container queries.
			* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things
			*/
			overflow: hidden;
			width: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));
			height: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));
		}
	}
}

`], sourceRoot: "" }]);
      const A = f;
    }, 4721: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:0 var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/collapsible.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/collapsible.css"], names: [], mappings: "AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,wDAAyD,CAFzD,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,yDACD,CAGC,mEACC,wBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-collapsible.ck-collapsible_collapsed {
	& > .ck-collapsible__children {
		display: none;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-collapsible {
	& > .ck.ck-button {
		width: 100%;
		font-weight: bold;
		padding: var(--ck-spacing-medium) var(--ck-spacing-large);
		border-radius: 0;
		color: inherit;

		&:focus {
			background: transparent;
		}

		&:active, &:not(:focus), &:hover:not(:focus) {
			background: transparent;
			border-color: transparent;
			box-shadow: none;
		}

		& > .ck-icon {
			margin-right: var(--ck-spacing-medium);
			width: var(--ck-collapsible-arrow-size);
		}
	}

	& > .ck-collapsible__children {
		padding: 0 var(--ck-spacing-large) var(--ck-spacing-large);
	}

	&.ck-collapsible_collapsed {
		& > .ck.ck-button .ck-icon {
			transform: rotate(-90deg);
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 5730: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck-editor__editable .ck-list-bogus-paragraph{display:block}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/documentlist.css"], names: [], mappings: "AAKA,8CACC,aACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-editor__editable .ck-list-bogus-paragraph {
	display: block;
}
`], sourceRoot: "" }]);
      const A = f;
    }, 4564: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/list.css"], names: [], mappings: "AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content ol {
	list-style-type: decimal;

	& ol {
		list-style-type: lower-latin;

		& ol {
			list-style-type: lower-roman;

			& ol {
				list-style-type: upper-latin;

				& ol {
					list-style-type: upper-roman;
				}
			}
		}
	}
}

.ck-content ul {
	list-style-type: disc;

	& ul {
		list-style-type: circle;

		& ul {
			list-style-type: square;

			& ul {
				list-style-type: square;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 6082: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css"], names: [], mappings: "AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-list-properties {
	/* When there are no list styles and there is no collapsible. */
	&.ck-list-properties_without-styles {
		padding: var(--ck-spacing-large);

		& > * {
			min-width: 14em;

			& + * {
				margin-top: var(--ck-spacing-standard);
			}
		}
	}

	/*
	 * When the numbered list property fields (start at, reversed) should be displayed,
	 * more horizontal space is needed. Reconfigure the style grid to create that space.
	 */
	&.ck-list-properties_with-numbered-properties {
		& > .ck-list-styles-list {
			grid-template-columns: repeat( 4, auto );
		}

		/* When list styles are rendered and property fields are in a collapsible. */
		& > .ck-collapsible {
			border-top: 1px solid var(--ck-color-base-border);

			& > .ck-collapsible__children {
				& > * {
					width: 100%;

					& + * {
						margin-top: var(--ck-spacing-standard);
					}
				}
			}
		}
	}

	& .ck.ck-numbered-list-properties__start-index .ck-input {
		min-width: auto;
		width: 100%;
	}

	& .ck.ck-numbered-list-properties__reversed-order {
		background: transparent;
		padding-left: 0;
		padding-right: 0;
		margin-bottom: calc(-1 * var(--ck-spacing-tiny));

		&:active, &:hover {
			box-shadow: none;
			border-color: transparent;
			background: none;
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 2417: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-list-styles-list{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/liststyles.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"], names: [], mappings: "AAKA,wBACC,YACD,CCFA,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-list-styles-list {
	display: grid;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-list-style-button-size: 44px;
}

.ck.ck-list-styles-list {
	grid-template-columns: repeat( 3, auto );
	row-gap: var(--ck-spacing-medium);
	column-gap: var(--ck-spacing-medium);
	padding: var(--ck-spacing-large);

	& .ck-button {
		/* Make the button look like a thumbnail (the icon "takes it all"). */
		width: var(--ck-list-style-button-size);
		height: var(--ck-list-style-button-size);
		padding: 0;

		/*
		 * Buttons are aligned by the grid so disable default button margins to not collide with the
		 * gaps in the grid.
		 */
		margin: 0;

		/*
		 * Make sure the button border (which is displayed on focus, BTW) does not steal pixels
		 * from the button dimensions and, as a result, decrease the size of the icon
		 * (which becomes blurry as it scales down).
		 */
		box-sizing: content-box;

		& .ck-icon {
			width: var(--ck-list-style-button-size);
			height: var(--ck-list-style-button-size);
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 1199: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-content .todo-list .todo-list__label>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out,background .25s ease-in-out,border .25s ease-in-out;width:100%}.ck-content .todo-list .todo-list__label>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-editor__editable .todo-list .todo-list__label>input{cursor:pointer}.ck-editor__editable .todo-list .todo-list__label>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}', "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/todolist.css"], names: [], mappings: "AAKA,MACC,kCACD,CAEA,uBACC,eA0ED,CAxEC,0BACC,iBAKD,CAHC,qCACC,cACD,CAIA,+CACC,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAqDD,CAxCC,sDAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,0FAAgG,CAJhG,UAKD,CAEA,qDAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAIF,wEACC,qBACD,CAKF,6CACC,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAED,CAMA,wDACC,cAKD,CAHC,qEACC,mCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-todo-list-checkmark-size: 16px;
}

.ck-content .todo-list {
	list-style: none;

	& li {
		margin-bottom: 5px;

		& .todo-list {
			margin-top: 5px;
		}
	}

	& .todo-list__label {
		& > input {
			-webkit-appearance: none;
			display: inline-block;
			position: relative;
			width: var(--ck-todo-list-checkmark-size);
			height: var(--ck-todo-list-checkmark-size);
			vertical-align: middle;

			/* Needed on iOS */
			border: 0;

			/* LTR styles */
			left: -25px;
			margin-right: -15px;
			right: 0;
			margin-left: 0;

			&::before {
				display: block;
				position: absolute;
				box-sizing: border-box;
				content: '';
				width: 100%;
				height: 100%;
				border: 1px solid hsl(0, 0%, 20%);
				border-radius: 2px;
				transition: 250ms ease-in-out box-shadow, 250ms ease-in-out background, 250ms ease-in-out border;
			}

			&::after {
				display: block;
				position: absolute;
				box-sizing: content-box;
				pointer-events: none;
				content: '';

				/* Calculate tick position, size and border-width proportional to the checkmark size. */
				left: calc( var(--ck-todo-list-checkmark-size) / 3 );
				top: calc( var(--ck-todo-list-checkmark-size) / 5.3 );
				width: calc( var(--ck-todo-list-checkmark-size) / 5.3 );
				height: calc( var(--ck-todo-list-checkmark-size) / 2.6 );
				border-style: solid;
				border-color: transparent;
				border-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;
				transform: rotate(45deg);
			}

			&[checked] {
				&::before {
					background: hsl(126, 64%, 41%);
					border-color: hsl(126, 64%, 41%);
				}

				&::after {
					border-color: hsl(0, 0%, 100%);
				}
			}
		}

		& .todo-list__label__description {
			vertical-align: middle;
		}
	}
}

/* RTL styles */
[dir="rtl"] .todo-list .todo-list__label > input {
	left: 0;
	margin-right: 0;
	right: -25px;
	margin-left: -15px;
}

/*
 * To-do list should be interactive only during the editing
 * (https://github.com/ckeditor/ckeditor5/issues/2090).
 */
.ck-editor__editable .todo-list .todo-list__label > input {
	cursor: pointer;

	&:hover::before {
		box-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 2896: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, '.ck-source-editing-area{overflow:hidden;position:relative}.ck-source-editing-area textarea,.ck-source-editing-area:after{border:1px solid transparent;font-family:monospace;font-size:var(--ck-font-size-normal);line-height:var(--ck-line-height-base);margin:0;padding:var(--ck-spacing-large);white-space:pre-wrap}.ck-source-editing-area:after{content:attr(data-value) " ";display:block;visibility:hidden}.ck-source-editing-area textarea{border-color:var(--ck-color-base-border);border-radius:0;box-sizing:border-box;height:100%;outline:none;overflow:hidden;position:absolute;resize:none;width:100%}.ck-rounded-corners .ck-source-editing-area textarea,.ck-source-editing-area textarea.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck-source-editing-area textarea:not([readonly]):focus{border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}', "", { version: 3, sources: ["webpack://./../ckeditor5-source-editing/theme/sourceediting.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,wBAEC,eAAgB,CADhB,iBAED,CAEA,+DAIC,4BAA6B,CAG7B,qBAAsB,CADtB,oCAAqC,CADrC,sCAAuC,CAFvC,QAAS,CADT,+BAAgC,CAMhC,oBACD,CAEA,8BACC,4BAA6B,CAE7B,aAAc,CADd,iBAED,CAEA,iCASC,wCAAyC,CC7BzC,eAAgB,CD2BhB,qBAAsB,CAJtB,WAAY,CAEZ,YAAa,CACb,eAAgB,CALhB,iBAAkB,CAGlB,WAAY,CAFZ,UAkBD,CApBA,yGChBE,qCAAsC,CD4BtC,wBAAyB,CACzB,yBAOF,CAJC,uDEpCA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFwCA", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";
@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css";
@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";

.ck-source-editing-area {
	position: relative;
	overflow: hidden;
}

.ck-source-editing-area::after,
.ck-source-editing-area textarea {
	padding: var(--ck-spacing-large);
	margin: 0;
	border: 1px solid transparent;
	line-height: var(--ck-line-height-base);
	font-size: var(--ck-font-size-normal);
	font-family: monospace;
	white-space: pre-wrap;
}

.ck-source-editing-area::after {
	content: attr(data-value) " ";
	visibility: hidden;
	display: block;
}

.ck-source-editing-area textarea {
	position: absolute;
	width: 100%;
	height: 100%;
	resize: none;
	outline: none;
	overflow: hidden;
	box-sizing: border-box;

	border-color: var(--ck-color-base-border);

	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	&:not([readonly]):focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 7368: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-input-color {
	width: 100%;
	display: flex;
	flex-direction: row-reverse;

	& > input.ck.ck-input-text {
		min-width: auto;
		flex-grow: 1;
	}

	& > div.ck.ck-dropdown {
		min-width: auto;

		/* This dropdown has no arrow but a color preview instead. */
		& > .ck-input-color__button .ck-dropdown__arrow {
			display: none;
		}
	}

	& .ck.ck-input-color__button {
		/* Resolving issue with misaligned buttons on Safari (see #10589) */
		display: flex;

		& .ck.ck-input-color__button__preview {
			position: relative;
			overflow: hidden;

			& > .ck.ck-input-color__button__preview__no-color-indicator {
				position: absolute;
				display: block;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_rounded.css";

.ck.ck-input-color {
	& > .ck.ck-input-text {
		@mixin ck-dir ltr {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		@mixin ck-dir rtl {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* Make sure the focused input is always on top of the dropdown button so its
		   outline and border are never cropped (also when the input is read-only). */
		&:focus {
			z-index: 0;
		}
	}

	& > .ck.ck-dropdown {
		& > .ck.ck-button.ck-input-color__button {
			padding: 0;

			@mixin ck-dir ltr {
				border-top-left-radius: 0;
				border-bottom-left-radius: 0;

				&:not(:focus) {
					border-left: 1px solid transparent;
				}
			}

			@mixin ck-dir rtl {
				border-top-right-radius: 0;
				border-bottom-right-radius: 0;

				&:not(:focus) {
					border-right: 1px solid transparent;
				}
			}

			&.ck-disabled {
				background: var(--ck-color-input-disabled-background);
			}

			& > .ck.ck-input-color__button__preview {
				@mixin ck-rounded-corners;

				width: 20px;
				height: 20px;
				border: 1px solid var(--ck-color-input-border);

				& > .ck.ck-input-color__button__preview__no-color-indicator {
					top: -30%;
					left: 50%;
					height: 150%;
					width: 8%;
					background: hsl(0, 100%, 50%);
					border-radius: 2px;
					transform: rotate(45deg);
					transform-origin: 50%;
				}
			}
		}
	}

	& .ck.ck-input-color__remove-color {
		width: 100%;
		padding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);

		border-bottom-left-radius: 0;
		border-bottom-right-radius: 0;

		&:not(:focus) {
			border-bottom: 1px solid var(--ck-color-input-border);
		}

		@mixin ck-dir ltr {
			border-top-right-radius: 0;
		}

		@mixin ck-dir rtl {
			border-top-left-radius: 0;
		}

		& .ck.ck-icon {
			margin-right: var(--ck-spacing-standard);

			@mixin ck-dir rtl {
				margin-right: 0;
				margin-left: var(--ck-spacing-standard);
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 4070: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/form.css"], names: [], mappings: "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form {
	padding: 0 0 var(--ck-spacing-large);

	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}

	& .ck.ck-input-text {
		min-width: 100%;
		width: 0;
	}

	& .ck.ck-dropdown {
		min-width: 100%;

		& .ck-dropdown__button {
			&:not(:focus) {
				border: 1px solid var(--ck-color-base-border);
			}

			& .ck-button__label {
				width: 100%;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 9247: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/formrow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css"], names: [], mappings: "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		flex-grow: 1;
	}

	&.ck-table-form__action-row {
		& .ck-button-save,
		& .ck-button-cancel {
			justify-content: center;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-form__row {
	padding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		& + * {
			@mixin ck-dir ltr {
				margin-left: var(--ck-spacing-large);
			}

			@mixin ck-dir rtl {
				margin-right: var(--ck-spacing-large);
			}
		}
	}

	& > .ck-label {
		width: 100%;
		min-width: 100%;
	}

	&.ck-table-form__action-row {
		margin-top: var(--ck-spacing-large);

		& .ck-button .ck-button__label {
			color: var(--ck-color-text);
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 1613: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/inserttable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"], names: [], mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-insert-table-dropdown__grid {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-insert-table-dropdown-padding: 10px;
	--ck-insert-table-dropdown-box-height: 11px;
	--ck-insert-table-dropdown-box-width: 12px;
	--ck-insert-table-dropdown-box-margin: 1px;
}

.ck .ck-insert-table-dropdown__grid {
	/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */
	width: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);
	padding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;
}

.ck .ck-insert-table-dropdown__label,
.ck[dir=rtl] .ck-insert-table-dropdown__label {
	text-align: center;
}

.ck .ck-insert-table-dropdown-grid-box {
	min-width: var(--ck-insert-table-dropdown-box-width);
	min-height: var(--ck-insert-table-dropdown-box-height);
	margin: var(--ck-insert-table-dropdown-box-margin);
	border: 1px solid var(--ck-color-base-border);
	border-radius: 1px;
	outline: none;
	transition: none;

	&:focus {
		box-shadow: none;
	}

	&.ck-on {
		border-color: var(--ck-color-focus-border);
		background: var(--ck-color-focus-outer-shadow);
	}
}

`], sourceRoot: "" }]);
      const A = f;
    }, 6306: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/table.css"], names: [], mappings: "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .table {
	/* Give the table widget some air and center it horizontally */
	/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
	margin: 0.9em auto;
	display: table;

	& table {
		/* The table cells should have slight borders */
		border-collapse: collapse;
		border-spacing: 0;

		/* Table width and height are set on the parent <figure>. Make sure the table inside stretches
		to the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */
		width: 100%;
		height: 100%;

		/* The outer border of the table should be slightly darker than the inner lines.
		Also see https://github.com/ckeditor/ckeditor5-table/issues/50. */
		border: 1px double hsl(0, 0%, 70%);

		& td,
		& th {
			min-width: 2em;
			padding: .4em;

			/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it's not necessary here.
			However, the border is a content style, so it should use .ck-content (so it works outside the editor).
			Hence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */
			border: 1px solid hsl(0, 0%, 75%);
		}

		& th {
			font-weight: bold;
			background: hsla(0, 0%, 0%, 5%);
		}
	}
}

/* Text alignment of the table header should match the editor settings and override the native browser styling,
when content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */
.ck-content[dir="rtl"] .table th {
	text-align: right;
}

.ck-content[dir="ltr"] .table th {
	text-align: left;
}

.ck-editor__editable .ck-table-bogus-paragraph {
	/*
	 * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.
	 * See https://github.com/ckeditor/ckeditor5/issues/6062.
	 */
	display: inline-block;

	/*
	 * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.
	 * See https://github.com/ckeditor/ckeditor5/issues/9117.
	 */
	width: 100%;
}
`], sourceRoot: "" }]);
      const A = f;
    }, 2128: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ":root{--ck-color-table-caption-background:#f7f7f7;--ck-color-table-caption-text:#333;--ck-color-table-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-table-caption-background);caption-side:top;color:var(--ck-color-table-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-table-caption-highlighted-background)}to{background-color:var(--ck-color-table-caption-background)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,oDACD,CAGA,8BAMC,yDAA0D,CAJ1D,gBAAiB,CAGjB,wCAAyC,CAJzC,qBAAsB,CAOtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,iBAAkB,CADlB,qBAOD,CAIC,qEACC,iDACD,CAEA,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAGD,sCACC,GACC,qEACD,CAEA,GACC,yDACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-table-caption-background: hsl(0, 0%, 97%);
	--ck-color-table-caption-text: hsl(0, 0%, 20%);
	--ck-color-table-caption-highlighted-background: hsl(52deg 100% 50%);
}

/* Content styles */
.ck-content .table > figcaption {
	display: table-caption;
	caption-side: top;
	word-break: break-word;
	text-align: center;
	color: var(--ck-color-table-caption-text);
	background-color: var(--ck-color-table-caption-background);
	padding: .6em;
	font-size: .75em;
	outline-offset: -1px;
}

/* Editing styles */
.ck.ck-editor__editable .table > figcaption {
	&.table__caption_highlighted {
		animation: ck-table-caption-highlight .6s ease-out;
	}

	&.ck-placeholder::before {
		padding-left: inherit;
		padding-right: inherit;

		/*
		 * Make sure the table caption placeholder doesn't overflow the placeholder area.
		 * See https://github.com/ckeditor/ckeditor5/issues/9162.
		 */
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}
}

@keyframes ck-table-caption-highlight {
	0% {
		background-color: var(--ck-color-table-caption-highlighted-background);
	}

	100% {
		background-color: var(--ck-color-table-caption-background);
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 5087: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecellproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css"], names: [], mappings: "AAOE,6FACC,cAiBD,CAdE,0HAEC,cACD,CAEA,yHAEC,cACD,CAEA,uHACC,WACD,CClBJ,kCACC,WAkBD,CAfE,2FACC,mBAAoB,CACpB,SAAU,CACV,SACD,CAGC,4GACC,eAAgB,CAGhB,qCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-cell-properties-form {
	& .ck-form__row {
		&.ck-table-cell-properties-form__alignment-row {
			flex-wrap: wrap;

			& .ck.ck-toolbar {
				&:first-of-type {
					/* 4 buttons out of 7 (h-alignment + v-alignment) = 0.57 */
					flex-grow: 0.57;
				}

				&:last-of-type {
					/* 3 buttons out of 7 (h-alignment + v-alignment) = 0.43 */
					flex-grow: 0.43;
				}

				& .ck-button {
					flex-grow: 1;
				}
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-cell-properties-form {
	width: 320px;

	& .ck-form__row {
		&.ck-table-cell-properties-form__padding-row {
			align-self: flex-end;
			padding: 0;
			width: 25%;
		}

		&.ck-table-cell-properties-form__alignment-row {
			& .ck.ck-toolbar {
				background: none;

				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */
				margin-top: var(--ck-spacing-standard);
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 4101: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ":root{--ck-color-table-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:-999999px;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:-999999px;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-table-column-resizer-hover);opacity:.25}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecolumnresize.css"], names: [], mappings: "AAKA,MACC,iEAAkE,CAClE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAEC,iBACD,CAEA,wDAOC,gBAAiB,CAGjB,iBAAkB,CATlB,iBAAkB,CAOlB,oDAAqD,CAFrD,aAAc,CAKd,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,2DAA4D,CAC5D,WACD,CAEA,iEACC,mDAAoD,CACpD,WACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-table-column-resizer-hover: var(--ck-color-base-active);
	--ck-table-column-resizer-width: 7px;

	/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.
	   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */
	--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);
}

.ck-content .table .ck-table-resized {
	table-layout: fixed;
}

.ck-content .table table {
	overflow: hidden;
}

.ck-content .table td,
.ck-content .table th {
	position: relative;
}

.ck.ck-editor__editable .table .ck-table-column-resizer {
	position: absolute;
	/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,
	   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as
	   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally
	   unrealistic height for a single table. */
	top: -999999px;
	bottom: -999999px;
	right: var(--ck-table-column-resizer-position-offset);
	width: var(--ck-table-column-resizer-width);
	cursor: col-resize;
	user-select: none;
	z-index: var(--ck-z-default);
}

.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {
	display: none;
}

/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,
   all resizers must be hidden while the table is dragged. */
.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {
	display: none;
}

.ck.ck-editor__editable .table .ck-table-column-resizer:hover,
.ck.ck-editor__editable .table .ck-table-column-resizer__active {
	background-color: var(--ck-color-table-column-resizer-hover);
	opacity: 0.25;
}

.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {
	left: var(--ck-table-column-resizer-position-offset);
	right: unset;
}
`], sourceRoot: "" }]);
      const A = f;
    }, 3881: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ":root{--ck-color-table-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"], names: [], mappings: "AAKA,MACC,6DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-table-focused-cell-background: hsla(212, 90%, 80%, .3);
}

.ck-widget.table {
	& td,
	& th {
		&.ck-editor__nested-editable.ck-editor__nested-editable_focused,
		&.ck-editor__nested-editable:focus {
			/* A very slight background to highlight the focused cell */
			background: var(--ck-color-table-focused-cell-background);

			/* Fixes the problem where surrounding cells cover the focused cell's border.
			It does not fix the problem in all places but the UX is improved.
			See https://github.com/ckeditor/ckeditor5-table/issues/29. */
			border-style: none;
			outline: 1px solid var(--ck-color-focus-border);
			outline-offset: -1px; /* progressive enhancement - no IE support */
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 6237: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCAyBD,CAvBC,8ECxCD,eDyDC,CAjBA,mMCpCA,qCDqDA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAUD,CAPC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-form {
	& .ck-form__row {
		&.ck-table-form__border-row {
			flex-wrap: wrap;
		}

		&.ck-table-form__background-row {
			flex-wrap: wrap;
		}

		&.ck-table-form__dimensions-row {
			flex-wrap: wrap;
			align-items: center;

			& .ck-labeled-field-view {
				display: flex;
				flex-direction: column-reverse;
				align-items: center;

				& .ck.ck-dropdown {
					flex-grow: 0;
				}
			}

			& .ck-table-form__dimension-operator {
				flex-grow: 0;
			}
		}
	}

	& .ck.ck-labeled-field-view {
		/* Allow absolute positioning of the status (error) balloons. */
		position: relative;

		& .ck.ck-labeled-field-view__status {
			position: absolute;
			left: 50%;
			bottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );
			transform: translate(-50%,100%);

			/* Make sure the balloon status stays on top of other form elements. */
			z-index: 1;

			/* The arrow pointing towards the field. */
			&::after {
				content: "";
				position: absolute;
				top: calc( -1 * var(--ck-table-properties-error-arrow-size) );
				left: 50%;
				transform: translateX( -50% );
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

:root {
	--ck-table-properties-error-arrow-size: 6px;
	--ck-table-properties-min-error-width: 150px;
}

.ck.ck-table-form {
	& .ck-form__row {
		&.ck-table-form__border-row {
			& .ck-labeled-field-view {
				& > .ck-label {
					font-size: var(--ck-font-size-tiny);
					text-align: center;
				}
			}

			& .ck-table-form__border-style,
			& .ck-table-form__border-width {
				width: 80px;
				min-width: 80px;
				max-width: 80px;
			}
		}

		&.ck-table-form__dimensions-row {
			padding: 0;

			& .ck-table-form__dimensions-row__width,
			& .ck-table-form__dimensions-row__height {
				margin: 0
			}

			& .ck-table-form__dimension-operator {
				align-self: flex-end;
				display: inline-block;
				height: var(--ck-ui-component-min-height);
				line-height: var(--ck-ui-component-min-height);
				margin: 0 var(--ck-spacing-small);
			}
		}
	}

	& .ck.ck-labeled-field-view {
		padding-top: var(--ck-spacing-standard);

		& .ck.ck-labeled-field-view__status {
			@mixin ck-rounded-corners;

			background: var(--ck-color-base-error);
			color: var(--ck-color-base-background);
			padding: var(--ck-spacing-small) var(--ck-spacing-medium);
			min-width: var(--ck-table-properties-min-error-width);
			text-align: center;

			/* The arrow pointing towards the field. */
			&::after {
				border-color: transparent transparent var(--ck-color-base-error) transparent;
				border-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);
				border-style: solid;
			}

			animation: ck-table-form-labeled-view-status-appear .15s ease both;
		}

		/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */
		& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {
			display: none;
		}
	}
}

@keyframes ck-table-form-labeled-view-status-appear {
	0% {
		opacity: 0;
	}

	100% {
		opacity: 1;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 7341: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tableproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css"], names: [], mappings: "AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-properties-form {
	& .ck-form__row {
		&.ck-table-properties-form__alignment-row {
			flex-wrap: wrap;
			flex-basis: 0;
			align-content: baseline;

			& .ck.ck-toolbar .ck-toolbar__items {
				flex-wrap: nowrap;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-properties-form {
	width: 320px;

	& .ck-form__row {
		&.ck-table-properties-form__alignment-row {
			align-self: flex-end;
			padding: 0;

			& .ck.ck-toolbar {
				background: none;

				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */
				margin-top: var(--ck-spacing-standard);

				& .ck-toolbar__items > * {
					width: 40px;
				}
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 6945: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"], names: [], mappings: "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);
}

.ck.ck-editor__editable .table table {
	& td.ck-editor__editable_selected,
	& th.ck-editor__editable_selected {
		position: relative;
		caret-color: transparent;
		outline: unset;
		box-shadow: unset;

		/* https://github.com/ckeditor/ckeditor5/issues/6446 */
		&:after {
			content: '';
			pointer-events: none;
			background-color: var(--ck-table-selected-cell-background);
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
		}

		& ::selection,
		&:focus {
			background-color: transparent;
		}

		/*
		 * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.
		 * See https://github.com/ckeditor/ckeditor5/issues/9491.
		 */
		& .ck-widget {
			outline: unset;

			& > .ck-widget__selection-handle {
				display: none;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 4906: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/button/button.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-unselectable;

	position: relative;
	display: inline-flex;
	align-items: center;
	justify-content: left;

	& .ck-button__label {
		display: none;
	}

	&.ck-button_with-text {
		& .ck-button__label {
			display: inline-block;
		}
	}

	/* Center the icon horizontally in a button without text. */
	&:not(.ck-button_with-text)  {
		justify-content: center;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../mixins/_button.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-button-colors --ck-color-button-default;
	@mixin ck-rounded-corners;

	white-space: nowrap;
	cursor: default;
	vertical-align: middle;
	padding: var(--ck-spacing-tiny);
	text-align: center;

	/* A very important piece of styling. Go to variable declaration to learn more. */
	min-width: var(--ck-ui-component-min-height);
	min-height: var(--ck-ui-component-min-height);

	/* Normalize the height of the line. Removing this will break consistent height
	among text and text-less buttons (with icons). */
	line-height: 1;

	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	/* Avoid flickering when the foucs border shows up. */
	border: 1px solid transparent;

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .2s ease-in-out, border .2s ease-in-out;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */
	-webkit-appearance: none;

	&:active,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	/* Allow icon coloring using the text "color" property. */
	& .ck-button__icon {
		& use,
		& use * {
			color: inherit;
		}
	}

	& .ck-button__label {
		/* Enable font size inheritance, which allows fluid UI scaling. */
		font-size: inherit;
		font-weight: inherit;
		color: inherit;
		cursor: inherit;

		/* Must be consistent with .ck-icon's vertical align. Otherwise, buttons with and
		without labels (but with icons) have different sizes in Chrome */
		vertical-align: middle;

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}
	}

	& .ck-button__keystroke {
		color: inherit;

		@mixin ck-dir ltr {
			margin-left: var(--ck-spacing-large);
		}

		@mixin ck-dir rtl {
			margin-right: var(--ck-spacing-large);
		}

		font-weight: bold;
		opacity: .7;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
	&.ck-disabled {
		&:active,
		&:focus {
			/* The disabled button should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}

		& .ck-button__icon {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
		& .ck-button__label {
			@mixin ck-disabled;
		}

		& .ck-button__keystroke {
			opacity: .3;
		}
	}

	&.ck-button_with-text {
		padding: var(--ck-spacing-tiny) var(--ck-spacing-standard);

		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__icon {
			@mixin ck-dir ltr {
				margin-left: calc(-1 * var(--ck-spacing-small));
				margin-right: var(--ck-spacing-small);
			}

			@mixin ck-dir rtl {
				margin-right: calc(-1 * var(--ck-spacing-small));
				margin-left: var(--ck-spacing-small);
			}
		}
	}

	&.ck-button_with-keystroke {
		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__label {
			flex-grow: 1;
		}
	}

	/* A style of the button which is currently on, e.g. its feature is active. */
	&.ck-on {
		@mixin ck-button-colors --ck-color-button-on;

		color: var(--ck-color-button-on-color);
	}

	&.ck-button-save {
		color: var(--ck-color-button-save);
	}

	&.ck-button-cancel {
		color: var(--ck-color-button-cancel);
	}
}

/* A style of the button which handles the primary action. */
.ck.ck-button-action,
a.ck.ck-button-action {
	@mixin ck-button-colors --ck-color-button-action;

	color: var(--ck-color-button-action-text);
}

.ck.ck-button-bold,
a.ck.ck-button-bold {
	font-weight: bold;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements a button of given background color.
 *
 * @param {String} $background - Background color of the button.
 * @param {String} $border - Border color of the button.
 */
@define-mixin ck-button-colors $prefix {
	background: var($(prefix)-background);

	&:not(.ck-disabled) {
		&:hover {
			background: var($(prefix)-hover-background);
		}

		&:active {
			background: var($(prefix)-active-background);
		}
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
	&.ck-disabled {
		background: var($(prefix)-disabled-background);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 6758: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-button.ck-switchbutton {
	& .ck-button__toggle {
		display: block;

		& .ck-button__toggle__inner {
			display: block;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature
of the component, floating–point numbers have been used which, for the default font size
(see: --ck-font-size-base), will generate simple integers. */
:root {
	/* 34px at 13px font-size */
	--ck-switch-button-toggle-width: 2.6153846154em;
	/* 14px at 13px font-size */
	--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);
	--ck-switch-button-translation: calc(
		var(--ck-switch-button-toggle-width) -
		var(--ck-switch-button-toggle-inner-size) -
		2px /* Border */
	);
	--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);
}

.ck.ck-button.ck-switchbutton {
	/* Unlike a regular button, the switch button text color and background should never change.
	 * Changing toggle switch (background, outline) is enough to carry the information about the
	 * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)
	 */
	&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {
		color: inherit;
		background: transparent;
	}

	& .ck-button__label {
		@mixin ck-dir ltr {
			/* Separate the label from the switch */
			margin-right: calc(2 * var(--ck-spacing-large));
		}

		@mixin ck-dir rtl {
			/* Separate the label from the switch */
			margin-left: calc(2 * var(--ck-spacing-large));
		}
	}

	& .ck-button__toggle {
		@mixin ck-rounded-corners;

		@mixin ck-dir ltr {
			/* Make sure the toggle is always to the right as far as possible. */
			margin-left: auto;
		}

		@mixin ck-dir rtl {
			/* Make sure the toggle is always to the left as far as possible. */
			margin-right: auto;
		}

		/* Apply some smooth transition to the box-shadow and border. */
		/* Gently animate the background color of the toggle switch */
		transition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;
		border: 1px solid transparent;
		width: var(--ck-switch-button-toggle-width);
		background: var(--ck-color-switch-button-off-background);

		& .ck-button__toggle__inner {
			@mixin ck-rounded-corners {
				border-radius: calc(.5 * var(--ck-border-radius));
			}

			width: var(--ck-switch-button-toggle-inner-size);
			height: var(--ck-switch-button-toggle-inner-size);
			background: var(--ck-color-switch-button-inner-background);

			/* Gently animate the inner part of the toggle switch */
			transition: all 300ms ease;
		}

		&:hover {
			background: var(--ck-color-switch-button-off-hover-background);

			& .ck-button__toggle__inner {
				box-shadow: var(--ck-switch-button-inner-hover-shadow);
			}
		}
	}

	&.ck-disabled .ck-button__toggle {
		@mixin ck-disabled;
	}

	/* Overriding default .ck-button:focus styles + an outline around the toogle */
	&:focus {
		border-color: transparent;
		outline: none;
		box-shadow: none;

		& .ck-button__toggle {
			box-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);
			outline-offset: 1px;
			outline: var(--ck-focus-ring);
		}
	}

	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-on {
		& .ck-button__toggle {
			background: var(--ck-color-switch-button-on-background);

			&:hover {
				background: var(--ck-color-switch-button-on-hover-background);
			}

			& .ck-button__toggle__inner {
				/*
				* Move the toggle switch to the right. It will be animated.
				*/
				@mixin ck-dir ltr {
					transform: translateX( var( --ck-switch-button-translation ) );
				}

				@mixin ck-dir rtl {
					transform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );
				}
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 6781: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"], names: [], mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-color-grid {
	display: grid;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-grid-tile-size: 24px;

	/* Not using global colors here because these may change but some colors in a pallette
	 * require special treatment. For instance, this ensures no matter what the UI text color is,
	 * the check icon will look good on the black color tile. */
	--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);
}

.ck.ck-color-grid {
	grid-gap: 5px;
	padding: 8px;
}

.ck.ck-color-grid__tile {
	width: var(--ck-color-grid-tile-size);
	height: var(--ck-color-grid-tile-size);
	min-width: var(--ck-color-grid-tile-size);
	min-height: var(--ck-color-grid-tile-size);
	padding: 0;
	transition: .2s ease box-shadow;
	border: 0;

	&.ck-disabled {
		cursor: unset;
		transition: unset;
	}

	&.ck-color-table__color-tile_bordered {
		box-shadow: 0 0 0 1px var(--ck-color-base-border);
	}

	& .ck.ck-icon {
		display: none;
		color: var(--ck-color-color-grid-check-icon);
	}

	&.ck-on {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);

		& .ck.ck-icon {
			display: block;
		}
	}

	&.ck-on,
	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		/* Disable the default .ck-button's border ring. */
		border: 0;
	}

	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);
	}
}

.ck.ck-color-grid__label {
	padding: 0 var(--ck-spacing-standard);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 3398: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-input{min-width:unset}.color-picker-hex-input{width:max-content}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/colorpicker/colorpicker.css"], names: [], mappings: "AAKA,aACC,eACD,CAEA,wBACC,iBACD,CAEA,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAMD,CAJC,qDAEC,sCAAuC,CADvC,kCAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-input {
	min-width: unset;
}

.color-picker-hex-input {
	width: max-content;
}

.ck.ck-color-picker__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;

	& .ck-color-picker__hash-view {
		padding-top: var(--ck-spacing-tiny);
		padding-right: var(--ck-spacing-medium);
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 5485: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-dropdown-max-width: 75vw;
}

.ck.ck-dropdown {
	display: inline-block;
	position: relative;

	& .ck-dropdown__arrow {
		pointer-events: none;
		z-index: var(--ck-z-default);
	}

	/* Dropdown button should span horizontally, e.g. in vertical toolbars */
	& .ck-button.ck-dropdown__button {
		width: 100%;
	}

	& .ck-dropdown__panel {
		display: none;
		z-index: var(--ck-z-modal);
		max-width: var(--ck-dropdown-max-width);

		position: absolute;

		&.ck-dropdown__panel-visible {
			display: inline-block;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_n,
		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_nme {
			bottom: 100%;
		}

		&.ck-dropdown__panel_se,
		&.ck-dropdown__panel_sw,
		&.ck-dropdown__panel_smw,
		&.ck-dropdown__panel_sme,
		&.ck-dropdown__panel_s {
			/*
			 * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.
			 * See https://github.com/ckeditor/ckeditor5/issues/1053.
			 */
			top: 100%;
			bottom: auto;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_se {
			left: 0px;
		}

		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_sw {
			right: 0px;
		}

		&.ck-dropdown__panel_s,
		&.ck-dropdown__panel_n {
			/* Positioning panels relative to the center of the button */
			left: 50%;
			transform: translateX(-50%);
		}

		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_smw {
			/* Positioning panels relative to the middle-west of the button */
			left: 75%;
			transform: translateX(-75%);
		}

		&.ck-dropdown__panel_nme,
		&.ck-dropdown__panel_sme {
			/* Positioning panels relative to the middle-east of the button */
			left: 25%;
			transform: translateX(-25%);
		}
	}
}

/*
 * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.
 * See https://github.com/ckeditor/ckeditor5/issues/7874
 */
.ck.ck-toolbar .ck-dropdown__panel {
	z-index: calc( var(--ck-z-modal) + 1 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-dropdown {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-dropdown__arrow {
		width: var(--ck-dropdown-arrow-size);
	}

	@mixin ck-dir ltr {
		& .ck-dropdown__arrow {
			right: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-dropdown__arrow {
			left: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-right: var(--ck-spacing-small);
		}
	}

	&.ck-disabled .ck-dropdown__arrow {
		@mixin ck-disabled;
	}

	& .ck-button.ck-dropdown__button {
		@mixin ck-dir ltr {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-left: var(--ck-spacing-small);
			}
		}

		@mixin ck-dir rtl {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-right: var(--ck-spacing-small);
			}
		}

		/* #23 */
		& .ck-button__label {
			width: 7em;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
		&.ck-disabled .ck-button__label {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/816 */
		&.ck-on {
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
		}

		&.ck-dropdown__button_label-width_auto .ck-button__label {
			width: auto;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/8699 */
		&.ck-off:active,
		&.ck-on:active {
			box-shadow: none;
			
			&:focus {
				@mixin ck-box-shadow var(--ck-focus-outer-shadow);
			}
		}
	}
}

.ck.ck-dropdown__panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	background: var(--ck-color-dropdown-panel-background);
	border: 1px solid var(--ck-color-dropdown-panel-border);
	bottom: 0;

	/* Make sure the panel is at least as wide as the drop-down's button. */
	min-width: 100%;

	/* Disabled corner border radius to be consistent with the .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-dropdown__panel_se {
		border-top-left-radius: 0;
	}

	&.ck-dropdown__panel_sw {
		border-top-right-radius: 0;
	}

	&.ck-dropdown__panel_ne {
		border-bottom-left-radius: 0;
	}

	&.ck-dropdown__panel_nw {
		border-bottom-right-radius: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 3949: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

.ck.ck-dropdown .ck-dropdown__panel .ck-list {
	/* Disabled radius of top-left border to be consistent with .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
	}

	/* Make sure the button belonging to the first/last child of the list goes well with the
	border radius of the entire panel. */
	& .ck-list__item {
		&:first-child .ck-button {
			@mixin ck-rounded-corners {
				border-top-left-radius: 0;
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}
		}

		&:last-child .ck-button {
			@mixin ck-rounded-corners {
				border-top-left-radius: 0;
				border-top-right-radius: 0;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 7686: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-splitbutton {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-splitbutton__action:focus {
		z-index: calc(var(--ck-z-default) + 1);
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-split-button-hover-background: hsl(0, 0%, 92%);
	--ck-color-split-button-hover-border: hsl(0, 0%, 70%);
}

.ck.ck-splitbutton {
	/*
	 * Note: ck-rounded and ck-dir mixins don't go together (because they both use @nest).
	 */
	&:hover > .ck-splitbutton__action,
	&.ck-splitbutton_open > .ck-splitbutton__action {
		@nest [dir="ltr"] & {
			/* Don't round the action button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the action button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}
	}

	& > .ck-splitbutton__arrow {
		/* It's a text-less button and since the icon is positioned absolutely in such situation,
		it must get some arbitrary min-width. */
		min-width: unset;

		@nest [dir="ltr"] & {
			/* Don't round the arrow button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the arrow button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		& svg {
			width: var(--ck-dropdown-arrow-size);
		}
	}

	/* Make sure the divider stretches 100% height of the button
	https://github.com/ckeditor/ckeditor5/issues/10936 */
	& > .ck-splitbutton__arrow:not(:focus) {
		border-top-width: 0px;
		border-bottom-width: 0px;
	}

	/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling
	as a whole. The background of both buttons should stand out and there should be a visual
	separation between both buttons. */
	&.ck-splitbutton_open,
	&:hover {
		/* When the split button hovered as a whole, not as individual buttons. */
		& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {
			background: var(--ck-color-split-button-hover-background);
		}

		/* Splitbutton separator needs to be set with the ::after pseudoselector
		to display properly the borders on focus */
		& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
			content: '';
			position: absolute;
			width: 1px;
			height: 100%;
			background-color: var(--ck-color-split-button-hover-border);
		}

		/* Make sure the divider between the buttons looks fine when the button is focused */
		& > .ck-splitbutton__arrow:focus::after {
			--ck-color-split-button-hover-border: var(--ck-color-focus-border);
		}

		@nest [dir="ltr"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				left: -1px;
			}
		}

		@nest [dir="rtl"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				right: -1px;
			}
		}
	}

	/* Don't round the bottom left and right corners of the buttons when "open"
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-splitbutton_open {
		@mixin ck-rounded-corners {
			& > .ck-splitbutton__action {
				border-bottom-left-radius: 0;
			}

			& > .ck-splitbutton__arrow {
				border-bottom-right-radius: 0;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 7339: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"], names: [], mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-toolbar-dropdown-max-width: 60vw;
}

.ck.ck-toolbar-dropdown > .ck-dropdown__panel {
	/* https://github.com/ckeditor/ckeditor5/issues/5586 */
	width: max-content;
	max-width: var(--ck-toolbar-dropdown-max-width);

	& .ck-button {
		&:focus {
			z-index: calc(var(--ck-z-default) + 1);
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-toolbar-dropdown .ck-toolbar {
	border: 0;
}
`], sourceRoot: "" }]);
      const A = f;
    }, 9688: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_focus.css";
@import "../../mixins/_button.css";

:root {
	--ck-color-editable-blur-selection: hsl(0, 0%, 85%);
}

.ck.ck-editor__editable:not(.ck-editor__nested-editable) {
	@mixin ck-rounded-corners;

	&.ck-focused {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);
	}
}

.ck.ck-editor__editable_inline {
	overflow: auto;
	padding: 0 var(--ck-spacing-standard);
	border: 1px solid transparent;

	&[dir="ltr"] {
		text-align: left;
	}

	&[dir="rtl"] {
		text-align: right;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */
	& > *:first-child {
		margin-top: var(--ck-spacing-large);
	}

	/* https://github.com/ckeditor/ckeditor5/issues/847 */
	& > *:last-child {
		/*
		 * This value should match with the default margins of the block elements (like .media or .image)
		 * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).
		 */
		margin-bottom: var(--ck-spacing-large);
	}

	/* https://github.com/ckeditor/ckeditor5/issues/6517 */
	&.ck-blurred ::selection {
		background: var(--ck-color-editable-blur-selection);
	}
}

/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */
.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {
	&::after {
		border-bottom-color: var(--ck-color-base-foreground);
	}
}

.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {
	&::after {
		border-top-color: var(--ck-color-base-foreground);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 8847: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"], names: [], mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form__header {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	align-items: center;
	justify-content: space-between;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-form-header-height: 38px;
}

.ck.ck-form__header {
	padding: var(--ck-spacing-small) var(--ck-spacing-large);
	height: var(--ck-form-header-height);
	line-height: var(--ck-form-header-height);
	border-bottom: 1px solid var(--ck-color-base-border);

	& .ck-form__header__label {
		font-weight: bold;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 6574: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/icon/icon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"], names: [], mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-icon {
	vertical-align: middle;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));
}

.ck.ck-icon {
	width: var(--ck-icon-size);
	height: var(--ck-icon-size);

	/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */
	font-size: .8333350694em;

	/* Inherit cursor style (#5). */
	cursor: inherit;

	/* This will prevent blurry icons on Firefox. See #340. */
	will-change: transform;

	& * {
		/* Inherit cursor style (#5). */
		cursor: inherit;
	}

	/* Allows dynamic coloring of an icon by inheriting its color from the parent. */
	&.ck-icon_inherit-color {
		color: inherit;

		& * {
			color: inherit;

			&:not([fill]) {
				/* Needed by FF. */
				fill: currentColor;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 4879: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-input-width: 18em;

	/* Backward compatibility. */
	--ck-input-text-width: var(--ck-input-width);
}

.ck.ck-input {
	@mixin ck-rounded-corners;

	background: var(--ck-color-input-background);
	border: 1px solid var(--ck-color-input-border);
	padding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);
	min-width: var(--ck-input-width);

	/* This is important to stay of the same height as surrounding buttons */
	min-height: var(--ck-ui-component-min-height);

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .1s ease-in-out, border .1s ease-in-out;

	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	&[readonly] {
		border: 1px solid var(--ck-color-input-disabled-border);
		background: var(--ck-color-input-disabled-background);
		color: var(--ck-color-input-disabled-text);

		&:focus {
			/* The read-only input should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}
	}

	&.ck-error {
		border-color: var(--ck-color-input-error-border);
		animation: ck-input-shake .3s ease both;

		&:focus {
			@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);
		}
	}
}

@keyframes ck-input-shake {
	20% {
		transform: translateX(-2px);
	}

	40% {
		transform: translateX(2px);
	}

	60% {
		transform: translateX(-1px);
	}

	80% {
		transform: translateX(1px);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 3662: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/label/label.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"], names: [], mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-label {
	display: block;
}

.ck.ck-voice-label {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-label {
	font-weight: bold;
}
`], sourceRoot: "" }]);
      const A = f;
    }, 2577: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-labeled-field-view {
	& > .ck.ck-labeled-field-view__input-wrapper {
		display: flex;
		position: relative;
	}

	& .ck.ck-label {
		display: block;
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../../../mixins/_rounded.css";

:root {
	--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);
	--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));
	--ck-color-labeled-field-label-background: var(--ck-color-base-background);
}

.ck.ck-labeled-field-view {
	@mixin ck-rounded-corners;

	& > .ck.ck-labeled-field-view__input-wrapper {
		width: 100%;

		& > .ck.ck-label {
			top: 0px;

			@mixin ck-dir ltr {
				left: 0px;
			}

			@mixin ck-dir rtl {
				right: 0px;
			}

			pointer-events: none;
			transform-origin: 0 0;

			/* By default, display the label scaled down above the field. */
			transform: translate(var(--ck-spacing-medium), -6px) scale(.75);

			background: var(--ck-color-labeled-field-label-background);
			padding: 0 calc(.5 * var(--ck-font-size-tiny));
			line-height: initial;
			font-weight: normal;

			/* Prevent overflow when the label is longer than the input */
			text-overflow: ellipsis;
			overflow: hidden;

			max-width: 100%;

			transition:
				transform var(--ck-labeled-field-view-transition),
				padding var(--ck-labeled-field-view-transition),
				background var(--ck-labeled-field-view-transition);
		}
	}

	&.ck-error {
		& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
			color: var(--ck-color-base-error);
		}

		& .ck-input:not([readonly]) + .ck.ck-label {
			color: var(--ck-color-base-error);
		}
	}

	& .ck-labeled-field-view__status {
		font-size: var(--ck-font-size-small);
		margin-top: var(--ck-spacing-small);

		/* Let the info wrap to the next line to avoid stretching the layout horizontally.
		The status could be very long. */
		white-space: normal;

		&.ck-labeled-field-view__status_error {
			color: var(--ck-color-base-error);
		}
	}

	/* Disabled fields and fields that have no focus should fade out. */
	&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		color: var(--ck-color-input-disabled-text);
	}

	/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */
	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		@mixin ck-dir ltr {
			transform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		@mixin ck-dir rtl {
			transform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		/* Compensate for the default translate position. */
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));

		background: transparent;
		padding: 0;
	}

	/*------ DropdownView integration ----------------------------------------------------------------------------------- */

	/* Make sure dropdown' background color in any of dropdown's state does not collide with labeled field. */
	& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {
		background: transparent;
	}

	/* When the dropdown is "empty", the labeled field label replaces its label. */
	&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {
		opacity: 0;
	}

	/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 1046: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/list/list.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-list {
	@mixin ck-unselectable;

	display: flex;
	flex-direction: column;

	& .ck-list__item,
	& .ck-list__separator {
		display: block;
	}

	/* Make sure that whatever child of the list item gets focus, it remains on the
	top. Thanks to that, styles like box-shadow, outline, etc. are not masked by
	adjacent list items. */
	& .ck-list__item > *:focus {
		position: relative;
		z-index: var(--ck-z-default);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";

.ck.ck-list {
	@mixin ck-rounded-corners;

	list-style-type: none;
	background: var(--ck-color-list-background);
}

.ck.ck-list__item {
	cursor: default;
	min-width: 12em;

	& .ck-button {
		min-height: unset;
		width: 100%;
		text-align: left;
		border-radius: 0;

		/* List items should have the same height. Use absolute units to make sure it is so
		   because e.g. different heading styles may have different height
		   https://github.com/ckeditor/ckeditor5-heading/issues/63 */
		padding:
			calc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))
			calc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));

		& .ck-button__label {
			/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */
			line-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));
		}

		&:active {
			box-shadow: none;
		}

		&.ck-on {
			background: var(--ck-color-list-button-on-background);
			color: var(--ck-color-list-button-on-text);

			&:active {
				box-shadow: none;
			}

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-on-background-focus);
			}

			&:focus:not(.ck-switchbutton):not(.ck-disabled) {
				border-color: var(--ck-color-base-background);
			}
		}

		&:hover:not(.ck-disabled) {
			background: var(--ck-color-list-button-hover-background);
		}
	}

	/* It's unnecessary to change the background/text of a switch toggle; it has different ways
	of conveying its state (like the switcher) */
	& .ck-switchbutton {
		&.ck-on {
			background: var(--ck-color-list-background);
			color: inherit;

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-hover-background);
				color: inherit;
			}
		}
	}
}

.ck.ck-list__separator {
	height: 1px;
	width: 100%;
	background: var(--ck-color-base-border);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 8793: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Make sure the balloon arrow does not float over its children. */
	--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);
}

.ck.ck-balloon-panel {
	display: none;
	position: absolute;

	z-index: var(--ck-z-modal);

	&.ck-balloon-panel_with-arrow {
		&::before,
		&::after {
			content: "";
			position: absolute;
		}

		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&[class*="arrow_n"] {
		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&[class*="arrow_s"] {
		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&.ck-balloon-panel_visible {
		display: block;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-balloon-border-width: 1px;
	--ck-balloon-arrow-offset: 2px;
	--ck-balloon-arrow-height: 10px;
	--ck-balloon-arrow-half-width: 8px;
	--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);
}

.ck.ck-balloon-panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	min-height: 15px;

	background: var(--ck-color-panel-background);
	border: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);

	&.ck-balloon-panel_with-arrow {
		&::before,
		&::after {
			width: 0;
			height: 0;
			border-style: solid;
		}
	}

	&[class*="arrow_n"] {
		&::before,
		&::after {
			border-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);
		}

		&::before {
			border-color: transparent transparent var(--ck-color-panel-border) transparent;
			margin-top: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent transparent var(--ck-color-panel-background) transparent;
			margin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_s"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);
		}

		&::before {
			border-color: var(--ck-color-panel-border) transparent transparent;
			filter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));
			margin-bottom: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: var(--ck-color-panel-background) transparent transparent transparent;
			margin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_e"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);
		}

		&::before {
			border-color: transparent transparent transparent var(--ck-color-panel-border);
			margin-right: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent transparent transparent var(--ck-color-panel-background);
			margin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_w"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;
		}

		&::before {
			border-color: transparent var(--ck-color-panel-border) transparent transparent;
			margin-left: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent var(--ck-color-panel-background) transparent transparent;
			margin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&.ck-balloon-panel_arrow_n {
		&::before,
		&::after {
			left: 50%;
			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nw {
		&::before,
		&::after {
			left: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_ne {
		&::before,
		&::after {
			right: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_s {
		&::before,
		&::after {
			left: 50%;
			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_sw {
		&::before,
		&::after {
			left: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_se {
		&::before,
		&::after {
			right: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_sme {
		&::before,
		&::after {
			right: 25%;
			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_smw {
		&::before,
		&::after {
			left: 25%;
			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nme {
		&::before,
		&::after {
			right: 25%;
			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nmw {
		&::before,
		&::after {
			left: 25%;
			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_e {
		&::before,
		&::after {
			right: calc(-1 * var(--ck-balloon-arrow-height));
			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: 50%;
		}
	}

	&.ck-balloon-panel_arrow_w {
		&::before,
		&::after {
			left: calc(-1 * var(--ck-balloon-arrow-height));
			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 4650: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"], names: [], mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-balloon-rotator__navigation {
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Buttons inside a toolbar should be centered when rotator bar is wider.
 * See: https://github.com/ckeditor/ckeditor5-ui/issues/495
 */
.ck .ck-balloon-rotator__content .ck-toolbar {
	justify-content: center;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-balloon-rotator__navigation {
	background: var(--ck-color-toolbar-background);
	border-bottom: 1px solid var(--ck-color-toolbar-border);
	padding: 0 var(--ck-spacing-small);

	/* Let's keep similar appearance to \`ck-toolbar\`. */
	& > * {
		margin-right: var(--ck-spacing-small);
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	/* Gives counter more breath than buttons. */
	& .ck-balloon-rotator__counter {
		margin-right: var(--ck-spacing-standard);

		/* We need to use smaller margin because of previous button's right margin. */
		margin-left: var(--ck-spacing-small);
	}
}

.ck .ck-balloon-rotator__content {

	/* Disable default annotation shadow inside rotator with fake panels. */
	& .ck.ck-annotation-wrapper {
		box-shadow: none;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 7676: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-fake-panel {
	position: absolute;

	/* Fake panels should be placed under main balloon content. */
	z-index: calc(var(--ck-z-modal) - 1);
}

.ck .ck-fake-panel div {
	position: absolute;
}

.ck .ck-fake-panel div:nth-child( 1 ) {
	z-index: 2;
}

.ck .ck-fake-panel div:nth-child( 2 ) {
	z-index: 1;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_shadow.css";

:root {
	--ck-balloon-fake-panel-offset-horizontal: 6px;
	--ck-balloon-fake-panel-offset-vertical: 6px;
}

/* Let's use \`.ck-balloon-panel\` appearance. See: balloonpanel.css. */
.ck .ck-fake-panel div {
	@mixin ck-drop-shadow;

	min-height: 15px;

	background: var(--ck-color-panel-background);
	border: 1px solid var(--ck-color-panel-border);
	border-radius: var(--ck-border-radius);

	width: 100%;
	height: 100%;
}

.ck .ck-fake-panel div:nth-child( 1 ) {
	margin-left: var(--ck-balloon-fake-panel-offset-horizontal);
	margin-top: var(--ck-balloon-fake-panel-offset-vertical);
}

.ck .ck-fake-panel div:nth-child( 2 ) {
	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);
	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);
}
.ck .ck-fake-panel div:nth-child( 3 ) {
	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);
	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);
}

/* If balloon is positioned above element, we need to move fake panel to the top. */
.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,
.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,
.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {
	--ck-balloon-fake-panel-offset-vertical: -6px;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 5868: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-sticky-panel {
	& .ck-sticky-panel__content_sticky {
		z-index: var(--ck-z-modal); /* #315 */
		position: fixed;
		top: 0;
	}

	& .ck-sticky-panel__content_sticky_bottom-limit {
		top: auto;
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_shadow.css";

.ck.ck-sticky-panel {
	& .ck-sticky-panel__content_sticky {
		@mixin ck-drop-shadow;

		border-width: 0 1px 1px;
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 6764: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"], names: [], mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck-vertical-form .ck-button {
	&::after {
		content: "";
		width: 0;
		position: absolute;
		right: -1px;
		top: -1px;
		bottom: -1px;
		z-index: 1;
	}

	&:focus::after {
		display: none;
	}
}

.ck.ck-responsive-form {
	@mixin ck-media-phone {
		& .ck-button {
			&::after {
				content: "";
				width: 0;
				position: absolute;
				right: -1px;
				top: -1px;
				bottom: -1px;
				z-index: 1;
			}

			&:focus::after {
				display: none;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck-vertical-form > .ck-button:nth-last-child(2)::after {
	border-right: 1px solid var(--ck-color-base-border);
}

.ck.ck-responsive-form {
	padding: var(--ck-spacing-large);

	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}

	@mixin ck-dir ltr {
		& > :not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& > :not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		padding: 0;
		width: calc(.8 * var(--ck-input-width));

		& .ck-labeled-field-view {
			margin: var(--ck-spacing-large) var(--ck-spacing-large) 0;

			& .ck-input-text {
				min-width: 0;
				width: 100%;
			}

			/* Let the long error messages wrap in the narrow form. */
			& .ck-labeled-field-view__error {
				white-space: normal;
			}
		}

		/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */
		& > .ck-button:nth-last-child(2) {
			&::after {
				border-right: 1px solid var(--ck-color-base-border);
			}
		}

		& > .ck-button:nth-last-child(1),
		& > .ck-button:nth-last-child(2) {
			padding: var(--ck-spacing-standard);
			margin-top: var(--ck-spacing-large);
			border-radius: 0;

			&:not(:focus) {
				border-top: 1px solid var(--ck-color-base-border);
			}

			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;

				&:last-of-type {
					border-right: 1px solid var(--ck-color-base-border);
				}
			}
		}
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 9695: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"], names: [], mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-block-toolbar-button {
	position: absolute;
	z-index: var(--ck-z-default);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-block-toolbar-button: var(--ck-color-text);
	--ck-block-toolbar-button-size: var(--ck-font-size-normal);
}

.ck.ck-block-toolbar-button {
	color: var(--ck-color-block-toolbar-button);
	font-size: var(--ck-block-toolbar-size);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 5542: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-toolbar {
	@mixin ck-unselectable;

	display: flex;
	flex-flow: row nowrap;
	align-items: center;

	& > .ck-toolbar__items {
		display: flex;
		flex-flow: row wrap;
		align-items: center;
		flex-grow: 1;

	}

	& .ck.ck-toolbar__separator {
		display: inline-block;

		/*
		 * A leading or trailing separator makes no sense (separates from nothing on one side).
		 * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and
		 * moved to another toolbar in the dropdown.
		 */
		&:first-child,
		&:last-child {
			display: none;
		}
	}

	& .ck-toolbar__line-break {
		flex-basis: 100%;
	}

	&.ck-toolbar_grouping > .ck-toolbar__items {
		flex-wrap: nowrap;
	}

	&.ck-toolbar_vertical > .ck-toolbar__items {
		flex-direction: column;
	}

	&.ck-toolbar_floating > .ck-toolbar__items {
		flex-wrap: nowrap;
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		& > .ck-dropdown__button .ck-dropdown__arrow {
			display: none;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-toolbar {
	@mixin ck-rounded-corners;

	background: var(--ck-color-toolbar-background);
	padding: 0 var(--ck-spacing-small);
	border: 1px solid var(--ck-color-toolbar-border);

	& .ck.ck-toolbar__separator {
		align-self: stretch;
		width: 1px;
		min-width: 1px;
		background: var(--ck-color-toolbar-border);

		/*
		 * These margins make the separators look better in balloon toolbars (when aligned with the "tip").
		 * See https://github.com/ckeditor/ckeditor5/issues/7493.
		 */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	& .ck-toolbar__line-break {
		height: 0;
	}

	& > .ck-toolbar__items {
		& > *:not(.ck-toolbar__line-break) {
			/* (#11) Separate toolbar items. */
			margin-right: var(--ck-spacing-small);
		}

		/* Don't display a separator after an empty items container, for instance,
		when all items were grouped */
		&:empty + .ck.ck-toolbar__separator {
			display: none;
		}
	}

	& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),
	& > .ck.ck-toolbar__grouped-dropdown {
		/* Make sure items wrapped to the next line have v-spacing */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	&.ck-toolbar_vertical {
		/* Items in a vertical toolbar span the entire width. */
		padding: 0;

		/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */
		& > .ck-toolbar__items > .ck {
			/* Items in a vertical toolbar should span the horizontal space. */
			width: 100%;

			/* Items in a vertical toolbar should have no margin. */
			margin: 0;

			/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */
			border-radius: 0;
		}
	}

	&.ck-toolbar_compact {
		/* No spacing around items. */
		padding: 0;

		& > .ck-toolbar__items > * {
			/* Compact toolbar items have no spacing between them. */
			margin: 0;

			/* "Middle" children should have no rounded corners. */
			&:not(:first-child):not(:last-child) {
				border-radius: 0;
			}
		}
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		/*
		 * Dropdown button has asymmetric padding to fit the arrow.
		 * This button has no arrow so let's revert that padding back to normal.
		 */
		& > .ck.ck-button.ck-dropdown__button {
			padding-left: var(--ck-spacing-tiny);
		}
	}

	/* A drop-down containing the nested toolbar with configured items. */
	& .ck-toolbar__nested-toolbar-dropdown {
		/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */
		& > .ck-dropdown__panel {
			min-width: auto;
		}

		& > .ck-button > .ck-button__label {
			max-width: 7em;
			width: auto;
		}
	}

	&:focus {
		outline: none;
	}

	@nest .ck-toolbar-container & {
		border: 0;
	}
}

/* stylelint-disable */

/*
 * Styles for RTL toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="rtl"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="rtl"] {
	& > .ck-toolbar__items > .ck {
		margin-right: 0;
	}

	&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {
		/* (#11) Separate toolbar items. */
		margin-left: var(--ck-spacing-small);
	}

	& > .ck-toolbar__items > .ck:last-child {
		margin-left: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-left: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-left: var(--ck-spacing-small);
	}
}

/*
 * Styles for LTR toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="ltr"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="ltr"] {
	& > .ck-toolbar__items > .ck:last-child {
		margin-right: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-right: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-right: var(--ck-spacing-small);
	}
}

/* stylelint-enable */
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 3332: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"], names: [], mappings: "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-balloon-panel.ck-tooltip {
	/* Keep tooltips transparent for any interactions. */
	pointer-events: none;

	z-index: calc( var(--ck-z-modal) + 100 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

.ck.ck-balloon-panel.ck-tooltip {
	--ck-balloon-border-width: 0px;
	--ck-balloon-arrow-offset: 0px;
	--ck-balloon-arrow-half-width: 4px;
	--ck-balloon-arrow-height: 4px;
	--ck-color-panel-background: var(--ck-color-tooltip-background);

	padding: 0 var(--ck-spacing-medium);

	& .ck-tooltip__text {
		font-size: .9em;
		line-height: 1.5;
		color: var(--ck-color-tooltip-text);
	}

	/* Reset balloon panel styles */
	box-shadow: none;

	/* Hide the default shadow of the .ck-balloon-panel tip */
	&::before {
		display: none;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 4793: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);border:0;box-shadow:none;min-height:unset}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/globals/_hidden.css", "webpack://./../ckeditor5-ui/theme/globals/_reset.css", "webpack://./../ckeditor5-ui/theme/globals/_zindex.css", "webpack://./../ckeditor5-ui/theme/globals/_transition.css", "webpack://./../ckeditor5-ui/theme/globals/_poweredby.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"], names: [], mappings: "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAItD,0CAA2C,CAF3C,QAAS,CACT,eAAgB,CAEhB,gBA6CD,CA3CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,2BAA4B,CAC5B,8CACD,CC5DD,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which hides an element in DOM.
 */
.ck-hidden {
	/* Override selector specificity. Otherwise, all elements with some display
	style defined will override this one, which is not a desired result. */
	display: none !important;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-reset,
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	box-sizing: border-box;
	width: auto;
	height: auto;
	position: static;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-z-default: 1;
	--ck-z-modal: calc( var(--ck-z-default) + 999 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class that disables all transitions of the element and its children.
 */
.ck-transitions-disabled,
.ck-transitions-disabled * {
	transition: none !important;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-powered-by-line-height: 10px;
	--ck-powered-by-padding-vertical: 2px;
	--ck-powered-by-padding-horizontal: 4px;
	--ck-powered-by-text-color: hsl(0, 0%, 31%);
	--ck-powered-by-border-radius: var(--ck-border-radius);
	--ck-powered-by-background: hsl(0, 0%, 100%);
	--ck-powered-by-border-color: var(--ck-color-focus-border);
}

.ck.ck-balloon-panel.ck-powered-by-balloon {
	--ck-border-radius: var(--ck-powered-by-border-radius);

	border: 0;
	box-shadow: none;
	background: var(--ck-powered-by-background);
	min-height: unset;

	& .ck.ck-powered-by {
		line-height: var(--ck-powered-by-line-height);

		& a {
			cursor: pointer;
			display: flex;
			align-items: center;
			opacity: .66;
			filter: grayscale(80%);
			line-height: var(--ck-powered-by-line-height);
			padding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);
		}

		& .ck-powered-by__label {
			font-size: 7.5px;
			letter-spacing: -.2px;
			padding-left: 2px;
			text-transform: uppercase;
			font-weight: bold;
			margin-right: 4px;
			cursor: pointer;
			line-height: normal;
			color: var(--ck-powered-by-text-color);

		}

		& .ck-icon {
			display: block;
			cursor: pointer;
		}

		&:hover {
			& a {
				filter: grayscale(0%);
				opacity: 1;
			}
		}
	}

	&[class*="position_border"] {
		border: var(--ck-focus-ring);
		border-color: var(--ck-powered-by-border-color);
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-base-foreground: 								hsl(0, 0%, 98%);
	--ck-color-base-background: 								hsl(0, 0%, 100%);
	--ck-color-base-border: 									hsl(220, 6%, 81%);
	--ck-color-base-action: 									hsl(104, 50.2%, 42.5%);
	--ck-color-base-focus: 										hsl(209, 92%, 70%);
	--ck-color-base-text: 										hsl(0, 0%, 20%);
	--ck-color-base-active: 									hsl(218.1, 100%, 58%);
	--ck-color-base-active-focus:								hsl(218.2, 100%, 52.5%);
	--ck-color-base-error:										hsl(15, 100%, 43%);

	/* -- Generic colors ------------------------------------------------------------------------ */

	--ck-color-focus-border-coordinates: 						218, 81.8%, 56.9%;
	--ck-color-focus-border: 									hsl(var(--ck-color-focus-border-coordinates));
	--ck-color-focus-outer-shadow:								hsl(212.4, 89.3%, 89%);
	--ck-color-focus-disabled-shadow:							hsla(209, 90%, 72%,.3);
	--ck-color-focus-error-shadow:								hsla(9,100%,56%,.3);
	--ck-color-text: 											var(--ck-color-base-text);
	--ck-color-shadow-drop: 									hsla(0, 0%, 0%, 0.15);
	--ck-color-shadow-drop-active:								hsla(0, 0%, 0%, 0.2);
	--ck-color-shadow-inner: 									hsla(0, 0%, 0%, 0.1);

	/* -- Buttons ------------------------------------------------------------------------------- */

	--ck-color-button-default-background: 						transparent;
	--ck-color-button-default-hover-background: 				hsl(0, 0%, 94.1%);
	--ck-color-button-default-active-background: 				hsl(0, 0%, 94.1%);
	--ck-color-button-default-disabled-background: 				transparent;

	--ck-color-button-on-background: 							hsl(212, 100%, 97.1%);
	--ck-color-button-on-hover-background: 						hsl(211.7, 100%, 92.9%);
	--ck-color-button-on-active-background: 					hsl(211.7, 100%, 92.9%);
	--ck-color-button-on-disabled-background: 					hsl(211, 15%, 95%);
	--ck-color-button-on-color:									hsl(218.1, 100%, 58%);


	--ck-color-button-action-background: 						var(--ck-color-base-action);
	--ck-color-button-action-hover-background: 					hsl(104, 53.2%, 40.2%);
	--ck-color-button-action-active-background: 				hsl(104, 53.2%, 40.2%);
	--ck-color-button-action-disabled-background: 				hsl(104, 44%, 58%);
	--ck-color-button-action-text: 								var(--ck-color-base-background);

	--ck-color-button-save: 									hsl(120, 100%, 27%);
	--ck-color-button-cancel: 									hsl(15, 100%, 43%);

	--ck-color-switch-button-off-background:					hsl(0, 0%, 57.6%);
	--ck-color-switch-button-off-hover-background:				hsl(0, 0%, 49%);
	--ck-color-switch-button-on-background:						var(--ck-color-button-action-background);
	--ck-color-switch-button-on-hover-background:				hsl(104, 53.2%, 40.2%);
	--ck-color-switch-button-inner-background:					var(--ck-color-base-background);
	--ck-color-switch-button-inner-shadow:						hsla(0, 0%, 0%, 0.1);

	/* -- Dropdown ------------------------------------------------------------------------------ */

	--ck-color-dropdown-panel-background: 						var(--ck-color-base-background);
	--ck-color-dropdown-panel-border: 							var(--ck-color-base-border);

	/* -- Input --------------------------------------------------------------------------------- */

	--ck-color-input-background: 								var(--ck-color-base-background);
	--ck-color-input-border: 									var(--ck-color-base-border);
	--ck-color-input-error-border:								var(--ck-color-base-error);
	--ck-color-input-text: 										var(--ck-color-base-text);
	--ck-color-input-disabled-background: 						hsl(0, 0%, 95%);
	--ck-color-input-disabled-border: 							var(--ck-color-base-border);
	--ck-color-input-disabled-text: 							hsl(0, 0%, 46%);

	/* -- List ---------------------------------------------------------------------------------- */

	--ck-color-list-background: 								var(--ck-color-base-background);
	--ck-color-list-button-hover-background: 					var(--ck-color-button-default-hover-background);
	--ck-color-list-button-on-background: 						var(--ck-color-button-on-color);
	--ck-color-list-button-on-background-focus: 				var(--ck-color-button-on-color);
	--ck-color-list-button-on-text:								var(--ck-color-base-background);

	/* -- Panel --------------------------------------------------------------------------------- */

	--ck-color-panel-background: 								var(--ck-color-base-background);
	--ck-color-panel-border: 									var(--ck-color-base-border);

	/* -- Toolbar ------------------------------------------------------------------------------- */

	--ck-color-toolbar-background: 								var(--ck-color-base-background);
	--ck-color-toolbar-border: 									var(--ck-color-base-border);

	/* -- Tooltip ------------------------------------------------------------------------------- */

	--ck-color-tooltip-background: 								var(--ck-color-base-text);
	--ck-color-tooltip-text: 									var(--ck-color-base-background);

	/* -- Engine -------------------------------------------------------------------------------- */

	--ck-color-engine-placeholder-text: 						hsl(0, 0%, 44%);

	/* -- Upload -------------------------------------------------------------------------------- */

	--ck-color-upload-bar-background:		 					hsl(209, 92%, 70%);

	/* -- Link -------------------------------------------------------------------------------- */

	--ck-color-link-default:									hsl(240, 100%, 47%);
	--ck-color-link-selected-background:						hsla(201, 100%, 56%, 0.1);
	--ck-color-link-fake-selection:								hsla(201, 100%, 56%, 0.3);

	/* -- Search result highlight ---------------------------------------------------------------- */

	--ck-color-highlight-background:							hsl(60, 100%, 50%)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * An opacity value of disabled UI item.
	 */
	--ck-disabled-opacity: .5;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * The geometry of the of focused element's outer shadow.
	 */
	--ck-focus-outer-shadow-geometry: 0 0 0 3px;

	/**
	 * A visual style of focused element's outer shadow.
	 */
	--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);

	/**
	 * A visual style of focused element's outer shadow (when disabled).
	 */
	--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);

	/**
	 * A visual style of focused element's outer shadow (when has errors).
	 */
	--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);

	/**
	 * A visual style of focused element's border or outline.
	 */
	--ck-focus-ring: 1px solid var(--ck-color-focus-border);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-font-size-base: 13px;
	--ck-line-height-base: 1.84615;
	--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;

	--ck-font-size-tiny: 0.7em;
	--ck-font-size-small: 0.75em;
	--ck-font-size-normal: 1em;
	--ck-font-size-big: 1.4em;
	--ck-font-size-large: 1.8em;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* This is super-important. This is **manually** adjusted so a button without an icon
	is never smaller than a button with icon, additionally making sure that text-less buttons
	are perfect squares. The value is also shared by other components which should stay "in-line"
	with buttons. */
	--ck-ui-component-min-height: 2.3em;
}

/**
 * Resets an element, ignoring its children.
 */
.ck.ck-reset,
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	/* Do not include inheritable rules here. */
	margin: 0;
	padding: 0;
	border: 0;
	background: transparent;
	text-decoration: none;
	vertical-align: middle;
	transition: none;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */
	word-wrap: break-word;
}

/**
 * Resets an element AND its children.
 */
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	/* These are rule inherited by all children elements. */
	border-collapse: collapse;
	font: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);
	color: var(--ck-color-text);
	text-align: left;
	white-space: nowrap;
	cursor: auto;
	float: none;
}

.ck-reset_all {
	& .ck-rtl *:not(.ck-reset_all-excluded *) {
		text-align: right;
	}

	& iframe:not(.ck-reset_all-excluded *) {
		/* For IE */
		vertical-align: inherit;
	}

	& textarea:not(.ck-reset_all-excluded *) {
		white-space: pre-wrap;
	}

	& textarea:not(.ck-reset_all-excluded *),
	& input[type="text"]:not(.ck-reset_all-excluded *),
	& input[type="password"]:not(.ck-reset_all-excluded *) {
		cursor: text;
	}

	& textarea[disabled]:not(.ck-reset_all-excluded *),
	& input[type="text"][disabled]:not(.ck-reset_all-excluded *),
	& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {
		cursor: default;
	}

	& fieldset:not(.ck-reset_all-excluded *) {
		padding: 10px;
		border: 2px groove hsl(255, 7%, 88%);
	}

	& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {
		/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */
		padding: 0;
		border: 0
	}
}

/**
 * Default UI rules for RTL languages.
 */
.ck[dir="rtl"],
.ck[dir="rtl"] .ck {
	text-align: right;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Default border-radius value.
 */
:root{
	--ck-border-radius: 2px;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * A visual style of element's inner shadow (i.e. input).
	 */
	--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;

	/**
	 * A visual style of element's drop shadow (i.e. panel).
	 */
	--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);

	/**
	 * A visual style of element's active shadow (i.e. comment or suggestion).
	 */
	--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-spacing-unit: 						0.6em;
	--ck-spacing-large: 					calc(var(--ck-spacing-unit) * 1.5);
	--ck-spacing-standard: 					var(--ck-spacing-unit);
	--ck-spacing-medium: 					calc(var(--ck-spacing-unit) * 0.8);
	--ck-spacing-small: 					calc(var(--ck-spacing-unit) * 0.5);
	--ck-spacing-tiny: 						calc(var(--ck-spacing-unit) * 0.3);
	--ck-spacing-extra-tiny: 				calc(var(--ck-spacing-unit) * 0.16);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 3488: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widget.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-resizer: var(--ck-color-focus-border);
	--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);
	--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);

	--ck-resizer-border-radius: var(--ck-border-radius);
	--ck-resizer-tooltip-offset: 10px;
	--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);
}

.ck .ck-widget {
	/* This is neccessary for type around UI to be positioned properly. */
	position: relative;
}

.ck .ck-widget.ck-widget_with-selection-handle {
	/* Make the widget wrapper a relative positioning container for the drag handle. */
	position: relative;

	& .ck-widget__selection-handle {
		position: absolute;

		& .ck-icon {
			/* Make sure the icon in not a subject to font-size or line-height to avoid
			unnecessary spacing around it. */
			display: block;
		}
	}

	/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */
	&:hover > .ck-widget__selection-handle {
		visibility: visible;
	}

	/* Show the selection handle when the widget is selected, but not for nested widgets. */
	&.ck-widget_selected > .ck-widget__selection-handle {
		visibility: visible;
	}
}

.ck .ck-size-view {
	background: var(--ck-color-resizer-tooltip-background);
	color: var(--ck-color-resizer-tooltip-text);
	border: 1px solid var(--ck-color-resizer-tooltip-text);
	border-radius: var(--ck-resizer-border-radius);
	font-size: var(--ck-font-size-tiny);
	display: block;
	padding: 0 var(--ck-spacing-small);
	height: var(--ck-resizer-tooltip-height);
	line-height: var(--ck-resizer-tooltip-height);

	&.ck-orientation-top-left,
	&.ck-orientation-top-right,
	&.ck-orientation-bottom-right,
	&.ck-orientation-bottom-left,
	&.ck-orientation-above-center {
		position: absolute;
	}

	&.ck-orientation-top-left {
		top: var(--ck-resizer-tooltip-offset);
		left: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-top-right {
		top: var(--ck-resizer-tooltip-offset);
		right: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-bottom-right {
		bottom: var(--ck-resizer-tooltip-offset);
		right: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-bottom-left {
		bottom: var(--ck-resizer-tooltip-offset);
		left: var(--ck-resizer-tooltip-offset);
	}

	/* Class applied if the widget is too small to contain the size label */
	&.ck-orientation-above-center {
		top: calc(var(--ck-resizer-tooltip-height) * -1);
		left: 50%;
		transform: translate(-50%);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";

:root {
	--ck-widget-outline-thickness: 3px;
	--ck-widget-handler-icon-size: 16px;
	--ck-widget-handler-animation-duration: 200ms;
	--ck-widget-handler-animation-curve: ease;

	--ck-color-widget-blurred-border: hsl(0, 0%, 87%);
	--ck-color-widget-hover-border: hsl(43, 100%, 62%);
	--ck-color-widget-editable-focus-background: var(--ck-color-base-background);
	--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);
}

.ck .ck-widget {
	outline-width: var(--ck-widget-outline-thickness);
	outline-style: solid;
	outline-color: transparent;
	transition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);
	}

	&:hover {
		outline-color: var(--ck-color-widget-hover-border);
	}
}

.ck .ck-editor__nested-editable {
	border: 1px solid transparent;

	/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.
	These styles show a different border for a blink of an eye, so \`:focus\` need to have same styles applied. */
	&.ck-editor__nested-editable_focused,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);

		background-color: var(--ck-color-widget-editable-focus-background);
	}
}

.ck .ck-widget.ck-widget_with-selection-handle {
	& .ck-widget__selection-handle {
		padding: 4px;
		box-sizing: border-box;

		/* Background and opacity will be animated as the handler shows up or the widget gets selected. */
		background-color: transparent;
		opacity: 0;

		/* Transition:
		   * background-color for the .ck-widget_selected state change,
		   * visibility for hiding the handler,
		   * opacity for the proper look of the icon when the handler disappears. */
		transition:
			background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),
			visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),
			opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		/* Make only top corners round. */
		border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;

		/* Place the drag handler outside the widget wrapper. */
		transform: translateY(-100%);
		left: calc(0px - var(--ck-widget-outline-thickness));
		top: 0;

		& .ck-icon {
			/* Make sure the dimensions of the icon are independent of the fon-size of the content. */
			width: var(--ck-widget-handler-icon-size);
			height: var(--ck-widget-handler-icon-size);
			color: var(--ck-color-widget-drag-handler-icon-color);

			/* The "selected" part of the icon is invisible by default */
			& .ck-icon__selected-indicator {
				opacity: 0;

				/* Note: The animation is longer on purpose. Simply feels better. */
				transition: opacity 300ms var(--ck-widget-handler-animation-curve);
			}
		}

		/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */
		&:hover .ck-icon .ck-icon__selected-indicator {
			opacity: 1;
		}
	}

	/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */
	&:hover > .ck-widget__selection-handle {
		opacity: 1;
		background-color: var(--ck-color-widget-hover-border);
	}

	/* Show the selection handler when the widget is selected, but not for nested widgets. */
	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		& > .ck-widget__selection-handle {
			opacity: 1;
			background-color: var(--ck-color-focus-border);

			/* When the widget is selected, notify the user using the proper look of the icon. */
			& .ck-icon .ck-icon__selected-indicator {
				opacity: 1;
			}
		}
	}
}

/* In a RTL environment, align the selection handler to the right side of the widget */
/* stylelint-disable-next-line no-descending-specificity */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {
	left: auto;
	right: calc(0px - var(--ck-widget-outline-thickness));
}

/* https://github.com/ckeditor/ckeditor5/issues/6415 */
.ck.ck-editor__editable.ck-read-only .ck-widget {
	/* Prevent the :hover outline from showing up because of the used outline-color transition. */
	transition: none;

	&:not(.ck-widget_selected) {
		/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.
		 * See: https://github.com/ckeditor/ckeditor5/issues/1261
		 *
		 * Leave the unit because this custom property is used in calc() by other features.
		 * See: https://github.com/ckeditor/ckeditor5/issues/6775
		 */
		--ck-widget-outline-thickness: 0px;
	}

	&.ck-widget_with-selection-handle {
		& .ck-widget__selection-handle,
		& .ck-widget__selection-handle:hover {
			background: var(--ck-color-widget-blurred-border);
		}
	}
}

/* Style the widget when it's selected but the editable it belongs to lost focus. */
/* stylelint-disable-next-line no-descending-specificity */
.ck.ck-editor__editable.ck-blurred .ck-widget {
	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		outline-color: var(--ck-color-widget-blurred-border);

		&.ck-widget_with-selection-handle {
			& > .ck-widget__selection-handle,
			& > .ck-widget__selection-handle:hover {
				background: var(--ck-color-widget-blurred-border);
			}
		}
	}
}

.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,
.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {
	/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.
	In fact, anything with overflow: hidden.
	https://github.com/ckeditor/ckeditor5-block-quote/issues/28
	https://github.com/ckeditor/ckeditor5-widget/issues/44
	https://github.com/ckeditor/ckeditor5-widget/issues/66 */
	margin-top: calc(1em + var(--ck-widget-handler-icon-size));
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`], sourceRoot: "" }]);
      const A = f;
    }, 8506: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widgetresize.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"], names: [], mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget_with-resizer {
	/* Make the widget wrapper a relative positioning container for the drag handle. */
	position: relative;
}

.ck .ck-widget__resizer {
	display: none;
	position: absolute;

	/* The wrapper itself should not interfere with the pointer device, only the handles should. */
	pointer-events: none;

	left: 0;
	top: 0;
}

.ck-focused .ck-widget_with-resizer.ck-widget_selected {
	& > .ck-widget__resizer {
		display: block;
	}
}

.ck .ck-widget__resizer__handle {
	position: absolute;

	/* Resizers are the only UI elements that should interfere with a pointer device. */
	pointer-events: all;

	&.ck-widget__resizer__handle-top-left,
	&.ck-widget__resizer__handle-bottom-right {
		cursor: nwse-resize;
	}

	&.ck-widget__resizer__handle-top-right,
	&.ck-widget__resizer__handle-bottom-left {
		cursor: nesw-resize;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-resizer-size: 10px;

	/* Set the resizer with a 50% offset. */
	--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);
	--ck-resizer-border-width: 1px;
}

.ck .ck-widget__resizer {
	outline: 1px solid var(--ck-color-resizer);
}

.ck .ck-widget__resizer__handle {
	width: var(--ck-resizer-size);
	height: var(--ck-resizer-size);
	background: var(--ck-color-focus-border);
	border: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);
	border-radius: var(--ck-resizer-border-radius);

	&.ck-widget__resizer__handle-top-left {
		top: var(--ck-resizer-offset);
		left: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-top-right {
		top: var(--ck-resizer-offset);
		right: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-bottom-right {
		bottom: var(--ck-resizer-offset);
		right: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-bottom-left {
		bottom: var(--ck-resizer-offset);
		left: var(--ck-resizer-offset);
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 4921: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widgettypearound.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"], names: [], mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		display: block;
		position: absolute;
		overflow: hidden;
		z-index: var(--ck-z-default);

		& svg {
			position: absolute;
			top: 50%;
			left: 50%;
			z-index: calc(var(--ck-z-default) + 2);
		}

		&.ck-widget__type-around__button_before {
			/* Place it in the middle of the outline */
			top: calc(-0.5 * var(--ck-widget-outline-thickness));
			left: min(10%, 30px);

			transform: translateY(-50%);
		}

		&.ck-widget__type-around__button_after {
			/* Place it in the middle of the outline */
			bottom: calc(-0.5 * var(--ck-widget-outline-thickness));
			right: min(10%, 30px);

			transform: translateY(50%);
		}
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		&::after {
			content: "";
			display: block;
			position: absolute;
			top: 1px;
			left: 1px;
			z-index: calc(var(--ck-z-default) + 1);
		}
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		display: none;
		position: absolute;
		left: 0;
		right: 0;
	}

	/*
	 * When the widget is hovered the "fake caret" would normally be narrower than the
	 * extra outline displayed around the widget. Let's extend the "fake caret" to match
	 * the full width of the widget.
	 */
	&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		left: calc( -1 * var(--ck-widget-outline-thickness) );
		right: calc( -1 * var(--ck-widget-outline-thickness) );
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		top: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		bottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}
}

/*
 * Integration with the read-only mode of the editor.
 */
.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the restricted editing mode (feature) of the editor.
 */
.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the #isEnabled property of the WidgetTypeAround plugin.
 */
.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-widget-type-around-button-size: 20px;
	--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);
	--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);
	--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);
	--ck-color-widget-type-around-button-radar-start-alpha: 0;
	--ck-color-widget-type-around-button-radar-end-alpha: .3;
	--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);
}

@define-mixin ck-widget-type-around-button-visible {
	opacity: 1;
	pointer-events: auto;
}

@define-mixin ck-widget-type-around-button-hidden {
	opacity: 0;
	pointer-events: none;
}

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		width: var(--ck-widget-type-around-button-size);
		height: var(--ck-widget-type-around-button-size);
		background: var(--ck-color-widget-type-around-button);
		border-radius: 100px;
		transition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		@mixin ck-widget-type-around-button-hidden;

		& svg {
			width: 10px;
			height: 8px;
			transform: translate(-50%,-50%);
			transition: transform .5s ease;
			margin-top: 1px;

			& * {
				stroke-dasharray: 10;
				stroke-dashoffset: 0;

				fill: none;
				stroke: var(--ck-color-widget-type-around-button-icon);
				stroke-width: 1.5px;
				stroke-linecap: round;
				stroke-linejoin: round;
			}

			& line {
				stroke-dasharray: 7;
			}
		}

		&:hover {
			/*
			 * Display the "sonar" around the button when hovered.
			 */
			animation: ck-widget-type-around-button-sonar 1s ease infinite;

			/*
			 * Animate active button's icon.
			 */
			& svg {
				& polyline {
					animation: ck-widget-type-around-arrow-dash 2s linear;
				}

				& line {
					animation: ck-widget-type-around-arrow-tip-dash 2s linear;
				}
			}
		}
	}

	/*
	 * Show type around buttons when the widget gets selected or being hovered.
	 */
	&.ck-widget_selected,
	&:hover {
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-visible;
		}
	}

	/*
	 * Styles for the buttons when the widget is NOT selected (but the buttons are visible
	 * and still can be hovered).
	 */
	&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {
		background: var(--ck-color-widget-type-around-button-hover);
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		background: var(--ck-color-widget-type-around-button-active);

		&::after {
			width: calc(var(--ck-widget-type-around-button-size) - 2px);
			height: calc(var(--ck-widget-type-around-button-size) - 2px);
			border-radius: 100px;
			background: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);
		}
	}

	/*
	 * Styles for the "before" button when the widget has a selection handle. Because some space
	 * is consumed by the handle, the button must be moved slightly to the right to let it breathe.
	 */
	&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {
		margin-left: 20px;
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& .ck-widget__type-around__fake-caret {
		pointer-events: none;
		height: 1px;
		animation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;

		/*
		 * The semi-transparent-outline+background combo improves the contrast
		 * when the background underneath the fake caret is dark.
		 */
		outline: solid 1px hsla(0, 0%, 100%, .5);
		background: var(--ck-color-base-text);
	}

	/*
	 * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).
	 * Despite the widget being physically selected in the model, its outline should disappear.
	 */
	&.ck-widget_selected {
		&.ck-widget_type-around_show-fake-caret_before,
		&.ck-widget_type-around_show-fake-caret_after {
			outline-color: transparent;
		}
	}

	&.ck-widget_type-around_show-fake-caret_before,
	&.ck-widget_type-around_show-fake-caret_after {
		/*
		 * When the "fake caret" is visible we simulate that the widget is not selected
		 * (despite being physically selected), so the outline color should be for the
		 * unselected widget.
		 */
		&.ck-widget_selected:hover {
			outline-color: var(--ck-color-widget-hover-border);
		}

		/*
		 * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).
		 * In this state, the type around buttons would collide with the fake carets so they should disappear.
		 */
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-hidden;
		}

		/*
		 * Fake horizontal caret integration with the selection handle. When the caret is visible, simply
		 * hide the handle because it intersects with the caret (and does not make much sense anyway).
		 */
		&.ck-widget_with-selection-handle {
			&.ck-widget_selected,
			&.ck-widget_selected:hover {
				& > .ck-widget__selection-handle {
					opacity: 0
				}
			}
		}

		/*
		 * Fake horizontal caret integration with the resize UI. When the caret is visible, simply
		 * hide the resize UI because it creates too much noise. It can be visible when the user
		 * hovers the widget, though.
		 */
		&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {
			opacity: 0
		}
	}
}

/*
 * Styles for the "before" button when the widget has a selection handle in an RTL environment.
 * The selection handler is aligned to the right side of the widget so there is no need to create
 * additional space for it next to the "before" button.
 */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {
	margin-left: 0;
	margin-right: 20px;
}

/*
 * Hide type around buttons when the widget is selected as a child of a selected
 * nested editable (e.g. mulit-cell table selection).
 *
 * See https://github.com/ckeditor/ckeditor5/issues/7263.
 */
.ck-editor__nested-editable.ck-editor__editable_selected {
	& .ck-widget {
		&.ck-widget_selected,
		&:hover {
			& > .ck-widget__type-around > .ck-widget__type-around__button {
				@mixin ck-widget-type-around-button-hidden;
			}
		}
	}
}

/*
 * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).
 */
.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {
	background: var(--ck-color-widget-type-around-button-blurred-editable);

	& svg * {
		stroke: hsl(0,0%,60%);
	}
}

@keyframes ck-widget-type-around-arrow-dash {
	0% {
		stroke-dashoffset: 10;
	}
	20%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-arrow-tip-dash {
	0%, 20% {
		stroke-dashoffset: 7;
	}
	40%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-button-sonar {
	0% {
		box-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
	50% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));
	}
	100% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
}

@keyframes ck-widget-type-around-fake-caret-pulse {
	0% {
		opacity: 1;
	}
	49% {
		opacity: 1;
	}
	50% {
		opacity: 0;
	}
	99% {
		opacity: 0;
	}
	100% {
		opacity: 1;
	}
}
`], sourceRoot: "" }]);
      const A = f;
    }, 2245: (k, S, m) => {
      m.d(S, { Z: () => A });
      var E = m(1799), x = m.n(E), v = m(2609), f = m.n(v)()(x());
      f.push([k.id, ".viur-txt-align--left{text-align:left}.viur-txt-align--right{text-align:right}.viur-txt-align--center{text-align:center}.viur-txt-align--justify{text-align:justify}.viur-txt-indent--1{margin-left:1em}.viur-txt-indent--2{margin-left:2em}.viur-txt-indent--3{margin-left:3em}.viur-txt-indent--4{margin-left:4em}.viur-txt-indent--5{margin-left:5em}.viur-txt-indent--6{margin-left:6em}.viur-txt-indent--7{margin-left:7em}.viur-txt-indent--8{margin-left:8em}.viur-txt-indent--9{margin-left:9em}.viur-txt-indent--10{margin-left:10em}", "", { version: 3, sources: ["webpack://./../viur/theme.css"], names: [], mappings: "AAKA,sBACC,eACD,CACA,uBACC,gBACD,CACA,wBACC,iBACD,CACA,yBACC,kBACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,oBACC,eACD,CACA,qBACC,gBACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.viur-txt-align--left{
	text-align: left;
}
.viur-txt-align--right{
	text-align: right;
}
.viur-txt-align--center{
	text-align: center;
}
.viur-txt-align--justify{
	text-align: justify;
}
.viur-txt-indent--1{
	margin-left: 1em;
}
.viur-txt-indent--2{
	margin-left: 2em;
}
.viur-txt-indent--3{
	margin-left: 3em;
}
.viur-txt-indent--4{
	margin-left: 4em;
}
.viur-txt-indent--5{
	margin-left: 5em;
}
.viur-txt-indent--6{
	margin-left: 6em;
}
.viur-txt-indent--7{
	margin-left: 7em;
}
.viur-txt-indent--8{
	margin-left: 8em;
}
.viur-txt-indent--9{
	margin-left: 9em;
}
.viur-txt-indent--10{
	margin-left: 10em;
}

`], sourceRoot: "" }]);
      const A = f;
    }, 2609: (k) => {
      k.exports = function(S) {
        var m = [];
        return m.toString = function() {
          return this.map(function(E) {
            var x = S(E);
            return E[2] ? "@media ".concat(E[2], " {").concat(x, "}") : x;
          }).join("");
        }, m.i = function(E, x, v) {
          typeof E == "string" && (E = [[null, E, ""]]);
          var f = {};
          if (v) for (var A = 0; A < this.length; A++) {
            var P = this[A][0];
            P != null && (f[P] = !0);
          }
          for (var B = 0; B < E.length; B++) {
            var R = [].concat(E[B]);
            v && f[R[0]] || (x && (R[2] ? R[2] = "".concat(x, " and ").concat(R[2]) : R[2] = x), m.push(R));
          }
        }, m;
      };
    }, 1799: (k) => {
      function S(E, x) {
        return function(v) {
          if (Array.isArray(v)) return v;
        }(E) || function(v, f) {
          var A = v && (typeof Symbol < "u" && v[Symbol.iterator] || v["@@iterator"]);
          if (A != null) {
            var P, B, R = [], N = !0, j = !1;
            try {
              for (A = A.call(v); !(N = (P = A.next()).done) && (R.push(P.value), !f || R.length !== f); N = !0) ;
            } catch (q) {
              j = !0, B = q;
            } finally {
              try {
                N || A.return == null || A.return();
              } finally {
                if (j) throw B;
              }
            }
            return R;
          }
        }(E, x) || function(v, f) {
          if (v) {
            if (typeof v == "string") return m(v, f);
            var A = Object.prototype.toString.call(v).slice(8, -1);
            if (A === "Object" && v.constructor && (A = v.constructor.name), A === "Map" || A === "Set") return Array.from(v);
            if (A === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(A)) return m(v, f);
          }
        }(E, x) || function() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }();
      }
      function m(E, x) {
        (x == null || x > E.length) && (x = E.length);
        for (var v = 0, f = new Array(x); v < x; v++) f[v] = E[v];
        return f;
      }
      k.exports = function(E) {
        var x = S(E, 4), v = x[1], f = x[3];
        if (!f) return v;
        if (typeof btoa == "function") {
          var A = btoa(unescape(encodeURIComponent(JSON.stringify(f)))), P = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(A), B = "/*# ".concat(P, " */"), R = f.sources.map(function(N) {
            return "/*# sourceURL=".concat(f.sourceRoot || "").concat(N, " */");
          });
          return [v].concat(R).concat([B]).join(`
`);
        }
        return [v].join(`
`);
      };
    }, 6062: (k, S, m) => {
      var E, x = function() {
        return E === void 0 && (E = !!(window && document && document.all && !window.atob)), E;
      }, v = /* @__PURE__ */ function() {
        var Y = {};
        return function(ne) {
          if (Y[ne] === void 0) {
            var T = document.querySelector(ne);
            if (window.HTMLIFrameElement && T instanceof window.HTMLIFrameElement) try {
              T = T.contentDocument.head;
            } catch {
              T = null;
            }
            Y[ne] = T;
          }
          return Y[ne];
        };
      }(), f = [];
      function A(Y) {
        for (var ne = -1, T = 0; T < f.length; T++) if (f[T].identifier === Y) {
          ne = T;
          break;
        }
        return ne;
      }
      function P(Y, ne) {
        for (var T = {}, ee = [], Te = 0; Te < Y.length; Te++) {
          var Me = Y[Te], Le = ne.base ? Me[0] + ne.base : Me[0], en = T[Le] || 0, Bt = "".concat(Le, " ").concat(en);
          T[Le] = en + 1;
          var Tt = A(Bt), Hn = { css: Me[1], media: Me[2], sourceMap: Me[3] };
          Tt !== -1 ? (f[Tt].references++, f[Tt].updater(Hn)) : f.push({ identifier: Bt, updater: se(Hn, ne), references: 1 }), ee.push(Bt);
        }
        return ee;
      }
      function B(Y) {
        var ne = document.createElement("style"), T = Y.attributes || {};
        if (T.nonce === void 0) {
          var ee = m.nc;
          ee && (T.nonce = ee);
        }
        if (Object.keys(T).forEach(function(Me) {
          ne.setAttribute(Me, T[Me]);
        }), typeof Y.insert == "function") Y.insert(ne);
        else {
          var Te = v(Y.insert || "head");
          if (!Te) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          Te.appendChild(ne);
        }
        return ne;
      }
      var R, N = (R = [], function(Y, ne) {
        return R[Y] = ne, R.filter(Boolean).join(`
`);
      });
      function j(Y, ne, T, ee) {
        var Te = T ? "" : ee.media ? "@media ".concat(ee.media, " {").concat(ee.css, "}") : ee.css;
        if (Y.styleSheet) Y.styleSheet.cssText = N(ne, Te);
        else {
          var Me = document.createTextNode(Te), Le = Y.childNodes;
          Le[ne] && Y.removeChild(Le[ne]), Le.length ? Y.insertBefore(Me, Le[ne]) : Y.appendChild(Me);
        }
      }
      function q(Y, ne, T) {
        var ee = T.css, Te = T.media, Me = T.sourceMap;
        if (Te ? Y.setAttribute("media", Te) : Y.removeAttribute("media"), Me && typeof btoa < "u" && (ee += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(Me)))), " */")), Y.styleSheet) Y.styleSheet.cssText = ee;
        else {
          for (; Y.firstChild; ) Y.removeChild(Y.firstChild);
          Y.appendChild(document.createTextNode(ee));
        }
      }
      var Z = null, Q = 0;
      function se(Y, ne) {
        var T, ee, Te;
        if (ne.singleton) {
          var Me = Q++;
          T = Z || (Z = B(ne)), ee = j.bind(null, T, Me, !1), Te = j.bind(null, T, Me, !0);
        } else T = B(ne), ee = q.bind(null, T, ne), Te = function() {
          (function(Le) {
            if (Le.parentNode === null) return !1;
            Le.parentNode.removeChild(Le);
          })(T);
        };
        return ee(Y), function(Le) {
          if (Le) {
            if (Le.css === Y.css && Le.media === Y.media && Le.sourceMap === Y.sourceMap) return;
            ee(Y = Le);
          } else Te();
        };
      }
      k.exports = function(Y, ne) {
        (ne = ne || {}).singleton || typeof ne.singleton == "boolean" || (ne.singleton = x());
        var T = P(Y = Y || [], ne);
        return function(ee) {
          if (ee = ee || [], Object.prototype.toString.call(ee) === "[object Array]") {
            for (var Te = 0; Te < T.length; Te++) {
              var Me = A(T[Te]);
              f[Me].references--;
            }
            for (var Le = P(ee, ne), en = 0; en < T.length; en++) {
              var Bt = A(T[en]);
              f[Bt].references === 0 && (f[Bt].updater(), f.splice(Bt, 1));
            }
            T = Le;
          }
        };
      };
    } }, O = {};
    function D(k) {
      var S = O[k];
      if (S !== void 0) return S.exports;
      var m = O[k] = { id: k, exports: {} };
      return _[k](m, m.exports, D), m.exports;
    }
    D.n = (k) => {
      var S = k && k.__esModule ? () => k.default : () => k;
      return D.d(S, { a: S }), S;
    }, D.d = (k, S) => {
      for (var m in S) D.o(S, m) && !D.o(k, m) && Object.defineProperty(k, m, { enumerable: !0, get: S[m] });
    }, D.g = function() {
      if (typeof globalThis == "object") return globalThis;
      try {
        return this || new Function("return this")();
      } catch {
        if (typeof window == "object") return window;
      }
    }(), D.o = (k, S) => Object.prototype.hasOwnProperty.call(k, S), D.nc = void 0;
    var M = {};
    return (() => {
      function k({ emitter: o, activator: e, callback: t, contextElements: n }) {
        o.listenTo(document, "mousedown", (i, r) => {
          if (!e()) return;
          const s = typeof r.composedPath == "function" ? r.composedPath() : [], a = typeof n == "function" ? n() : n;
          for (const l of a) if (l.contains(r.target) || s.includes(l)) return;
          t();
        });
      }
      function S(o) {
        return class extends o {
          disableCssTransitions() {
            this._isCssTransitionsDisabled = !0;
          }
          enableCssTransitions() {
            this._isCssTransitionsDisabled = !1;
          }
          constructor(...e) {
            super(...e), this.set("_isCssTransitionsDisabled", !1), this.initializeCssTransitionDisablerMixin();
          }
          initializeCssTransitionDisablerMixin() {
            this.extendTemplate({ attributes: { class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")] } });
          }
        };
      }
      function m({ view: o }) {
        o.listenTo(o.element, "submit", (e, t) => {
          t.preventDefault(), o.fire("submit");
        }, { useCapture: !0 });
      }
      D.d(M, { default: () => sl });
      const E = function() {
        try {
          return navigator.userAgent.toLowerCase();
        } catch {
          return "";
        }
      }(), x = { isMac: A(E), isWindows: (v = E, v.indexOf("windows") > -1), isGecko: function(o) {
        return !!o.match(/gecko\/\d+/);
      }(E), isSafari: function(o) {
        return o.indexOf(" applewebkit/") > -1 && o.indexOf("chrome") === -1;
      }(E), isiOS: function(o) {
        return !!o.match(/iphone|ipad/i) || A(o) && navigator.maxTouchPoints > 0;
      }(E), isAndroid: function(o) {
        return o.indexOf("android") > -1;
      }(E), isBlink: function(o) {
        return o.indexOf("chrome/") > -1 && o.indexOf("edge/") < 0;
      }(E), features: { isRegExpUnicodePropertySupported: function() {
        let o = !1;
        try {
          o = "ć".search(new RegExp("[\\p{L}]", "u")) === 0;
        } catch {
        }
        return o;
      }() } };
      var v;
      const f = x;
      function A(o) {
        return o.indexOf("macintosh") > -1;
      }
      function P(o, e, t, n) {
        t = t || function(l, c) {
          return l === c;
        };
        const i = Array.isArray(o) ? o : Array.prototype.slice.call(o), r = Array.isArray(e) ? e : Array.prototype.slice.call(e), s = function(l, c, d) {
          const u = B(l, c, d);
          if (u === -1) return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
          const g = R(l, u), p = R(c, u), b = B(g, p, d), w = l.length - b, y = c.length - b;
          return { firstIndex: u, lastIndexOld: w, lastIndexNew: y };
        }(i, r, t);
        return n ? function(l, c) {
          const { firstIndex: d, lastIndexOld: u, lastIndexNew: g } = l;
          if (d === -1) return Array(c).fill("equal");
          let p = [];
          return d > 0 && (p = p.concat(Array(d).fill("equal"))), g - d > 0 && (p = p.concat(Array(g - d).fill("insert"))), u - d > 0 && (p = p.concat(Array(u - d).fill("delete"))), g < c && (p = p.concat(Array(c - g).fill("equal"))), p;
        }(s, r.length) : function(l, c) {
          const d = [], { firstIndex: u, lastIndexOld: g, lastIndexNew: p } = c;
          return p - u > 0 && d.push({ index: u, type: "insert", values: l.slice(u, p) }), g - u > 0 && d.push({ index: u + (p - u), type: "delete", howMany: g - u }), d;
        }(r, s);
      }
      function B(o, e, t) {
        for (let n = 0; n < Math.max(o.length, e.length); n++) if (o[n] === void 0 || e[n] === void 0 || !t(o[n], e[n])) return n;
        return -1;
      }
      function R(o, e) {
        return o.slice(e).reverse();
      }
      function N(o, e, t) {
        t = t || function(w, y) {
          return w === y;
        };
        const n = o.length, i = e.length;
        if (n > 200 || i > 200 || n + i > 300) return N.fastDiff(o, e, t, !0);
        let r, s;
        if (i < n) {
          const w = o;
          o = e, e = w, r = "delete", s = "insert";
        } else r = "insert", s = "delete";
        const a = o.length, l = e.length, c = l - a, d = {}, u = {};
        function g(w) {
          const y = (u[w - 1] !== void 0 ? u[w - 1] : -1) + 1, I = u[w + 1] !== void 0 ? u[w + 1] : -1, z = y > I ? -1 : 1;
          d[w + z] && (d[w] = d[w + z].slice(0)), d[w] || (d[w] = []), d[w].push(y > I ? r : s);
          let H = Math.max(y, I), X = H - w;
          for (; X < a && H < l && t(o[X], e[H]); ) X++, H++, d[w].push("equal");
          return H;
        }
        let p, b = 0;
        do {
          for (p = -b; p < c; p++) u[p] = g(p);
          for (p = c + b; p > c; p--) u[p] = g(p);
          u[c] = g(c), b++;
        } while (u[c] !== l);
        return d[c].slice(1);
      }
      N.fastDiff = P;
      const j = function() {
        return function o() {
          o.called = !0;
        };
      };
      class q {
        constructor(e, t) {
          this.source = e, this.name = t, this.path = [], this.stop = j(), this.off = j();
        }
      }
      const Z = new Array(256).fill("").map((o, e) => ("0" + e.toString(16)).slice(-2));
      function Q() {
        const o = 4294967296 * Math.random() >>> 0, e = 4294967296 * Math.random() >>> 0, t = 4294967296 * Math.random() >>> 0, n = 4294967296 * Math.random() >>> 0;
        return "e" + Z[o >> 0 & 255] + Z[o >> 8 & 255] + Z[o >> 16 & 255] + Z[o >> 24 & 255] + Z[e >> 0 & 255] + Z[e >> 8 & 255] + Z[e >> 16 & 255] + Z[e >> 24 & 255] + Z[t >> 0 & 255] + Z[t >> 8 & 255] + Z[t >> 16 & 255] + Z[t >> 24 & 255] + Z[n >> 0 & 255] + Z[n >> 8 & 255] + Z[n >> 16 & 255] + Z[n >> 24 & 255];
      }
      const se = { get(o = "normal") {
        return typeof o != "number" ? this[o] || this.normal : o;
      }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5 };
      function Y(o, e) {
        const t = se.get(e.priority);
        for (let n = 0; n < o.length; n++) if (se.get(o[n].priority) < t) return void o.splice(n, 0, e);
        o.push(e);
      }
      const ne = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
      class T extends Error {
        constructor(e, t, n) {
          super(function(i, r) {
            const s = /* @__PURE__ */ new WeakSet(), a = (d, u) => {
              if (typeof u == "object" && u !== null) {
                if (s.has(u)) return `[object ${u.constructor.name}]`;
                s.add(u);
              }
              return u;
            }, l = r ? ` ${JSON.stringify(r, a)}` : "", c = Te(i);
            return i + l + c;
          }(e, n)), this.name = "CKEditorError", this.context = t, this.data = n;
        }
        is(e) {
          return e === "CKEditorError";
        }
        static rethrowUnexpectedError(e, t) {
          if (e.is && e.is("CKEditorError")) throw e;
          const n = new T(e.message, t);
          throw n.stack = e.stack, n;
        }
      }
      function ee(o, e) {
        console.warn(...Me(o, e));
      }
      function Te(o) {
        return `
Read more: ${ne}#error-${o}`;
      }
      function Me(o, e) {
        const t = Te(o);
        return e ? [o, e, t] : [o, t];
      }
      const Le = "38.0.1", en = new Date(2023, 4, 23), Bt = typeof window == "object" ? window : D.g;
      if (Bt.CKEDITOR_VERSION) throw new T("ckeditor-duplicated-modules", null);
      Bt.CKEDITOR_VERSION = Le;
      const Tt = Symbol("listeningTo"), Hn = Symbol("emitterId"), jt = Symbol("delegations"), bl = _e(Object);
      function _e(o) {
        return o ? class extends o {
          on(e, t, n) {
            this.listenTo(this, e, t, n);
          }
          once(e, t, n) {
            let i = !1;
            this.listenTo(this, e, (r, ...s) => {
              i || (i = !0, r.off(), t.call(this, r, ...s));
            }, n);
          }
          off(e, t) {
            this.stopListening(this, e, t);
          }
          listenTo(e, t, n, i = {}) {
            let r, s;
            this[Tt] || (this[Tt] = {});
            const a = this[Tt];
            Ir(e) || kl(e);
            const l = Ir(e);
            (r = a[l]) || (r = a[l] = { emitter: e, callbacks: {} }), (s = r.callbacks[t]) || (s = r.callbacks[t] = []), s.push(n), function(c, d, u, g, p) {
              d._addEventListener ? d._addEventListener(u, g, p) : c._addEventListener.call(d, u, g, p);
            }(this, e, t, n, i);
          }
          stopListening(e, t, n) {
            const i = this[Tt];
            let r = e && Ir(e);
            const s = i && r ? i[r] : void 0, a = s && t ? s.callbacks[t] : void 0;
            if (!(!i || e && !s || t && !a)) if (n)
              Rr(this, e, t, n), a.indexOf(n) !== -1 && (a.length === 1 ? delete s.callbacks[t] : Rr(this, e, t, n));
            else if (a) {
              for (; n = a.pop(); ) Rr(this, e, t, n);
              delete s.callbacks[t];
            } else if (s) {
              for (t in s.callbacks) this.stopListening(e, t);
              delete i[r];
            } else {
              for (r in i) this.stopListening(i[r].emitter);
              delete this[Tt];
            }
          }
          fire(e, ...t) {
            try {
              const n = e instanceof q ? e : new q(this, e), i = n.name;
              let r = Al(this, i);
              if (n.path.push(this), r) {
                const a = [n, ...t];
                r = Array.from(r);
                for (let l = 0; l < r.length && (r[l].callback.apply(this, a), n.off.called && (delete n.off.called, this._removeEventListener(i, r[l].callback)), !n.stop.called); l++) ;
              }
              const s = this[jt];
              if (s) {
                const a = s.get(i), l = s.get("*");
                a && _l(a, n, t), l && _l(l, n, t);
              }
              return n.return;
            } catch (n) {
              T.rethrowUnexpectedError(n, this);
            }
          }
          delegate(...e) {
            return { to: (t, n) => {
              this[jt] || (this[jt] = /* @__PURE__ */ new Map()), e.forEach((i) => {
                const r = this[jt].get(i);
                r ? r.set(t, n) : this[jt].set(i, /* @__PURE__ */ new Map([[t, n]]));
              });
            } };
          }
          stopDelegating(e, t) {
            if (this[jt]) if (e) if (t) {
              const n = this[jt].get(e);
              n && n.delete(t);
            } else this[jt].delete(e);
            else this[jt].clear();
          }
          _addEventListener(e, t, n) {
            (function(s, a) {
              const l = wl(s);
              if (l[a]) return;
              let c = a, d = null;
              const u = [];
              for (; c !== "" && !l[c]; ) l[c] = { callbacks: [], childEvents: [] }, u.push(l[c]), d && l[c].childEvents.push(d), d = c, c = c.substr(0, c.lastIndexOf(":"));
              if (c !== "") {
                for (const g of u) g.callbacks = l[c].callbacks.slice();
                l[c].childEvents.push(d);
              }
            })(this, e);
            const i = Pr(this, e), r = { callback: t, priority: se.get(n.priority) };
            for (const s of i) Y(s, r);
          }
          _removeEventListener(e, t) {
            const n = Pr(this, e);
            for (const i of n) for (let r = 0; r < i.length; r++) i[r].callback == t && (i.splice(r, 1), r--);
          }
        } : bl;
      }
      function kl(o, e) {
        o[Hn] || (o[Hn] = e || Q());
      }
      function Ir(o) {
        return o[Hn];
      }
      function wl(o) {
        return o._events || Object.defineProperty(o, "_events", { value: {} }), o._events;
      }
      function Pr(o, e) {
        const t = wl(o)[e];
        if (!t) return [];
        let n = [t.callbacks];
        for (let i = 0; i < t.childEvents.length; i++) {
          const r = Pr(o, t.childEvents[i]);
          n = n.concat(r);
        }
        return n;
      }
      function Al(o, e) {
        let t;
        return o._events && (t = o._events[e]) && t.callbacks.length ? t.callbacks : e.indexOf(":") > -1 ? Al(o, e.substr(0, e.lastIndexOf(":"))) : null;
      }
      function _l(o, e, t) {
        for (let [n, i] of o) {
          i ? typeof i == "function" && (i = i(e.name)) : i = e.name;
          const r = new q(e.source, i);
          r.path = [...e.path], n.fire(r, ...t);
        }
      }
      function Rr(o, e, t, n) {
        e._removeEventListener ? e._removeEventListener(t, n) : o._removeEventListener.call(e, t, n);
      }
      ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
        _e[o] = bl.prototype[o];
      });
      const ze = function(o) {
        var e = typeof o;
        return o != null && (e == "object" || e == "function");
      }, di = Symbol("observableProperties"), ui = Symbol("boundObservables"), hi = Symbol("boundProperties"), qn = Symbol("decoratedMethods"), vl = Symbol("decoratedOriginal"), Cl = ve(_e());
      function ve(o) {
        return o ? class extends o {
          set(e, t) {
            if (ze(e)) return void Object.keys(e).forEach((i) => {
              this.set(i, e[i]);
            }, this);
            Or(this);
            const n = this[di];
            if (e in this && !n.has(e)) throw new T("observable-set-cannot-override", this);
            Object.defineProperty(this, e, { enumerable: !0, configurable: !0, get: () => n.get(e), set(i) {
              const r = n.get(e);
              let s = this.fire(`set:${e}`, e, i, r);
              s === void 0 && (s = i), r === s && n.has(e) || (n.set(e, s), this.fire(`change:${e}`, e, s, r));
            } }), this[e] = t;
          }
          bind(...e) {
            if (!e.length || !yl(e)) throw new T("observable-bind-wrong-properties", this);
            if (new Set(e).size !== e.length) throw new T("observable-bind-duplicate-properties", this);
            Or(this);
            const t = this[hi];
            e.forEach((i) => {
              if (t.has(i)) throw new T("observable-bind-rebind", this);
            });
            const n = /* @__PURE__ */ new Map();
            return e.forEach((i) => {
              const r = { property: i, to: [] };
              t.set(i, r), n.set(i, r);
            }), { to: Sb, toMany: Db, _observable: this, _bindProperties: e, _to: [], _bindings: n };
          }
          unbind(...e) {
            if (!this[di]) return;
            const t = this[hi], n = this[ui];
            if (e.length) {
              if (!yl(e)) throw new T("observable-unbind-wrong-properties", this);
              e.forEach((i) => {
                const r = t.get(i);
                r && (r.to.forEach(([s, a]) => {
                  const l = n.get(s), c = l[a];
                  c.delete(r), c.size || delete l[a], Object.keys(l).length || (n.delete(s), this.stopListening(s, "change"));
                }), t.delete(i));
              });
            } else n.forEach((i, r) => {
              this.stopListening(r, "change");
            }), n.clear(), t.clear();
          }
          decorate(e) {
            Or(this);
            const t = this[e];
            if (!t) throw new T("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: e });
            this.on(e, (n, i) => {
              n.return = t.apply(this, i);
            }), this[e] = function(...n) {
              return this.fire(e, n);
            }, this[e][vl] = t, this[qn] || (this[qn] = []), this[qn].push(e);
          }
          stopListening(e, t, n) {
            if (!e && this[qn]) {
              for (const i of this[qn]) this[i] = this[i][vl];
              delete this[qn];
            }
            super.stopListening(e, t, n);
          }
        } : Cl;
      }
      function Or(o) {
        o[di] || (Object.defineProperty(o, di, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(o, ui, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(o, hi, { value: /* @__PURE__ */ new Map() }));
      }
      function Sb(...o) {
        const e = function(...r) {
          if (!r.length) throw new T("observable-bind-to-parse-error", null);
          const s = { to: [] };
          let a;
          return typeof r[r.length - 1] == "function" && (s.callback = r.pop()), r.forEach((l) => {
            if (typeof l == "string") a.properties.push(l);
            else {
              if (typeof l != "object") throw new T("observable-bind-to-parse-error", null);
              a = { observable: l, properties: [] }, s.to.push(a);
            }
          }), s;
        }(...o), t = Array.from(this._bindings.keys()), n = t.length;
        if (!e.callback && e.to.length > 1) throw new T("observable-bind-to-no-callback", this);
        if (n > 1 && e.callback) throw new T("observable-bind-to-extra-callback", this);
        var i;
        e.to.forEach((r) => {
          if (r.properties.length && r.properties.length !== n) throw new T("observable-bind-to-properties-length", this);
          r.properties.length || (r.properties = this._bindProperties);
        }), this._to = e.to, e.callback && (this._bindings.get(t[0]).callback = e.callback), i = this._observable, this._to.forEach((r) => {
          const s = i[ui];
          let a;
          s.get(r.observable) || i.listenTo(r.observable, "change", (l, c) => {
            a = s.get(r.observable)[c], a && a.forEach((d) => {
              El(i, d.property);
            });
          });
        }), function(r) {
          let s;
          r._bindings.forEach((a, l) => {
            r._to.forEach((c) => {
              s = c.properties[a.callback ? 0 : r._bindProperties.indexOf(l)], a.to.push([c.observable, s]), function(d, u, g, p) {
                const b = d[ui], w = b.get(g), y = w || {};
                y[p] || (y[p] = /* @__PURE__ */ new Set()), y[p].add(u), w || b.set(g, y);
              }(r._observable, a, c.observable, s);
            });
          });
        }(this), this._bindProperties.forEach((r) => {
          El(this._observable, r);
        });
      }
      function Db(o, e, t) {
        if (this._bindings.size > 1) throw new T("observable-bind-to-many-not-one-binding", this);
        this.to(...function(n, i) {
          const r = n.map((s) => [s, i]);
          return Array.prototype.concat.apply([], r);
        }(o, e), t);
      }
      function yl(o) {
        return o.every((e) => typeof e == "string");
      }
      function El(o, e) {
        const t = o[hi].get(e);
        let n;
        t.callback ? n = t.callback.apply(o, t.to.map((i) => i[0][i[1]])) : (n = t.to[0], n = n[0][n[1]]), Object.prototype.hasOwnProperty.call(o, e) ? o[e] = n : o.set(e, n);
      }
      ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
        ve[o] = Cl.prototype[o];
      });
      class xl {
        constructor() {
          this._replacedElements = [];
        }
        replace(e, t) {
          this._replacedElements.push({ element: e, newElement: t }), e.style.display = "none", t && e.parentNode.insertBefore(t, e.nextSibling);
        }
        restore() {
          this._replacedElements.forEach(({ element: e, newElement: t }) => {
            e.style.display = "", t && t.remove();
          }), this._replacedElements = [];
        }
      }
      function zr(o) {
        let e = 0;
        for (const t of o) e++;
        return e;
      }
      function ot(o, e) {
        const t = Math.min(o.length, e.length);
        for (let n = 0; n < t; n++) if (o[n] != e[n]) return n;
        return o.length == e.length ? "same" : o.length < e.length ? "prefix" : "extension";
      }
      function gt(o) {
        return !(!o || !o[Symbol.iterator]);
      }
      const Sl = typeof vr == "object" && vr && vr.Object === Object && vr;
      var Bb = typeof self == "object" && self && self.Object === Object && self;
      const yt = Sl || Bb || Function("return this")(), It = yt.Symbol;
      var Dl = Object.prototype, Tb = Dl.hasOwnProperty, Ib = Dl.toString, xo = It ? It.toStringTag : void 0;
      const Pb = function(o) {
        var e = Tb.call(o, xo), t = o[xo];
        try {
          o[xo] = void 0;
          var n = !0;
        } catch {
        }
        var i = Ib.call(o);
        return n && (e ? o[xo] = t : delete o[xo]), i;
      };
      var Rb = Object.prototype.toString;
      const Ob = function(o) {
        return Rb.call(o);
      };
      var Bl = It ? It.toStringTag : void 0;
      const tn = function(o) {
        return o == null ? o === void 0 ? "[object Undefined]" : "[object Null]" : Bl && Bl in Object(o) ? Pb(o) : Ob(o);
      }, it = Array.isArray, At = function(o) {
        return o != null && typeof o == "object";
      }, Tl = function(o) {
        return typeof o == "string" || !it(o) && At(o) && tn(o) == "[object String]";
      };
      function Mr(o, e, t = {}, n = []) {
        const i = t && t.xmlns, r = i ? o.createElementNS(i, e) : o.createElement(e);
        for (const s in t) r.setAttribute(s, t[s]);
        !Tl(n) && gt(n) || (n = [n]);
        for (let s of n) Tl(s) && (s = o.createTextNode(s)), r.appendChild(s);
        return r;
      }
      const Il = function(o, e) {
        return function(t) {
          return o(e(t));
        };
      }, Fr = Il(Object.getPrototypeOf, Object);
      var zb = Function.prototype, Mb = Object.prototype, Pl = zb.toString, Fb = Mb.hasOwnProperty, Nb = Pl.call(Object);
      const at = function(o) {
        if (!At(o) || tn(o) != "[object Object]") return !1;
        var e = Fr(o);
        if (e === null) return !0;
        var t = Fb.call(e, "constructor") && e.constructor;
        return typeof t == "function" && t instanceof t && Pl.call(t) == Nb;
      }, Vb = function() {
        this.__data__ = [], this.size = 0;
      }, So = function(o, e) {
        return o === e || o != o && e != e;
      }, gi = function(o, e) {
        for (var t = o.length; t--; ) if (So(o[t][0], e)) return t;
        return -1;
      };
      var Lb = Array.prototype.splice;
      const jb = function(o) {
        var e = this.__data__, t = gi(e, o);
        return !(t < 0) && (t == e.length - 1 ? e.pop() : Lb.call(e, t, 1), --this.size, !0);
      }, $b = function(o) {
        var e = this.__data__, t = gi(e, o);
        return t < 0 ? void 0 : e[t][1];
      }, Hb = function(o) {
        return gi(this.__data__, o) > -1;
      }, qb = function(o, e) {
        var t = this.__data__, n = gi(t, o);
        return n < 0 ? (++this.size, t.push([o, e])) : t[n][1] = e, this;
      };
      function Un(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.clear(); ++e < t; ) {
          var n = o[e];
          this.set(n[0], n[1]);
        }
      }
      Un.prototype.clear = Vb, Un.prototype.delete = jb, Un.prototype.get = $b, Un.prototype.has = Hb, Un.prototype.set = qb;
      const mi = Un, Ub = function() {
        this.__data__ = new mi(), this.size = 0;
      }, Wb = function(o) {
        var e = this.__data__, t = e.delete(o);
        return this.size = e.size, t;
      }, Kb = function(o) {
        return this.__data__.get(o);
      }, Gb = function(o) {
        return this.__data__.has(o);
      }, mn = function(o) {
        if (!ze(o)) return !1;
        var e = tn(o);
        return e == "[object Function]" || e == "[object GeneratorFunction]" || e == "[object AsyncFunction]" || e == "[object Proxy]";
      }, Nr = yt["__core-js_shared__"];
      var Rl = function() {
        var o = /[^.]+$/.exec(Nr && Nr.keys && Nr.keys.IE_PROTO || "");
        return o ? "Symbol(src)_1." + o : "";
      }();
      const Zb = function(o) {
        return !!Rl && Rl in o;
      };
      var Jb = Function.prototype.toString;
      const pn = function(o) {
        if (o != null) {
          try {
            return Jb.call(o);
          } catch {
          }
          try {
            return o + "";
          } catch {
          }
        }
        return "";
      };
      var Yb = /^\[object .+?Constructor\]$/, Qb = Function.prototype, Xb = Object.prototype, ek = Qb.toString, tk = Xb.hasOwnProperty, nk = RegExp("^" + ek.call(tk).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      const ok = function(o) {
        return !(!ze(o) || Zb(o)) && (mn(o) ? nk : Yb).test(pn(o));
      }, ik = function(o, e) {
        return o == null ? void 0 : o[e];
      }, fn = function(o, e) {
        var t = ik(o, e);
        return ok(t) ? t : void 0;
      }, Do = fn(yt, "Map"), Bo = fn(Object, "create"), rk = function() {
        this.__data__ = Bo ? Bo(null) : {}, this.size = 0;
      }, sk = function(o) {
        var e = this.has(o) && delete this.__data__[o];
        return this.size -= e ? 1 : 0, e;
      };
      var ak = Object.prototype.hasOwnProperty;
      const lk = function(o) {
        var e = this.__data__;
        if (Bo) {
          var t = e[o];
          return t === "__lodash_hash_undefined__" ? void 0 : t;
        }
        return ak.call(e, o) ? e[o] : void 0;
      };
      var ck = Object.prototype.hasOwnProperty;
      const dk = function(o) {
        var e = this.__data__;
        return Bo ? e[o] !== void 0 : ck.call(e, o);
      }, uk = function(o, e) {
        var t = this.__data__;
        return this.size += this.has(o) ? 0 : 1, t[o] = Bo && e === void 0 ? "__lodash_hash_undefined__" : e, this;
      };
      function Wn(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.clear(); ++e < t; ) {
          var n = o[e];
          this.set(n[0], n[1]);
        }
      }
      Wn.prototype.clear = rk, Wn.prototype.delete = sk, Wn.prototype.get = lk, Wn.prototype.has = dk, Wn.prototype.set = uk;
      const Ol = Wn, hk = function() {
        this.size = 0, this.__data__ = { hash: new Ol(), map: new (Do || mi)(), string: new Ol() };
      }, gk = function(o) {
        var e = typeof o;
        return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? o !== "__proto__" : o === null;
      }, pi = function(o, e) {
        var t = o.__data__;
        return gk(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
      }, mk = function(o) {
        var e = pi(this, o).delete(o);
        return this.size -= e ? 1 : 0, e;
      }, pk = function(o) {
        return pi(this, o).get(o);
      }, fk = function(o) {
        return pi(this, o).has(o);
      }, bk = function(o, e) {
        var t = pi(this, o), n = t.size;
        return t.set(o, e), this.size += t.size == n ? 0 : 1, this;
      };
      function Kn(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.clear(); ++e < t; ) {
          var n = o[e];
          this.set(n[0], n[1]);
        }
      }
      Kn.prototype.clear = hk, Kn.prototype.delete = mk, Kn.prototype.get = pk, Kn.prototype.has = fk, Kn.prototype.set = bk;
      const fi = Kn, kk = function(o, e) {
        var t = this.__data__;
        if (t instanceof mi) {
          var n = t.__data__;
          if (!Do || n.length < 199) return n.push([o, e]), this.size = ++t.size, this;
          t = this.__data__ = new fi(n);
        }
        return t.set(o, e), this.size = t.size, this;
      };
      function Gn(o) {
        var e = this.__data__ = new mi(o);
        this.size = e.size;
      }
      Gn.prototype.clear = Ub, Gn.prototype.delete = Wb, Gn.prototype.get = Kb, Gn.prototype.has = Gb, Gn.prototype.set = kk;
      const To = Gn, wk = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length; ++t < n && e(o[t], t, o) !== !1; ) ;
        return o;
      }, bi = function() {
        try {
          var o = fn(Object, "defineProperty");
          return o({}, "", {}), o;
        } catch {
        }
      }(), Vr = function(o, e, t) {
        e == "__proto__" && bi ? bi(o, e, { configurable: !0, enumerable: !0, value: t, writable: !0 }) : o[e] = t;
      };
      var Ak = Object.prototype.hasOwnProperty;
      const Lr = function(o, e, t) {
        var n = o[e];
        Ak.call(o, e) && So(n, t) && (t !== void 0 || e in o) || Vr(o, e, t);
      }, Zn = function(o, e, t, n) {
        var i = !t;
        t || (t = {});
        for (var r = -1, s = e.length; ++r < s; ) {
          var a = e[r], l = void 0;
          l === void 0 && (l = o[a]), i ? Vr(t, a, l) : Lr(t, a, l);
        }
        return t;
      }, _k = function(o, e) {
        for (var t = -1, n = Array(o); ++t < o; ) n[t] = e(t);
        return n;
      }, zl = function(o) {
        return At(o) && tn(o) == "[object Arguments]";
      };
      var Ml = Object.prototype, vk = Ml.hasOwnProperty, Ck = Ml.propertyIsEnumerable;
      const jr = zl(/* @__PURE__ */ function() {
        return arguments;
      }()) ? zl : function(o) {
        return At(o) && vk.call(o, "callee") && !Ck.call(o, "callee");
      }, yk = function() {
        return !1;
      };
      var Fl = C && !C.nodeType && C, Nl = Fl && !0 && h && !h.nodeType && h, Vl = Nl && Nl.exports === Fl ? yt.Buffer : void 0;
      const Io = (Vl ? Vl.isBuffer : void 0) || yk;
      var Ek = /^(?:0|[1-9]\d*)$/;
      const $r = function(o, e) {
        var t = typeof o;
        return !!(e = e ?? 9007199254740991) && (t == "number" || t != "symbol" && Ek.test(o)) && o > -1 && o % 1 == 0 && o < e;
      }, Ll = function(o) {
        return typeof o == "number" && o > -1 && o % 1 == 0 && o <= 9007199254740991;
      };
      var Re = {};
      Re["[object Float32Array]"] = Re["[object Float64Array]"] = Re["[object Int8Array]"] = Re["[object Int16Array]"] = Re["[object Int32Array]"] = Re["[object Uint8Array]"] = Re["[object Uint8ClampedArray]"] = Re["[object Uint16Array]"] = Re["[object Uint32Array]"] = !0, Re["[object Arguments]"] = Re["[object Array]"] = Re["[object ArrayBuffer]"] = Re["[object Boolean]"] = Re["[object DataView]"] = Re["[object Date]"] = Re["[object Error]"] = Re["[object Function]"] = Re["[object Map]"] = Re["[object Number]"] = Re["[object Object]"] = Re["[object RegExp]"] = Re["[object Set]"] = Re["[object String]"] = Re["[object WeakMap]"] = !1;
      const xk = function(o) {
        return At(o) && Ll(o.length) && !!Re[tn(o)];
      }, Hr = function(o) {
        return function(e) {
          return o(e);
        };
      };
      var jl = C && !C.nodeType && C, Po = jl && !0 && h && !h.nodeType && h, qr = Po && Po.exports === jl && Sl.process;
      const Jn = function() {
        try {
          var o = Po && Po.require && Po.require("util").types;
          return o || qr && qr.binding && qr.binding("util");
        } catch {
        }
      }();
      var $l = Jn && Jn.isTypedArray;
      const Ur = $l ? Hr($l) : xk;
      var Sk = Object.prototype.hasOwnProperty;
      const Hl = function(o, e) {
        var t = it(o), n = !t && jr(o), i = !t && !n && Io(o), r = !t && !n && !i && Ur(o), s = t || n || i || r, a = s ? _k(o.length, String) : [], l = a.length;
        for (var c in o) !e && !Sk.call(o, c) || s && (c == "length" || i && (c == "offset" || c == "parent") || r && (c == "buffer" || c == "byteLength" || c == "byteOffset") || $r(c, l)) || a.push(c);
        return a;
      };
      var Dk = Object.prototype;
      const Wr = function(o) {
        var e = o && o.constructor;
        return o === (typeof e == "function" && e.prototype || Dk);
      }, Bk = Il(Object.keys, Object);
      var Tk = Object.prototype.hasOwnProperty;
      const Ik = function(o) {
        if (!Wr(o)) return Bk(o);
        var e = [];
        for (var t in Object(o)) Tk.call(o, t) && t != "constructor" && e.push(t);
        return e;
      }, ki = function(o) {
        return o != null && Ll(o.length) && !mn(o);
      }, Kr = function(o) {
        return ki(o) ? Hl(o) : Ik(o);
      }, Pk = function(o, e) {
        return o && Zn(e, Kr(e), o);
      }, Rk = function(o) {
        var e = [];
        if (o != null) for (var t in Object(o)) e.push(t);
        return e;
      };
      var Ok = Object.prototype.hasOwnProperty;
      const zk = function(o) {
        if (!ze(o)) return Rk(o);
        var e = Wr(o), t = [];
        for (var n in o) (n != "constructor" || !e && Ok.call(o, n)) && t.push(n);
        return t;
      }, Yn = function(o) {
        return ki(o) ? Hl(o, !0) : zk(o);
      }, Mk = function(o, e) {
        return o && Zn(e, Yn(e), o);
      };
      var ql = C && !C.nodeType && C, Ul = ql && !0 && h && !h.nodeType && h, Wl = Ul && Ul.exports === ql ? yt.Buffer : void 0, Kl = Wl ? Wl.allocUnsafe : void 0;
      const Gl = function(o, e) {
        if (e) return o.slice();
        var t = o.length, n = Kl ? Kl(t) : new o.constructor(t);
        return o.copy(n), n;
      }, Gr = function(o, e) {
        var t = -1, n = o.length;
        for (e || (e = Array(n)); ++t < n; ) e[t] = o[t];
        return e;
      }, Fk = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length, i = 0, r = []; ++t < n; ) {
          var s = o[t];
          e(s, t, o) && (r[i++] = s);
        }
        return r;
      }, Zl = function() {
        return [];
      };
      var Nk = Object.prototype.propertyIsEnumerable, Jl = Object.getOwnPropertySymbols;
      const Zr = Jl ? function(o) {
        return o == null ? [] : (o = Object(o), Fk(Jl(o), function(e) {
          return Nk.call(o, e);
        }));
      } : Zl, Vk = function(o, e) {
        return Zn(o, Zr(o), e);
      }, Yl = function(o, e) {
        for (var t = -1, n = e.length, i = o.length; ++t < n; ) o[i + t] = e[t];
        return o;
      }, Ql = Object.getOwnPropertySymbols ? function(o) {
        for (var e = []; o; ) Yl(e, Zr(o)), o = Fr(o);
        return e;
      } : Zl, Lk = function(o, e) {
        return Zn(o, Ql(o), e);
      }, Xl = function(o, e, t) {
        var n = e(o);
        return it(o) ? n : Yl(n, t(o));
      }, Jr = function(o) {
        return Xl(o, Kr, Zr);
      }, jk = function(o) {
        return Xl(o, Yn, Ql);
      }, Yr = fn(yt, "DataView"), Qr = fn(yt, "Promise"), Xr = fn(yt, "Set"), es = fn(yt, "WeakMap");
      var ec = "[object Map]", tc = "[object Promise]", nc = "[object Set]", oc = "[object WeakMap]", ic = "[object DataView]", $k = pn(Yr), Hk = pn(Do), qk = pn(Qr), Uk = pn(Xr), Wk = pn(es), bn = tn;
      (Yr && bn(new Yr(new ArrayBuffer(1))) != ic || Do && bn(new Do()) != ec || Qr && bn(Qr.resolve()) != tc || Xr && bn(new Xr()) != nc || es && bn(new es()) != oc) && (bn = function(o) {
        var e = tn(o), t = e == "[object Object]" ? o.constructor : void 0, n = t ? pn(t) : "";
        if (n) switch (n) {
          case $k:
            return ic;
          case Hk:
            return ec;
          case qk:
            return tc;
          case Uk:
            return nc;
          case Wk:
            return oc;
        }
        return e;
      });
      const Ro = bn;
      var Kk = Object.prototype.hasOwnProperty;
      const Gk = function(o) {
        var e = o.length, t = new o.constructor(e);
        return e && typeof o[0] == "string" && Kk.call(o, "index") && (t.index = o.index, t.input = o.input), t;
      }, wi = yt.Uint8Array, ts = function(o) {
        var e = new o.constructor(o.byteLength);
        return new wi(e).set(new wi(o)), e;
      }, Zk = function(o, e) {
        var t = e ? ts(o.buffer) : o.buffer;
        return new o.constructor(t, o.byteOffset, o.byteLength);
      };
      var Jk = /\w*$/;
      const Yk = function(o) {
        var e = new o.constructor(o.source, Jk.exec(o));
        return e.lastIndex = o.lastIndex, e;
      };
      var rc = It ? It.prototype : void 0, sc = rc ? rc.valueOf : void 0;
      const Qk = function(o) {
        return sc ? Object(sc.call(o)) : {};
      }, ac = function(o, e) {
        var t = e ? ts(o.buffer) : o.buffer;
        return new o.constructor(t, o.byteOffset, o.length);
      }, Xk = function(o, e, t) {
        var n = o.constructor;
        switch (e) {
          case "[object ArrayBuffer]":
            return ts(o);
          case "[object Boolean]":
          case "[object Date]":
            return new n(+o);
          case "[object DataView]":
            return Zk(o, t);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return ac(o, t);
          case "[object Map]":
          case "[object Set]":
            return new n();
          case "[object Number]":
          case "[object String]":
            return new n(o);
          case "[object RegExp]":
            return Yk(o);
          case "[object Symbol]":
            return Qk(o);
        }
      };
      var lc = Object.create;
      const ew = /* @__PURE__ */ function() {
        function o() {
        }
        return function(e) {
          if (!ze(e)) return {};
          if (lc) return lc(e);
          o.prototype = e;
          var t = new o();
          return o.prototype = void 0, t;
        };
      }(), cc = function(o) {
        return typeof o.constructor != "function" || Wr(o) ? {} : ew(Fr(o));
      }, tw = function(o) {
        return At(o) && Ro(o) == "[object Map]";
      };
      var dc = Jn && Jn.isMap;
      const nw = dc ? Hr(dc) : tw, ow = function(o) {
        return At(o) && Ro(o) == "[object Set]";
      };
      var uc = Jn && Jn.isSet;
      const iw = uc ? Hr(uc) : ow;
      var hc = "[object Arguments]", gc = "[object Function]", mc = "[object Object]", Ie = {};
      Ie[hc] = Ie["[object Array]"] = Ie["[object ArrayBuffer]"] = Ie["[object DataView]"] = Ie["[object Boolean]"] = Ie["[object Date]"] = Ie["[object Float32Array]"] = Ie["[object Float64Array]"] = Ie["[object Int8Array]"] = Ie["[object Int16Array]"] = Ie["[object Int32Array]"] = Ie["[object Map]"] = Ie["[object Number]"] = Ie[mc] = Ie["[object RegExp]"] = Ie["[object Set]"] = Ie["[object String]"] = Ie["[object Symbol]"] = Ie["[object Uint8Array]"] = Ie["[object Uint8ClampedArray]"] = Ie["[object Uint16Array]"] = Ie["[object Uint32Array]"] = !0, Ie["[object Error]"] = Ie[gc] = Ie["[object WeakMap]"] = !1;
      const ns = function o(e, t, n, i, r, s) {
        var a, l = 1 & t, c = 2 & t, d = 4 & t;
        if (n && (a = r ? n(e, i, r, s) : n(e)), a !== void 0) return a;
        if (!ze(e)) return e;
        var u = it(e);
        if (u) {
          if (a = Gk(e), !l) return Gr(e, a);
        } else {
          var g = Ro(e), p = g == gc || g == "[object GeneratorFunction]";
          if (Io(e)) return Gl(e, l);
          if (g == mc || g == hc || p && !r) {
            if (a = c || p ? {} : cc(e), !l) return c ? Lk(e, Mk(a, e)) : Vk(e, Pk(a, e));
          } else {
            if (!Ie[g]) return r ? e : {};
            a = Xk(e, g, l);
          }
        }
        s || (s = new To());
        var b = s.get(e);
        if (b) return b;
        s.set(e, a), iw(e) ? e.forEach(function(y) {
          a.add(o(y, t, n, y, e, s));
        }) : nw(e) && e.forEach(function(y, I) {
          a.set(I, o(y, t, n, I, e, s));
        });
        var w = u ? void 0 : (d ? c ? jk : Jr : c ? Yn : Kr)(e);
        return wk(w || e, function(y, I) {
          w && (y = e[I = y]), Lr(a, I, o(y, t, n, I, e, s));
        }), a;
      }, os = function(o, e) {
        return ns(o, 5, e = typeof e == "function" ? e : void 0);
      }, Qn = function(o) {
        return At(o) && o.nodeType === 1 && !at(o);
      };
      class pc {
        constructor(e, t) {
          this._config = {}, t && this.define(fc(t)), e && this._setObjectToTarget(this._config, e);
        }
        set(e, t) {
          this._setToTarget(this._config, e, t);
        }
        define(e, t) {
          this._setToTarget(this._config, e, t, !0);
        }
        get(e) {
          return this._getFromSource(this._config, e);
        }
        *names() {
          for (const e of Object.keys(this._config)) yield e;
        }
        _setToTarget(e, t, n, i = !1) {
          if (at(t)) return void this._setObjectToTarget(e, t, i);
          const r = t.split(".");
          t = r.pop();
          for (const s of r) at(e[s]) || (e[s] = {}), e = e[s];
          if (at(n)) return at(e[t]) || (e[t] = {}), e = e[t], void this._setObjectToTarget(e, n, i);
          i && e[t] !== void 0 || (e[t] = n);
        }
        _getFromSource(e, t) {
          const n = t.split(".");
          t = n.pop();
          for (const i of n) {
            if (!at(e[i])) {
              e = null;
              break;
            }
            e = e[i];
          }
          return e ? fc(e[t]) : void 0;
        }
        _setObjectToTarget(e, t, n) {
          Object.keys(t).forEach((i) => {
            this._setToTarget(e, i, t[i], n);
          });
        }
      }
      function fc(o) {
        return os(o, rw);
      }
      function rw(o) {
        return Qn(o) ? o : void 0;
      }
      function nn(o) {
        if (o) {
          if (o.defaultView) return o instanceof o.defaultView.Document;
          if (o.ownerDocument && o.ownerDocument.defaultView) return o instanceof o.ownerDocument.defaultView.Node;
        }
        return !1;
      }
      function Ai(o) {
        const e = Object.prototype.toString.apply(o);
        return e == "[object Window]" || e == "[object global]";
      }
      const bc = on(_e());
      function on(o) {
        return o ? class extends o {
          listenTo(e, t, n, i = {}) {
            if (nn(e) || Ai(e)) {
              const r = { capture: !!i.useCapture, passive: !!i.usePassive }, s = this._getProxyEmitter(e, r) || new sw(e, r);
              this.listenTo(s, t, n, i);
            } else super.listenTo(e, t, n, i);
          }
          stopListening(e, t, n) {
            if (nn(e) || Ai(e)) {
              const i = this._getAllProxyEmitters(e);
              for (const r of i) this.stopListening(r, t, n);
            } else super.stopListening(e, t, n);
          }
          _getProxyEmitter(e, t) {
            return function(n, i) {
              const r = n[Tt];
              return r && r[i] ? r[i].emitter : null;
            }(this, kc(e, t));
          }
          _getAllProxyEmitters(e) {
            return [{ capture: !1, passive: !1 }, { capture: !1, passive: !0 }, { capture: !0, passive: !1 }, { capture: !0, passive: !0 }].map((t) => this._getProxyEmitter(e, t)).filter((t) => !!t);
          }
        } : bc;
      }
      ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((o) => {
        on[o] = bc.prototype[o];
      });
      class sw extends _e() {
        constructor(e, t) {
          super(), kl(this, kc(e, t)), this._domNode = e, this._options = t;
        }
        attach(e) {
          if (this._domListeners && this._domListeners[e]) return;
          const t = this._createDomListener(e);
          this._domNode.addEventListener(e, t, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[e] = t;
        }
        detach(e) {
          let t;
          !this._domListeners[e] || (t = this._events[e]) && t.callbacks.length || this._domListeners[e].removeListener();
        }
        _addEventListener(e, t, n) {
          this.attach(e), _e().prototype._addEventListener.call(this, e, t, n);
        }
        _removeEventListener(e, t) {
          _e().prototype._removeEventListener.call(this, e, t), this.detach(e);
        }
        _createDomListener(e) {
          const t = (n) => {
            this.fire(e, n);
          };
          return t.removeListener = () => {
            this._domNode.removeEventListener(e, t, this._options), delete this._domListeners[e];
          }, t;
        }
      }
      function kc(o, e) {
        let t = function(n) {
          return n["data-ck-expando"] || (n["data-ck-expando"] = Q());
        }(o);
        for (const n of Object.keys(e).sort()) e[n] && (t += "-" + n);
        return t;
      }
      let is;
      try {
        is = { window, document };
      } catch {
        is = { window: {}, document: {} };
      }
      const le = is;
      function wc(o) {
        const e = [];
        let t = o;
        for (; t && t.nodeType != Node.DOCUMENT_NODE; ) e.unshift(t), t = t.parentNode;
        return e;
      }
      function je(o) {
        return Object.prototype.toString.call(o) == "[object Text]";
      }
      function _i(o) {
        return Object.prototype.toString.apply(o) == "[object Range]";
      }
      function Ac(o) {
        const e = o.ownerDocument.defaultView.getComputedStyle(o);
        return { top: parseInt(e.borderTopWidth, 10), right: parseInt(e.borderRightWidth, 10), bottom: parseInt(e.borderBottomWidth, 10), left: parseInt(e.borderLeftWidth, 10) };
      }
      const _c = ["top", "right", "bottom", "left", "width", "height"];
      class Fe {
        constructor(e) {
          const t = _i(e);
          if (Object.defineProperty(this, "_source", { value: e._source || e, writable: !0, enumerable: !1 }), Cc(e) || t) if (t) {
            const n = Fe.getDomRangeRects(e);
            vi(this, Fe.getBoundingRect(n));
          } else vi(this, e.getBoundingClientRect());
          else if (Ai(e)) {
            const { innerWidth: n, innerHeight: i } = e;
            vi(this, { top: 0, right: n, bottom: i, left: 0, width: n, height: i });
          } else vi(this, e);
        }
        clone() {
          return new Fe(this);
        }
        moveTo(e, t) {
          return this.top = t, this.right = e + this.width, this.bottom = t + this.height, this.left = e, this;
        }
        moveBy(e, t) {
          return this.top += t, this.right += e, this.left += e, this.bottom += t, this;
        }
        getIntersection(e) {
          const t = { top: Math.max(this.top, e.top), right: Math.min(this.right, e.right), bottom: Math.min(this.bottom, e.bottom), left: Math.max(this.left, e.left), width: 0, height: 0 };
          return t.width = t.right - t.left, t.height = t.bottom - t.top, t.width < 0 || t.height < 0 ? null : new Fe(t);
        }
        getIntersectionArea(e) {
          const t = this.getIntersection(e);
          return t ? t.getArea() : 0;
        }
        getArea() {
          return this.width * this.height;
        }
        getVisible() {
          const e = this._source;
          let t = this.clone();
          if (!vc(e)) {
            let n = e.parentNode || e.commonAncestorContainer;
            for (; n && !vc(n); ) {
              const i = new Fe(n), r = t.getIntersection(i);
              if (!r) return null;
              r.getArea() < t.getArea() && (t = r), n = n.parentNode;
            }
          }
          return t;
        }
        isEqual(e) {
          for (const t of _c) if (this[t] !== e[t]) return !1;
          return !0;
        }
        contains(e) {
          const t = this.getIntersection(e);
          return !(!t || !t.isEqual(e));
        }
        excludeScrollbarsAndBorders() {
          const e = this._source;
          let t, n, i;
          if (Ai(e)) t = e.innerWidth - e.document.documentElement.clientWidth, n = e.innerHeight - e.document.documentElement.clientHeight, i = e.getComputedStyle(e.document.documentElement).direction;
          else {
            const r = Ac(e);
            t = e.offsetWidth - e.clientWidth - r.left - r.right, n = e.offsetHeight - e.clientHeight - r.top - r.bottom, i = e.ownerDocument.defaultView.getComputedStyle(e).direction, this.left += r.left, this.top += r.top, this.right -= r.right, this.bottom -= r.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
          }
          return this.width -= t, i === "ltr" ? this.right -= t : this.left += t, this.height -= n, this.bottom -= n, this;
        }
        static getDomRangeRects(e) {
          const t = [], n = Array.from(e.getClientRects());
          if (n.length) for (const i of n) t.push(new Fe(i));
          else {
            let i = e.startContainer;
            je(i) && (i = i.parentNode);
            const r = new Fe(i.getBoundingClientRect());
            r.right = r.left, r.width = 0, t.push(r);
          }
          return t;
        }
        static getBoundingRect(e) {
          const t = { left: Number.POSITIVE_INFINITY, top: Number.POSITIVE_INFINITY, right: Number.NEGATIVE_INFINITY, bottom: Number.NEGATIVE_INFINITY, width: 0, height: 0 };
          let n = 0;
          for (const i of e) n++, t.left = Math.min(t.left, i.left), t.top = Math.min(t.top, i.top), t.right = Math.max(t.right, i.right), t.bottom = Math.max(t.bottom, i.bottom);
          return n == 0 ? null : (t.width = t.right - t.left, t.height = t.bottom - t.top, new Fe(t));
        }
      }
      function vi(o, e) {
        for (const t of _c) o[t] = e[t];
      }
      function vc(o) {
        return !!Cc(o) && o === o.ownerDocument.body;
      }
      function Cc(o) {
        return o !== null && typeof o == "object" && o.nodeType === 1 && typeof o.getBoundingClientRect == "function";
      }
      const We = class {
        constructor(o, e) {
          We._observerInstance || We._createObserver(), this._element = o, this._callback = e, We._addElementCallback(o, e), We._observerInstance.observe(o);
        }
        destroy() {
          We._deleteElementCallback(this._element, this._callback);
        }
        static _addElementCallback(o, e) {
          We._elementCallbacks || (We._elementCallbacks = /* @__PURE__ */ new Map());
          let t = We._elementCallbacks.get(o);
          t || (t = /* @__PURE__ */ new Set(), We._elementCallbacks.set(o, t)), t.add(e);
        }
        static _deleteElementCallback(o, e) {
          const t = We._getElementCallbacks(o);
          t && (t.delete(e), t.size || (We._elementCallbacks.delete(o), We._observerInstance.unobserve(o))), We._elementCallbacks && !We._elementCallbacks.size && (We._observerInstance = null, We._elementCallbacks = null);
        }
        static _getElementCallbacks(o) {
          return We._elementCallbacks ? We._elementCallbacks.get(o) : null;
        }
        static _createObserver() {
          We._observerInstance = new le.window.ResizeObserver((o) => {
            for (const e of o) {
              const t = We._getElementCallbacks(e.target);
              if (t) for (const n of t) n(e);
            }
          });
        }
      };
      let Ci = We;
      function aw(o, e) {
        o instanceof HTMLTextAreaElement && (o.value = e), o.innerHTML = e;
      }
      function rs(o) {
        return (e) => e + o;
      }
      function yi(o) {
        let e = 0;
        for (; o.previousSibling; ) o = o.previousSibling, e++;
        return e;
      }
      function yc(o, e, t) {
        o.insertBefore(t, o.childNodes[e] || null);
      }
      function Xn(o) {
        return o && o.nodeType === Node.COMMENT_NODE;
      }
      function Ec(o) {
        try {
          le.document.createAttribute(o);
        } catch {
          return !1;
        }
        return !0;
      }
      function kn(o) {
        return !!(o && o.getClientRects && o.getClientRects().length);
      }
      Ci._observerInstance = null, Ci._elementCallbacks = null;
      var xc = Math.pow;
      function Sc({ element: o, target: e, positions: t, limiter: n, fitInViewport: i, viewportOffsetConfig: r }) {
        mn(e) && (e = e()), mn(n) && (n = n());
        const s = function(g) {
          return g && g.parentNode ? g.offsetParent === le.document.body ? null : g.offsetParent : null;
        }(o), a = new Fe(o), l = new Fe(e);
        let c;
        const d = i && function(g) {
          g = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, g);
          const p = new Fe(le.window);
          return p.top += g.top, p.height -= g.top, p.bottom -= g.bottom, p.height -= g.bottom, p;
        }(r) || null, u = { targetRect: l, elementRect: a, positionedElementAncestor: s, viewportRect: d };
        if (n || i) {
          const g = n && new Fe(n).getVisible();
          Object.assign(u, { limiterRect: g, viewportRect: d }), c = function(p, b) {
            const { elementRect: w } = b, y = w.getArea(), I = p.map((X) => new ss(X, b)).filter((X) => !!X.name);
            let z = 0, H = null;
            for (const X of I) {
              const { limiterIntersectionArea: ce, viewportIntersectionArea: Oe } = X;
              if (ce === y) return X;
              const be = xc(Oe, 2) + xc(ce, 2);
              be > z && (z = be, H = X);
            }
            return H;
          }(t, u) || new ss(t[0], u);
        } else c = new ss(t[0], u);
        return c;
      }
      function Dc(o) {
        const { scrollX: e, scrollY: t } = le.window;
        return o.clone().moveBy(e, t);
      }
      class ss {
        constructor(e, t) {
          const n = e(t.targetRect, t.elementRect, t.viewportRect);
          if (!n) return;
          const { left: i, top: r, name: s, config: a } = n;
          this.name = s, this.config = a, this._positioningFunctionCorrdinates = { left: i, top: r }, this._options = t;
        }
        get left() {
          return this._absoluteRect.left;
        }
        get top() {
          return this._absoluteRect.top;
        }
        get limiterIntersectionArea() {
          const e = this._options.limiterRect;
          if (e) {
            const t = this._options.viewportRect;
            if (!t) return e.getIntersectionArea(this._rect);
            {
              const n = e.getIntersection(t);
              if (n) return n.getIntersectionArea(this._rect);
            }
          }
          return 0;
        }
        get viewportIntersectionArea() {
          const e = this._options.viewportRect;
          return e ? e.getIntersectionArea(this._rect) : 0;
        }
        get _rect() {
          return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top)), this._cachedRect;
        }
        get _absoluteRect() {
          return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = Dc(this._rect), this._options.positionedElementAncestor && function(e, t) {
            const n = Dc(new Fe(t)), i = Ac(t);
            let r = 0, s = 0;
            r -= n.left, s -= n.top, r += t.scrollLeft, s += t.scrollTop, r -= i.left, s -= i.top, e.moveBy(r, s);
          }(this._cachedAbsoluteRect, this._options.positionedElementAncestor)), this._cachedAbsoluteRect;
        }
      }
      function Bc(o) {
        const e = o.parentNode;
        e && e.removeChild(o);
      }
      function lw({ window: o, rect: e, alignToTop: t, forceScroll: n, viewportOffset: i }) {
        const r = e.clone().moveBy(0, i), s = e.clone().moveBy(0, -i), a = new Fe(o).excludeScrollbarsAndBorders(), l = t && n, c = [s, r].every((b) => a.contains(b));
        let { scrollX: d, scrollY: u } = o;
        const g = d, p = u;
        l ? u -= a.top - e.top + i : c || (Ic(s, a) ? u -= a.top - e.top + i : Tc(r, a) && (u += t ? e.top - a.top - i : e.bottom - a.bottom + i)), c || (Pc(e, a) ? d -= a.left - e.left + i : Rc(e, a) && (d += e.right - a.right + i)), d == g && u === p || o.scrollTo(d, u);
      }
      function cw({ parent: o, getRect: e, alignToTop: t, forceScroll: n, ancestorOffset: i = 0 }) {
        const r = as(o), s = t && n;
        let a, l, c;
        for (; o != r.document.body; ) l = e(), a = new Fe(o).excludeScrollbarsAndBorders(), c = a.contains(l), s ? o.scrollTop -= a.top - l.top + i : c || (Ic(l, a) ? o.scrollTop -= a.top - l.top + i : Tc(l, a) && (o.scrollTop += t ? l.top - a.top - i : l.bottom - a.bottom + i)), c || (Pc(l, a) ? o.scrollLeft -= a.left - l.left + i : Rc(l, a) && (o.scrollLeft += l.right - a.right + i)), o = o.parentNode;
      }
      function Tc(o, e) {
        return o.bottom > e.bottom;
      }
      function Ic(o, e) {
        return o.top < e.top;
      }
      function Pc(o, e) {
        return o.left < e.left;
      }
      function Rc(o, e) {
        return o.right > e.right;
      }
      function as(o) {
        return _i(o) ? o.startContainer.ownerDocument.defaultView : o.ownerDocument.defaultView;
      }
      function dw(o) {
        if (_i(o)) {
          let e = o.commonAncestorContainer;
          return je(e) && (e = e.parentNode), e;
        }
        return o.parentNode;
      }
      function Oc(o, e) {
        const t = as(o), n = new Fe(o);
        if (t === e) return n;
        {
          let i = t;
          for (; i != e; ) {
            const r = i.frameElement, s = new Fe(r).excludeScrollbarsAndBorders();
            n.moveBy(s.left, s.top), i = i.parent;
          }
        }
        return n;
      }
      const uw = { ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧" }, hw = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" }, ge = function() {
        const o = { arrowleft: 37, arrowup: 38, arrowright: 39, arrowdown: 40, backspace: 8, delete: 46, enter: 13, space: 32, esc: 27, tab: 9, ctrl: 1114112, shift: 2228224, alt: 4456448, cmd: 8912896 };
        for (let e = 65; e <= 90; e++)
          o[String.fromCharCode(e).toLowerCase()] = e;
        for (let e = 48; e <= 57; e++) o[e - 48] = e;
        for (let e = 112; e <= 123; e++) o["f" + (e - 111)] = e;
        for (const e of "`-=[];',./\\") o[e] = e.charCodeAt(0);
        return o;
      }(), gw = Object.fromEntries(Object.entries(ge).map(([o, e]) => [e, o.charAt(0).toUpperCase() + o.slice(1)]));
      function eo(o) {
        let e;
        if (typeof o == "string") {
          if (e = ge[o.toLowerCase()], !e) throw new T("keyboard-unknown-key", null, { key: o });
        } else e = o.keyCode + (o.altKey ? ge.alt : 0) + (o.ctrlKey ? ge.ctrl : 0) + (o.shiftKey ? ge.shift : 0) + (o.metaKey ? ge.cmd : 0);
        return e;
      }
      function Ei(o) {
        return typeof o == "string" && (o = function(e) {
          return e.split("+").map((t) => t.trim());
        }(o)), o.map((e) => typeof e == "string" ? function(t) {
          if (t.endsWith("!")) return eo(t.slice(0, -1));
          const n = eo(t);
          return f.isMac && n == ge.ctrl ? ge.cmd : n;
        }(e) : e).reduce((e, t) => t + e, 0);
      }
      function zc(o) {
        let e = Ei(o);
        return Object.entries(f.isMac ? uw : hw).reduce((t, [n, i]) => (e & ge[n] && (e &= ~ge[n], t += i), t), "") + (e ? gw[e] : "");
      }
      function ls(o, e) {
        const t = e === "ltr";
        switch (o) {
          case ge.arrowleft:
            return t ? "left" : "right";
          case ge.arrowright:
            return t ? "right" : "left";
          case ge.arrowup:
            return "up";
          case ge.arrowdown:
            return "down";
        }
      }
      function $e(o) {
        return Array.isArray(o) ? o : [o];
      }
      function mw(o, e, t = 1) {
        if (typeof t != "number") throw new T("translation-service-quantity-not-a-number", null, { quantity: t });
        const n = Object.keys(le.window.CKEDITOR_TRANSLATIONS).length;
        n === 1 && (o = Object.keys(le.window.CKEDITOR_TRANSLATIONS)[0]);
        const i = e.id || e.string;
        if (n === 0 || !function(l, c) {
          return !!le.window.CKEDITOR_TRANSLATIONS[l] && !!le.window.CKEDITOR_TRANSLATIONS[l].dictionary[c];
        }(o, i)) return t !== 1 ? e.plural : e.string;
        const r = le.window.CKEDITOR_TRANSLATIONS[o].dictionary, s = le.window.CKEDITOR_TRANSLATIONS[o].getPluralForm || ((l) => l === 1 ? 0 : 1), a = r[i];
        return typeof a == "string" ? a : a[Number(s(t))];
      }
      le.window.CKEDITOR_TRANSLATIONS || (le.window.CKEDITOR_TRANSLATIONS = {});
      const pw = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];
      function Mc(o) {
        return pw.includes(o) ? "rtl" : "ltr";
      }
      class fw {
        constructor({ uiLanguage: e = "en", contentLanguage: t } = {}) {
          this.uiLanguage = e, this.contentLanguage = t || this.uiLanguage, this.uiLanguageDirection = Mc(this.uiLanguage), this.contentLanguageDirection = Mc(this.contentLanguage), this.t = (n, i) => this._t(n, i);
        }
        get language() {
          return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
        }
        _t(e, t = []) {
          t = $e(t), typeof e == "string" && (e = { string: e });
          const n = e.plural ? t[0] : 1;
          return function(i, r) {
            return i.replace(/%(\d+)/g, (s, a) => a < r.length ? r[a] : s);
          }(mw(this.uiLanguage, e, n), t);
        }
      }
      class _t extends _e() {
        constructor(e = {}, t = {}) {
          super();
          const n = gt(e);
          if (n || (t = e), this._items = [], this._itemMap = /* @__PURE__ */ new Map(), this._idProperty = t.idProperty || "id", this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap(), this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap(), this._skippedIndexesFromExternal = [], n) for (const i of e) this._items.push(i), this._itemMap.set(this._getItemIdBeforeAdding(i), i);
        }
        get length() {
          return this._items.length;
        }
        get first() {
          return this._items[0] || null;
        }
        get last() {
          return this._items[this.length - 1] || null;
        }
        add(e, t) {
          return this.addMany([e], t);
        }
        addMany(e, t) {
          if (t === void 0) t = this._items.length;
          else if (t > this._items.length || t < 0) throw new T("collection-add-item-invalid-index", this);
          let n = 0;
          for (const i of e) {
            const r = this._getItemIdBeforeAdding(i), s = t + n;
            this._items.splice(s, 0, i), this._itemMap.set(r, i), this.fire("add", i, s), n++;
          }
          return this.fire("change", { added: e, removed: [], index: t }), this;
        }
        get(e) {
          let t;
          if (typeof e == "string") t = this._itemMap.get(e);
          else {
            if (typeof e != "number") throw new T("collection-get-invalid-arg", this);
            t = this._items[e];
          }
          return t || null;
        }
        has(e) {
          if (typeof e == "string") return this._itemMap.has(e);
          {
            const t = e[this._idProperty];
            return t && this._itemMap.has(t);
          }
        }
        getIndex(e) {
          let t;
          return t = typeof e == "string" ? this._itemMap.get(e) : e, t ? this._items.indexOf(t) : -1;
        }
        remove(e) {
          const [t, n] = this._remove(e);
          return this.fire("change", { added: [], removed: [t], index: n }), t;
        }
        map(e, t) {
          return this._items.map(e, t);
        }
        find(e, t) {
          return this._items.find(e, t);
        }
        filter(e, t) {
          return this._items.filter(e, t);
        }
        clear() {
          this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
          const e = Array.from(this._items);
          for (; this.length; ) this._remove(0);
          this.fire("change", { added: [], removed: e, index: 0 });
        }
        bindTo(e) {
          if (this._bindToCollection) throw new T("collection-bind-to-rebind", this);
          return this._bindToCollection = e, { as: (t) => {
            this._setUpBindToBinding((n) => new t(n));
          }, using: (t) => {
            typeof t == "function" ? this._setUpBindToBinding(t) : this._setUpBindToBinding((n) => n[t]);
          } };
        }
        _setUpBindToBinding(e) {
          const t = this._bindToCollection, n = (i, r, s) => {
            const a = t._bindToCollection == this, l = t._bindToInternalToExternalMap.get(r);
            if (a && l) this._bindToExternalToInternalMap.set(r, l), this._bindToInternalToExternalMap.set(l, r);
            else {
              const c = e(r);
              if (!c) return void this._skippedIndexesFromExternal.push(s);
              let d = s;
              for (const u of this._skippedIndexesFromExternal) s > u && d--;
              for (const u of t._skippedIndexesFromExternal) d >= u && d++;
              this._bindToExternalToInternalMap.set(r, c), this._bindToInternalToExternalMap.set(c, r), this.add(c, d);
              for (let u = 0; u < t._skippedIndexesFromExternal.length; u++) d <= t._skippedIndexesFromExternal[u] && t._skippedIndexesFromExternal[u]++;
            }
          };
          for (const i of t) n(0, i, t.getIndex(i));
          this.listenTo(t, "add", n), this.listenTo(t, "remove", (i, r, s) => {
            const a = this._bindToExternalToInternalMap.get(r);
            a && this.remove(a), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((l, c) => (s < c && l.push(c - 1), s > c && l.push(c), l), []);
          });
        }
        _getItemIdBeforeAdding(e) {
          const t = this._idProperty;
          let n;
          if (t in e) {
            if (n = e[t], typeof n != "string") throw new T("collection-add-invalid-id", this);
            if (this.get(n)) throw new T("collection-add-item-already-exists", this);
          } else e[t] = n = Q();
          return n;
        }
        _remove(e) {
          let t, n, i, r = !1;
          const s = this._idProperty;
          if (typeof e == "string" ? (n = e, i = this._itemMap.get(n), r = !i, i && (t = this._items.indexOf(i))) : typeof e == "number" ? (t = e, i = this._items[t], r = !i, i && (n = i[s])) : (i = e, n = i[s], t = this._items.indexOf(i), r = t == -1 || !this._itemMap.get(n)), r) throw new T("collection-remove-404", this);
          this._items.splice(t, 1), this._itemMap.delete(n);
          const a = this._bindToInternalToExternalMap.get(i);
          return this._bindToInternalToExternalMap.delete(i), this._bindToExternalToInternalMap.delete(a), this.fire("remove", i, t), [i, t];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
      }
      function Ke(o) {
        const e = o.next();
        return e.done ? null : e.value;
      }
      class Et extends on(ve()) {
        constructor() {
          super(), this._elements = /* @__PURE__ */ new Set(), this._nextEventLoopTimeout = null, this.set("isFocused", !1), this.set("focusedElement", null);
        }
        add(e) {
          if (this._elements.has(e)) throw new T("focustracker-add-element-already-exist", this);
          this.listenTo(e, "focus", () => this._focus(e), { useCapture: !0 }), this.listenTo(e, "blur", () => this._blur(), { useCapture: !0 }), this._elements.add(e);
        }
        remove(e) {
          e === this.focusedElement && this._blur(), this._elements.has(e) && (this.stopListening(e), this._elements.delete(e));
        }
        destroy() {
          this.stopListening();
        }
        _focus(e) {
          clearTimeout(this._nextEventLoopTimeout), this.focusedElement = e, this.isFocused = !0;
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null, this.isFocused = !1;
          }, 0);
        }
      }
      class $t {
        constructor() {
          this._listener = new (on())();
        }
        listenTo(e) {
          this._listener.listenTo(e, "keydown", (t, n) => {
            this._listener.fire("_keydown:" + eo(n), n);
          });
        }
        set(e, t, n = {}) {
          const i = Ei(e), r = n.priority;
          this._listener.listenTo(this._listener, "_keydown:" + i, (s, a) => {
            t(a, () => {
              a.preventDefault(), a.stopPropagation(), s.stop();
            }), s.return = !0;
          }, { priority: r });
        }
        press(e) {
          return !!this._listener.fire("_keydown:" + eo(e), e);
        }
        stopListening(e) {
          this._listener.stopListening(e);
        }
        destroy() {
          this.stopListening();
        }
      }
      function Ht(o) {
        return gt(o) ? new Map(o) : function(e) {
          const t = /* @__PURE__ */ new Map();
          for (const n in e) t.set(n, e[n]);
          return t;
        }(o);
      }
      function cs(o, e) {
        let t;
        function n(...i) {
          n.cancel(), t = setTimeout(() => o(...i), e);
        }
        return n.cancel = () => {
          clearTimeout(t);
        }, n;
      }
      function ds(o, e) {
        return !!(t = o.charAt(e - 1)) && t.length == 1 && /[\ud800-\udbff]/.test(t) && function(n) {
          return !!n && n.length == 1 && /[\udc00-\udfff]/.test(n);
        }(o.charAt(e));
        var t;
      }
      function us(o, e) {
        return !!(t = o.charAt(e)) && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t);
        var t;
      }
      const bw = function() {
        const o = [new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}", "u"), new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")], e = new RegExp("\\p{Regional_Indicator}{2}", "u").source, t = "(?:" + o.map((n) => n.source).join("|") + ")";
        return new RegExp(`${e}|${t}(?:‍${t})*`, "ug");
      }();
      function Fc(o, e) {
        const t = String(o).matchAll(bw);
        return Array.from(t).some((n) => n.index < e && e < n.index + n[0].length);
      }
      class wn extends _t {
        constructor(e = []) {
          super(e, { idProperty: "viewUid" }), this.on("add", (t, n, i) => {
            this._renderViewIntoCollectionParent(n, i);
          }), this.on("remove", (t, n) => {
            n.element && this._parentElement && n.element.remove();
          }), this._parentElement = null;
        }
        destroy() {
          this.map((e) => e.destroy());
        }
        setParent(e) {
          this._parentElement = e;
          for (const t of this) this._renderViewIntoCollectionParent(t);
        }
        delegate(...e) {
          if (!e.length || !e.every((t) => typeof t == "string")) throw new T("ui-viewcollection-delegate-wrong-events", this);
          return { to: (t) => {
            for (const n of this) for (const i of e) n.delegate(i).to(t);
            this.on("add", (n, i) => {
              for (const r of e) i.delegate(r).to(t);
            }), this.on("remove", (n, i) => {
              for (const r of e) i.stopDelegating(r, t);
            });
          } };
        }
        _renderViewIntoCollectionParent(e, t) {
          e.isRendered || e.render(), e.element && this._parentElement && this._parentElement.insertBefore(e.element, this._parentElement.children[t]);
        }
        remove(e) {
          return super.remove(e);
        }
      }
      var kw = D(6062), J = D.n(kw), Nc = D(4793), ww = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Nc.Z, ww), Nc.Z.locals;
      class de extends on(ve()) {
        constructor(e) {
          super(), this.element = null, this.isRendered = !1, this.locale = e, this.t = e && e.t, this._viewCollections = new _t(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (t, n) => {
            n.locale = e, n.t = e && e.t;
          }), this.decorate("render");
        }
        get bindTemplate() {
          return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Pt.bind(this, this);
        }
        createCollection(e) {
          const t = new wn(e);
          return this._viewCollections.add(t), t;
        }
        registerChild(e) {
          gt(e) || (e = [e]);
          for (const t of e) this._unboundChildren.add(t);
        }
        deregisterChild(e) {
          gt(e) || (e = [e]);
          for (const t of e) this._unboundChildren.remove(t);
        }
        setTemplate(e) {
          this.template = new Pt(e);
        }
        extendTemplate(e) {
          Pt.extend(this.template, e);
        }
        render() {
          if (this.isRendered) throw new T("ui-view-render-already-rendered", this);
          this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = !0;
        }
        destroy() {
          this.stopListening(), this._viewCollections.map((e) => e.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
        }
      }
      class Pt extends _e() {
        constructor(e) {
          super(), Object.assign(this, $c(jc(e))), this._isRendered = !1, this._revertData = null;
        }
        render() {
          const e = this._renderNode({ intoFragment: !0 });
          return this._isRendered = !0, e;
        }
        apply(e) {
          return this._revertData = { children: [], bindings: [], attributes: {} }, this._renderNode({ node: e, intoFragment: !1, isApplying: !0, revertData: this._revertData }), e;
        }
        revert(e) {
          if (!this._revertData) throw new T("ui-template-revert-not-applied", [this, e]);
          this._revertTemplateFromNode(e, this._revertData);
        }
        *getViews() {
          yield* function* e(t) {
            if (t.children) for (const n of t.children) Si(n) ? yield n : hs(n) && (yield* e(n));
          }(this);
        }
        static bind(e, t) {
          return { to: (n, i) => new Aw({ eventNameOrFunction: n, attribute: n, observable: e, emitter: t, callback: i }), if: (n, i, r) => new Vc({ observable: e, emitter: t, attribute: n, valueIfTrue: i, callback: r }) };
        }
        static extend(e, t) {
          if (e._isRendered) throw new T("template-extend-render", [this, e]);
          Wc(e, $c(jc(t)));
        }
        _renderNode(e) {
          let t;
          if (t = e.node ? this.tag && this.text : this.tag ? this.text : !this.text, t) throw new T("ui-template-wrong-syntax", this);
          return this.text ? this._renderText(e) : this._renderElement(e);
        }
        _renderElement(e) {
          let t = e.node;
          return t || (t = e.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(e), this._renderElementChildren(e), this._setUpListeners(e), t;
        }
        _renderText(e) {
          let t = e.node;
          return t ? e.revertData.text = t.textContent : t = e.node = document.createTextNode(""), xi(this.text) ? this._bindToObservable({ schema: this.text, updater: _w(t), data: e }) : t.textContent = this.text.join(""), t;
        }
        _renderAttributes(e) {
          if (!this.attributes) return;
          const t = e.node, n = e.revertData;
          for (const i in this.attributes) {
            const r = t.getAttribute(i), s = this.attributes[i];
            n && (n.attributes[i] = r);
            const a = Kc(s) ? s[0].ns : null;
            if (xi(s)) {
              const l = Kc(s) ? s[0].value : s;
              n && Gc(i) && l.unshift(r), this._bindToObservable({ schema: l, updater: vw(t, i, a), data: e });
            } else if (i == "style" && typeof s[0] != "string") this._renderStyleAttribute(s[0], e);
            else {
              n && r && Gc(i) && s.unshift(r);
              const l = s.map((c) => c && c.value || c).reduce((c, d) => c.concat(d), []).reduce(qc, "");
              to(l) || t.setAttributeNS(a, i, l);
            }
          }
        }
        _renderStyleAttribute(e, t) {
          const n = t.node;
          for (const i in e) {
            const r = e[i];
            xi(r) ? this._bindToObservable({ schema: [r], updater: Cw(n, i), data: t }) : n.style[i] = r;
          }
        }
        _renderElementChildren(e) {
          const t = e.node, n = e.intoFragment ? document.createDocumentFragment() : t, i = e.isApplying;
          let r = 0;
          for (const s of this.children) if (gs(s)) {
            if (!i) {
              s.setParent(t);
              for (const a of s) n.appendChild(a.element);
            }
          } else if (Si(s)) i || (s.isRendered || s.render(), n.appendChild(s.element));
          else if (nn(s)) n.appendChild(s);
          else if (i) {
            const a = { children: [], bindings: [], attributes: {} };
            e.revertData.children.push(a), s._renderNode({ intoFragment: !1, node: n.childNodes[r++], isApplying: !0, revertData: a });
          } else n.appendChild(s.render());
          e.intoFragment && t.appendChild(n);
        }
        _setUpListeners(e) {
          if (this.eventListeners) for (const t in this.eventListeners) {
            const n = this.eventListeners[t].map((i) => {
              const [r, s] = t.split("@");
              return i.activateDomEventListener(r, s, e);
            });
            e.revertData && e.revertData.bindings.push(n);
          }
        }
        _bindToObservable({ schema: e, updater: t, data: n }) {
          const i = n.revertData;
          Lc(e, t, n);
          const r = e.filter((s) => !to(s)).filter((s) => s.observable).map((s) => s.activateAttributeListener(e, t, n));
          i && i.bindings.push(r);
        }
        _revertTemplateFromNode(e, t) {
          for (const i of t.bindings) for (const r of i) r();
          if (t.text) return void (e.textContent = t.text);
          const n = e;
          for (const i in t.attributes) {
            const r = t.attributes[i];
            r === null ? n.removeAttribute(i) : n.setAttribute(i, r);
          }
          for (let i = 0; i < t.children.length; ++i) this._revertTemplateFromNode(n.childNodes[i], t.children[i]);
        }
      }
      class Oo {
        constructor(e) {
          this.attribute = e.attribute, this.observable = e.observable, this.emitter = e.emitter, this.callback = e.callback;
        }
        getValue(e) {
          const t = this.observable[this.attribute];
          return this.callback ? this.callback(t, e) : t;
        }
        activateAttributeListener(e, t, n) {
          const i = () => Lc(e, t, n);
          return this.emitter.listenTo(this.observable, `change:${this.attribute}`, i), () => {
            this.emitter.stopListening(this.observable, `change:${this.attribute}`, i);
          };
        }
      }
      class Aw extends Oo {
        constructor(e) {
          super(e), this.eventNameOrFunction = e.eventNameOrFunction;
        }
        activateDomEventListener(e, t, n) {
          const i = (r, s) => {
            t && !s.target.matches(t) || (typeof this.eventNameOrFunction == "function" ? this.eventNameOrFunction(s) : this.observable.fire(this.eventNameOrFunction, s));
          };
          return this.emitter.listenTo(n.node, e, i), () => {
            this.emitter.stopListening(n.node, e, i);
          };
        }
      }
      class Vc extends Oo {
        constructor(e) {
          super(e), this.valueIfTrue = e.valueIfTrue;
        }
        getValue(e) {
          return !to(super.getValue(e)) && (this.valueIfTrue || !0);
        }
      }
      function xi(o) {
        return !!o && (o.value && (o = o.value), Array.isArray(o) ? o.some(xi) : o instanceof Oo);
      }
      function Lc(o, e, { node: t }) {
        const n = function(r, s) {
          return r.map((a) => a instanceof Oo ? a.getValue(s) : a);
        }(o, t);
        let i;
        i = o.length == 1 && o[0] instanceof Vc ? n[0] : n.reduce(qc, ""), to(i) ? e.remove() : e.set(i);
      }
      function _w(o) {
        return { set(e) {
          o.textContent = e;
        }, remove() {
          o.textContent = "";
        } };
      }
      function vw(o, e, t) {
        return { set(n) {
          o.setAttributeNS(t, e, n);
        }, remove() {
          o.removeAttributeNS(t, e);
        } };
      }
      function Cw(o, e) {
        return { set(t) {
          o.style[e] = t;
        }, remove() {
          o.style[e] = null;
        } };
      }
      function jc(o) {
        return os(o, (e) => {
          if (e && (e instanceof Oo || hs(e) || Si(e) || gs(e))) return e;
        });
      }
      function $c(o) {
        if (typeof o == "string" ? o = /* @__PURE__ */ function(e) {
          return { text: [e] };
        }(o) : o.text && function(e) {
          e.text = $e(e.text);
        }(o), o.on && (o.eventListeners = function(e) {
          for (const t in e) Hc(e, t);
          return e;
        }(o.on), delete o.on), !o.text) {
          o.attributes && function(t) {
            for (const n in t) t[n].value && (t[n].value = $e(t[n].value)), Hc(t, n);
          }(o.attributes);
          const e = [];
          if (o.children) if (gs(o.children)) e.push(o.children);
          else for (const t of o.children) hs(t) || Si(t) || nn(t) ? e.push(t) : e.push(new Pt(t));
          o.children = e;
        }
        return o;
      }
      function Hc(o, e) {
        o[e] = $e(o[e]);
      }
      function qc(o, e) {
        return to(e) ? o : to(o) ? e : `${o} ${e}`;
      }
      function Uc(o, e) {
        for (const t in e) o[t] ? o[t].push(...e[t]) : o[t] = e[t];
      }
      function Wc(o, e) {
        if (e.attributes && (o.attributes || (o.attributes = {}), Uc(o.attributes, e.attributes)), e.eventListeners && (o.eventListeners || (o.eventListeners = {}), Uc(o.eventListeners, e.eventListeners)), e.text && o.text.push(...e.text), e.children && e.children.length) {
          if (o.children.length != e.children.length) throw new T("ui-template-extend-children-mismatch", o);
          let t = 0;
          for (const n of e.children) Wc(o.children[t++], n);
        }
      }
      function to(o) {
        return !o && o !== 0;
      }
      function Si(o) {
        return o instanceof de;
      }
      function hs(o) {
        return o instanceof Pt;
      }
      function gs(o) {
        return o instanceof wn;
      }
      function Kc(o) {
        return ze(o[0]) && o[0].ns;
      }
      function Gc(o) {
        return o == "class" || o == "style";
      }
      class yw extends wn {
        constructor(e, t = []) {
          super(t), this.locale = e;
        }
        attachToDom() {
          this._bodyCollectionContainer = new Pt({ tag: "div", attributes: { class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"], dir: this.locale.uiLanguageDirection }, children: this }).render();
          let e = document.querySelector(".ck-body-wrapper");
          e || (e = Mr(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(e)), e.appendChild(this._bodyCollectionContainer);
        }
        detachFromDom() {
          super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
          const e = document.querySelector(".ck-body-wrapper");
          e && e.childElementCount == 0 && e.remove();
        }
      }
      var Zc = D(6574), Ew = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Zc.Z, Ew), Zc.Z.locals;
      const Jc = class extends de {
        constructor() {
          super();
          const o = this.bindTemplate;
          this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", !0), this.setTemplate({ tag: "svg", ns: "http://www.w3.org/2000/svg", attributes: { class: ["ck", "ck-icon", "ck-reset_all-excluded", o.if("isColorInherited", "ck-icon_inherit-color")], viewBox: o.to("viewBox") } });
        }
        render() {
          super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
            this._updateXMLContent(), this._colorFillPaths();
          }), this.on("change:fillColor", () => {
            this._colorFillPaths();
          });
        }
        _updateXMLContent() {
          if (this.content) {
            const o = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"), e = o.getAttribute("viewBox");
            e && (this.viewBox = e);
            for (const { name: t, value: n } of Array.from(o.attributes)) Jc.presentationalAttributeNames.includes(t) && this.element.setAttribute(t, n);
            for (; this.element.firstChild; ) this.element.removeChild(this.element.firstChild);
            for (; o.childNodes.length > 0; ) this.element.appendChild(o.childNodes[0]);
          }
        }
        _colorFillPaths() {
          this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((o) => {
            o.style.fill = this.fillColor;
          });
        }
      };
      let zo = Jc;
      zo.presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"];
      var Yc = D(4906), xw = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Yc.Z, xw), Yc.Z.locals;
      class De extends de {
        constructor(e) {
          super(e), this._focusDelayed = null;
          const t = this.bindTemplate, n = Q();
          this.set("ariaChecked", void 0), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", `ck-editor__aria-label_${n}`), this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isVisible", !0), this.set("isToggleable", !1), this.set("keystroke", void 0), this.set("label", void 0), this.set("role", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.set("withKeystroke", !1), this.children = this.createCollection(), this.labelView = this._createLabelView(), this.iconView = new zo(), this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
          const i = { tag: "button", attributes: { class: ["ck", "ck-button", t.to("class"), t.if("isEnabled", "ck-disabled", (r) => !r), t.if("isVisible", "ck-hidden", (r) => !r), t.to("isOn", (r) => r ? "ck-on" : "ck-off"), t.if("withText", "ck-button_with-text"), t.if("withKeystroke", "ck-button_with-keystroke")], role: t.to("role"), type: t.to("type", (r) => r || "button"), tabindex: t.to("tabindex"), "aria-label": t.to("ariaLabel"), "aria-labelledby": t.to("ariaLabelledBy"), "aria-disabled": t.if("isEnabled", !0, (r) => !r), "aria-checked": t.to("isOn"), "aria-pressed": t.to("isOn", (r) => !!this.isToggleable && String(!!r)), "data-cke-tooltip-text": t.to("_tooltipString"), "data-cke-tooltip-position": t.to("tooltipPosition") }, children: this.children, on: { click: t.to((r) => {
            this.isEnabled ? this.fire("execute") : r.preventDefault();
          }) } };
          f.isSafari && (this._focusDelayed || (this._focusDelayed = cs(() => this.focus(), 0)), i.on.mousedown = t.to(() => {
            this._focusDelayed();
          }), i.on.mouseup = t.to(() => {
            this._focusDelayed.cancel();
          })), this.setTemplate(i);
        }
        render() {
          super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView);
        }
        focus() {
          this.element.focus();
        }
        destroy() {
          this._focusDelayed && this._focusDelayed.cancel(), super.destroy();
        }
        _createLabelView() {
          const e = new de(), t = this.bindTemplate;
          return e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__label"], style: t.to("labelStyle"), id: this.ariaLabelledBy }, children: [{ text: t.to("label") }] }), e;
        }
        _createKeystrokeView() {
          const e = new de();
          return e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__keystroke"] }, children: [{ text: this.bindTemplate.to("keystroke", (t) => zc(t)) }] }), e;
        }
        _getTooltipString(e, t, n) {
          return e ? typeof e == "string" ? e : (n && (n = zc(n)), e instanceof Function ? e(t, n) : `${t}${n ? ` (${n})` : ""}`) : "";
        }
      }
      var Qc = D(6758), Sw = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Qc.Z, Sw), Qc.Z.locals;
      class Di extends De {
        constructor(e) {
          super(e), this.isToggleable = !0, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
        }
        render() {
          super.render(), this.children.add(this.toggleSwitchView);
        }
        _createToggleView() {
          const e = new de();
          return e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__toggle"] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }] }), e;
        }
      }
      var Xc = D(6781), Dw = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Xc.Z, Dw), Xc.Z.locals, D(1103), D(841);
      var ed = D(3662), Bw = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(ed.Z, Bw), ed.Z.locals;
      class td extends de {
        constructor(e) {
          super(e), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${Q()}`;
          const t = this.bindTemplate;
          this.setTemplate({ tag: "label", attributes: { class: ["ck", "ck-label"], id: this.id, for: t.to("for") }, children: [{ text: t.to("text") }] });
        }
      }
      var nd = D(2577), Tw = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(nd.Z, Tw), nd.Z.locals;
      class od extends de {
        constructor(e, t) {
          super(e);
          const n = `ck-labeled-field-view-${Q()}`, i = `ck-labeled-field-view-status-${Q()}`;
          this.fieldView = t(this, n, i), this.set("label", void 0), this.set("isEnabled", !0), this.set("isEmpty", !0), this.set("isFocused", !1), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(n), this.statusView = this._createStatusView(i), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", (s, a) => s || a);
          const r = this.bindTemplate;
          this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view", r.to("class"), r.if("isEnabled", "ck-disabled", (s) => !s), r.if("isEmpty", "ck-labeled-field-view_empty"), r.if("isFocused", "ck-labeled-field-view_focused"), r.if("placeholder", "ck-labeled-field-view_placeholder"), r.if("errorText", "ck-error")] }, children: [{ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] }, children: this.fieldWrapperChildren }, this.statusView] });
        }
        _createLabelView(e) {
          const t = new td(this.locale);
          return t.for = e, t.bind("text").to(this, "label"), t;
        }
        _createStatusView(e) {
          const t = new de(this.locale), n = this.bindTemplate;
          return t.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__status", n.if("errorText", "ck-labeled-field-view__status_error"), n.if("_statusText", "ck-hidden", (i) => !i)], id: e, role: n.if("errorText", "alert") }, children: [{ text: n.to("_statusText") }] }), t;
        }
        focus() {
          this.fieldView.focus();
        }
      }
      var id = D(4879), Iw = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(id.Z, Iw), id.Z.locals;
      class Pw extends de {
        constructor(e) {
          super(e), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("isReadOnly", !1), this.set("hasError", !1), this.set("ariaDescribedById", void 0), this.focusTracker = new Et(), this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", !0), this.set("inputMode", "text");
          const t = this.bindTemplate;
          this.setTemplate({ tag: "input", attributes: { class: ["ck", "ck-input", t.if("isFocused", "ck-input_focused"), t.if("isEmpty", "ck-input-text_empty"), t.if("hasError", "ck-error")], id: t.to("id"), placeholder: t.to("placeholder"), readonly: t.to("isReadOnly"), inputmode: t.to("inputMode"), "aria-invalid": t.if("hasError", !0), "aria-describedby": t.to("ariaDescribedById") }, on: { input: t.to((...n) => {
            this.fire("input", ...n), this._updateIsEmpty();
          }), change: t.to(this._updateIsEmpty.bind(this)) } });
        }
        render() {
          super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (e, t, n) => {
            this._setDomElementValue(n), this._updateIsEmpty();
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy();
        }
        select() {
          this.element.select();
        }
        focus() {
          this.element.focus();
        }
        _updateIsEmpty() {
          this.isEmpty = !this.element.value;
        }
        _setDomElementValue(e) {
          this.element.value = e || e === 0 ? e : "";
        }
      }
      class Rw extends Pw {
        constructor(e) {
          super(e), this.extendTemplate({ attributes: { type: "text", class: ["ck-input-text"] } });
        }
      }
      class Ow extends de {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-dropdown__panel", t.to("position", (n) => `ck-dropdown__panel_${n}`), t.if("isVisible", "ck-dropdown__panel-visible")] }, children: this.children, on: { selectstart: t.to((n) => {
            n.target.tagName.toLocaleLowerCase() !== "input" && n.preventDefault();
          }) } });
        }
        focus() {
          if (this.children.length) {
            const e = this.children.first;
            typeof e.focus == "function" ? e.focus() : ee("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this });
          }
        }
        focusLast() {
          if (this.children.length) {
            const e = this.children.last;
            typeof e.focusLast == "function" ? e.focusLast() : e.focus();
          }
        }
      }
      var rd = D(5485), zw = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(rd.Z, zw), rd.Z.locals;
      const ms = class extends de {
        constructor(o, e, t) {
          super(o);
          const n = this.bindTemplate;
          this.buttonView = e, this.panelView = t, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.keystrokes = new $t(), this.focusTracker = new Et(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dropdown", n.to("class"), n.if("isEnabled", "ck-disabled", (i) => !i)], id: n.to("id"), "aria-describedby": n.to("ariaDescribedById") }, children: [e, t] }), e.extendTemplate({ attributes: { class: ["ck-dropdown__button"], "data-cke-tooltip-disabled": n.to("isOpen") } });
        }
        render() {
          super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", () => {
            this.isOpen = !this.isOpen;
          }), this.panelView.bind("isVisible").to(this, "isOpen"), this.on("change:isOpen", (e, t, n) => {
            n && (this.panelPosition === "auto" ? this.panelView.position = ms._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: !0, positions: this._panelPositions }).name : this.panelView.position = this.panelPosition);
          }), this.keystrokes.listenTo(this.element);
          const o = (e, t) => {
            this.isOpen && (this.isOpen = !1, t());
          };
          this.keystrokes.set("arrowdown", (e, t) => {
            this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0, t());
          }), this.keystrokes.set("arrowright", (e, t) => {
            this.isOpen && t();
          }), this.keystrokes.set("arrowleft", o), this.keystrokes.set("esc", o);
        }
        focus() {
          this.buttonView.focus();
        }
        get _panelPositions() {
          const { south: o, north: e, southEast: t, southWest: n, northEast: i, northWest: r, southMiddleEast: s, southMiddleWest: a, northMiddleEast: l, northMiddleWest: c } = ms.defaultPanelPositions;
          return this.locale.uiLanguageDirection !== "rtl" ? [t, n, s, a, o, i, r, l, c, e] : [n, t, a, s, o, r, i, c, l, e];
        }
      };
      let ps = ms;
      ps.defaultPanelPositions = { south: (o, e) => ({ top: o.bottom, left: o.left - (e.width - o.width) / 2, name: "s" }), southEast: (o) => ({ top: o.bottom, left: o.left, name: "se" }), southWest: (o, e) => ({ top: o.bottom, left: o.left - e.width + o.width, name: "sw" }), southMiddleEast: (o, e) => ({ top: o.bottom, left: o.left - (e.width - o.width) / 4, name: "sme" }), southMiddleWest: (o, e) => ({ top: o.bottom, left: o.left - 3 * (e.width - o.width) / 4, name: "smw" }), north: (o, e) => ({ top: o.top - e.height, left: o.left - (e.width - o.width) / 2, name: "n" }), northEast: (o, e) => ({ top: o.top - e.height, left: o.left, name: "ne" }), northWest: (o, e) => ({ top: o.top - e.height, left: o.left - e.width + o.width, name: "nw" }), northMiddleEast: (o, e) => ({ top: o.top - e.height, left: o.left - (e.width - o.width) / 4, name: "nme" }), northMiddleWest: (o, e) => ({ top: o.top - e.height, left: o.left - 3 * (e.width - o.width) / 4, name: "nmw" }) }, ps._getOptimalPosition = Sc;
      const sd = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
      class ad extends De {
        constructor(e) {
          super(e), this.arrowView = this._createArrowView(), this.extendTemplate({ attributes: { "aria-haspopup": !0, "aria-expanded": this.bindTemplate.to("isOn", (t) => String(t)) } }), this.delegate("execute").to(this, "open");
        }
        render() {
          super.render(), this.children.add(this.arrowView);
        }
        _createArrowView() {
          const e = new zo();
          return e.content = sd, e.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }), e;
        }
      }
      class Mo {
        constructor(e) {
          if (this.focusables = e.focusables, this.focusTracker = e.focusTracker, this.keystrokeHandler = e.keystrokeHandler, this.actions = e.actions, e.actions && e.keystrokeHandler) for (const t in e.actions) {
            let n = e.actions[t];
            typeof n == "string" && (n = [n]);
            for (const i of n) e.keystrokeHandler.set(i, (r, s) => {
              this[t](), s();
            });
          }
        }
        get first() {
          return this.focusables.find(fs) || null;
        }
        get last() {
          return this.focusables.filter(fs).slice(-1)[0] || null;
        }
        get next() {
          return this._getFocusableItem(1);
        }
        get previous() {
          return this._getFocusableItem(-1);
        }
        get current() {
          let e = null;
          return this.focusTracker.focusedElement === null ? null : (this.focusables.find((t, n) => {
            const i = t.element === this.focusTracker.focusedElement;
            return i && (e = n), i;
          }), e);
        }
        focusFirst() {
          this._focus(this.first);
        }
        focusLast() {
          this._focus(this.last);
        }
        focusNext() {
          this._focus(this.next);
        }
        focusPrevious() {
          this._focus(this.previous);
        }
        _focus(e) {
          e && e.focus();
        }
        _getFocusableItem(e) {
          const t = this.current, n = this.focusables.length;
          if (!n) return null;
          if (t === null) return this[e === 1 ? "first" : "last"];
          let i = (t + n + e) % n;
          do {
            const r = this.focusables.get(i);
            if (fs(r)) return r;
            i = (i + n + e) % n;
          } while (i !== t);
          return null;
        }
      }
      function fs(o) {
        return !(!o.focus || !kn(o.element));
      }
      class ld extends de {
        constructor(e) {
          super(e), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } });
        }
      }
      class Mw extends de {
        constructor(e) {
          super(e), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__line-break"] } });
        }
      }
      function cd(o) {
        return Array.isArray(o) ? { items: o, removeItems: [] } : o ? Object.assign({ items: [], removeItems: [] }, o) : { items: [], removeItems: [] };
      }
      class K extends ve() {
        constructor(e) {
          super(), this._disableStack = /* @__PURE__ */ new Set(), this.editor = e, this.set("isEnabled", !0);
        }
        forceDisabled(e) {
          this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", dd, { priority: "highest" }), this.isEnabled = !1);
        }
        clearForceDisabled(e) {
          this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", dd), this.isEnabled = !0);
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return !1;
        }
      }
      function dd(o) {
        o.return = !1, o.stop();
      }
      class ae extends ve() {
        constructor(e) {
          super(), this.editor = e, this.set("value", void 0), this.set("isEnabled", !1), this._affectsData = !0, this._isEnabledBasedOnSelection = !0, this._disableStack = /* @__PURE__ */ new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
            this.refresh();
          }), this.listenTo(e, "change:isReadOnly", () => {
            this.refresh();
          }), this.on("set:isEnabled", (t) => {
            this.affectsData && (e.isReadOnly || this._isEnabledBasedOnSelection && !e.model.canEditAt(e.model.document.selection)) && (t.return = !1, t.stop());
          }, { priority: "highest" }), this.on("execute", (t) => {
            this.isEnabled || t.stop();
          }, { priority: "high" });
        }
        get affectsData() {
          return this._affectsData;
        }
        set affectsData(e) {
          this._affectsData = e;
        }
        refresh() {
          this.isEnabled = !0;
        }
        forceDisabled(e) {
          this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", ud, { priority: "highest" }), this.isEnabled = !1);
        }
        clearForceDisabled(e) {
          this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", ud), this.refresh());
        }
        execute(...e) {
        }
        destroy() {
          this.stopListening();
        }
      }
      function ud(o) {
        o.return = !1, o.stop();
      }
      class hd extends ae {
        constructor() {
          super(...arguments), this._childCommandsDefinitions = [];
        }
        refresh() {
        }
        execute(...e) {
          const t = this._getFirstEnabledCommand();
          return !!t && t.execute(e);
        }
        registerChildCommand(e, t = {}) {
          Y(this._childCommandsDefinitions, { command: e, priority: t.priority || "normal" }), e.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled();
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand();
        }
        _getFirstEnabledCommand() {
          const e = this._childCommandsDefinitions.find(({ command: t }) => t.isEnabled);
          return e && e.command;
        }
      }
      class gd extends _e() {
        constructor(e, t = [], n = []) {
          super(), this._plugins = /* @__PURE__ */ new Map(), this._context = e, this._availablePlugins = /* @__PURE__ */ new Map();
          for (const i of t) i.pluginName && this._availablePlugins.set(i.pluginName, i);
          this._contextPlugins = /* @__PURE__ */ new Map();
          for (const [i, r] of n) this._contextPlugins.set(i, r), this._contextPlugins.set(r, i), i.pluginName && this._availablePlugins.set(i.pluginName, i);
        }
        *[Symbol.iterator]() {
          for (const e of this._plugins) typeof e[0] == "function" && (yield e);
        }
        get(e) {
          const t = this._plugins.get(e);
          if (!t) {
            let n = e;
            throw typeof e == "function" && (n = e.pluginName || e.name), new T("plugincollection-plugin-not-loaded", this._context, { plugin: n });
          }
          return t;
        }
        has(e) {
          return this._plugins.has(e);
        }
        init(e, t = [], n = []) {
          const i = this, r = this._context;
          (function b(w, y = /* @__PURE__ */ new Set()) {
            w.forEach((I) => {
              l(I) && (y.has(I) || (y.add(I), I.pluginName && !i._availablePlugins.has(I.pluginName) && i._availablePlugins.set(I.pluginName, I), I.requires && b(I.requires, y)));
            });
          })(e), g(e);
          const s = [...function b(w, y = /* @__PURE__ */ new Set()) {
            return w.map((I) => l(I) ? I : i._availablePlugins.get(I)).reduce((I, z) => y.has(z) ? I : (y.add(z), z.requires && (g(z.requires, z), b(z.requires, y).forEach((H) => I.add(H))), I.add(z)), /* @__PURE__ */ new Set());
          }(e.filter((b) => !d(b, t)))];
          (function(b, w) {
            for (const y of w) {
              if (typeof y != "function") throw new T("plugincollection-replace-plugin-invalid-type", null, { pluginItem: y });
              const I = y.pluginName;
              if (!I) throw new T("plugincollection-replace-plugin-missing-name", null, { pluginItem: y });
              if (y.requires && y.requires.length) throw new T("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: I });
              const z = i._availablePlugins.get(I);
              if (!z) throw new T("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: I });
              const H = b.indexOf(z);
              if (H === -1) {
                if (i._contextPlugins.has(z)) return;
                throw new T("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: I });
              }
              if (z.requires && z.requires.length) throw new T("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: I });
              b.splice(H, 1, y), i._availablePlugins.set(I, y);
            }
          })(s, n);
          const a = s.map((b) => {
            let w = i._contextPlugins.get(b);
            return w = w || new b(r), i._add(b, w), w;
          });
          return p(a, "init").then(() => p(a, "afterInit")).then(() => a);
          function l(b) {
            return typeof b == "function";
          }
          function c(b) {
            return l(b) && !!b.isContextPlugin;
          }
          function d(b, w) {
            return w.some((y) => y === b || u(b) === y || u(y) === b);
          }
          function u(b) {
            return l(b) ? b.pluginName || b.name : b;
          }
          function g(b, w = null) {
            b.map((y) => l(y) ? y : i._availablePlugins.get(y) || y).forEach((y) => {
              (function(I, z) {
                if (!l(I))
                  throw z ? new T("plugincollection-soft-required", r, { missingPlugin: I, requiredBy: u(z) }) : new T("plugincollection-plugin-not-found", r, { plugin: I });
              })(y, w), function(I, z) {
                if (c(z) && !c(I))
                  throw new T("plugincollection-context-required", r, { plugin: u(I), requiredBy: u(z) });
              }(y, w), function(I, z) {
                if (z && d(I, t))
                  throw new T("plugincollection-required", r, { plugin: u(I), requiredBy: u(z) });
              }(y, w);
            });
          }
          function p(b, w) {
            return b.reduce((y, I) => I[w] ? i._contextPlugins.has(I) ? y : y.then(I[w].bind(I)) : y, Promise.resolve());
          }
        }
        destroy() {
          const e = [];
          for (const [, t] of this) typeof t.destroy != "function" || this._contextPlugins.has(t) || e.push(t.destroy());
          return Promise.all(e);
        }
        _add(e, t) {
          this._plugins.set(e, t);
          const n = e.pluginName;
          if (n) {
            if (this._plugins.has(n)) throw new T("plugincollection-plugin-name-conflict", null, { pluginName: n, plugin1: this._plugins.get(n).constructor, plugin2: e });
            this._plugins.set(n, t);
          }
        }
      }
      class md {
        constructor(e) {
          this._contextOwner = null, this.config = new pc(e, this.constructor.defaultConfig);
          const t = this.constructor.builtinPlugins;
          this.config.define("plugins", t), this.plugins = new gd(this, t);
          const n = this.config.get("language") || {};
          this.locale = new fw({ uiLanguage: typeof n == "string" ? n : n.ui, contentLanguage: this.config.get("language.content") }), this.t = this.locale.t, this.editors = new _t();
        }
        initPlugins() {
          const e = this.config.get("plugins") || [], t = this.config.get("substitutePlugins") || [];
          for (const n of e.concat(t)) {
            if (typeof n != "function") throw new T("context-initplugins-constructor-only", null, { Plugin: n });
            if (n.isContextPlugin !== !0) throw new T("context-initplugins-invalid-plugin", null, { Plugin: n });
          }
          return this.plugins.init(e, [], t);
        }
        destroy() {
          return Promise.all(Array.from(this.editors, (e) => e.destroy())).then(() => this.plugins.destroy());
        }
        _addEditor(e, t) {
          if (this._contextOwner) throw new T("context-addeditor-private-context");
          this.editors.add(e), t && (this._contextOwner = e);
        }
        _removeEditor(e) {
          return this.editors.has(e) && this.editors.remove(e), this._contextOwner === e ? this.destroy() : Promise.resolve();
        }
        _getEditorConfig() {
          const e = {};
          for (const t of this.config.names()) ["plugins", "removePlugins", "extraPlugins"].includes(t) || (e[t] = this.config.get(t));
          return e;
        }
        static create(e) {
          return new Promise((t) => {
            const n = new this(e);
            t(n.initPlugins().then(() => n));
          });
        }
      }
      class Bi extends ve() {
        constructor(e) {
          super(), this.context = e;
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return !0;
        }
      }
      class Fw extends $t {
        constructor(e) {
          super(), this.editor = e;
        }
        set(e, t, n = {}) {
          if (typeof t == "string") {
            const i = t;
            t = (r, s) => {
              this.editor.execute(i), s();
            };
          }
          super.set(e, t, n);
        }
      }
      var pd = D(4717), Nw = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(pd.Z, Nw), pd.Z.locals;
      const Ti = /* @__PURE__ */ new WeakMap();
      function Vw(o, e) {
        return !!e.hasClass("ck-placeholder") && (o.removeClass("ck-placeholder", e), !0);
      }
      function bs(o, e) {
        const t = Ti.get(o), n = [];
        let i = !1;
        for (const [r, s] of t) s.isDirectHost && (n.push(r), fd(e, r, s) && (i = !0));
        for (const [r, s] of t) {
          if (s.isDirectHost) continue;
          const a = Lw(r);
          a && (n.includes(a) || (s.hostElement = a, fd(e, r, s) && (i = !0)));
        }
        return i;
      }
      function fd(o, e, t) {
        const { text: n, isDirectHost: i, hostElement: r } = t;
        let s = !1;
        return r.getAttribute("data-placeholder") !== n && (o.setAttribute("data-placeholder", n, r), s = !0), (i || e.childCount == 1) && function(a, l) {
          if (!a.isAttached() || Array.from(a.getChildren()).some((u) => !u.is("uiElement"))) return !1;
          const c = a.document, d = c.selection.anchor;
          return !(c.isComposing && d && d.parent === a || !l && c.isFocused && (!d || d.parent === a));
        }(r, t.keepOnFocus) ? function(a, l) {
          return !l.hasClass("ck-placeholder") && (a.addClass("ck-placeholder", l), !0);
        }(o, r) && (s = !0) : Vw(o, r) && (s = !0), s;
      }
      function Lw(o) {
        if (o.childCount) {
          const e = o.getChild(0);
          if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement")) return e;
        }
        return null;
      }
      class An {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      const bd = function(o) {
        return ns(o, 4);
      };
      class _n extends _e(An) {
        constructor(e) {
          super(), this.document = e, this.parent = null;
        }
        get index() {
          let e;
          if (!this.parent) return null;
          if ((e = this.parent.getChildIndex(this)) == -1) throw new T("view-node-not-found-in-parent", this);
          return e;
        }
        get nextSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e + 1) || null;
        }
        get previousSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e - 1) || null;
        }
        get root() {
          let e = this;
          for (; e.parent; ) e = e.parent;
          return e;
        }
        isAttached() {
          return this.root.is("rootElement");
        }
        getPath() {
          const e = [];
          let t = this;
          for (; t.parent; ) e.unshift(t.index), t = t.parent;
          return e;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this : this.parent;
          for (; n; ) t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
        getCommonAncestor(e, t = {}) {
          const n = this.getAncestors(t), i = e.getAncestors(t);
          let r = 0;
          for (; n[r] == i[r] && n[r]; ) r++;
          return r === 0 ? null : n[r - 1];
        }
        isBefore(e) {
          if (this == e || this.root !== e.root) return !1;
          const t = this.getPath(), n = e.getPath(), i = ot(t, n);
          switch (i) {
            case "prefix":
              return !0;
            case "extension":
              return !1;
            default:
              return t[i] < n[i];
          }
        }
        isAfter(e) {
          return this != e && this.root === e.root && !this.isBefore(e);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _fireChange(e, t) {
          this.fire(`change:${e}`, t), this.parent && this.parent._fireChange(e, t);
        }
        toJSON() {
          const e = bd(this);
          return delete e.parent, e;
        }
      }
      _n.prototype.is = function(o) {
        return o === "node" || o === "view:node";
      };
      class Ce extends _n {
        constructor(e, t) {
          super(e), this._textData = t;
        }
        get data() {
          return this._textData;
        }
        get _data() {
          return this.data;
        }
        set _data(e) {
          this._fireChange("text", this), this._textData = e;
        }
        isSimilar(e) {
          return e instanceof Ce && (this === e || this.data === e.data);
        }
        _clone() {
          return new Ce(this.document, this.data);
        }
      }
      Ce.prototype.is = function(o) {
        return o === "$text" || o === "view:$text" || o === "text" || o === "view:text" || o === "node" || o === "view:node";
      };
      class Rt extends An {
        constructor(e, t, n) {
          if (super(), this.textNode = e, t < 0 || t > e.data.length) throw new T("view-textproxy-wrong-offsetintext", this);
          if (n < 0 || t + n > e.data.length) throw new T("view-textproxy-wrong-length", this);
          this.data = e.data.substring(t, t + n), this.offsetInText = t;
        }
        get offsetSize() {
          return this.data.length;
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        get document() {
          return this.textNode.document;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this.textNode : this.parent;
          for (; n !== null; ) t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
      }
      Rt.prototype.is = function(o) {
        return o === "$textProxy" || o === "view:$textProxy" || o === "textProxy" || o === "view:textProxy";
      };
      class no {
        constructor(...e) {
          this._patterns = [], this.add(...e);
        }
        add(...e) {
          for (let t of e) (typeof t == "string" || t instanceof RegExp) && (t = { name: t }), this._patterns.push(t);
        }
        match(...e) {
          for (const t of e) for (const n of this._patterns) {
            const i = kd(t, n);
            if (i) return { element: t, pattern: n, match: i };
          }
          return null;
        }
        matchAll(...e) {
          const t = [];
          for (const n of e) for (const i of this._patterns) {
            const r = kd(n, i);
            r && t.push({ element: n, pattern: i, match: r });
          }
          return t.length > 0 ? t : null;
        }
        getElementName() {
          if (this._patterns.length !== 1) return null;
          const e = this._patterns[0], t = e.name;
          return typeof e == "function" || !t || t instanceof RegExp ? null : t;
        }
      }
      function kd(o, e) {
        if (typeof e == "function") return e(o);
        const t = {};
        return e.name && (t.name = function(n, i) {
          return n instanceof RegExp ? !!i.match(n) : n === i;
        }(e.name, o.name), !t.name) || e.attributes && (t.attributes = function(n, i) {
          const r = new Set(i.getAttributeKeys());
          return at(n) ? (n.style !== void 0 && ee("matcher-pattern-deprecated-attributes-style-key", n), n.class !== void 0 && ee("matcher-pattern-deprecated-attributes-class-key", n)) : (r.delete("style"), r.delete("class")), ks(n, r, (s) => i.getAttribute(s));
        }(e.attributes, o), !t.attributes) || e.classes && (t.classes = function(n, i) {
          return ks(n, i.getClassNames(), () => {
          });
        }(e.classes, o), !t.classes) || e.styles && (t.styles = function(n, i) {
          return ks(n, i.getStyleNames(!0), (r) => i.getStyle(r));
        }(e.styles, o), !t.styles) ? null : t;
      }
      function ks(o, e, t) {
        const n = function(s) {
          return Array.isArray(s) ? s.map((a) => at(a) ? (a.key !== void 0 && a.value !== void 0 || ee("matcher-pattern-missing-key-or-value", a), [a.key, a.value]) : [a, !0]) : at(s) ? Object.entries(s) : [[s, !0]];
        }(o), i = Array.from(e), r = [];
        if (n.forEach(([s, a]) => {
          i.forEach((l) => {
            (function(c, d) {
              return c === !0 || c === d || c instanceof RegExp && d.match(c);
            })(s, l) && function(c, d, u) {
              if (c === !0) return !0;
              const g = u(d);
              return c === g || c instanceof RegExp && !!String(g).match(c);
            }(a, l, t) && r.push(l);
          });
        }), n.length && !(r.length < n.length)) return r;
      }
      const Ii = function(o) {
        return typeof o == "symbol" || At(o) && tn(o) == "[object Symbol]";
      };
      var jw = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, $w = /^\w*$/;
      const Hw = function(o, e) {
        if (it(o)) return !1;
        var t = typeof o;
        return !(t != "number" && t != "symbol" && t != "boolean" && o != null && !Ii(o)) || $w.test(o) || !jw.test(o) || e != null && o in Object(e);
      };
      function ws(o, e) {
        if (typeof o != "function" || e != null && typeof e != "function") throw new TypeError("Expected a function");
        var t = function() {
          var n = arguments, i = e ? e.apply(this, n) : n[0], r = t.cache;
          if (r.has(i)) return r.get(i);
          var s = o.apply(this, n);
          return t.cache = r.set(i, s) || r, s;
        };
        return t.cache = new (ws.Cache || fi)(), t;
      }
      ws.Cache = fi;
      const qw = ws, Uw = function(o) {
        var e = qw(o, function(n) {
          return t.size === 500 && t.clear(), n;
        }), t = e.cache;
        return e;
      };
      var Ww = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Kw = /\\(\\)?/g, Gw = Uw(function(o) {
        var e = [];
        return o.charCodeAt(0) === 46 && e.push(""), o.replace(Ww, function(t, n, i, r) {
          e.push(i ? r.replace(Kw, "$1") : n || t);
        }), e;
      });
      const Zw = Gw, Jw = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length, i = Array(n); ++t < n; ) i[t] = e(o[t], t, o);
        return i;
      };
      var wd = It ? It.prototype : void 0, Ad = wd ? wd.toString : void 0;
      const Yw = function o(e) {
        if (typeof e == "string") return e;
        if (it(e)) return Jw(e, o) + "";
        if (Ii(e)) return Ad ? Ad.call(e) : "";
        var t = e + "";
        return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
      }, As = function(o) {
        return o == null ? "" : Yw(o);
      }, _s = function(o, e) {
        return it(o) ? o : Hw(o, e) ? [o] : Zw(As(o));
      }, Qw = function(o) {
        var e = o == null ? 0 : o.length;
        return e ? o[e - 1] : void 0;
      }, vs = function(o) {
        if (typeof o == "string" || Ii(o)) return o;
        var e = o + "";
        return e == "0" && 1 / o == -1 / 0 ? "-0" : e;
      }, _d = function(o, e) {
        for (var t = 0, n = (e = _s(e, o)).length; o != null && t < n; ) o = o[vs(e[t++])];
        return t && t == n ? o : void 0;
      }, vd = function(o, e, t) {
        var n = -1, i = o.length;
        e < 0 && (e = -e > i ? 0 : i + e), (t = t > i ? i : t) < 0 && (t += i), i = e > t ? 0 : t - e >>> 0, e >>>= 0;
        for (var r = Array(i); ++n < i; ) r[n] = o[n + e];
        return r;
      }, Xw = function(o, e) {
        return e.length < 2 ? o : _d(o, vd(e, 0, -1));
      }, eA = function(o, e) {
        return e = _s(e, o), (o = Xw(o, e)) == null || delete o[vs(Qw(e))];
      }, tA = function(o, e) {
        return o == null || eA(o, e);
      }, Pi = function(o, e, t) {
        var n = o == null ? void 0 : _d(o, e);
        return n === void 0 ? t : n;
      }, Cs = function(o, e, t) {
        (t !== void 0 && !So(o[e], t) || t === void 0 && !(e in o)) && Vr(o, e, t);
      }, nA = /* @__PURE__ */ function(o) {
        return function(e, t, n) {
          for (var i = -1, r = Object(e), s = n(e), a = s.length; a--; ) {
            var l = s[++i];
            if (t(r[l], l, r) === !1) break;
          }
          return e;
        };
      }(), oA = function(o) {
        return At(o) && ki(o);
      }, ys = function(o, e) {
        if ((e !== "constructor" || typeof o[e] != "function") && e != "__proto__") return o[e];
      }, iA = function(o) {
        return Zn(o, Yn(o));
      }, rA = function(o, e, t, n, i, r, s) {
        var a = ys(o, t), l = ys(e, t), c = s.get(l);
        if (c) Cs(o, t, c);
        else {
          var d = r ? r(a, l, t + "", o, e, s) : void 0, u = d === void 0;
          if (u) {
            var g = it(l), p = !g && Io(l), b = !g && !p && Ur(l);
            d = l, g || p || b ? it(a) ? d = a : oA(a) ? d = Gr(a) : p ? (u = !1, d = Gl(l, !0)) : b ? (u = !1, d = ac(l, !0)) : d = [] : at(l) || jr(l) ? (d = a, jr(a) ? d = iA(a) : ze(a) && !mn(a) || (d = cc(l))) : u = !1;
          }
          u && (s.set(l, d), i(d, l, n, r, s), s.delete(l)), Cs(o, t, d);
        }
      }, Cd = function o(e, t, n, i, r) {
        e !== t && nA(t, function(s, a) {
          if (r || (r = new To()), ze(s)) rA(e, t, a, n, o, i, r);
          else {
            var l = i ? i(ys(e, a), s, a + "", e, t, r) : void 0;
            l === void 0 && (l = s), Cs(e, a, l);
          }
        }, Yn);
      }, vn = function(o) {
        return o;
      }, sA = function(o, e, t) {
        switch (t.length) {
          case 0:
            return o.call(e);
          case 1:
            return o.call(e, t[0]);
          case 2:
            return o.call(e, t[0], t[1]);
          case 3:
            return o.call(e, t[0], t[1], t[2]);
        }
        return o.apply(e, t);
      };
      var yd = Math.max;
      const aA = function(o, e, t) {
        return e = yd(e === void 0 ? o.length - 1 : e, 0), function() {
          for (var n = arguments, i = -1, r = yd(n.length - e, 0), s = Array(r); ++i < r; ) s[i] = n[e + i];
          i = -1;
          for (var a = Array(e + 1); ++i < e; ) a[i] = n[i];
          return a[e] = t(s), sA(o, this, a);
        };
      }, lA = function(o) {
        return function() {
          return o;
        };
      }, cA = bi ? function(o, e) {
        return bi(o, "toString", { configurable: !0, enumerable: !1, value: lA(e), writable: !0 });
      } : vn;
      var dA = Date.now;
      const uA = function(o) {
        var e = 0, t = 0;
        return function() {
          var n = dA(), i = 16 - (n - t);
          if (t = n, i > 0) {
            if (++e >= 800) return arguments[0];
          } else e = 0;
          return o.apply(void 0, arguments);
        };
      }(cA), Ed = function(o, e) {
        return uA(aA(o, e, vn), o + "");
      }, hA = function(o, e, t) {
        if (!ze(t)) return !1;
        var n = typeof e;
        return !!(n == "number" ? ki(t) && $r(e, t.length) : n == "string" && e in t) && So(t[e], o);
      }, Es = function(o) {
        return Ed(function(e, t) {
          var n = -1, i = t.length, r = i > 1 ? t[i - 1] : void 0, s = i > 2 ? t[2] : void 0;
          for (r = o.length > 3 && typeof r == "function" ? (i--, r) : void 0, s && hA(t[0], t[1], s) && (r = i < 3 ? void 0 : r, i = 1), e = Object(e); ++n < i; ) {
            var a = t[n];
            a && o(e, a, n, r);
          }
          return e;
        });
      }, xd = Es(function(o, e, t) {
        Cd(o, e, t);
      }), gA = function(o, e, t, n) {
        if (!ze(o)) return o;
        for (var i = -1, r = (e = _s(e, o)).length, s = r - 1, a = o; a != null && ++i < r; ) {
          var l = vs(e[i]), c = t;
          if (l === "__proto__" || l === "constructor" || l === "prototype") return o;
          if (i != s) {
            var d = a[l];
            (c = void 0) == void 0 && (c = ze(d) ? d : $r(e[i + 1]) ? [] : {});
          }
          Lr(a, l, c), a = a[l];
        }
        return o;
      }, mA = function(o, e, t) {
        return o == null ? o : gA(o, e, t);
      };
      class pA {
        constructor(e) {
          this._styles = {}, this._styleProcessor = e;
        }
        get isEmpty() {
          const e = Object.entries(this._styles);
          return !Array.from(e).length;
        }
        get size() {
          return this.isEmpty ? 0 : this.getStyleNames().length;
        }
        setTo(e) {
          this.clear();
          const t = Array.from(function(n) {
            let i = null, r = 0, s = 0, a = null;
            const l = /* @__PURE__ */ new Map();
            if (n === "") return l;
            n.charAt(n.length - 1) != ";" && (n += ";");
            for (let c = 0; c < n.length; c++) {
              const d = n.charAt(c);
              if (i === null) switch (d) {
                case ":":
                  a || (a = n.substr(r, c - r), s = c + 1);
                  break;
                case '"':
                case "'":
                  i = d;
                  break;
                case ";": {
                  const u = n.substr(s, c - s);
                  a && l.set(a.trim(), u.trim()), a = null, r = c + 1;
                  break;
                }
              }
              else d === i && (i = null);
            }
            return l;
          }(e).entries());
          for (const [n, i] of t) this._styleProcessor.toNormalizedForm(n, i, this._styles);
        }
        has(e) {
          if (this.isEmpty) return !1;
          const t = this._styleProcessor.getReducedForm(e, this._styles).find(([n]) => n === e);
          return Array.isArray(t);
        }
        set(e, t) {
          if (ze(e)) for (const [n, i] of Object.entries(e)) this._styleProcessor.toNormalizedForm(n, i, this._styles);
          else this._styleProcessor.toNormalizedForm(e, t, this._styles);
        }
        remove(e) {
          const t = xs(e);
          tA(this._styles, t), delete this._styles[e], this._cleanEmptyObjectsOnPath(t);
        }
        getNormalized(e) {
          return this._styleProcessor.getNormalized(e, this._styles);
        }
        toString() {
          return this.isEmpty ? "" : this._getStylesEntries().map((e) => e.join(":")).sort().join(";") + ";";
        }
        getAsString(e) {
          if (this.isEmpty) return;
          if (this._styles[e] && !ze(this._styles[e])) return this._styles[e];
          const t = this._styleProcessor.getReducedForm(e, this._styles).find(([n]) => n === e);
          return Array.isArray(t) ? t[1] : void 0;
        }
        getStyleNames(e = !1) {
          return this.isEmpty ? [] : e ? this._styleProcessor.getStyleNames(this._styles) : this._getStylesEntries().map(([t]) => t);
        }
        clear() {
          this._styles = {};
        }
        _getStylesEntries() {
          const e = [], t = Object.keys(this._styles);
          for (const n of t) e.push(...this._styleProcessor.getReducedForm(n, this._styles));
          return e;
        }
        _cleanEmptyObjectsOnPath(e) {
          const t = e.split(".");
          if (!(t.length > 1)) return;
          const n = t.splice(0, t.length - 1).join("."), i = Pi(this._styles, n);
          i && !Array.from(Object.keys(i)).length && this.remove(n);
        }
      }
      class fA {
        constructor() {
          this._normalizers = /* @__PURE__ */ new Map(), this._extractors = /* @__PURE__ */ new Map(), this._reducers = /* @__PURE__ */ new Map(), this._consumables = /* @__PURE__ */ new Map();
        }
        toNormalizedForm(e, t, n) {
          if (ze(t)) Ss(n, xs(e), t);
          else if (this._normalizers.has(e)) {
            const i = this._normalizers.get(e), { path: r, value: s } = i(t);
            Ss(n, r, s);
          } else Ss(n, e, t);
        }
        getNormalized(e, t) {
          if (!e) return xd({}, t);
          if (t[e] !== void 0) return t[e];
          if (this._extractors.has(e)) {
            const n = this._extractors.get(e);
            if (typeof n == "string") return Pi(t, n);
            const i = n(e, t);
            if (i) return i;
          }
          return Pi(t, xs(e));
        }
        getReducedForm(e, t) {
          const n = this.getNormalized(e, t);
          return n === void 0 ? [] : this._reducers.has(e) ? this._reducers.get(e)(n) : [[e, n]];
        }
        getStyleNames(e) {
          const t = Array.from(this._consumables.keys()).filter((i) => {
            const r = this.getNormalized(i, e);
            return r && typeof r == "object" ? Object.keys(r).length : r;
          }), n = /* @__PURE__ */ new Set([...t, ...Object.keys(e)]);
          return Array.from(n.values());
        }
        getRelatedStyles(e) {
          return this._consumables.get(e) || [];
        }
        setNormalizer(e, t) {
          this._normalizers.set(e, t);
        }
        setExtractor(e, t) {
          this._extractors.set(e, t);
        }
        setReducer(e, t) {
          this._reducers.set(e, t);
        }
        setStyleRelation(e, t) {
          this._mapStyleNames(e, t);
          for (const n of t) this._mapStyleNames(n, [e]);
        }
        _mapStyleNames(e, t) {
          this._consumables.has(e) || this._consumables.set(e, []), this._consumables.get(e).push(...t);
        }
      }
      function xs(o) {
        return o.replace("-", ".");
      }
      function Ss(o, e, t) {
        let n = t;
        ze(t) && (n = xd({}, Pi(o, e), t)), mA(o, e, n);
      }
      class mt extends _n {
        constructor(e, t, n, i) {
          if (super(e), this._unsafeAttributesToRender = [], this._customProperties = /* @__PURE__ */ new Map(), this.name = t, this._attrs = function(r) {
            const s = Ht(r);
            for (const [a, l] of s) l === null ? s.delete(a) : typeof l != "string" && s.set(a, String(l));
            return s;
          }(n), this._children = [], i && this._insertChild(0, i), this._classes = /* @__PURE__ */ new Set(), this._attrs.has("class")) {
            const r = this._attrs.get("class");
            Sd(this._classes, r), this._attrs.delete("class");
          }
          this._styles = new pA(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style"));
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this._children.length === 0;
        }
        getChild(e) {
          return this._children[e];
        }
        getChildIndex(e) {
          return this._children.indexOf(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        *getAttributeKeys() {
          this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys();
        }
        *getAttributes() {
          yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
        }
        getAttribute(e) {
          if (e == "class") return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
          if (e == "style") {
            const t = this._styles.toString();
            return t == "" ? void 0 : t;
          }
          return this._attrs.get(e);
        }
        hasAttribute(e) {
          return e == "class" ? this._classes.size > 0 : e == "style" ? !this._styles.isEmpty : this._attrs.has(e);
        }
        isSimilar(e) {
          if (!(e instanceof mt)) return !1;
          if (this === e) return !0;
          if (this.name != e.name || this._attrs.size !== e._attrs.size || this._classes.size !== e._classes.size || this._styles.size !== e._styles.size) return !1;
          for (const [t, n] of this._attrs) if (!e._attrs.has(t) || e._attrs.get(t) !== n) return !1;
          for (const t of this._classes) if (!e._classes.has(t)) return !1;
          for (const t of this._styles.getStyleNames()) if (!e._styles.has(t) || e._styles.getAsString(t) !== this._styles.getAsString(t)) return !1;
          return !0;
        }
        hasClass(...e) {
          for (const t of e) if (!this._classes.has(t)) return !1;
          return !0;
        }
        getClassNames() {
          return this._classes.keys();
        }
        getStyle(e) {
          return this._styles.getAsString(e);
        }
        getNormalizedStyle(e) {
          return this._styles.getNormalized(e);
        }
        getStyleNames(e) {
          return this._styles.getStyleNames(e);
        }
        hasStyle(...e) {
          for (const t of e) if (!this._styles.has(t)) return !1;
          return !0;
        }
        findAncestor(...e) {
          const t = new no(...e);
          let n = this.parent;
          for (; n && !n.is("documentFragment"); ) {
            if (t.match(n)) return n;
            n = n.parent;
          }
          return null;
        }
        getCustomProperty(e) {
          return this._customProperties.get(e);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        getIdentity() {
          const e = Array.from(this._classes).sort().join(","), t = this._styles.toString(), n = Array.from(this._attrs).map((i) => `${i[0]}="${i[1]}"`).sort().join(" ");
          return this.name + (e == "" ? "" : ` class="${e}"`) + (t ? ` style="${t}"` : "") + (n == "" ? "" : ` ${n}`);
        }
        shouldRenderUnsafeAttribute(e) {
          return this._unsafeAttributesToRender.includes(e);
        }
        _clone(e = !1) {
          const t = [];
          if (e) for (const i of this.getChildren()) t.push(i._clone(e));
          const n = new this.constructor(this.document, this.name, this._attrs, t);
          return n._classes = new Set(this._classes), n._styles.set(this._styles.getNormalized()), n._customProperties = new Map(this._customProperties), n.getFillerOffset = this.getFillerOffset, n._unsafeAttributesToRender = this._unsafeAttributesToRender, n;
        }
        _appendChild(e) {
          return this._insertChild(this.childCount, e);
        }
        _insertChild(e, t) {
          this._fireChange("children", this);
          let n = 0;
          const i = function(r, s) {
            return typeof s == "string" ? [new Ce(r, s)] : (gt(s) || (s = [s]), Array.from(s).map((a) => typeof a == "string" ? new Ce(r, a) : a instanceof Rt ? new Ce(r, a.data) : a));
          }(this.document, t);
          for (const r of i) r.parent !== null && r._remove(), r.parent = this, r.document = this.document, this._children.splice(e, 0, r), e++, n++;
          return n;
        }
        _removeChildren(e, t = 1) {
          this._fireChange("children", this);
          for (let n = e; n < e + t; n++) this._children[n].parent = null;
          return this._children.splice(e, t);
        }
        _setAttribute(e, t) {
          const n = String(t);
          this._fireChange("attributes", this), e == "class" ? Sd(this._classes, n) : e == "style" ? this._styles.setTo(n) : this._attrs.set(e, n);
        }
        _removeAttribute(e) {
          return this._fireChange("attributes", this), e == "class" ? this._classes.size > 0 && (this._classes.clear(), !0) : e == "style" ? !this._styles.isEmpty && (this._styles.clear(), !0) : this._attrs.delete(e);
        }
        _addClass(e) {
          this._fireChange("attributes", this);
          for (const t of $e(e)) this._classes.add(t);
        }
        _removeClass(e) {
          this._fireChange("attributes", this);
          for (const t of $e(e)) this._classes.delete(t);
        }
        _setStyle(e, t) {
          this._fireChange("attributes", this), typeof e != "string" ? this._styles.set(e) : this._styles.set(e, t);
        }
        _removeStyle(e) {
          this._fireChange("attributes", this);
          for (const t of $e(e)) this._styles.remove(t);
        }
        _setCustomProperty(e, t) {
          this._customProperties.set(e, t);
        }
        _removeCustomProperty(e) {
          return this._customProperties.delete(e);
        }
      }
      function Sd(o, e) {
        const t = e.split(/\s+/);
        o.clear(), t.forEach((n) => o.add(n));
      }
      mt.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "element" || o === "view:element") : o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Fo extends mt {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = Dd;
        }
      }
      function Dd() {
        const o = [...this.getChildren()], e = o[this.childCount - 1];
        if (e && e.is("element", "br")) return this.childCount;
        for (const t of o) if (!t.is("uiElement")) return null;
        return this.childCount;
      }
      Fo.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Ri extends ve(Fo) {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.set("isReadOnly", !1), this.set("isFocused", !1), this.bind("isReadOnly").to(e), this.bind("isFocused").to(e, "isFocused", (r) => r && e.selection.editableElement == this), this.listenTo(e.selection, "change", () => {
            this.isFocused = e.isFocused && e.selection.editableElement == this;
          });
        }
        destroy() {
          this.stopListening();
        }
      }
      Ri.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      const Bd = Symbol("rootName");
      class Td extends Ri {
        constructor(e, t) {
          super(e, t), this.rootName = "main";
        }
        get rootName() {
          return this.getCustomProperty(Bd);
        }
        set rootName(e) {
          this._setCustomProperty(Bd, e);
        }
        set _name(e) {
          this.name = e;
        }
      }
      Td.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "rootElement" || o === "view:rootElement" || o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element") : o === "rootElement" || o === "view:rootElement" || o === "editableElement" || o === "view:editableElement" || o === "containerElement" || o === "view:containerElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Cn {
        constructor(e = {}) {
          if (!e.boundaries && !e.startPosition) throw new T("view-tree-walker-no-start-position", null);
          if (e.direction && e.direction != "forward" && e.direction != "backward") throw new T("view-tree-walker-unknown-direction", e.startPosition, { direction: e.direction });
          this.boundaries = e.boundaries || null, e.startPosition ? this._position = G._createAt(e.startPosition) : this._position = G._createAt(e.boundaries[e.direction == "backward" ? "end" : "start"]), this.direction = e.direction || "forward", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(e) {
          let t, n;
          do
            n = this.position, t = this.next();
          while (!t.done && e(t.value));
          t.done || (this._position = n);
        }
        next() {
          return this.direction == "forward" ? this._next() : this._previous();
        }
        _next() {
          let e = this.position.clone();
          const t = this.position, n = e.parent;
          if (n.parent === null && e.offset === n.childCount) return { done: !0, value: void 0 };
          if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) return { done: !0, value: void 0 };
          let i;
          if (n instanceof Ce) {
            if (e.isAtEnd) return this._position = G._createAfter(n), this._next();
            i = n.data[e.offset];
          } else i = n.getChild(e.offset);
          if (i instanceof mt) return this.shallow ? e.offset++ : e = new G(i, 0), this._position = e, this._formatReturnValue("elementStart", i, t, e, 1);
          if (i instanceof Ce) {
            if (this.singleCharacters) return e = new G(i, 0), this._position = e, this._next();
            {
              let r, s = i.data.length;
              return i == this._boundaryEndParent ? (s = this.boundaries.end.offset, r = new Rt(i, 0, s), e = G._createAfter(r)) : (r = new Rt(i, 0, i.data.length), e.offset++), this._position = e, this._formatReturnValue("text", r, t, e, s);
            }
          }
          if (typeof i == "string") {
            let r;
            this.singleCharacters ? r = 1 : r = (n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length) - e.offset;
            const s = new Rt(n, e.offset, r);
            return e.offset += r, this._position = e, this._formatReturnValue("text", s, t, e, r);
          }
          return e = G._createAfter(n), this._position = e, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n, t, e);
        }
        _previous() {
          let e = this.position.clone();
          const t = this.position, n = e.parent;
          if (n.parent === null && e.offset === 0) return { done: !0, value: void 0 };
          if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) return { done: !0, value: void 0 };
          let i;
          if (n instanceof Ce) {
            if (e.isAtStart) return this._position = G._createBefore(n), this._previous();
            i = n.data[e.offset - 1];
          } else i = n.getChild(e.offset - 1);
          if (i instanceof mt) return this.shallow ? (e.offset--, this._position = e, this._formatReturnValue("elementStart", i, t, e, 1)) : (e = new G(i, i.childCount), this._position = e, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", i, t, e));
          if (i instanceof Ce) {
            if (this.singleCharacters) return e = new G(i, i.data.length), this._position = e, this._previous();
            {
              let r, s = i.data.length;
              if (i == this._boundaryStartParent) {
                const a = this.boundaries.start.offset;
                r = new Rt(i, a, i.data.length - a), s = r.data.length, e = G._createBefore(r);
              } else r = new Rt(i, 0, i.data.length), e.offset--;
              return this._position = e, this._formatReturnValue("text", r, t, e, s);
            }
          }
          if (typeof i == "string") {
            let r;
            if (this.singleCharacters) r = 1;
            else {
              const a = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
              r = e.offset - a;
            }
            e.offset -= r;
            const s = new Rt(n, e.offset, r);
            return this._position = e, this._formatReturnValue("text", s, t, e, r);
          }
          return e = G._createBefore(n), this._position = e, this._formatReturnValue("elementStart", n, t, e, 1);
        }
        _formatReturnValue(e, t, n, i, r) {
          return t instanceof Rt && (t.offsetInText + t.data.length == t.textNode.data.length && (this.direction != "forward" || this.boundaries && this.boundaries.end.isEqual(this.position) ? n = G._createAfter(t.textNode) : (i = G._createAfter(t.textNode), this._position = i)), t.offsetInText === 0 && (this.direction != "backward" || this.boundaries && this.boundaries.start.isEqual(this.position) ? n = G._createBefore(t.textNode) : (i = G._createBefore(t.textNode), this._position = i))), { done: !1, value: { type: e, item: t, previousPosition: n, nextPosition: i, length: r } };
        }
      }
      class G extends An {
        constructor(e, t) {
          super(), this.parent = e, this.offset = t;
        }
        get nodeAfter() {
          return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null;
        }
        get nodeBefore() {
          return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null;
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          const e = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
          return this.offset === e;
        }
        get root() {
          return this.parent.root;
        }
        get editableElement() {
          let e = this.parent;
          for (; !(e instanceof Ri); ) {
            if (!e.parent) return null;
            e = e.parent;
          }
          return e;
        }
        getShiftedBy(e) {
          const t = G._createAt(this), n = t.offset + e;
          return t.offset = n < 0 ? 0 : n, t;
        }
        getLastMatchingPosition(e, t = {}) {
          t.startPosition = this;
          const n = new Cn(t);
          return n.skip(e), n.position;
        }
        getAncestors() {
          return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: !0 });
        }
        getCommonAncestor(e) {
          const t = this.getAncestors(), n = e.getAncestors();
          let i = 0;
          for (; t[i] == n[i] && t[i]; ) i++;
          return i === 0 ? null : t[i - 1];
        }
        isEqual(e) {
          return this.parent == e.parent && this.offset == e.offset;
        }
        isBefore(e) {
          return this.compareWith(e) == "before";
        }
        isAfter(e) {
          return this.compareWith(e) == "after";
        }
        compareWith(e) {
          if (this.root !== e.root) return "different";
          if (this.isEqual(e)) return "same";
          const t = this.parent.is("node") ? this.parent.getPath() : [], n = e.parent.is("node") ? e.parent.getPath() : [];
          t.push(this.offset), n.push(e.offset);
          const i = ot(t, n);
          switch (i) {
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return t[i] < n[i] ? "before" : "after";
          }
        }
        getWalker(e = {}) {
          return e.startPosition = this, new Cn(e);
        }
        clone() {
          return new G(this.parent, this.offset);
        }
        static _createAt(e, t) {
          if (e instanceof G) return new this(e.parent, e.offset);
          {
            const n = e;
            if (t == "end") t = n.is("$text") ? n.data.length : n.childCount;
            else {
              if (t == "before") return this._createBefore(n);
              if (t == "after") return this._createAfter(n);
              if (t !== 0 && !t) throw new T("view-createpositionat-offset-required", n);
            }
            return new G(n, t);
          }
        }
        static _createAfter(e) {
          if (e.is("$textProxy")) return new G(e.textNode, e.offsetInText + e.data.length);
          if (!e.parent) throw new T("view-position-after-root", e, { root: e });
          return new G(e.parent, e.index + 1);
        }
        static _createBefore(e) {
          if (e.is("$textProxy")) return new G(e.textNode, e.offsetInText);
          if (!e.parent) throw new T("view-position-before-root", e, { root: e });
          return new G(e.parent, e.index);
        }
      }
      G.prototype.is = function(o) {
        return o === "position" || o === "view:position";
      };
      class te extends An {
        constructor(e, t = null) {
          super(), this.start = e.clone(), this.end = t ? t.clone() : e.clone();
        }
        *[Symbol.iterator]() {
          yield* new Cn({ boundaries: this, ignoreElementEnd: !0 });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return this.start.parent === this.end.parent;
        }
        get root() {
          return this.start.root;
        }
        getEnlarged() {
          let e = this.start.getLastMatchingPosition(Oi, { direction: "backward" }), t = this.end.getLastMatchingPosition(Oi);
          return e.parent.is("$text") && e.isAtStart && (e = G._createBefore(e.parent)), t.parent.is("$text") && t.isAtEnd && (t = G._createAfter(t.parent)), new te(e, t);
        }
        getTrimmed() {
          let e = this.start.getLastMatchingPosition(Oi);
          if (e.isAfter(this.end) || e.isEqual(this.end)) return new te(e, e);
          let t = this.end.getLastMatchingPosition(Oi, { direction: "backward" });
          const n = e.nodeAfter, i = t.nodeBefore;
          return n && n.is("$text") && (e = new G(n, 0)), i && i.is("$text") && (t = new G(i, i.data.length)), new te(e, t);
        }
        isEqual(e) {
          return this == e || this.start.isEqual(e.start) && this.end.isEqual(e.end);
        }
        containsPosition(e) {
          return e.isAfter(this.start) && e.isBefore(this.end);
        }
        containsRange(e, t = !1) {
          e.isCollapsed && (t = !1);
          const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start), i = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
          return n && i;
        }
        getDifference(e) {
          const t = [];
          return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new te(this.start, e.start)), this.containsPosition(e.end) && t.push(new te(e.end, this.end))) : t.push(this.clone()), t;
        }
        getIntersection(e) {
          if (this.isIntersecting(e)) {
            let t = this.start, n = this.end;
            return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new te(t, n);
          }
          return null;
        }
        getWalker(e = {}) {
          return e.boundaries = this, new Cn(e);
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) return null;
          let e = this.start.nodeAfter, t = this.end.nodeBefore;
          return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (e = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (t = this.end.parent.previousSibling), e && e.is("element") && e === t ? e : null;
        }
        clone() {
          return new te(this.start, this.end);
        }
        *getItems(e = {}) {
          e.boundaries = this, e.ignoreElementEnd = !0;
          const t = new Cn(e);
          for (const n of t) yield n.item;
        }
        *getPositions(e = {}) {
          e.boundaries = this;
          const t = new Cn(e);
          yield t.position;
          for (const n of t) yield n.nextPosition;
        }
        isIntersecting(e) {
          return this.start.isBefore(e.end) && this.end.isAfter(e.start);
        }
        static _createFromParentsAndOffsets(e, t, n, i) {
          return new this(new G(e, t), new G(n, i));
        }
        static _createFromPositionAndShift(e, t) {
          const n = e, i = e.getShiftedBy(t);
          return t > 0 ? new this(n, i) : new this(i, n);
        }
        static _createIn(e) {
          return this._createFromParentsAndOffsets(e, 0, e, e.childCount);
        }
        static _createOn(e) {
          const t = e.is("$textProxy") ? e.offsetSize : 1;
          return this._createFromPositionAndShift(G._createBefore(e), t);
        }
      }
      function Oi(o) {
        return !(!o.item.is("attributeElement") && !o.item.is("uiElement"));
      }
      te.prototype.is = function(o) {
        return o === "range" || o === "view:range";
      };
      class Ot extends _e(An) {
        constructor(...e) {
          super(), this._ranges = [], this._lastRangeBackward = !1, this._isFake = !1, this._fakeSelectionLabel = "", e.length && this.setTo(...e);
        }
        get isFake() {
          return this._isFake;
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel;
        }
        get anchor() {
          if (!this._ranges.length) return null;
          const e = this._ranges[this._ranges.length - 1];
          return (this._lastRangeBackward ? e.end : e.start).clone();
        }
        get focus() {
          if (!this._ranges.length) return null;
          const e = this._ranges[this._ranges.length - 1];
          return (this._lastRangeBackward ? e.start : e.end).clone();
        }
        get isCollapsed() {
          return this.rangeCount === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        get editableElement() {
          return this.anchor ? this.anchor.editableElement : null;
        }
        *getRanges() {
          for (const e of this._ranges) yield e.clone();
        }
        getFirstRange() {
          let e = null;
          for (const t of this._ranges) e && !t.start.isBefore(e.start) || (e = t);
          return e ? e.clone() : null;
        }
        getLastRange() {
          let e = null;
          for (const t of this._ranges) e && !t.end.isAfter(e.end) || (e = t);
          return e ? e.clone() : null;
        }
        getFirstPosition() {
          const e = this.getFirstRange();
          return e ? e.start.clone() : null;
        }
        getLastPosition() {
          const e = this.getLastRange();
          return e ? e.end.clone() : null;
        }
        isEqual(e) {
          if (this.isFake != e.isFake || this.isFake && this.fakeSelectionLabel != e.fakeSelectionLabel || this.rangeCount != e.rangeCount) return !1;
          if (this.rangeCount === 0) return !0;
          if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus)) return !1;
          for (const t of this._ranges) {
            let n = !1;
            for (const i of e._ranges) if (t.isEqual(i)) {
              n = !0;
              break;
            }
            if (!n) return !1;
          }
          return !0;
        }
        isSimilar(e) {
          if (this.isBackward != e.isBackward) return !1;
          const t = zr(this.getRanges());
          if (t != zr(e.getRanges())) return !1;
          if (t == 0) return !0;
          for (let n of this.getRanges()) {
            n = n.getTrimmed();
            let i = !1;
            for (let r of e.getRanges()) if (r = r.getTrimmed(), n.start.isEqual(r.start) && n.end.isEqual(r.end)) {
              i = !0;
              break;
            }
            if (!i) return !1;
          }
          return !0;
        }
        getSelectedElement() {
          return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
        }
        setTo(...e) {
          let [t, n, i] = e;
          if (typeof n == "object" && (i = n, n = void 0), t === null) this._setRanges([]), this._setFakeOptions(i);
          else if (t instanceof Ot || t instanceof Ds) this._setRanges(t.getRanges(), t.isBackward), this._setFakeOptions({ fake: t.isFake, label: t.fakeSelectionLabel });
          else if (t instanceof te) this._setRanges([t], i && i.backward), this._setFakeOptions(i);
          else if (t instanceof G) this._setRanges([new te(t)]), this._setFakeOptions(i);
          else if (t instanceof _n) {
            const r = !!i && !!i.backward;
            let s;
            if (n === void 0) throw new T("view-selection-setto-required-second-parameter", this);
            s = n == "in" ? te._createIn(t) : n == "on" ? te._createOn(t) : new te(G._createAt(t, n)), this._setRanges([s], r), this._setFakeOptions(i);
          } else {
            if (!gt(t)) throw new T("view-selection-setto-not-selectable", this);
            this._setRanges(t, i && i.backward), this._setFakeOptions(i);
          }
          this.fire("change");
        }
        setFocus(e, t) {
          if (this.anchor === null) throw new T("view-selection-setfocus-no-ranges", this);
          const n = G._createAt(e, t);
          if (n.compareWith(this.focus) == "same") return;
          const i = this.anchor;
          this._ranges.pop(), n.compareWith(i) == "before" ? this._addRange(new te(n, i), !0) : this._addRange(new te(i, n)), this.fire("change");
        }
        _setRanges(e, t = !1) {
          e = Array.from(e), this._ranges = [];
          for (const n of e) this._addRange(n);
          this._lastRangeBackward = !!t;
        }
        _setFakeOptions(e = {}) {
          this._isFake = !!e.fake, this._fakeSelectionLabel = e.fake && e.label || "";
        }
        _addRange(e, t = !1) {
          if (!(e instanceof te)) throw new T("view-selection-add-range-not-range", this);
          this._pushRange(e), this._lastRangeBackward = !!t;
        }
        _pushRange(e) {
          for (const t of this._ranges) if (e.isIntersecting(t)) throw new T("view-selection-range-intersects", this, { addedRange: e, intersectingRange: t });
          this._ranges.push(new te(e.start, e.end));
        }
      }
      Ot.prototype.is = function(o) {
        return o === "selection" || o === "view:selection";
      };
      class Ds extends _e(An) {
        constructor(...e) {
          super(), this._selection = new Ot(), this._selection.delegate("change").to(this), e.length && this._selection.setTo(...e);
        }
        get isFake() {
          return this._selection.isFake;
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get editableElement() {
          return this._selection.editableElement;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        *getRanges() {
          yield* this._selection.getRanges();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        isEqual(e) {
          return this._selection.isEqual(e);
        }
        isSimilar(e) {
          return this._selection.isSimilar(e);
        }
        _setTo(...e) {
          this._selection.setTo(...e);
        }
        _setFocus(e, t) {
          this._selection.setFocus(e, t);
        }
      }
      Ds.prototype.is = function(o) {
        return o === "selection" || o == "documentSelection" || o == "view:selection" || o == "view:documentSelection";
      };
      class oo extends q {
        constructor(e, t, n) {
          super(e, t), this.startRange = n, this._eventPhase = "none", this._currentTarget = null;
        }
        get eventPhase() {
          return this._eventPhase;
        }
        get currentTarget() {
          return this._currentTarget;
        }
      }
      const Bs = Symbol("bubbling contexts");
      function Ts(o) {
        return class extends o {
          fire(e, ...t) {
            try {
              const n = e instanceof q ? e : new q(this, e), i = Is(this);
              if (!i.size) return;
              if (No(n, "capturing", this), io(i, "$capture", n, ...t)) return n.return;
              const r = n.startRange || this.selection.getFirstRange(), s = r ? r.getContainedElement() : null, a = !!s && !!Id(i, s);
              let l = s || function(c) {
                if (!c) return null;
                const d = c.start.parent, u = c.end.parent, g = d.getPath(), p = u.getPath();
                return g.length > p.length ? d : u;
              }(r);
              if (No(n, "atTarget", l), !a) {
                if (io(i, "$text", n, ...t)) return n.return;
                No(n, "bubbling", l);
              }
              for (; l; ) {
                if (l.is("rootElement")) {
                  if (io(i, "$root", n, ...t)) return n.return;
                } else if (l.is("element") && io(i, l.name, n, ...t)) return n.return;
                if (io(i, l, n, ...t)) return n.return;
                l = l.parent, No(n, "bubbling", l);
              }
              return No(n, "bubbling", this), io(i, "$document", n, ...t), n.return;
            } catch (n) {
              T.rethrowUnexpectedError(n, this);
            }
          }
          _addEventListener(e, t, n) {
            const i = $e(n.context || "$document"), r = Is(this);
            for (const s of i) {
              let a = r.get(s);
              a || (a = new (_e())(), r.set(s, a)), this.listenTo(a, e, t, n);
            }
          }
          _removeEventListener(e, t) {
            const n = Is(this);
            for (const i of n.values()) this.stopListening(i, e, t);
          }
        };
      }
      {
        const o = Ts(Object);
        ["fire", "_addEventListener", "_removeEventListener"].forEach((e) => {
          Ts[e] = o.prototype[e];
        });
      }
      function No(o, e, t) {
        o instanceof oo && (o._eventPhase = e, o._currentTarget = t);
      }
      function io(o, e, t, ...n) {
        const i = typeof e == "string" ? o.get(e) : Id(o, e);
        return !!i && (i.fire(t, ...n), t.stop.called);
      }
      function Id(o, e) {
        for (const [t, n] of o) if (typeof t == "function" && t(e)) return n;
        return null;
      }
      function Is(o) {
        return o[Bs] || (o[Bs] = /* @__PURE__ */ new Map()), o[Bs];
      }
      class Pd extends Ts(ve()) {
        constructor(e) {
          super(), this._postFixers = /* @__PURE__ */ new Set(), this.selection = new Ds(), this.roots = new _t({ idProperty: "rootName" }), this.stylesProcessor = e, this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1);
        }
        getRoot(e = "main") {
          return this.roots.get(e);
        }
        registerPostFixer(e) {
          this._postFixers.add(e);
        }
        destroy() {
          this.roots.map((e) => e.destroy()), this.stopListening();
        }
        _callPostFixers(e) {
          let t = !1;
          do
            for (const n of this._postFixers) if (t = n(e), t) break;
          while (t);
        }
      }
      class yn extends mt {
        constructor(e, t, n, i) {
          super(e, t, n, i), this._priority = 10, this._id = null, this._clonesGroup = null, this.getFillerOffset = bA;
        }
        get priority() {
          return this._priority;
        }
        get id() {
          return this._id;
        }
        getElementsWithSameId() {
          if (this.id === null) throw new T("attribute-element-get-elements-with-same-id-no-id", this);
          return new Set(this._clonesGroup);
        }
        isSimilar(e) {
          return this.id !== null || e.id !== null ? this.id === e.id : super.isSimilar(e) && this.priority == e.priority;
        }
        _clone(e = !1) {
          const t = super._clone(e);
          return t._priority = this._priority, t._id = this._id, t;
        }
      }
      function bA() {
        if (Ps(this)) return null;
        let o = this.parent;
        for (; o && o.is("attributeElement"); ) {
          if (Ps(o) > 1) return null;
          o = o.parent;
        }
        return !o || Ps(o) > 1 ? null : this.childCount;
      }
      function Ps(o) {
        return Array.from(o.getChildren()).filter((e) => !e.is("uiElement")).length;
      }
      yn.DEFAULT_PRIORITY = 10, yn.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "attributeElement" || o === "view:attributeElement" || o === "element" || o === "view:element") : o === "attributeElement" || o === "view:attributeElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Rs extends mt {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = kA;
        }
        _insertChild(e, t) {
          if (t && (t instanceof _n || Array.from(t).length > 0)) throw new T("view-emptyelement-cannot-add", [this, t]);
          return 0;
        }
      }
      function kA() {
        return null;
      }
      Rs.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "emptyElement" || o === "view:emptyElement" || o === "element" || o === "view:element") : o === "emptyElement" || o === "view:emptyElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class zi extends mt {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = AA;
        }
        _insertChild(e, t) {
          if (t && (t instanceof _n || Array.from(t).length > 0)) throw new T("view-uielement-cannot-add", [this, t]);
          return 0;
        }
        render(e, t) {
          return this.toDomElement(e);
        }
        toDomElement(e) {
          const t = e.createElement(this.name);
          for (const n of this.getAttributeKeys()) t.setAttribute(n, this.getAttribute(n));
          return t;
        }
      }
      function wA(o) {
        o.document.on("arrowKey", (e, t) => function(n, i, r) {
          if (i.keyCode == ge.arrowright) {
            const s = i.domTarget.ownerDocument.defaultView.getSelection(), a = s.rangeCount == 1 && s.getRangeAt(0).collapsed;
            if (a || i.shiftKey) {
              const l = s.focusNode, c = s.focusOffset, d = r.domPositionToView(l, c);
              if (d === null) return;
              let u = !1;
              const g = d.getLastMatchingPosition((p) => (p.item.is("uiElement") && (u = !0), !(!p.item.is("uiElement") && !p.item.is("attributeElement"))));
              if (u) {
                const p = r.viewPositionToDom(g);
                a ? s.collapse(p.parent, p.offset) : s.extend(p.parent, p.offset);
              }
            }
          }
        }(0, t, o.domConverter), { priority: "low" });
      }
      function AA() {
        return null;
      }
      zi.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "uiElement" || o === "view:uiElement" || o === "element" || o === "view:element") : o === "uiElement" || o === "view:uiElement" || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class Os extends mt {
        constructor(e, t, n, i) {
          super(e, t, n, i), this.getFillerOffset = _A;
        }
        _insertChild(e, t) {
          if (t && (t instanceof _n || Array.from(t).length > 0)) throw new T("view-rawelement-cannot-add", [this, t]);
          return 0;
        }
        render(e, t) {
        }
      }
      function _A() {
        return null;
      }
      Os.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "rawElement" || o === "view:rawElement" || o === "element" || o === "view:element") : o === "rawElement" || o === "view:rawElement" || o === this.name || o === "view:" + this.name || o === "element" || o === "view:element" || o === "node" || o === "view:node";
      };
      class En extends _e(An) {
        constructor(e, t) {
          super(), this._children = [], this._customProperties = /* @__PURE__ */ new Map(), this.document = e, t && this._insertChild(0, t);
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]();
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get name() {
        }
        getCustomProperty(e) {
          return this._customProperties.get(e);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        _appendChild(e) {
          return this._insertChild(this.childCount, e);
        }
        getChild(e) {
          return this._children[e];
        }
        getChildIndex(e) {
          return this._children.indexOf(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        _insertChild(e, t) {
          this._fireChange("children", this);
          let n = 0;
          const i = function(r, s) {
            return typeof s == "string" ? [new Ce(r, s)] : (gt(s) || (s = [s]), Array.from(s).map((a) => typeof a == "string" ? new Ce(r, a) : a instanceof Rt ? new Ce(r, a.data) : a));
          }(this.document, t);
          for (const r of i) r.parent !== null && r._remove(), r.parent = this, this._children.splice(e, 0, r), e++, n++;
          return n;
        }
        _removeChildren(e, t = 1) {
          this._fireChange("children", this);
          for (let n = e; n < e + t; n++) this._children[n].parent = null;
          return this._children.splice(e, t);
        }
        _fireChange(e, t) {
          this.fire("change:" + e, t);
        }
        _setCustomProperty(e, t) {
          this._customProperties.set(e, t);
        }
        _removeCustomProperty(e) {
          return this._customProperties.delete(e);
        }
      }
      En.prototype.is = function(o) {
        return o === "documentFragment" || o === "view:documentFragment";
      };
      class Rd {
        constructor(e) {
          this._cloneGroups = /* @__PURE__ */ new Map(), this._slotFactory = null, this.document = e;
        }
        setSelection(...e) {
          this.document.selection._setTo(...e);
        }
        setSelectionFocus(e, t) {
          this.document.selection._setFocus(e, t);
        }
        createDocumentFragment(e) {
          return new En(this.document, e);
        }
        createText(e) {
          return new Ce(this.document, e);
        }
        createAttributeElement(e, t, n = {}) {
          const i = new yn(this.document, e, t);
          return typeof n.priority == "number" && (i._priority = n.priority), n.id && (i._id = n.id), n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i;
        }
        createContainerElement(e, t, n = {}, i = {}) {
          let r = null;
          at(n) ? i = n : r = n;
          const s = new Fo(this.document, e, t, r);
          return i.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), s;
        }
        createEditableElement(e, t, n = {}) {
          const i = new Ri(this.document, e, t);
          return n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i;
        }
        createEmptyElement(e, t, n = {}) {
          const i = new Rs(this.document, e, t);
          return n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i;
        }
        createUIElement(e, t, n) {
          const i = new zi(this.document, e, t);
          return n && (i.render = n), i;
        }
        createRawElement(e, t, n, i = {}) {
          const r = new Os(this.document, e, t);
          return n && (r.render = n), i.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), r;
        }
        setAttribute(e, t, n) {
          n._setAttribute(e, t);
        }
        removeAttribute(e, t) {
          t._removeAttribute(e);
        }
        addClass(e, t) {
          t._addClass(e);
        }
        removeClass(e, t) {
          t._removeClass(e);
        }
        setStyle(e, t, n) {
          at(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t);
        }
        removeStyle(e, t) {
          t._removeStyle(e);
        }
        setCustomProperty(e, t, n) {
          n._setCustomProperty(e, t);
        }
        removeCustomProperty(e, t) {
          return t._removeCustomProperty(e);
        }
        breakAttributes(e) {
          return e instanceof G ? this._breakAttributes(e) : this._breakAttributesRange(e);
        }
        breakContainer(e) {
          const t = e.parent;
          if (!t.is("containerElement")) throw new T("view-writer-break-non-container-element", this.document);
          if (!t.parent) throw new T("view-writer-break-root", this.document);
          if (e.isAtStart) return G._createBefore(t);
          if (!e.isAtEnd) {
            const n = t._clone(!1);
            this.insert(G._createAfter(t), n);
            const i = new te(e, G._createAt(t, "end")), r = new G(n, 0);
            this.move(i, r);
          }
          return G._createAfter(t);
        }
        mergeAttributes(e) {
          const t = e.offset, n = e.parent;
          if (n.is("$text")) return e;
          if (n.is("attributeElement") && n.childCount === 0) {
            const s = n.parent, a = n.index;
            return n._remove(), this._removeFromClonedElementsGroup(n), this.mergeAttributes(new G(s, a));
          }
          const i = n.getChild(t - 1), r = n.getChild(t);
          if (!i || !r) return e;
          if (i.is("$text") && r.is("$text")) return zd(i, r);
          if (i.is("attributeElement") && r.is("attributeElement") && i.isSimilar(r)) {
            const s = i.childCount;
            return i._appendChild(r.getChildren()), r._remove(), this._removeFromClonedElementsGroup(r), this.mergeAttributes(new G(i, s));
          }
          return e;
        }
        mergeContainers(e) {
          const t = e.nodeBefore, n = e.nodeAfter;
          if (!(t && n && t.is("containerElement") && n.is("containerElement"))) throw new T("view-writer-merge-containers-invalid-position", this.document);
          const i = t.getChild(t.childCount - 1), r = i instanceof Ce ? G._createAt(i, "end") : G._createAt(t, "end");
          return this.move(te._createIn(n), G._createAt(t, "end")), this.remove(te._createOn(n)), r;
        }
        insert(e, t) {
          Md(t = gt(t) ? [...t] : [t], this.document);
          const n = t.reduce((s, a) => {
            const l = s[s.length - 1], c = !a.is("uiElement");
            return l && l.breakAttributes == c ? l.nodes.push(a) : s.push({ breakAttributes: c, nodes: [a] }), s;
          }, []);
          let i = null, r = e;
          for (const { nodes: s, breakAttributes: a } of n) {
            const l = this._insertNodes(r, s, a);
            i || (i = l.start), r = l.end;
          }
          return i ? new te(i, r) : new te(e);
        }
        remove(e) {
          const t = e instanceof te ? e : te._createOn(e);
          if (Vo(t, this.document), t.isCollapsed) return new En(this.document);
          const { start: n, end: i } = this._breakAttributesRange(t, !0), r = n.parent, s = i.offset - n.offset, a = r._removeChildren(n.offset, s);
          for (const c of a) this._removeFromClonedElementsGroup(c);
          const l = this.mergeAttributes(n);
          return t.start = l, t.end = l.clone(), new En(this.document, a);
        }
        clear(e, t) {
          Vo(e, this.document);
          const n = e.getWalker({ direction: "backward", ignoreElementEnd: !0 });
          for (const i of n) {
            const r = i.item;
            let s;
            if (r.is("element") && t.isSimilar(r)) s = te._createOn(r);
            else if (!i.nextPosition.isAfter(e.start) && r.is("$textProxy")) {
              const a = r.getAncestors().find((l) => l.is("element") && t.isSimilar(l));
              a && (s = te._createIn(a));
            }
            s && (s.end.isAfter(e.end) && (s.end = e.end), s.start.isBefore(e.start) && (s.start = e.start), this.remove(s));
          }
        }
        move(e, t) {
          let n;
          if (t.isAfter(e.end)) {
            const i = (t = this._breakAttributes(t, !0)).parent, r = i.childCount;
            e = this._breakAttributesRange(e, !0), n = this.remove(e), t.offset += i.childCount - r;
          } else n = this.remove(e);
          return this.insert(t, n);
        }
        wrap(e, t) {
          if (!(t instanceof yn)) throw new T("view-writer-wrap-invalid-attribute", this.document);
          if (Vo(e, this.document), e.isCollapsed) {
            let i = e.start;
            i.parent.is("element") && (n = i.parent, !Array.from(n.getChildren()).some((s) => !s.is("uiElement"))) && (i = i.getLastMatchingPosition((s) => s.item.is("uiElement"))), i = this._wrapPosition(i, t);
            const r = this.document.selection;
            return r.isCollapsed && r.getFirstPosition().isEqual(e.start) && this.setSelection(i), new te(i);
          }
          return this._wrapRange(e, t);
          var n;
        }
        unwrap(e, t) {
          if (!(t instanceof yn)) throw new T("view-writer-unwrap-invalid-attribute", this.document);
          if (Vo(e, this.document), e.isCollapsed) return e;
          const { start: n, end: i } = this._breakAttributesRange(e, !0), r = n.parent, s = this._unwrapChildren(r, n.offset, i.offset, t), a = this.mergeAttributes(s.start);
          a.isEqual(s.start) || s.end.offset--;
          const l = this.mergeAttributes(s.end);
          return new te(a, l);
        }
        rename(e, t) {
          const n = new Fo(this.document, e, t.getAttributes());
          return this.insert(G._createAfter(t), n), this.move(te._createIn(t), G._createAt(n, 0)), this.remove(te._createOn(t)), n;
        }
        clearClonedElementsGroup(e) {
          this._cloneGroups.delete(e);
        }
        createPositionAt(e, t) {
          return G._createAt(e, t);
        }
        createPositionAfter(e) {
          return G._createAfter(e);
        }
        createPositionBefore(e) {
          return G._createBefore(e);
        }
        createRange(e, t) {
          return new te(e, t);
        }
        createRangeOn(e) {
          return te._createOn(e);
        }
        createRangeIn(e) {
          return te._createIn(e);
        }
        createSelection(...e) {
          return new Ot(...e);
        }
        createSlot(e = "children") {
          if (!this._slotFactory) throw new T("view-writer-invalid-create-slot-context", this.document);
          return this._slotFactory(this, e);
        }
        _registerSlotFactory(e) {
          this._slotFactory = e;
        }
        _clearSlotFactory() {
          this._slotFactory = null;
        }
        _insertNodes(e, t, n) {
          let i, r;
          if (i = n ? zs(e) : e.parent.is("$text") ? e.parent.parent : e.parent, !i) throw new T("view-writer-invalid-position-container", this.document);
          r = n ? this._breakAttributes(e, !0) : e.parent.is("$text") ? Ms(e) : e;
          const s = i._insertChild(r.offset, t);
          for (const d of t) this._addToClonedElementsGroup(d);
          const a = r.getShiftedBy(s), l = this.mergeAttributes(r);
          l.isEqual(r) || a.offset--;
          const c = this.mergeAttributes(a);
          return new te(l, c);
        }
        _wrapChildren(e, t, n, i) {
          let r = t;
          const s = [];
          for (; r < n; ) {
            const l = e.getChild(r), c = l.is("$text"), d = l.is("attributeElement");
            if (d && this._wrapAttributeElement(i, l)) s.push(new G(e, r));
            else if (c || !d || vA(i, l)) {
              const u = i._clone();
              l._remove(), u._appendChild(l), e._insertChild(r, u), this._addToClonedElementsGroup(u), s.push(new G(e, r));
            } else this._wrapChildren(l, 0, l.childCount, i);
            r++;
          }
          let a = 0;
          for (const l of s)
            l.offset -= a, l.offset != t && (this.mergeAttributes(l).isEqual(l) || (a++, n--));
          return te._createFromParentsAndOffsets(e, t, e, n);
        }
        _unwrapChildren(e, t, n, i) {
          let r = t;
          const s = [];
          for (; r < n; ) {
            const l = e.getChild(r);
            if (l.is("attributeElement")) if (l.isSimilar(i)) {
              const c = l.getChildren(), d = l.childCount;
              l._remove(), e._insertChild(r, c), this._removeFromClonedElementsGroup(l), s.push(new G(e, r), new G(e, r + d)), r += d, n += d - 1;
            } else this._unwrapAttributeElement(i, l) ? (s.push(new G(e, r), new G(e, r + 1)), r++) : (this._unwrapChildren(l, 0, l.childCount, i), r++);
            else r++;
          }
          let a = 0;
          for (const l of s)
            l.offset -= a, !(l.offset == t || l.offset == n) && (this.mergeAttributes(l).isEqual(l) || (a++, n--));
          return te._createFromParentsAndOffsets(e, t, e, n);
        }
        _wrapRange(e, t) {
          const { start: n, end: i } = this._breakAttributesRange(e, !0), r = n.parent, s = this._wrapChildren(r, n.offset, i.offset, t), a = this.mergeAttributes(s.start);
          a.isEqual(s.start) || s.end.offset--;
          const l = this.mergeAttributes(s.end);
          return new te(a, l);
        }
        _wrapPosition(e, t) {
          if (t.isSimilar(e.parent)) return Od(e.clone());
          e.parent.is("$text") && (e = Ms(e));
          const n = this.createAttributeElement("_wrapPosition-fake-element");
          n._priority = Number.POSITIVE_INFINITY, n.isSimilar = () => !1, e.parent._insertChild(e.offset, n);
          const i = new te(e, e.getShiftedBy(1));
          this.wrap(i, t);
          const r = new G(n.parent, n.index);
          n._remove();
          const s = r.nodeBefore, a = r.nodeAfter;
          return s instanceof Ce && a instanceof Ce ? zd(s, a) : Od(r);
        }
        _wrapAttributeElement(e, t) {
          if (!Fd(e, t) || e.name !== t.name || e.priority !== t.priority) return !1;
          for (const n of e.getAttributeKeys()) if (n !== "class" && n !== "style" && t.hasAttribute(n) && t.getAttribute(n) !== e.getAttribute(n)) return !1;
          for (const n of e.getStyleNames()) if (t.hasStyle(n) && t.getStyle(n) !== e.getStyle(n)) return !1;
          for (const n of e.getAttributeKeys()) n !== "class" && n !== "style" && (t.hasAttribute(n) || this.setAttribute(n, e.getAttribute(n), t));
          for (const n of e.getStyleNames()) t.hasStyle(n) || this.setStyle(n, e.getStyle(n), t);
          for (const n of e.getClassNames()) t.hasClass(n) || this.addClass(n, t);
          return !0;
        }
        _unwrapAttributeElement(e, t) {
          if (!Fd(e, t) || e.name !== t.name || e.priority !== t.priority) return !1;
          for (const n of e.getAttributeKeys()) if (n !== "class" && n !== "style" && (!t.hasAttribute(n) || t.getAttribute(n) !== e.getAttribute(n))) return !1;
          if (!t.hasClass(...e.getClassNames())) return !1;
          for (const n of e.getStyleNames()) if (!t.hasStyle(n) || t.getStyle(n) !== e.getStyle(n)) return !1;
          for (const n of e.getAttributeKeys()) n !== "class" && n !== "style" && this.removeAttribute(n, t);
          return this.removeClass(Array.from(e.getClassNames()), t), this.removeStyle(Array.from(e.getStyleNames()), t), !0;
        }
        _breakAttributesRange(e, t = !1) {
          const n = e.start, i = e.end;
          if (Vo(e, this.document), e.isCollapsed) {
            const l = this._breakAttributes(e.start, t);
            return new te(l, l);
          }
          const r = this._breakAttributes(i, t), s = r.parent.childCount, a = this._breakAttributes(n, t);
          return r.offset += r.parent.childCount - s, new te(a, r);
        }
        _breakAttributes(e, t = !1) {
          const n = e.offset, i = e.parent;
          if (e.parent.is("emptyElement")) throw new T("view-writer-cannot-break-empty-element", this.document);
          if (e.parent.is("uiElement")) throw new T("view-writer-cannot-break-ui-element", this.document);
          if (e.parent.is("rawElement")) throw new T("view-writer-cannot-break-raw-element", this.document);
          if (!t && i.is("$text") && Fs(i.parent) || Fs(i)) return e.clone();
          if (i.is("$text")) return this._breakAttributes(Ms(e), t);
          if (n == i.childCount) {
            const r = new G(i.parent, i.index + 1);
            return this._breakAttributes(r, t);
          }
          if (n === 0) {
            const r = new G(i.parent, i.index);
            return this._breakAttributes(r, t);
          }
          {
            const r = i.index + 1, s = i._clone();
            i.parent._insertChild(r, s), this._addToClonedElementsGroup(s);
            const a = i.childCount - n, l = i._removeChildren(n, a);
            s._appendChild(l);
            const c = new G(i.parent, r);
            return this._breakAttributes(c, t);
          }
        }
        _addToClonedElementsGroup(e) {
          if (!e.root.is("rootElement")) return;
          if (e.is("element")) for (const i of e.getChildren()) this._addToClonedElementsGroup(i);
          const t = e.id;
          if (!t) return;
          let n = this._cloneGroups.get(t);
          n || (n = /* @__PURE__ */ new Set(), this._cloneGroups.set(t, n)), n.add(e), e._clonesGroup = n;
        }
        _removeFromClonedElementsGroup(e) {
          if (e.is("element")) for (const i of e.getChildren()) this._removeFromClonedElementsGroup(i);
          const t = e.id;
          if (!t) return;
          const n = this._cloneGroups.get(t);
          n && n.delete(e);
        }
      }
      function zs(o) {
        let e = o.parent;
        for (; !Fs(e); ) {
          if (!e) return;
          e = e.parent;
        }
        return e;
      }
      function vA(o, e) {
        return o.priority < e.priority || !(o.priority > e.priority) && o.getIdentity() < e.getIdentity();
      }
      function Od(o) {
        const e = o.nodeBefore;
        if (e && e.is("$text")) return new G(e, e.data.length);
        const t = o.nodeAfter;
        return t && t.is("$text") ? new G(t, 0) : o;
      }
      function Ms(o) {
        if (o.offset == o.parent.data.length) return new G(o.parent.parent, o.parent.index + 1);
        if (o.offset === 0) return new G(o.parent.parent, o.parent.index);
        const e = o.parent.data.slice(o.offset);
        return o.parent._data = o.parent.data.slice(0, o.offset), o.parent.parent._insertChild(o.parent.index + 1, new Ce(o.root.document, e)), new G(o.parent.parent, o.parent.index + 1);
      }
      function zd(o, e) {
        const t = o.data.length;
        return o._data += e.data, e._remove(), new G(o, t);
      }
      const CA = [Ce, yn, Fo, Rs, Os, zi];
      function Md(o, e) {
        for (const t of o) {
          if (!CA.some((n) => t instanceof n)) throw new T("view-writer-insert-invalid-node-type", e);
          t.is("$text") || Md(t.getChildren(), e);
        }
      }
      function Fs(o) {
        return o && (o.is("containerElement") || o.is("documentFragment"));
      }
      function Vo(o, e) {
        const t = zs(o.start), n = zs(o.end);
        if (!t || !n || t !== n) throw new T("view-writer-invalid-range-container", e);
      }
      function Fd(o, e) {
        return o.id === null && e.id === null;
      }
      const Nd = (o) => o.createTextNode(" "), Vd = (o) => {
        const e = o.createElement("span");
        return e.dataset.ckeFiller = "true", e.innerText = " ", e;
      }, Ld = (o) => {
        const e = o.createElement("br");
        return e.dataset.ckeFiller = "true", e;
      }, zt = 7, Mi = "⁠".repeat(zt);
      function pt(o) {
        return je(o) && o.data.substr(0, zt) === Mi;
      }
      function Lo(o) {
        return o.data.length == zt && pt(o);
      }
      function jd(o) {
        return pt(o) ? o.data.slice(zt) : o.data;
      }
      function yA(o, e) {
        if (e.keyCode == ge.arrowleft) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection();
          if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
            const n = t.getRangeAt(0).startContainer, i = t.getRangeAt(0).startOffset;
            pt(n) && i <= zt && t.collapse(n, 0);
          }
        }
      }
      var $d = D(9315), EA = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()($d.Z, EA), $d.Z.locals;
      class xA extends ve() {
        constructor(e, t) {
          super(), this.domDocuments = /* @__PURE__ */ new Set(), this.markedAttributes = /* @__PURE__ */ new Set(), this.markedChildren = /* @__PURE__ */ new Set(), this.markedTexts = /* @__PURE__ */ new Set(), this._inlineFiller = null, this._fakeSelectionContainer = null, this.domConverter = e, this.selection = t, this.set("isFocused", !1), this.set("isSelecting", !1), f.isBlink && !f.isAndroid && this.on("change:isSelecting", () => {
            this.isSelecting || this.render();
          }), this.set("isComposing", !1), this.on("change:isComposing", () => {
            this.isComposing || this.render();
          });
        }
        markToSync(e, t) {
          if (e === "text") this.domConverter.mapViewToDom(t.parent) && this.markedTexts.add(t);
          else {
            if (!this.domConverter.mapViewToDom(t)) return;
            if (e === "attributes") this.markedAttributes.add(t);
            else {
              if (e !== "children")
                throw new T("view-renderer-unknown-type", this);
              this.markedChildren.add(t);
            }
          }
        }
        render() {
          if (this.isComposing && !f.isAndroid) return;
          let e = null;
          const t = !(f.isBlink && !f.isAndroid) || !this.isSelecting;
          for (const n of this.markedChildren) this._updateChildrenMappings(n);
          t ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? e = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (e = this.selection.getFirstPosition(), this.markedChildren.add(e.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (e = this.domConverter.domPositionToView(this._inlineFiller), e && e.parent.is("$text") && (e = G._createBefore(e.parent)));
          for (const n of this.markedAttributes) this._updateAttrs(n);
          for (const n of this.markedChildren) this._updateChildren(n, { inlineFillerPosition: e });
          for (const n of this.markedTexts) !this.markedChildren.has(n.parent) && this.domConverter.mapViewToDom(n.parent) && this._updateText(n, { inlineFillerPosition: e });
          if (t) if (e) {
            const n = this.domConverter.viewPositionToDom(e), i = n.parent.ownerDocument;
            pt(n.parent) ? this._inlineFiller = n.parent : this._inlineFiller = Hd(i, n.parent, n.offset);
          } else this._inlineFiller = null;
          this._updateFocus(), this._updateSelection(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
        }
        _updateChildrenMappings(e) {
          if (!this.domConverter.mapViewToDom(e)) return;
          const t = Array.from(this.domConverter.mapViewToDom(e).childNodes), n = Array.from(this.domConverter.viewChildrenToDom(e, { withChildren: !1 })), i = this._diffNodeLists(t, n), r = this._findUpdateActions(i, t, n, SA);
          if (r.indexOf("update") !== -1) {
            const s = { equal: 0, insert: 0, delete: 0 };
            for (const a of r) if (a === "update") {
              const l = s.equal + s.insert, c = s.equal + s.delete, d = e.getChild(l);
              !d || d.is("uiElement") || d.is("rawElement") || this._updateElementMappings(d, t[c]), Bc(n[l]), s.equal++;
            } else s[a]++;
          }
        }
        _updateElementMappings(e, t) {
          this.domConverter.unbindDomElement(t), this.domConverter.bindElements(t, e), this.markedChildren.add(e), this.markedAttributes.add(e);
        }
        _getInlineFillerPosition() {
          const e = this.selection.getFirstPosition();
          return e.parent.is("$text") ? G._createBefore(e.parent) : e;
        }
        _isSelectionInInlineFiller() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) return !1;
          const e = this.selection.getFirstPosition(), t = this.domConverter.viewPositionToDom(e);
          return !!(t && je(t.parent) && pt(t.parent));
        }
        _removeInlineFiller() {
          const e = this._inlineFiller;
          if (!pt(e)) throw new T("view-renderer-filler-was-lost", this);
          Lo(e) ? e.remove() : e.data = e.data.substr(zt), this._inlineFiller = null;
        }
        _needsInlineFillerAtSelection() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) return !1;
          const e = this.selection.getFirstPosition(), t = e.parent, n = e.offset;
          if (!this.domConverter.mapViewToDom(t.root) || !t.is("element") || !function(s) {
            if (s.getAttribute("contenteditable") == "false") return !1;
            const a = s.findAncestor((l) => l.hasAttribute("contenteditable"));
            return !a || a.getAttribute("contenteditable") == "true";
          }(t) || n === t.getFillerOffset()) return !1;
          const i = e.nodeBefore, r = e.nodeAfter;
          return !(i instanceof Ce || r instanceof Ce) && (!f.isAndroid || !i && !r);
        }
        _updateText(e, t) {
          const n = this.domConverter.findCorrespondingDomText(e);
          let i = this.domConverter.viewToDom(e).data;
          const r = t.inlineFillerPosition;
          r && r.parent == e.parent && r.offset == e.index && (i = Mi + i), qd(n, i);
        }
        _updateAttrs(e) {
          const t = this.domConverter.mapViewToDom(e);
          if (!t) return;
          const n = Array.from(t.attributes).map((r) => r.name), i = e.getAttributeKeys();
          for (const r of i) this.domConverter.setDomElementAttribute(t, r, e.getAttribute(r), e);
          for (const r of n) e.hasAttribute(r) || this.domConverter.removeDomElementAttribute(t, r);
        }
        _updateChildren(e, t) {
          const n = this.domConverter.mapViewToDom(e);
          if (!n) return;
          if (f.isAndroid) {
            let u = null;
            for (const g of Array.from(n.childNodes)) {
              if (u && je(u) && je(g)) {
                n.normalize();
                break;
              }
              u = g;
            }
          }
          const i = t.inlineFillerPosition, r = n.childNodes, s = Array.from(this.domConverter.viewChildrenToDom(e, { bind: !0 }));
          i && i.parent === e && Hd(n.ownerDocument, s, i.offset);
          const a = this._diffNodeLists(r, s), l = this._findUpdateActions(a, r, s, DA);
          let c = 0;
          const d = /* @__PURE__ */ new Set();
          for (const u of l) u === "delete" ? (d.add(r[c]), Bc(r[c])) : u !== "equal" && u !== "update" || c++;
          c = 0;
          for (const u of l) u === "insert" ? (yc(n, c, s[c]), c++) : u === "update" ? (qd(r[c], s[c].data), c++) : u === "equal" && (this._markDescendantTextToSync(this.domConverter.domToView(s[c])), c++);
          for (const u of d) u.parentNode || this.domConverter.unbindDomElement(u);
        }
        _diffNodeLists(e, t) {
          return e = function(n, i) {
            const r = Array.from(n);
            return r.length == 0 || !i || r[r.length - 1] == i && r.pop(), r;
          }(e, this._fakeSelectionContainer), N(e, t, BA.bind(null, this.domConverter));
        }
        _findUpdateActions(e, t, n, i) {
          if (e.indexOf("insert") === -1 || e.indexOf("delete") === -1) return e;
          let r = [], s = [], a = [];
          const l = { equal: 0, insert: 0, delete: 0 };
          for (const c of e) c === "insert" ? a.push(n[l.equal + l.insert]) : c === "delete" ? s.push(t[l.equal + l.delete]) : (r = r.concat(N(s, a, i).map((d) => d === "equal" ? "update" : d)), r.push("equal"), s = [], a = []), l[c]++;
          return r.concat(N(s, a, i).map((c) => c === "equal" ? "update" : c));
        }
        _markDescendantTextToSync(e) {
          if (e) {
            if (e.is("$text")) this.markedTexts.add(e);
            else if (e.is("element")) for (const t of e.getChildren()) this._markDescendantTextToSync(t);
          }
        }
        _updateSelection() {
          if (f.isBlink && !f.isAndroid && this.isSelecting && !this.markedChildren.size) return;
          if (this.selection.rangeCount === 0) return this._removeDomSelection(), void this._removeFakeSelection();
          const e = this.domConverter.mapViewToDom(this.selection.editableElement);
          this.isFocused && e && (this.selection.isFake ? this._updateFakeSelection(e) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(e)) : this.isComposing && f.isAndroid || this._updateDomSelection(e));
        }
        _updateFakeSelection(e) {
          const t = e.ownerDocument;
          this._fakeSelectionContainer || (this._fakeSelectionContainer = function(s) {
            const a = s.createElement("div");
            return a.className = "ck-fake-selection-container", Object.assign(a.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" }), a.textContent = " ", a;
          }(t));
          const n = this._fakeSelectionContainer;
          if (this.domConverter.bindFakeSelection(n, this.selection), !this._fakeSelectionNeedsUpdate(e)) return;
          n.parentElement && n.parentElement == e || e.appendChild(n), n.textContent = this.selection.fakeSelectionLabel || " ";
          const i = t.getSelection(), r = t.createRange();
          i.removeAllRanges(), r.selectNodeContents(n), i.addRange(r);
        }
        _updateDomSelection(e) {
          const t = e.ownerDocument.defaultView.getSelection();
          if (!this._domSelectionNeedsUpdate(t)) return;
          const n = this.domConverter.viewPositionToDom(this.selection.anchor), i = this.domConverter.viewPositionToDom(this.selection.focus);
          t.collapse(n.parent, n.offset), t.extend(i.parent, i.offset), f.isGecko && function(r, s) {
            const a = r.parent;
            if (a.nodeType != Node.ELEMENT_NODE || r.offset != a.childNodes.length - 1) return;
            const l = a.childNodes[r.offset];
            l && l.tagName == "BR" && s.addRange(s.getRangeAt(0));
          }(i, t);
        }
        _domSelectionNeedsUpdate(e) {
          if (!this.domConverter.isDomSelectionCorrect(e)) return !0;
          const t = e && this.domConverter.domSelectionToView(e);
          return (!t || !this.selection.isEqual(t)) && !(!this.selection.isCollapsed && this.selection.isSimilar(t));
        }
        _fakeSelectionNeedsUpdate(e) {
          const t = this._fakeSelectionContainer, n = e.ownerDocument.getSelection();
          return !t || t.parentElement !== e || n.anchorNode !== t && !t.contains(n.anchorNode) || t.textContent !== this.selection.fakeSelectionLabel;
        }
        _removeDomSelection() {
          for (const e of this.domDocuments) {
            const t = e.getSelection();
            if (t.rangeCount) {
              const n = e.activeElement, i = this.domConverter.mapDomToView(n);
              n && i && t.removeAllRanges();
            }
          }
        }
        _removeFakeSelection() {
          const e = this._fakeSelectionContainer;
          e && e.remove();
        }
        _updateFocus() {
          if (this.isFocused) {
            const e = this.selection.editableElement;
            e && this.domConverter.focus(e);
          }
        }
      }
      function Hd(o, e, t) {
        const n = e instanceof Array ? e : e.childNodes, i = n[t];
        if (je(i)) return i.data = Mi + i.data, i;
        {
          const r = o.createTextNode(Mi);
          return Array.isArray(e) ? n.splice(t, 0, r) : yc(e, t, r), r;
        }
      }
      function SA(o, e) {
        return nn(o) && nn(e) && !je(o) && !je(e) && !Xn(o) && !Xn(e) && o.tagName.toLowerCase() === e.tagName.toLowerCase();
      }
      function DA(o, e) {
        return nn(o) && nn(e) && je(o) && je(e);
      }
      function BA(o, e, t) {
        return e === t || (je(e) && je(t) ? e.data === t.data : !(!o.isBlockFiller(e) || !o.isBlockFiller(t)));
      }
      function qd(o, e) {
        const t = o.data;
        if (t == e) return;
        const n = P(t, e);
        for (const i of n) i.type === "insert" ? o.insertData(i.index, i.values.join("")) : o.deleteData(i.index, i.howMany);
      }
      const TA = Ld(le.document), IA = Nd(le.document), PA = Vd(le.document), Fi = "data-ck-unsafe-attribute-", Ud = "data-ck-unsafe-element";
      class Wd {
        constructor(e, { blockFillerMode: t, renderingMode: n = "editing" } = {}) {
          this._domToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToDomMapping = /* @__PURE__ */ new WeakMap(), this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap(), this._rawContentElementMatcher = new no(), this._encounteredRawContentDomNodes = /* @__PURE__ */ new WeakSet(), this.document = e, this.renderingMode = n, this.blockFillerMode = t || (n === "editing" ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this.unsafeElements = ["script", "style"], this._domDocument = this.renderingMode === "editing" ? le.document : le.document.implementation.createHTMLDocument("");
        }
        bindFakeSelection(e, t) {
          this._fakeSelectionMapping.set(e, new Ot(t));
        }
        fakeSelectionToView(e) {
          return this._fakeSelectionMapping.get(e);
        }
        bindElements(e, t) {
          this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
        }
        unbindDomElement(e) {
          const t = this._domToViewMapping.get(e);
          if (t) {
            this._domToViewMapping.delete(e), this._viewToDomMapping.delete(t);
            for (const n of Array.from(e.children)) this.unbindDomElement(n);
          }
        }
        bindDocumentFragments(e, t) {
          this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
        }
        shouldRenderAttribute(e, t, n) {
          return this.renderingMode === "data" || !(e = e.toLowerCase()).startsWith("on") && (e !== "srcdoc" || !t.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) && (n === "img" && (e === "src" || e === "srcset") || n === "source" && e === "srcset" || !t.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i));
        }
        setContentOf(e, t) {
          if (this.renderingMode === "data") return void (e.innerHTML = t);
          const n = new DOMParser().parseFromString(t, "text/html"), i = n.createDocumentFragment(), r = n.body.childNodes;
          for (; r.length > 0; ) i.appendChild(r[0]);
          const s = n.createTreeWalker(i, NodeFilter.SHOW_ELEMENT), a = [];
          let l;
          for (; l = s.nextNode(); ) a.push(l);
          for (const c of a) {
            for (const u of c.getAttributeNames()) this.setDomElementAttribute(c, u, c.getAttribute(u));
            const d = c.tagName.toLowerCase();
            this._shouldRenameElement(d) && (Zd(d), c.replaceWith(this._createReplacementDomElement(d, c)));
          }
          for (; e.firstChild; ) e.firstChild.remove();
          e.append(i);
        }
        viewToDom(e, t = {}) {
          if (e.is("$text")) {
            const n = this._processDataFromViewText(e);
            return this._domDocument.createTextNode(n);
          }
          {
            if (this.mapViewToDom(e)) return this.mapViewToDom(e);
            let n;
            if (e.is("documentFragment")) n = this._domDocument.createDocumentFragment(), t.bind && this.bindDocumentFragments(n, e);
            else {
              if (e.is("uiElement")) return n = e.name === "$comment" ? this._domDocument.createComment(e.getCustomProperty("$rawContent")) : e.render(this._domDocument, this), t.bind && this.bindElements(n, e), n;
              this._shouldRenameElement(e.name) ? (Zd(e.name), n = this._createReplacementDomElement(e.name)) : n = e.hasAttribute("xmlns") ? this._domDocument.createElementNS(e.getAttribute("xmlns"), e.name) : this._domDocument.createElement(e.name), e.is("rawElement") && e.render(n, this), t.bind && this.bindElements(n, e);
              for (const i of e.getAttributeKeys()) this.setDomElementAttribute(n, i, e.getAttribute(i), e);
            }
            if (t.withChildren !== !1) for (const i of this.viewChildrenToDom(e, t)) n.appendChild(i);
            return n;
          }
        }
        setDomElementAttribute(e, t, n, i) {
          const r = this.shouldRenderAttribute(t, n, e.tagName.toLowerCase()) || i && i.shouldRenderUnsafeAttribute(t);
          r || ee("domconverter-unsafe-attribute-detected", { domElement: e, key: t, value: n }), Ec(t) ? (e.hasAttribute(t) && !r ? e.removeAttribute(t) : e.hasAttribute(Fi + t) && r && e.removeAttribute(Fi + t), e.setAttribute(r ? t : Fi + t, n)) : ee("domconverter-invalid-attribute-detected", { domElement: e, key: t, value: n });
        }
        removeDomElementAttribute(e, t) {
          t != Ud && (e.removeAttribute(t), e.removeAttribute(Fi + t));
        }
        *viewChildrenToDom(e, t = {}) {
          const n = e.getFillerOffset && e.getFillerOffset();
          let i = 0;
          for (const r of e.getChildren()) {
            n === i && (yield this._getBlockFiller());
            const s = r.is("element") && !!r.getCustomProperty("dataPipeline:transparentRendering") && !Ke(r.getAttributes());
            s && this.renderingMode == "data" ? yield* this.viewChildrenToDom(r, t) : (s && ee("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: r }), yield this.viewToDom(r, t)), i++;
          }
          n === i && (yield this._getBlockFiller());
        }
        viewRangeToDom(e) {
          const t = this.viewPositionToDom(e.start), n = this.viewPositionToDom(e.end), i = this._domDocument.createRange();
          return i.setStart(t.parent, t.offset), i.setEnd(n.parent, n.offset), i;
        }
        viewPositionToDom(e) {
          const t = e.parent;
          if (t.is("$text")) {
            const n = this.findCorrespondingDomText(t);
            if (!n) return null;
            let i = e.offset;
            return pt(n) && (i += zt), { parent: n, offset: i };
          }
          {
            let n, i, r;
            if (e.offset === 0) {
              if (n = this.mapViewToDom(t), !n) return null;
              r = n.childNodes[0];
            } else {
              const s = e.nodeBefore;
              if (i = s.is("$text") ? this.findCorrespondingDomText(s) : this.mapViewToDom(s), !i) return null;
              n = i.parentNode, r = i.nextSibling;
            }
            return je(r) && pt(r) ? { parent: r, offset: zt } : { parent: n, offset: i ? yi(i) + 1 : 0 };
          }
        }
        domToView(e, t = {}) {
          if (this.isBlockFiller(e)) return null;
          const n = this.getHostViewElement(e);
          if (n) return n;
          if (Xn(e) && t.skipComments) return null;
          if (je(e)) {
            if (Lo(e)) return null;
            {
              const i = this._processDataFromDomText(e);
              return i === "" ? null : new Ce(this.document, i);
            }
          }
          {
            if (this.mapDomToView(e)) return this.mapDomToView(e);
            let i;
            if (this.isDocumentFragment(e)) i = new En(this.document), t.bind && this.bindDocumentFragments(e, i);
            else {
              i = this._createViewElement(e, t), t.bind && this.bindElements(e, i);
              const r = e.attributes;
              if (r) for (let s = r.length, a = 0; a < s; a++) i._setAttribute(r[a].name, r[a].value);
              if (this._isViewElementWithRawContent(i, t) || Xn(e)) {
                const s = Xn(e) ? e.data : e.innerHTML;
                return i._setCustomProperty("$rawContent", s), this._encounteredRawContentDomNodes.add(e), i;
              }
            }
            if (t.withChildren !== !1) for (const r of this.domChildrenToView(e, t)) i._appendChild(r);
            return i;
          }
        }
        *domChildrenToView(e, t) {
          for (let n = 0; n < e.childNodes.length; n++) {
            const i = e.childNodes[n], r = this.domToView(i, t);
            r !== null && (yield r);
          }
        }
        domSelectionToView(e) {
          if (e.rangeCount === 1) {
            let i = e.getRangeAt(0).startContainer;
            je(i) && (i = i.parentNode);
            const r = this.fakeSelectionToView(i);
            if (r) return r;
          }
          const t = this.isDomSelectionBackward(e), n = [];
          for (let i = 0; i < e.rangeCount; i++) {
            const r = e.getRangeAt(i), s = this.domRangeToView(r);
            s && n.push(s);
          }
          return new Ot(n, { backward: t });
        }
        domRangeToView(e) {
          const t = this.domPositionToView(e.startContainer, e.startOffset), n = this.domPositionToView(e.endContainer, e.endOffset);
          return t && n ? new te(t, n) : null;
        }
        domPositionToView(e, t = 0) {
          if (this.isBlockFiller(e)) return this.domPositionToView(e.parentNode, yi(e));
          const n = this.mapDomToView(e);
          if (n && (n.is("uiElement") || n.is("rawElement"))) return G._createBefore(n);
          if (je(e)) {
            if (Lo(e)) return this.domPositionToView(e.parentNode, yi(e));
            const i = this.findCorrespondingViewText(e);
            let r = t;
            return i ? (pt(e) && (r -= zt, r = r < 0 ? 0 : r), new G(i, r)) : null;
          }
          if (t === 0) {
            const i = this.mapDomToView(e);
            if (i) return new G(i, 0);
          } else {
            const i = e.childNodes[t - 1];
            if (je(i) && Lo(i) || i && this.isBlockFiller(i)) return this.domPositionToView(i.parentNode, yi(i));
            const r = je(i) ? this.findCorrespondingViewText(i) : this.mapDomToView(i);
            if (r && r.parent) return new G(r.parent, r.index + 1);
          }
          return null;
        }
        mapDomToView(e) {
          return this.getHostViewElement(e) || this._domToViewMapping.get(e);
        }
        findCorrespondingViewText(e) {
          if (Lo(e)) return null;
          const t = this.getHostViewElement(e);
          if (t) return t;
          const n = e.previousSibling;
          if (n) {
            if (!this.isElement(n)) return null;
            const i = this.mapDomToView(n);
            if (i) {
              const r = i.nextSibling;
              return r instanceof Ce ? r : null;
            }
          } else {
            const i = this.mapDomToView(e.parentNode);
            if (i) {
              const r = i.getChild(0);
              return r instanceof Ce ? r : null;
            }
          }
          return null;
        }
        mapViewToDom(e) {
          return this._viewToDomMapping.get(e);
        }
        findCorrespondingDomText(e) {
          const t = e.previousSibling;
          return t && this.mapViewToDom(t) ? this.mapViewToDom(t).nextSibling : !t && e.parent && this.mapViewToDom(e.parent) ? this.mapViewToDom(e.parent).childNodes[0] : null;
        }
        focus(e) {
          const t = this.mapViewToDom(e);
          if (t && t.ownerDocument.activeElement !== t) {
            const { scrollX: n, scrollY: i } = le.window, r = [];
            Kd(t, (s) => {
              const { scrollLeft: a, scrollTop: l } = s;
              r.push([a, l]);
            }), t.focus(), Kd(t, (s) => {
              const [a, l] = r.shift();
              s.scrollLeft = a, s.scrollTop = l;
            }), le.window.scrollTo(n, i);
          }
        }
        isElement(e) {
          return e && e.nodeType == Node.ELEMENT_NODE;
        }
        isDocumentFragment(e) {
          return e && e.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
        }
        isBlockFiller(e) {
          return this.blockFillerMode == "br" ? e.isEqualNode(TA) : !(e.tagName !== "BR" || !Gd(e, this.blockElements) || e.parentNode.childNodes.length !== 1) || e.isEqualNode(PA) || function(t, n) {
            return t.isEqualNode(IA) && Gd(t, n) && t.parentNode.childNodes.length === 1;
          }(e, this.blockElements);
        }
        isDomSelectionBackward(e) {
          if (e.isCollapsed) return !1;
          const t = this._domDocument.createRange();
          try {
            t.setStart(e.anchorNode, e.anchorOffset), t.setEnd(e.focusNode, e.focusOffset);
          } catch {
            return !1;
          }
          const n = t.collapsed;
          return t.detach(), n;
        }
        getHostViewElement(e) {
          const t = wc(e);
          for (t.pop(); t.length; ) {
            const n = t.pop(), i = this._domToViewMapping.get(n);
            if (i && (i.is("uiElement") || i.is("rawElement"))) return i;
          }
          return null;
        }
        isDomSelectionCorrect(e) {
          return this._isDomSelectionPositionCorrect(e.anchorNode, e.anchorOffset) && this._isDomSelectionPositionCorrect(e.focusNode, e.focusOffset);
        }
        registerRawContentMatcher(e) {
          this._rawContentElementMatcher.add(e);
        }
        _getBlockFiller() {
          switch (this.blockFillerMode) {
            case "nbsp":
              return Nd(this._domDocument);
            case "markedNbsp":
              return Vd(this._domDocument);
            case "br":
              return Ld(this._domDocument);
          }
        }
        _isDomSelectionPositionCorrect(e, t) {
          if (je(e) && pt(e) && t < zt || this.isElement(e) && pt(e.childNodes[t])) return !1;
          const n = this.mapDomToView(e);
          return !n || !n.is("uiElement") && !n.is("rawElement");
        }
        _processDataFromViewText(e) {
          let t = e.data;
          if (e.getAncestors().some((n) => this.preElements.includes(n.name))) return t;
          if (t.charAt(0) == " ") {
            const n = this._getTouchingInlineViewNode(e, !1);
            !(n && n.is("$textProxy") && this._nodeEndsWithSpace(n)) && n || (t = " " + t.substr(1));
          }
          if (t.charAt(t.length - 1) == " ") {
            const n = this._getTouchingInlineViewNode(e, !0), i = n && n.is("$textProxy") && n.data.charAt(0) == " ";
            t.charAt(t.length - 2) != " " && n && !i || (t = t.substr(0, t.length - 1) + " ");
          }
          return t.replace(/ {2}/g, "  ");
        }
        _nodeEndsWithSpace(e) {
          if (e.getAncestors().some((n) => this.preElements.includes(n.name))) return !1;
          const t = this._processDataFromViewText(e);
          return t.charAt(t.length - 1) == " ";
        }
        _processDataFromDomText(e) {
          let t = e.data;
          if (function(c, d) {
            return wc(c).some((g) => g.tagName && d.includes(g.tagName.toLowerCase()));
          }(e, this.preElements)) return jd(e);
          t = t.replace(/[ \n\t\r]{1,}/g, " ");
          const n = this._getTouchingInlineDomNode(e, !1), i = this._getTouchingInlineDomNode(e, !0), r = this._checkShouldLeftTrimDomText(e, n), s = this._checkShouldRightTrimDomText(e, i);
          r && (t = t.replace(/^ /, "")), s && (t = t.replace(/ $/, "")), t = jd(new Text(t)), t = t.replace(/ \u00A0/g, "  ");
          const a = i && this.isElement(i) && i.tagName != "BR", l = i && je(i) && i.data.charAt(0) == " ";
          return (/( |\u00A0)\u00A0$/.test(t) || !i || a || l) && (t = t.replace(/\u00A0$/, " ")), (r || n && this.isElement(n) && n.tagName != "BR") && (t = t.replace(/^\u00A0/, " ")), t;
        }
        _checkShouldLeftTrimDomText(e, t) {
          return !t || (this.isElement(t) ? t.tagName === "BR" : !this._encounteredRawContentDomNodes.has(e.previousSibling) && /[^\S\u00A0]/.test(t.data.charAt(t.data.length - 1)));
        }
        _checkShouldRightTrimDomText(e, t) {
          return !t && !pt(e);
        }
        _getTouchingInlineViewNode(e, t) {
          const n = new Cn({ startPosition: t ? G._createAfter(e) : G._createBefore(e), direction: t ? "forward" : "backward" });
          for (const i of n) {
            if (i.item.is("element") && this.inlineObjectElements.includes(i.item.name)) return i.item;
            if (i.item.is("containerElement") || i.item.is("element", "br")) return null;
            if (i.item.is("$textProxy")) return i.item;
          }
          return null;
        }
        _getTouchingInlineDomNode(e, t) {
          if (!e.parentNode) return null;
          const n = t ? "firstChild" : "lastChild", i = t ? "nextSibling" : "previousSibling";
          let r = !0, s = e;
          do
            if (!r && s[n] ? s = s[n] : s[i] ? (s = s[i], r = !1) : (s = s.parentNode, r = !0), !s || this._isBlockElement(s)) return null;
          while (!je(s) && s.tagName != "BR" && !this._isInlineObjectElement(s));
          return s;
        }
        _isBlockElement(e) {
          return this.isElement(e) && this.blockElements.includes(e.tagName.toLowerCase());
        }
        _isInlineObjectElement(e) {
          return this.isElement(e) && this.inlineObjectElements.includes(e.tagName.toLowerCase());
        }
        _createViewElement(e, t) {
          if (Xn(e)) return new zi(this.document, "$comment");
          const n = t.keepOriginalCase ? e.tagName : e.tagName.toLowerCase();
          return new mt(this.document, n);
        }
        _isViewElementWithRawContent(e, t) {
          return t.withChildren !== !1 && !!this._rawContentElementMatcher.match(e);
        }
        _shouldRenameElement(e) {
          const t = e.toLowerCase();
          return this.renderingMode === "editing" && this.unsafeElements.includes(t);
        }
        _createReplacementDomElement(e, t) {
          const n = this._domDocument.createElement("span");
          if (n.setAttribute(Ud, e), t) {
            for (; t.firstChild; ) n.appendChild(t.firstChild);
            for (const i of t.getAttributeNames()) n.setAttribute(i, t.getAttribute(i));
          }
          return n;
        }
      }
      function Kd(o, e) {
        let t = o;
        for (; t; ) e(t), t = t.parentElement;
      }
      function Gd(o, e) {
        const t = o.parentNode;
        return !!t && !!t.tagName && e.includes(t.tagName.toLowerCase());
      }
      function Zd(o) {
        o === "script" && ee("domconverter-unsafe-script-element-detected"), o === "style" && ee("domconverter-unsafe-style-element-detected");
      }
      class Mt extends on() {
        constructor(e) {
          super(), this._isEnabled = !1, this.view = e, this.document = e.document;
        }
        get isEnabled() {
          return this._isEnabled;
        }
        enable() {
          this._isEnabled = !0;
        }
        disable() {
          this._isEnabled = !1;
        }
        destroy() {
          this.disable(), this.stopListening();
        }
        checkShouldIgnoreEventFromTarget(e) {
          return e && e.nodeType === 3 && (e = e.parentNode), !(!e || e.nodeType !== 1) && e.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
        }
      }
      const Jd = Es(function(o, e) {
        Zn(e, Yn(e), o);
      });
      class ro {
        constructor(e, t, n) {
          this.view = e, this.document = e.document, this.domEvent = t, this.domTarget = t.target, Jd(this, n);
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget);
        }
        preventDefault() {
          this.domEvent.preventDefault();
        }
        stopPropagation() {
          this.domEvent.stopPropagation();
        }
      }
      class rn extends Mt {
        constructor() {
          super(...arguments), this.useCapture = !1;
        }
        observe(e) {
          (typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType).forEach((t) => {
            this.listenTo(e, t, (n, i) => {
              this.isEnabled && !this.checkShouldIgnoreEventFromTarget(i.target) && this.onDomEvent(i);
            }, { useCapture: this.useCapture });
          });
        }
        stopObserving(e) {
          this.stopListening(e);
        }
        fire(e, t, n) {
          this.isEnabled && this.document.fire(e, new ro(this.view, t, n));
        }
      }
      class RA extends rn {
        constructor() {
          super(...arguments), this.domEventType = ["keydown", "keyup"];
        }
        onDomEvent(e) {
          const t = { keyCode: e.keyCode, altKey: e.altKey, ctrlKey: e.ctrlKey, shiftKey: e.shiftKey, metaKey: e.metaKey, get keystroke() {
            return eo(this);
          } };
          this.fire(e.type, e, t);
        }
      }
      const Ns = function() {
        return yt.Date.now();
      };
      var OA = /\s/;
      const zA = function(o) {
        for (var e = o.length; e-- && OA.test(o.charAt(e)); ) ;
        return e;
      };
      var MA = /^\s+/;
      const FA = function(o) {
        return o && o.slice(0, zA(o) + 1).replace(MA, "");
      };
      var NA = /^[-+]0x[0-9a-f]+$/i, VA = /^0b[01]+$/i, LA = /^0o[0-7]+$/i, jA = parseInt;
      const Yd = function(o) {
        if (typeof o == "number") return o;
        if (Ii(o)) return NaN;
        if (ze(o)) {
          var e = typeof o.valueOf == "function" ? o.valueOf() : o;
          o = ze(e) ? e + "" : e;
        }
        if (typeof o != "string") return o === 0 ? o : +o;
        o = FA(o);
        var t = VA.test(o);
        return t || LA.test(o) ? jA(o.slice(2), t ? 2 : 8) : NA.test(o) ? NaN : +o;
      };
      var $A = Math.max, HA = Math.min;
      const jo = function(o, e, t) {
        var n, i, r, s, a, l, c = 0, d = !1, u = !1, g = !0;
        if (typeof o != "function") throw new TypeError("Expected a function");
        function p(z) {
          var H = n, X = i;
          return n = i = void 0, c = z, s = o.apply(X, H);
        }
        function b(z) {
          var H = z - l;
          return l === void 0 || H >= e || H < 0 || u && z - c >= r;
        }
        function w() {
          var z = Ns();
          if (b(z)) return y(z);
          a = setTimeout(w, function(H) {
            var X = e - (H - l);
            return u ? HA(X, r - (H - c)) : X;
          }(z));
        }
        function y(z) {
          return a = void 0, g && n ? p(z) : (n = i = void 0, s);
        }
        function I() {
          var z = Ns(), H = b(z);
          if (n = arguments, i = this, l = z, H) {
            if (a === void 0) return function(X) {
              return c = X, a = setTimeout(w, e), d ? p(X) : s;
            }(l);
            if (u) return clearTimeout(a), a = setTimeout(w, e), p(l);
          }
          return a === void 0 && (a = setTimeout(w, e)), s;
        }
        return e = Yd(e) || 0, ze(t) && (d = !!t.leading, r = (u = "maxWait" in t) ? $A(Yd(t.maxWait) || 0, e) : r, g = "trailing" in t ? !!t.trailing : g), I.cancel = function() {
          a !== void 0 && clearTimeout(a), c = 0, n = l = i = a = void 0;
        }, I.flush = function() {
          return a === void 0 ? s : y(Ns());
        }, I;
      };
      class qA extends Mt {
        constructor(e) {
          super(e), this._fireSelectionChangeDoneDebounced = jo((t) => {
            this.document.fire("selectionChangeDone", t);
          }, 200);
        }
        observe() {
          const e = this.document;
          e.on("arrowKey", (t, n) => {
            e.selection.isFake && this.isEnabled && n.preventDefault();
          }, { context: "$capture" }), e.on("arrowKey", (t, n) => {
            e.selection.isFake && this.isEnabled && this._handleSelectionMove(n.keyCode);
          }, { priority: "lowest" });
        }
        stopObserving() {
        }
        destroy() {
          super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionMove(e) {
          const t = this.document.selection, n = new Ot(t.getRanges(), { backward: t.isBackward, fake: !1 });
          e != ge.arrowleft && e != ge.arrowup || n.setTo(n.getFirstPosition()), e != ge.arrowright && e != ge.arrowdown || n.setTo(n.getLastPosition());
          const i = { oldSelection: t, newSelection: n, domSelection: null };
          this.document.fire("selectionChange", i), this._fireSelectionChangeDoneDebounced(i);
        }
      }
      const UA = function(o) {
        return this.__data__.set(o, "__lodash_hash_undefined__"), this;
      }, WA = function(o) {
        return this.__data__.has(o);
      };
      function Ni(o) {
        var e = -1, t = o == null ? 0 : o.length;
        for (this.__data__ = new fi(); ++e < t; ) this.add(o[e]);
      }
      Ni.prototype.add = Ni.prototype.push = UA, Ni.prototype.has = WA;
      const KA = Ni, GA = function(o, e) {
        for (var t = -1, n = o == null ? 0 : o.length; ++t < n; ) if (e(o[t], t, o)) return !0;
        return !1;
      }, ZA = function(o, e) {
        return o.has(e);
      }, Qd = function(o, e, t, n, i, r) {
        var s = 1 & t, a = o.length, l = e.length;
        if (a != l && !(s && l > a)) return !1;
        var c = r.get(o), d = r.get(e);
        if (c && d) return c == e && d == o;
        var u = -1, g = !0, p = 2 & t ? new KA() : void 0;
        for (r.set(o, e), r.set(e, o); ++u < a; ) {
          var b = o[u], w = e[u];
          if (n) var y = s ? n(w, b, u, e, o, r) : n(b, w, u, o, e, r);
          if (y !== void 0) {
            if (y) continue;
            g = !1;
            break;
          }
          if (p) {
            if (!GA(e, function(I, z) {
              if (!ZA(p, z) && (b === I || i(b, I, t, n, r))) return p.push(z);
            })) {
              g = !1;
              break;
            }
          } else if (b !== w && !i(b, w, t, n, r)) {
            g = !1;
            break;
          }
        }
        return r.delete(o), r.delete(e), g;
      }, JA = function(o) {
        var e = -1, t = Array(o.size);
        return o.forEach(function(n, i) {
          t[++e] = [i, n];
        }), t;
      }, YA = function(o) {
        var e = -1, t = Array(o.size);
        return o.forEach(function(n) {
          t[++e] = n;
        }), t;
      };
      var Xd = It ? It.prototype : void 0, Vs = Xd ? Xd.valueOf : void 0;
      const QA = function(o, e, t, n, i, r, s) {
        switch (t) {
          case "[object DataView]":
            if (o.byteLength != e.byteLength || o.byteOffset != e.byteOffset) return !1;
            o = o.buffer, e = e.buffer;
          case "[object ArrayBuffer]":
            return !(o.byteLength != e.byteLength || !r(new wi(o), new wi(e)));
          case "[object Boolean]":
          case "[object Date]":
          case "[object Number]":
            return So(+o, +e);
          case "[object Error]":
            return o.name == e.name && o.message == e.message;
          case "[object RegExp]":
          case "[object String]":
            return o == e + "";
          case "[object Map]":
            var a = JA;
          case "[object Set]":
            var l = 1 & n;
            if (a || (a = YA), o.size != e.size && !l) return !1;
            var c = s.get(o);
            if (c) return c == e;
            n |= 2, s.set(o, e);
            var d = Qd(a(o), a(e), n, i, r, s);
            return s.delete(o), d;
          case "[object Symbol]":
            if (Vs) return Vs.call(o) == Vs.call(e);
        }
        return !1;
      };
      var XA = Object.prototype.hasOwnProperty;
      const e0 = function(o, e, t, n, i, r) {
        var s = 1 & t, a = Jr(o), l = a.length;
        if (l != Jr(e).length && !s) return !1;
        for (var c = l; c--; ) {
          var d = a[c];
          if (!(s ? d in e : XA.call(e, d))) return !1;
        }
        var u = r.get(o), g = r.get(e);
        if (u && g) return u == e && g == o;
        var p = !0;
        r.set(o, e), r.set(e, o);
        for (var b = s; ++c < l; ) {
          var w = o[d = a[c]], y = e[d];
          if (n) var I = s ? n(y, w, d, e, o, r) : n(w, y, d, o, e, r);
          if (!(I === void 0 ? w === y || i(w, y, t, n, r) : I)) {
            p = !1;
            break;
          }
          b || (b = d == "constructor");
        }
        if (p && !b) {
          var z = o.constructor, H = e.constructor;
          z == H || !("constructor" in o) || !("constructor" in e) || typeof z == "function" && z instanceof z && typeof H == "function" && H instanceof H || (p = !1);
        }
        return r.delete(o), r.delete(e), p;
      };
      var eu = "[object Arguments]", tu = "[object Array]", Vi = "[object Object]", nu = Object.prototype.hasOwnProperty;
      const t0 = function(o, e, t, n, i, r) {
        var s = it(o), a = it(e), l = s ? tu : Ro(o), c = a ? tu : Ro(e), d = (l = l == eu ? Vi : l) == Vi, u = (c = c == eu ? Vi : c) == Vi, g = l == c;
        if (g && Io(o)) {
          if (!Io(e)) return !1;
          s = !0, d = !1;
        }
        if (g && !d) return r || (r = new To()), s || Ur(o) ? Qd(o, e, t, n, i, r) : QA(o, e, l, t, n, i, r);
        if (!(1 & t)) {
          var p = d && nu.call(o, "__wrapped__"), b = u && nu.call(e, "__wrapped__");
          if (p || b) {
            var w = p ? o.value() : o, y = b ? e.value() : e;
            return r || (r = new To()), i(w, y, t, n, r);
          }
        }
        return !!g && (r || (r = new To()), e0(o, e, t, n, i, r));
      }, ou = function o(e, t, n, i, r) {
        return e === t || (e == null || t == null || !At(e) && !At(t) ? e != e && t != t : t0(e, t, n, i, o, r));
      }, n0 = function(o, e, t) {
        var n = (t = typeof t == "function" ? t : void 0) ? t(o, e) : void 0;
        return n === void 0 ? ou(o, e, void 0, t) : !!n;
      };
      class iu extends Mt {
        constructor(e) {
          super(e), this._config = { childList: !0, characterData: !0, subtree: !0 }, this.domConverter = e.domConverter, this.renderer = e._renderer, this._domElements = /* @__PURE__ */ new Set(), this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords());
        }
        observe(e) {
          this._domElements.add(e), this.isEnabled && this._mutationObserver.observe(e, this._config);
        }
        stopObserving(e) {
          if (this._domElements.delete(e), this.isEnabled) {
            this._mutationObserver.disconnect();
            for (const t of this._domElements) this._mutationObserver.observe(t, this._config);
          }
        }
        enable() {
          super.enable();
          for (const e of this._domElements) this._mutationObserver.observe(e, this._config);
        }
        disable() {
          super.disable(), this._mutationObserver.disconnect();
        }
        destroy() {
          super.destroy(), this._mutationObserver.disconnect();
        }
        _onMutations(e) {
          if (e.length === 0) return;
          const t = this.domConverter, n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
          for (const s of e) {
            const a = t.mapDomToView(s.target);
            a && (a.is("uiElement") || a.is("rawElement") || s.type !== "childList" || this._isBogusBrMutation(s) || i.add(a));
          }
          for (const s of e) {
            const a = t.mapDomToView(s.target);
            if ((!a || !a.is("uiElement") && !a.is("rawElement")) && s.type === "characterData") {
              const l = t.findCorrespondingViewText(s.target);
              l && !i.has(l.parent) ? n.add(l) : !l && pt(s.target) && i.add(t.mapDomToView(s.target.parentNode));
            }
          }
          let r = !1;
          for (const s of n) r = !0, this.renderer.markToSync("text", s);
          for (const s of i) {
            const a = t.mapViewToDom(s), l = Array.from(s.getChildren()), c = Array.from(t.domChildrenToView(a, { withChildren: !1 }));
            n0(l, c, o0) || (r = !0, this.renderer.markToSync("children", s));
          }
          r && this.view.forceRender();
        }
        _isBogusBrMutation(e) {
          let t = null;
          return e.nextSibling === null && e.removedNodes.length === 0 && e.addedNodes.length == 1 && (t = this.domConverter.domToView(e.addedNodes[0], { withChildren: !1 })), t && t.is("element", "br");
        }
      }
      function o0(o, e) {
        if (!Array.isArray(o)) return o === e || !(!o.is("$text") || !e.is("$text")) && o.data === e.data;
      }
      class Ls extends rn {
        constructor(e) {
          super(e), this._isFocusChanging = !1, this.domEventType = ["focus", "blur"], this.useCapture = !0;
          const t = this.document;
          t.on("focus", () => {
            this._isFocusChanging = !0, this._renderTimeoutId = setTimeout(() => {
              this.flush(), e.change(() => {
              });
            }, 50);
          }), t.on("blur", (n, i) => {
            const r = t.selection.editableElement;
            r !== null && r !== i.target || (t.isFocused = !1, this._isFocusChanging = !1, e.change(() => {
            }));
          });
        }
        flush() {
          this._isFocusChanging && (this._isFocusChanging = !1, this.document.isFocused = !0);
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
        destroy() {
          this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
        }
      }
      class i0 extends Mt {
        constructor(e) {
          super(e), this.mutationObserver = e.getObserver(iu), this.focusObserver = e.getObserver(Ls), this.selection = this.document.selection, this.domConverter = e.domConverter, this._documents = /* @__PURE__ */ new WeakSet(), this._fireSelectionChangeDoneDebounced = jo((t) => {
            this.document.fire("selectionChangeDone", t);
          }, 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = jo(() => this.document.isSelecting = !1, 5e3), this._loopbackCounter = 0;
        }
        observe(e) {
          const t = e.ownerDocument, n = () => {
            this.document.isSelecting && (this._handleSelectionChange(null, t), this.document.isSelecting = !1, this._documentIsSelectingInactivityTimeoutDebounced.cancel());
          };
          this.listenTo(e, "selectstart", () => {
            this.document.isSelecting = !0, this._documentIsSelectingInactivityTimeoutDebounced();
          }, { priority: "highest" }), this.listenTo(e, "keydown", n, { priority: "highest", useCapture: !0 }), this.listenTo(e, "keyup", n, { priority: "highest", useCapture: !0 }), this._documents.has(t) || (this.listenTo(t, "mouseup", n, { priority: "highest", useCapture: !0 }), this.listenTo(t, "selectionchange", (i, r) => {
            this.document.isComposing && !f.isAndroid || (this._handleSelectionChange(r, t), this._documentIsSelectingInactivityTimeoutDebounced());
          }), this._documents.add(t));
        }
        stopObserving(e) {
          this.stopListening(e);
        }
        destroy() {
          super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel();
        }
        _reportInfiniteLoop() {
        }
        _handleSelectionChange(e, t) {
          if (!this.isEnabled) return;
          const n = t.defaultView.getSelection();
          if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) return;
          this.mutationObserver.flush();
          const i = this.domConverter.domSelectionToView(n);
          if (i.rangeCount != 0) {
            if (this.view.hasDomSelection = !0, !this.selection.isEqual(i) || !this.domConverter.isDomSelectionCorrect(n)) if (++this._loopbackCounter > 60) this._reportInfiniteLoop();
            else if (this.focusObserver.flush(), this.selection.isSimilar(i)) this.view.forceRender();
            else {
              const r = { oldSelection: this.selection, newSelection: i, domSelection: n };
              this.document.fire("selectionChange", r), this._fireSelectionChangeDoneDebounced(r);
            }
          } else this.view.hasDomSelection = !1;
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0;
        }
      }
      class r0 extends rn {
        constructor(e) {
          super(e), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
          const t = this.document;
          t.on("compositionstart", () => {
            t.isComposing = !0;
          }, { priority: "low" }), t.on("compositionend", () => {
            t.isComposing = !1;
          }, { priority: "low" });
        }
        onDomEvent(e) {
          this.fire(e.type, e, { data: e.data });
        }
      }
      class ru {
        constructor(e, t = {}) {
          this._files = t.cacheFiles ? su(e) : null, this._native = e;
        }
        get files() {
          return this._files || (this._files = su(this._native)), this._files;
        }
        get types() {
          return this._native.types;
        }
        getData(e) {
          return this._native.getData(e);
        }
        setData(e, t) {
          this._native.setData(e, t);
        }
        set effectAllowed(e) {
          this._native.effectAllowed = e;
        }
        get effectAllowed() {
          return this._native.effectAllowed;
        }
        set dropEffect(e) {
          this._native.dropEffect = e;
        }
        get dropEffect() {
          return this._native.dropEffect;
        }
        setDragImage(e, t, n) {
          this._native.setDragImage(e, t, n);
        }
        get isCanceled() {
          return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
        }
      }
      function su(o) {
        const e = Array.from(o.files || []), t = Array.from(o.items || []);
        return e.length ? e : t.filter((n) => n.kind === "file").map((n) => n.getAsFile());
      }
      class s0 extends rn {
        constructor() {
          super(...arguments), this.domEventType = "beforeinput";
        }
        onDomEvent(e) {
          const t = e.getTargetRanges(), n = this.view, i = n.document;
          let r = null, s = null, a = [];
          if (e.dataTransfer && (r = new ru(e.dataTransfer)), e.data !== null ? s = e.data : r && (s = r.getData("text/plain")), i.selection.isFake) a = Array.from(i.selection.getRanges());
          else if (t.length) a = t.map((l) => n.domConverter.domRangeToView(l));
          else if (f.isAndroid) {
            const l = e.target.ownerDocument.defaultView.getSelection();
            a = Array.from(n.domConverter.domSelectionToView(l).getRanges());
          }
          if (f.isAndroid && e.inputType == "insertCompositionText" && s && s.endsWith(`
`)) this.fire(e.type, e, { inputType: "insertParagraph", targetRanges: [n.createRange(a[0].end)] });
          else if (e.inputType == "insertText" && s && s.includes(`
`)) {
            const l = s.split(/\n{1,2}/g);
            let c = a;
            for (let d = 0; d < l.length; d++) {
              const u = l[d];
              u != "" && (this.fire(e.type, e, { data: u, dataTransfer: r, targetRanges: c, inputType: e.inputType, isComposing: e.isComposing }), c = [i.selection.getFirstRange()]), d + 1 < l.length && (this.fire(e.type, e, { inputType: "insertParagraph", targetRanges: c }), c = [i.selection.getFirstRange()]);
            }
          } else this.fire(e.type, e, { data: s, dataTransfer: r, targetRanges: a, inputType: e.inputType, isComposing: e.isComposing });
        }
      }
      class a0 extends Mt {
        constructor(e) {
          super(e), this.document.on("keydown", (t, n) => {
            if (this.isEnabled && ((i = n.keyCode) == ge.arrowright || i == ge.arrowleft || i == ge.arrowup || i == ge.arrowdown)) {
              const r = new oo(this.document, "arrowKey", this.document.selection.getFirstRange());
              this.document.fire(r, n), r.stop.called && t.stop();
            }
            var i;
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class l0 extends Mt {
        constructor(e) {
          super(e);
          const t = this.document;
          t.on("keydown", (n, i) => {
            if (!this.isEnabled || i.keyCode != ge.tab || i.ctrlKey) return;
            const r = new oo(t, "tab", t.selection.getFirstRange());
            t.fire(r, i), r.stop.called && n.stop();
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class c0 extends ve() {
        constructor(e) {
          super(), this.domRoots = /* @__PURE__ */ new Map(), this._initialDomRootAttributes = /* @__PURE__ */ new WeakMap(), this._observers = /* @__PURE__ */ new Map(), this._ongoingChange = !1, this._postFixersInProgress = !1, this._renderingDisabled = !1, this._hasChangedSinceTheLastRendering = !1, this.document = new Pd(e), this.domConverter = new Wd(this.document), this.set("isRenderingInProgress", !1), this.set("hasDomSelection", !1), this._renderer = new xA(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new Rd(this.document), this.addObserver(iu), this.addObserver(Ls), this.addObserver(i0), this.addObserver(RA), this.addObserver(qA), this.addObserver(r0), this.addObserver(a0), this.addObserver(s0), this.addObserver(l0), this.document.on("arrowKey", yA, { priority: "low" }), wA(this), this.on("render", () => {
            this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = !1;
          }), this.listenTo(this.document.selection, "change", () => {
            this._hasChangedSinceTheLastRendering = !0;
          }), this.listenTo(this.document, "change:isFocused", () => {
            this._hasChangedSinceTheLastRendering = !0;
          });
        }
        attachDomRoot(e, t = "main") {
          const n = this.document.getRoot(t);
          n._name = e.tagName.toLowerCase();
          const i = {};
          for (const { name: s, value: a } of Array.from(e.attributes)) i[s] = a, s === "class" ? this._writer.addClass(a.split(" "), n) : this._writer.setAttribute(s, a, n);
          this._initialDomRootAttributes.set(e, i);
          const r = () => {
            this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n), n.isReadOnly ? this._writer.addClass("ck-read-only", n) : this._writer.removeClass("ck-read-only", n);
          };
          r(), this.domRoots.set(t, e), this.domConverter.bindElements(e, n), this._renderer.markToSync("children", n), this._renderer.markToSync("attributes", n), this._renderer.domDocuments.add(e.ownerDocument), n.on("change:children", (s, a) => this._renderer.markToSync("children", a)), n.on("change:attributes", (s, a) => this._renderer.markToSync("attributes", a)), n.on("change:text", (s, a) => this._renderer.markToSync("text", a)), n.on("change:isReadOnly", () => this.change(r)), n.on("change", () => {
            this._hasChangedSinceTheLastRendering = !0;
          });
          for (const s of this._observers.values()) s.observe(e, t);
        }
        detachDomRoot(e) {
          const t = this.domRoots.get(e);
          Array.from(t.attributes).forEach(({ name: i }) => t.removeAttribute(i));
          const n = this._initialDomRootAttributes.get(t);
          for (const i in n) t.setAttribute(i, n[i]);
          this.domRoots.delete(e), this.domConverter.unbindDomElement(t);
          for (const i of this._observers.values()) i.stopObserving(t);
        }
        getDomRoot(e = "main") {
          return this.domRoots.get(e);
        }
        addObserver(e) {
          let t = this._observers.get(e);
          if (t) return t;
          t = new e(this), this._observers.set(e, t);
          for (const [n, i] of this.domRoots) t.observe(i, n);
          return t.enable(), t;
        }
        getObserver(e) {
          return this._observers.get(e);
        }
        disableObservers() {
          for (const e of this._observers.values()) e.disable();
        }
        enableObservers() {
          for (const e of this._observers.values()) e.enable();
        }
        scrollToTheSelection({ alignToTop: e, forceScroll: t, viewportOffset: n = 20, ancestorOffset: i = 20 } = {}) {
          const r = this.document.selection.getFirstRange();
          r && function({ target: s, viewportOffset: a = 0, ancestorOffset: l = 0, alignToTop: c, forceScroll: d }) {
            const u = as(s);
            let g = u, p = null;
            for (; g; ) {
              let b;
              b = dw(g == u ? s : p), cw({ parent: b, getRect: () => Oc(s, g), alignToTop: c, ancestorOffset: l, forceScroll: d });
              const w = Oc(s, g);
              if (lw({ window: g, rect: w, viewportOffset: a, alignToTop: c, forceScroll: d }), g.parent != g) {
                if (p = g.frameElement, g = g.parent, !p) return;
              } else g = null;
            }
          }({ target: this.domConverter.viewRangeToDom(r), viewportOffset: n, ancestorOffset: i, alignToTop: e, forceScroll: t });
        }
        focus() {
          if (!this.document.isFocused) {
            const e = this.document.selection.editableElement;
            e && (this.domConverter.focus(e), this.forceRender());
          }
        }
        change(e) {
          if (this.isRenderingInProgress || this._postFixersInProgress) throw new T("cannot-change-view-tree", this);
          try {
            if (this._ongoingChange) return e(this._writer);
            this._ongoingChange = !0;
            const t = e(this._writer);
            return this._ongoingChange = !1, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0, this.document._callPostFixers(this._writer), this._postFixersInProgress = !1, this.fire("render")), t;
          } catch (t) {
            T.rethrowUnexpectedError(t, this);
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = !0, this.getObserver(Ls).flush(), this.change(() => {
          });
        }
        destroy() {
          for (const e of this._observers.values()) e.destroy();
          this.document.destroy(), this.stopListening();
        }
        createPositionAt(e, t) {
          return G._createAt(e, t);
        }
        createPositionAfter(e) {
          return G._createAfter(e);
        }
        createPositionBefore(e) {
          return G._createBefore(e);
        }
        createRange(e, t) {
          return new te(e, t);
        }
        createRangeOn(e) {
          return te._createOn(e);
        }
        createRangeIn(e) {
          return te._createIn(e);
        }
        createSelection(...e) {
          return new Ot(...e);
        }
        _disableRendering(e) {
          this._renderingDisabled = e, e == 0 && this.change(() => {
          });
        }
        _render() {
          this.isRenderingInProgress = !0, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = !1;
        }
      }
      class sn {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      class xn extends sn {
        constructor(e) {
          super(), this.parent = null, this._attrs = Ht(e);
        }
        get document() {
          return null;
        }
        get index() {
          let e;
          if (!this.parent) return null;
          if ((e = this.parent.getChildIndex(this)) === null) throw new T("model-node-not-found-in-parent", this);
          return e;
        }
        get startOffset() {
          let e;
          if (!this.parent) return null;
          if ((e = this.parent.getChildStartOffset(this)) === null) throw new T("model-node-not-found-in-parent", this);
          return e;
        }
        get offsetSize() {
          return 1;
        }
        get endOffset() {
          return this.parent ? this.startOffset + this.offsetSize : null;
        }
        get nextSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e + 1) || null;
        }
        get previousSibling() {
          const e = this.index;
          return e !== null && this.parent.getChild(e - 1) || null;
        }
        get root() {
          let e = this;
          for (; e.parent; ) e = e.parent;
          return e;
        }
        isAttached() {
          return this.parent !== null && this.root.isAttached();
        }
        getPath() {
          const e = [];
          let t = this;
          for (; t.parent; ) e.unshift(t.startOffset), t = t.parent;
          return e;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this : this.parent;
          for (; n; ) t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
        getCommonAncestor(e, t = {}) {
          const n = this.getAncestors(t), i = e.getAncestors(t);
          let r = 0;
          for (; n[r] == i[r] && n[r]; ) r++;
          return r === 0 ? null : n[r - 1];
        }
        isBefore(e) {
          if (this == e || this.root !== e.root) return !1;
          const t = this.getPath(), n = e.getPath(), i = ot(t, n);
          switch (i) {
            case "prefix":
              return !0;
            case "extension":
              return !1;
            default:
              return t[i] < n[i];
          }
        }
        isAfter(e) {
          return this != e && this.root === e.root && !this.isBefore(e);
        }
        hasAttribute(e) {
          return this._attrs.has(e);
        }
        getAttribute(e) {
          return this._attrs.get(e);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        toJSON() {
          const e = {};
          return this._attrs.size && (e.attributes = Array.from(this._attrs).reduce((t, n) => (t[n[0]] = n[1], t), {})), e;
        }
        _clone(e) {
          return new this.constructor(this._attrs);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _setAttribute(e, t) {
          this._attrs.set(e, t);
        }
        _setAttributesTo(e) {
          this._attrs = Ht(e);
        }
        _removeAttribute(e) {
          return this._attrs.delete(e);
        }
        _clearAttributes() {
          this._attrs.clear();
        }
      }
      xn.prototype.is = function(o) {
        return o === "node" || o === "model:node";
      };
      class $o {
        constructor(e) {
          this._nodes = [], e && this._insertNodes(0, e);
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]();
        }
        get length() {
          return this._nodes.length;
        }
        get maxOffset() {
          return this._nodes.reduce((e, t) => e + t.offsetSize, 0);
        }
        getNode(e) {
          return this._nodes[e] || null;
        }
        getNodeIndex(e) {
          const t = this._nodes.indexOf(e);
          return t == -1 ? null : t;
        }
        getNodeStartOffset(e) {
          const t = this.getNodeIndex(e);
          return t === null ? null : this._nodes.slice(0, t).reduce((n, i) => n + i.offsetSize, 0);
        }
        indexToOffset(e) {
          if (e == this._nodes.length) return this.maxOffset;
          const t = this._nodes[e];
          if (!t) throw new T("model-nodelist-index-out-of-bounds", this);
          return this.getNodeStartOffset(t);
        }
        offsetToIndex(e) {
          let t = 0;
          for (const n of this._nodes) {
            if (e >= t && e < t + n.offsetSize) return this.getNodeIndex(n);
            t += n.offsetSize;
          }
          if (t != e) throw new T("model-nodelist-offset-out-of-bounds", this, { offset: e, nodeList: this });
          return this.length;
        }
        _insertNodes(e, t) {
          for (const n of t) if (!(n instanceof xn)) throw new T("model-nodelist-insertnodes-not-node", this);
          this._nodes = function(n, i, r, s) {
            if (Math.max(i.length, n.length) > 1e4) return n.slice(0, r).concat(i).concat(n.slice(r + s, n.length));
            {
              const a = Array.from(n);
              return a.splice(r, s, ...i), a;
            }
          }(this._nodes, Array.from(t), e, 0);
        }
        _removeNodes(e, t = 1) {
          return this._nodes.splice(e, t);
        }
        toJSON() {
          return this._nodes.map((e) => e.toJSON());
        }
      }
      class ye extends xn {
        constructor(e, t) {
          super(t), this._data = e || "";
        }
        get offsetSize() {
          return this.data.length;
        }
        get data() {
          return this._data;
        }
        toJSON() {
          const e = super.toJSON();
          return e.data = this.data, e;
        }
        _clone() {
          return new ye(this.data, this.getAttributes());
        }
        static fromJSON(e) {
          return new ye(e.data, e.attributes);
        }
      }
      ye.prototype.is = function(o) {
        return o === "$text" || o === "model:$text" || o === "text" || o === "model:text" || o === "node" || o === "model:node";
      };
      class xt extends sn {
        constructor(e, t, n) {
          if (super(), this.textNode = e, t < 0 || t > e.offsetSize) throw new T("model-textproxy-wrong-offsetintext", this);
          if (n < 0 || t + n > e.offsetSize) throw new T("model-textproxy-wrong-length", this);
          this.data = e.data.substring(t, t + n), this.offsetInText = t;
        }
        get startOffset() {
          return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
        }
        get offsetSize() {
          return this.data.length;
        }
        get endOffset() {
          return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        getPath() {
          const e = this.textNode.getPath();
          return e.length > 0 && (e[e.length - 1] += this.offsetInText), e;
        }
        getAncestors(e = {}) {
          const t = [];
          let n = e.includeSelf ? this : this.parent;
          for (; n; ) t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
          return t;
        }
        hasAttribute(e) {
          return this.textNode.hasAttribute(e);
        }
        getAttribute(e) {
          return this.textNode.getAttribute(e);
        }
        getAttributes() {
          return this.textNode.getAttributes();
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys();
        }
      }
      xt.prototype.is = function(o) {
        return o === "$textProxy" || o === "model:$textProxy" || o === "textProxy" || o === "model:textProxy";
      };
      class Ee extends xn {
        constructor(e, t, n) {
          super(t), this._children = new $o(), this.name = e, n && this._insertChild(0, n);
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        getChild(e) {
          return this._children.getNode(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(e) {
          return this._children.getNodeIndex(e);
        }
        getChildStartOffset(e) {
          return this._children.getNodeStartOffset(e);
        }
        offsetToIndex(e) {
          return this._children.offsetToIndex(e);
        }
        getNodeByPath(e) {
          let t = this;
          for (const n of e) t = t.getChild(t.offsetToIndex(n));
          return t;
        }
        findAncestor(e, t = {}) {
          let n = t.includeSelf ? this : this.parent;
          for (; n; ) {
            if (n.name === e) return n;
            n = n.parent;
          }
          return null;
        }
        toJSON() {
          const e = super.toJSON();
          if (e.name = this.name, this._children.length > 0) {
            e.children = [];
            for (const t of this._children) e.children.push(t.toJSON());
          }
          return e;
        }
        _clone(e = !1) {
          const t = e ? Array.from(this._children).map((n) => n._clone(!0)) : void 0;
          return new Ee(this.name, this.getAttributes(), t);
        }
        _appendChild(e) {
          this._insertChild(this.childCount, e);
        }
        _insertChild(e, t) {
          const n = function(i) {
            return typeof i == "string" ? [new ye(i)] : (gt(i) || (i = [i]), Array.from(i).map((r) => typeof r == "string" ? new ye(r) : r instanceof xt ? new ye(r.data, r.getAttributes()) : r));
          }(t);
          for (const i of n) i.parent !== null && i._remove(), i.parent = this;
          this._children._insertNodes(e, n);
        }
        _removeChildren(e, t = 1) {
          const n = this._children._removeNodes(e, t);
          for (const i of n) i.parent = null;
          return n;
        }
        static fromJSON(e) {
          let t;
          if (e.children) {
            t = [];
            for (const n of e.children) n.name ? t.push(Ee.fromJSON(n)) : t.push(ye.fromJSON(n));
          }
          return new Ee(e.name, e.attributes, t);
        }
      }
      Ee.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "element" || o === "model:element") : o === "element" || o === "model:element" || o === "node" || o === "model:node";
      };
      class Ft {
        constructor(e) {
          if (!e || !e.boundaries && !e.startPosition) throw new T("model-tree-walker-no-start-position", null);
          const t = e.direction || "forward";
          if (t != "forward" && t != "backward") throw new T("model-tree-walker-unknown-direction", e, { direction: t });
          this.direction = t, this.boundaries = e.boundaries || null, e.startPosition ? this._position = e.startPosition.clone() : this._position = U._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(e) {
          let t, n, i, r;
          do
            i = this.position, r = this._visitedParent, { done: t, value: n } = this.next();
          while (!t && e(n));
          t || (this._position = i, this._visitedParent = r);
        }
        next() {
          return this.direction == "forward" ? this._next() : this._previous();
        }
        _next() {
          const e = this.position, t = this.position.clone(), n = this._visitedParent;
          if (n.parent === null && t.offset === n.maxOffset) return { done: !0, value: void 0 };
          if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) return { done: !0, value: void 0 };
          const i = Ho(t, n), r = i || au(t, n, i);
          if (r instanceof Ee) return this.shallow ? t.offset++ : (t.path.push(0), this._visitedParent = r), this._position = t, Sn("elementStart", r, e, t, 1);
          if (r instanceof ye) {
            let s;
            if (this.singleCharacters) s = 1;
            else {
              let c = r.endOffset;
              this._boundaryEndParent == n && this.boundaries.end.offset < c && (c = this.boundaries.end.offset), s = c - t.offset;
            }
            const a = t.offset - r.startOffset, l = new xt(r, a, s);
            return t.offset += s, this._position = t, Sn("text", l, e, t, s);
          }
          return t.path.pop(), t.offset++, this._position = t, this._visitedParent = n.parent, this.ignoreElementEnd ? this._next() : Sn("elementEnd", n, e, t);
        }
        _previous() {
          const e = this.position, t = this.position.clone(), n = this._visitedParent;
          if (n.parent === null && t.offset === 0) return { done: !0, value: void 0 };
          if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) return { done: !0, value: void 0 };
          const i = t.parent, r = Ho(t, i), s = r || lu(t, i, r);
          if (s instanceof Ee) return t.offset--, this.shallow ? (this._position = t, Sn("elementStart", s, e, t, 1)) : (t.path.push(s.maxOffset), this._position = t, this._visitedParent = s, this.ignoreElementEnd ? this._previous() : Sn("elementEnd", s, e, t));
          if (s instanceof ye) {
            let a;
            if (this.singleCharacters) a = 1;
            else {
              let d = s.startOffset;
              this._boundaryStartParent == n && this.boundaries.start.offset > d && (d = this.boundaries.start.offset), a = t.offset - d;
            }
            const l = t.offset - s.startOffset, c = new xt(s, l - a, a);
            return t.offset -= a, this._position = t, Sn("text", c, e, t, a);
          }
          return t.path.pop(), this._position = t, this._visitedParent = n.parent, Sn("elementStart", n, e, t, 1);
        }
      }
      function Sn(o, e, t, n, i) {
        return { done: !1, value: { type: o, item: e, previousPosition: t, nextPosition: n, length: i } };
      }
      class U extends sn {
        constructor(e, t, n = "toNone") {
          if (super(), !e.is("element") && !e.is("documentFragment")) throw new T("model-position-root-invalid", e);
          if (!(t instanceof Array) || t.length === 0) throw new T("model-position-path-incorrect-format", e, { path: t });
          e.is("rootElement") ? t = t.slice() : (t = [...e.getPath(), ...t], e = e.root), this.root = e, this.path = t, this.stickiness = n;
        }
        get offset() {
          return this.path[this.path.length - 1];
        }
        set offset(e) {
          this.path[this.path.length - 1] = e;
        }
        get parent() {
          let e = this.root;
          for (let t = 0; t < this.path.length - 1; t++) if (e = e.getChild(e.offsetToIndex(this.path[t])), !e) throw new T("model-position-path-incorrect", this, { position: this });
          if (e.is("$text")) throw new T("model-position-path-incorrect", this, { position: this });
          return e;
        }
        get index() {
          return this.parent.offsetToIndex(this.offset);
        }
        get textNode() {
          return Ho(this, this.parent);
        }
        get nodeAfter() {
          const e = this.parent;
          return au(this, e, Ho(this, e));
        }
        get nodeBefore() {
          const e = this.parent;
          return lu(this, e, Ho(this, e));
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset;
        }
        compareWith(e) {
          if (this.root != e.root) return "different";
          const t = ot(this.path, e.path);
          switch (t) {
            case "same":
              return "same";
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return this.path[t] < e.path[t] ? "before" : "after";
          }
        }
        getLastMatchingPosition(e, t = {}) {
          t.startPosition = this;
          const n = new Ft(t);
          return n.skip(e), n.position;
        }
        getParentPath() {
          return this.path.slice(0, -1);
        }
        getAncestors() {
          const e = this.parent;
          return e.is("documentFragment") ? [e] : e.getAncestors({ includeSelf: !0 });
        }
        findAncestor(e) {
          const t = this.parent;
          return t.is("element") ? t.findAncestor(e, { includeSelf: !0 }) : null;
        }
        getCommonPath(e) {
          if (this.root != e.root) return [];
          const t = ot(this.path, e.path), n = typeof t == "string" ? Math.min(this.path.length, e.path.length) : t;
          return this.path.slice(0, n);
        }
        getCommonAncestor(e) {
          const t = this.getAncestors(), n = e.getAncestors();
          let i = 0;
          for (; t[i] == n[i] && t[i]; ) i++;
          return i === 0 ? null : t[i - 1];
        }
        getShiftedBy(e) {
          const t = this.clone(), n = t.offset + e;
          return t.offset = n < 0 ? 0 : n, t;
        }
        isAfter(e) {
          return this.compareWith(e) == "after";
        }
        isBefore(e) {
          return this.compareWith(e) == "before";
        }
        isEqual(e) {
          return this.compareWith(e) == "same";
        }
        isTouching(e) {
          if (this.root !== e.root) return !1;
          const t = Math.min(this.path.length, e.path.length);
          for (let n = 0; n < t; n++) {
            const i = this.path[n] - e.path[n];
            if (i < -1 || i > 1) return !1;
            if (i === 1) return cu(e, this, n);
            if (i === -1) return cu(this, e, n);
          }
          return this.path.length === e.path.length || (this.path.length > e.path.length ? js(this.path, t) : js(e.path, t));
        }
        hasSameParentAs(e) {
          return this.root !== e.root ? !1 : ot(this.getParentPath(), e.getParentPath()) == "same";
        }
        getTransformedByOperation(e) {
          let t;
          switch (e.type) {
            case "insert":
              t = this._getTransformedByInsertOperation(e);
              break;
            case "move":
            case "remove":
            case "reinsert":
              t = this._getTransformedByMoveOperation(e);
              break;
            case "split":
              t = this._getTransformedBySplitOperation(e);
              break;
            case "merge":
              t = this._getTransformedByMergeOperation(e);
              break;
            default:
              t = U._createAt(this);
          }
          return t;
        }
        _getTransformedByInsertOperation(e) {
          return this._getTransformedByInsertion(e.position, e.howMany);
        }
        _getTransformedByMoveOperation(e) {
          return this._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
        }
        _getTransformedBySplitOperation(e) {
          const t = e.movedRange;
          return t.containsPosition(this) || t.start.isEqual(this) && this.stickiness == "toNext" ? this._getCombined(e.splitPosition, e.moveTargetPosition) : e.graveyardPosition ? this._getTransformedByMove(e.graveyardPosition, e.insertionPosition, 1) : this._getTransformedByInsertion(e.insertionPosition, 1);
        }
        _getTransformedByMergeOperation(e) {
          const t = e.movedRange;
          let n;
          return t.containsPosition(this) || t.start.isEqual(this) ? (n = this._getCombined(e.sourcePosition, e.targetPosition), e.sourcePosition.isBefore(e.targetPosition) && (n = n._getTransformedByDeletion(e.deletionPosition, 1))) : n = this.isEqual(e.deletionPosition) ? U._createAt(e.deletionPosition) : this._getTransformedByMove(e.deletionPosition, e.graveyardPosition, 1), n;
        }
        _getTransformedByDeletion(e, t) {
          const n = U._createAt(this);
          if (this.root != e.root) return n;
          if (ot(e.getParentPath(), this.getParentPath()) == "same") {
            if (e.offset < this.offset) {
              if (e.offset + t > this.offset) return null;
              n.offset -= t;
            }
          } else if (ot(e.getParentPath(), this.getParentPath()) == "prefix") {
            const i = e.path.length - 1;
            if (e.offset <= this.path[i]) {
              if (e.offset + t > this.path[i]) return null;
              n.path[i] -= t;
            }
          }
          return n;
        }
        _getTransformedByInsertion(e, t) {
          const n = U._createAt(this);
          if (this.root != e.root) return n;
          if (ot(e.getParentPath(), this.getParentPath()) == "same") (e.offset < this.offset || e.offset == this.offset && this.stickiness != "toPrevious") && (n.offset += t);
          else if (ot(e.getParentPath(), this.getParentPath()) == "prefix") {
            const i = e.path.length - 1;
            e.offset <= this.path[i] && (n.path[i] += t);
          }
          return n;
        }
        _getTransformedByMove(e, t, n) {
          if (t = t._getTransformedByDeletion(e, n), e.isEqual(t)) return U._createAt(this);
          const i = this._getTransformedByDeletion(e, n);
          return i === null || e.isEqual(this) && this.stickiness == "toNext" || e.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious" ? this._getCombined(e, t) : i._getTransformedByInsertion(t, n);
        }
        _getCombined(e, t) {
          const n = e.path.length - 1, i = U._createAt(t);
          return i.stickiness = this.stickiness, i.offset = i.offset + this.path[n] - e.offset, i.path = [...i.path, ...this.path.slice(n + 1)], i;
        }
        toJSON() {
          return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness };
        }
        clone() {
          return new this.constructor(this.root, this.path, this.stickiness);
        }
        static _createAt(e, t, n = "toNone") {
          if (e instanceof U) return new U(e.root, e.path, e.stickiness);
          {
            const i = e;
            if (t == "end") t = i.maxOffset;
            else {
              if (t == "before") return this._createBefore(i, n);
              if (t == "after") return this._createAfter(i, n);
              if (t !== 0 && !t) throw new T("model-createpositionat-offset-required", [this, e]);
            }
            if (!i.is("element") && !i.is("documentFragment")) throw new T("model-position-parent-incorrect", [this, e]);
            const r = i.getPath();
            return r.push(t), new this(i.root, r, n);
          }
        }
        static _createAfter(e, t) {
          if (!e.parent) throw new T("model-position-after-root", [this, e], { root: e });
          return this._createAt(e.parent, e.endOffset, t);
        }
        static _createBefore(e, t) {
          if (!e.parent) throw new T("model-position-before-root", e, { root: e });
          return this._createAt(e.parent, e.startOffset, t);
        }
        static fromJSON(e, t) {
          if (e.root === "$graveyard") {
            const n = new U(t.graveyard, e.path);
            return n.stickiness = e.stickiness, n;
          }
          if (!t.getRoot(e.root)) throw new T("model-position-fromjson-no-root", t, { rootName: e.root });
          return new U(t.getRoot(e.root), e.path, e.stickiness);
        }
      }
      function Ho(o, e) {
        const t = e.getChild(e.offsetToIndex(o.offset));
        return t && t.is("$text") && t.startOffset < o.offset ? t : null;
      }
      function au(o, e, t) {
        return t !== null ? null : e.getChild(e.offsetToIndex(o.offset));
      }
      function lu(o, e, t) {
        return t !== null ? null : e.getChild(e.offsetToIndex(o.offset) - 1);
      }
      function cu(o, e, t) {
        return t + 1 !== o.path.length && !!js(e.path, t + 1) && !!function(n, i) {
          let r = n.parent, s = n.path.length - 1, a = 0;
          for (; s >= i; ) {
            if (n.path[s] + a !== r.maxOffset) return !1;
            a = 1, s--, r = r.parent;
          }
          return !0;
        }(o, t + 1);
      }
      function js(o, e) {
        for (; e < o.length; ) {
          if (o[e] !== 0) return !1;
          e++;
        }
        return !0;
      }
      U.prototype.is = function(o) {
        return o === "position" || o === "model:position";
      };
      class V extends sn {
        constructor(e, t) {
          super(), this.start = U._createAt(e), this.end = t ? U._createAt(t) : U._createAt(e), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
        }
        *[Symbol.iterator]() {
          yield* new Ft({ boundaries: this, ignoreElementEnd: !0 });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return ot(this.start.getParentPath(), this.end.getParentPath()) == "same";
        }
        get root() {
          return this.start.root;
        }
        containsPosition(e) {
          return e.isAfter(this.start) && e.isBefore(this.end);
        }
        containsRange(e, t = !1) {
          e.isCollapsed && (t = !1);
          const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start), i = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
          return n && i;
        }
        containsItem(e) {
          const t = U._createBefore(e);
          return this.containsPosition(t) || this.start.isEqual(t);
        }
        isEqual(e) {
          return this.start.isEqual(e.start) && this.end.isEqual(e.end);
        }
        isIntersecting(e) {
          return this.start.isBefore(e.end) && this.end.isAfter(e.start);
        }
        getDifference(e) {
          const t = [];
          return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new V(this.start, e.start)), this.containsPosition(e.end) && t.push(new V(e.end, this.end))) : t.push(new V(this.start, this.end)), t;
        }
        getIntersection(e) {
          if (this.isIntersecting(e)) {
            let t = this.start, n = this.end;
            return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new V(t, n);
          }
          return null;
        }
        getJoined(e, t = !1) {
          let n = this.isIntersecting(e);
          if (n || (n = this.start.isBefore(e.start) ? t ? this.end.isTouching(e.start) : this.end.isEqual(e.start) : t ? e.end.isTouching(this.start) : e.end.isEqual(this.start)), !n) return null;
          let i = this.start, r = this.end;
          return e.start.isBefore(i) && (i = e.start), e.end.isAfter(r) && (r = e.end), new V(i, r);
        }
        getMinimalFlatRanges() {
          const e = [], t = this.start.getCommonPath(this.end).length, n = U._createAt(this.start);
          let i = n.parent;
          for (; n.path.length > t + 1; ) {
            const r = i.maxOffset - n.offset;
            r !== 0 && e.push(new V(n, n.getShiftedBy(r))), n.path = n.path.slice(0, -1), n.offset++, i = i.parent;
          }
          for (; n.path.length <= this.end.path.length; ) {
            const r = this.end.path[n.path.length - 1], s = r - n.offset;
            s !== 0 && e.push(new V(n, n.getShiftedBy(s))), n.offset = r, n.path.push(0);
          }
          return e;
        }
        getWalker(e = {}) {
          return e.boundaries = this, new Ft(e);
        }
        *getItems(e = {}) {
          e.boundaries = this, e.ignoreElementEnd = !0;
          const t = new Ft(e);
          for (const n of t) yield n.item;
        }
        *getPositions(e = {}) {
          e.boundaries = this;
          const t = new Ft(e);
          yield t.position;
          for (const n of t) yield n.nextPosition;
        }
        getTransformedByOperation(e) {
          switch (e.type) {
            case "insert":
              return this._getTransformedByInsertOperation(e);
            case "move":
            case "remove":
            case "reinsert":
              return this._getTransformedByMoveOperation(e);
            case "split":
              return [this._getTransformedBySplitOperation(e)];
            case "merge":
              return [this._getTransformedByMergeOperation(e)];
          }
          return [new V(this.start, this.end)];
        }
        getTransformedByOperations(e) {
          const t = [new V(this.start, this.end)];
          for (const n of e) for (let i = 0; i < t.length; i++) {
            const r = t[i].getTransformedByOperation(n);
            t.splice(i, 1, ...r), i += r.length - 1;
          }
          for (let n = 0; n < t.length; n++) {
            const i = t[n];
            for (let r = n + 1; r < t.length; r++) {
              const s = t[r];
              (i.containsRange(s) || s.containsRange(i) || i.isEqual(s)) && t.splice(r, 1);
            }
          }
          return t;
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) return null;
          const e = this.start.nodeAfter, t = this.end.nodeBefore;
          return e && e.is("element") && e === t ? e : null;
        }
        toJSON() {
          return { start: this.start.toJSON(), end: this.end.toJSON() };
        }
        clone() {
          return new this.constructor(this.start, this.end);
        }
        _getTransformedByInsertOperation(e, t = !1) {
          return this._getTransformedByInsertion(e.position, e.howMany, t);
        }
        _getTransformedByMoveOperation(e, t = !1) {
          const n = e.sourcePosition, i = e.howMany, r = e.targetPosition;
          return this._getTransformedByMove(n, r, i, t);
        }
        _getTransformedBySplitOperation(e) {
          const t = this.start._getTransformedBySplitOperation(e);
          let n = this.end._getTransformedBySplitOperation(e);
          return this.end.isEqual(e.insertionPosition) && (n = this.end.getShiftedBy(1)), t.root != n.root && (n = this.end.getShiftedBy(-1)), new V(t, n);
        }
        _getTransformedByMergeOperation(e) {
          if (this.start.isEqual(e.targetPosition) && this.end.isEqual(e.deletionPosition)) return new V(this.start);
          let t = this.start._getTransformedByMergeOperation(e), n = this.end._getTransformedByMergeOperation(e);
          return t.root != n.root && (n = this.end.getShiftedBy(-1)), t.isAfter(n) ? (e.sourcePosition.isBefore(e.targetPosition) ? (t = U._createAt(n), t.offset = 0) : (e.deletionPosition.isEqual(t) || (n = e.deletionPosition), t = e.targetPosition), new V(t, n)) : new V(t, n);
        }
        _getTransformedByInsertion(e, t, n = !1) {
          if (n && this.containsPosition(e)) return [new V(this.start, e), new V(e.getShiftedBy(t), this.end._getTransformedByInsertion(e, t))];
          {
            const i = new V(this.start, this.end);
            return i.start = i.start._getTransformedByInsertion(e, t), i.end = i.end._getTransformedByInsertion(e, t), [i];
          }
        }
        _getTransformedByMove(e, t, n, i = !1) {
          if (this.isCollapsed) {
            const u = this.start._getTransformedByMove(e, t, n);
            return [new V(u)];
          }
          const r = V._createFromPositionAndShift(e, n), s = t._getTransformedByDeletion(e, n);
          if (this.containsPosition(t) && !i && (r.containsPosition(this.start) || r.containsPosition(this.end))) {
            const u = this.start._getTransformedByMove(e, t, n), g = this.end._getTransformedByMove(e, t, n);
            return [new V(u, g)];
          }
          let a;
          const l = this.getDifference(r);
          let c = null;
          const d = this.getIntersection(r);
          if (l.length == 1 ? c = new V(l[0].start._getTransformedByDeletion(e, n), l[0].end._getTransformedByDeletion(e, n)) : l.length == 2 && (c = new V(this.start, this.end._getTransformedByDeletion(e, n))), a = c ? c._getTransformedByInsertion(s, n, d !== null || i) : [], d) {
            const u = new V(d.start._getCombined(r.start, s), d.end._getCombined(r.start, s));
            a.length == 2 ? a.splice(1, 0, u) : a.push(u);
          }
          return a;
        }
        _getTransformedByDeletion(e, t) {
          let n = this.start._getTransformedByDeletion(e, t), i = this.end._getTransformedByDeletion(e, t);
          return n == null && i == null ? null : (n == null && (n = e), i == null && (i = e), new V(n, i));
        }
        static _createFromPositionAndShift(e, t) {
          const n = e, i = e.getShiftedBy(t);
          return t > 0 ? new this(n, i) : new this(i, n);
        }
        static _createIn(e) {
          return new this(U._createAt(e, 0), U._createAt(e, e.maxOffset));
        }
        static _createOn(e) {
          return this._createFromPositionAndShift(U._createBefore(e), e.offsetSize);
        }
        static _createFromRanges(e) {
          if (e.length === 0) throw new T("range-create-from-ranges-empty-array", null);
          if (e.length == 1) return e[0].clone();
          const t = e[0];
          e.sort((r, s) => r.start.isAfter(s.start) ? 1 : -1);
          const n = e.indexOf(t), i = new this(t.start, t.end);
          if (n > 0) for (let r = n - 1; e[r].end.isEqual(i.start); r++) i.start = U._createAt(e[r].start);
          for (let r = n + 1; r < e.length && e[r].start.isEqual(i.end); r++) i.end = U._createAt(e[r].end);
          return i;
        }
        static fromJSON(e, t) {
          return new this(U.fromJSON(e.start, t), U.fromJSON(e.end, t));
        }
      }
      V.prototype.is = function(o) {
        return o === "range" || o === "model:range";
      };
      class du extends _e() {
        constructor() {
          super(), this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelLengthCallbacks = /* @__PURE__ */ new Map(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._deferredBindingRemovals = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this.on("modelToViewPosition", (e, t) => {
            if (t.viewPosition) return;
            const n = this._modelToViewMapping.get(t.modelPosition.parent);
            if (!n) throw new T("mapping-model-position-view-parent-not-found", this, { modelPosition: t.modelPosition });
            t.viewPosition = this.findPositionIn(n, t.modelPosition.offset);
          }, { priority: "low" }), this.on("viewToModelPosition", (e, t) => {
            if (t.modelPosition) return;
            const n = this.findMappedViewAncestor(t.viewPosition), i = this._viewToModelMapping.get(n), r = this._toModelOffset(t.viewPosition.parent, t.viewPosition.offset, n);
            t.modelPosition = U._createAt(i, r);
          }, { priority: "low" });
        }
        bindElements(e, t) {
          this._modelToViewMapping.set(e, t), this._viewToModelMapping.set(t, e);
        }
        unbindViewElement(e, t = {}) {
          const n = this.toModelElement(e);
          if (this._elementToMarkerNames.has(e)) for (const i of this._elementToMarkerNames.get(e)) this._unboundMarkerNames.add(i);
          t.defer ? this._deferredBindingRemovals.set(e, e.root) : (this._viewToModelMapping.delete(e), this._modelToViewMapping.get(n) == e && this._modelToViewMapping.delete(n));
        }
        unbindModelElement(e) {
          const t = this.toViewElement(e);
          this._modelToViewMapping.delete(e), this._viewToModelMapping.get(t) == e && this._viewToModelMapping.delete(t);
        }
        bindElementToMarker(e, t) {
          const n = this._markerNameToElements.get(t) || /* @__PURE__ */ new Set();
          n.add(e);
          const i = this._elementToMarkerNames.get(e) || /* @__PURE__ */ new Set();
          i.add(t), this._markerNameToElements.set(t, n), this._elementToMarkerNames.set(e, i);
        }
        unbindElementFromMarkerName(e, t) {
          const n = this._markerNameToElements.get(t);
          n && (n.delete(e), n.size == 0 && this._markerNameToElements.delete(t));
          const i = this._elementToMarkerNames.get(e);
          i && (i.delete(t), i.size == 0 && this._elementToMarkerNames.delete(e));
        }
        flushUnboundMarkerNames() {
          const e = Array.from(this._unboundMarkerNames);
          return this._unboundMarkerNames.clear(), e;
        }
        flushDeferredBindings() {
          for (const [e, t] of this._deferredBindingRemovals) e.root == t && this.unbindViewElement(e);
          this._deferredBindingRemovals = /* @__PURE__ */ new Map();
        }
        clearBindings() {
          this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this._deferredBindingRemovals = /* @__PURE__ */ new Map();
        }
        toModelElement(e) {
          return this._viewToModelMapping.get(e);
        }
        toViewElement(e) {
          return this._modelToViewMapping.get(e);
        }
        toModelRange(e) {
          return new V(this.toModelPosition(e.start), this.toModelPosition(e.end));
        }
        toViewRange(e) {
          return new te(this.toViewPosition(e.start), this.toViewPosition(e.end));
        }
        toModelPosition(e) {
          const t = { viewPosition: e, mapper: this };
          return this.fire("viewToModelPosition", t), t.modelPosition;
        }
        toViewPosition(e, t = {}) {
          const n = { modelPosition: e, mapper: this, isPhantom: t.isPhantom };
          return this.fire("modelToViewPosition", n), n.viewPosition;
        }
        markerNameToElements(e) {
          const t = this._markerNameToElements.get(e);
          if (!t) return null;
          const n = /* @__PURE__ */ new Set();
          for (const i of t) if (i.is("attributeElement")) for (const r of i.getElementsWithSameId()) n.add(r);
          else n.add(i);
          return n;
        }
        registerViewToModelLength(e, t) {
          this._viewToModelLengthCallbacks.set(e, t);
        }
        findMappedViewAncestor(e) {
          let t = e.parent;
          for (; !this._viewToModelMapping.has(t); ) t = t.parent;
          return t;
        }
        _toModelOffset(e, t, n) {
          if (n != e)
            return this._toModelOffset(e.parent, e.index, n) + this._toModelOffset(e, t, e);
          if (e.is("$text")) return t;
          let i = 0;
          for (let r = 0; r < t; r++) i += this.getModelLength(e.getChild(r));
          return i;
        }
        getModelLength(e) {
          if (this._viewToModelLengthCallbacks.get(e.name))
            return this._viewToModelLengthCallbacks.get(e.name)(e);
          if (this._viewToModelMapping.has(e)) return 1;
          if (e.is("$text")) return e.data.length;
          if (e.is("uiElement")) return 0;
          {
            let t = 0;
            for (const n of e.getChildren()) t += this.getModelLength(n);
            return t;
          }
        }
        findPositionIn(e, t) {
          let n, i = 0, r = 0, s = 0;
          if (e.is("$text")) return new G(e, t);
          for (; r < t; ) n = e.getChild(s), i = this.getModelLength(n), r += i, s++;
          return r == t ? this._moveViewPositionToTextNode(new G(e, s)) : this.findPositionIn(n, t - (r - i));
        }
        _moveViewPositionToTextNode(e) {
          const t = e.nodeBefore, n = e.nodeAfter;
          return t instanceof Ce ? new G(t, t.data.length) : n instanceof Ce ? new G(n, 0) : e;
        }
      }
      class d0 {
        constructor() {
          this._consumable = /* @__PURE__ */ new Map(), this._textProxyRegistry = /* @__PURE__ */ new Map();
        }
        add(e, t) {
          t = Li(t), e instanceof xt && (e = this._getSymbolForTextProxy(e)), this._consumable.has(e) || this._consumable.set(e, /* @__PURE__ */ new Map()), this._consumable.get(e).set(t, !0);
        }
        consume(e, t) {
          return t = Li(t), e instanceof xt && (e = this._getSymbolForTextProxy(e)), !!this.test(e, t) && (this._consumable.get(e).set(t, !1), !0);
        }
        test(e, t) {
          t = Li(t), e instanceof xt && (e = this._getSymbolForTextProxy(e));
          const n = this._consumable.get(e);
          if (n === void 0) return null;
          const i = n.get(t);
          return i === void 0 ? null : i;
        }
        revert(e, t) {
          t = Li(t), e instanceof xt && (e = this._getSymbolForTextProxy(e));
          const n = this.test(e, t);
          return n === !1 ? (this._consumable.get(e).set(t, !0), !0) : n !== !0 && null;
        }
        verifyAllConsumed(e) {
          const t = [];
          for (const [n, i] of this._consumable) for (const [r, s] of i) {
            const a = r.split(":")[0];
            s && e == a && t.push({ event: r, item: n.name || n.description });
          }
          if (t.length) throw new T("conversion-model-consumable-not-consumed", null, { items: t });
        }
        _getSymbolForTextProxy(e) {
          let t = null;
          const n = this._textProxyRegistry.get(e.startOffset);
          if (n) {
            const i = n.get(e.endOffset);
            i && (t = i.get(e.parent));
          }
          return t || (t = this._addSymbolForTextProxy(e)), t;
        }
        _addSymbolForTextProxy(e) {
          const t = e.startOffset, n = e.endOffset, i = e.parent, r = Symbol("$textProxy:" + e.data);
          let s, a;
          return s = this._textProxyRegistry.get(t), s || (s = /* @__PURE__ */ new Map(), this._textProxyRegistry.set(t, s)), a = s.get(n), a || (a = /* @__PURE__ */ new Map(), s.set(n, a)), a.set(i, r), r;
        }
      }
      function Li(o) {
        const e = o.split(":");
        return e[0] == "insert" ? e[0] : e[0] == "addMarker" || e[0] == "removeMarker" ? o : e.length > 1 ? e[0] + ":" + e[1] : e[0];
      }
      var u0 = Object.defineProperty, h0 = Object.defineProperties, g0 = Object.getOwnPropertyDescriptors, uu = Object.getOwnPropertySymbols, m0 = Object.prototype.hasOwnProperty, p0 = Object.prototype.propertyIsEnumerable, hu = (o, e, t) => e in o ? u0(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, $s = (o, e) => {
        for (var t in e || (e = {})) m0.call(e, t) && hu(o, t, e[t]);
        if (uu) for (var t of uu(e)) p0.call(e, t) && hu(o, t, e[t]);
        return o;
      }, gu = (o, e) => h0(o, g0(e));
      class mu extends _e() {
        constructor(e) {
          super(), this._conversionApi = $s({ dispatcher: this }, e), this._firedEventsMap = /* @__PURE__ */ new WeakMap();
        }
        convertChanges(e, t, n) {
          const i = this._createConversionApi(n, e.getRefreshedItems());
          for (const s of e.getMarkersToRemove()) this._convertMarkerRemove(s.name, s.range, i);
          const r = this._reduceChanges(e.getChanges());
          for (const s of r) s.type === "insert" ? this._convertInsert(V._createFromPositionAndShift(s.position, s.length), i) : s.type === "reinsert" ? this._convertReinsert(V._createFromPositionAndShift(s.position, s.length), i) : s.type === "remove" ? this._convertRemove(s.position, s.length, s.name, i) : this._convertAttribute(s.range, s.attributeKey, s.attributeOldValue, s.attributeNewValue, i);
          for (const s of i.mapper.flushUnboundMarkerNames()) {
            const a = t.get(s).getRange();
            this._convertMarkerRemove(s, a, i), this._convertMarkerAdd(s, a, i);
          }
          for (const s of e.getMarkersToAdd()) this._convertMarkerAdd(s.name, s.range, i);
          i.mapper.flushDeferredBindings(), i.consumable.verifyAllConsumed("insert");
        }
        convert(e, t, n, i = {}) {
          const r = this._createConversionApi(n, void 0, i);
          this._convertInsert(e, r);
          for (const [s, a] of t) this._convertMarkerAdd(s, a, r);
          r.consumable.verifyAllConsumed("insert");
        }
        convertSelection(e, t, n) {
          const i = Array.from(t.getMarkersAtPosition(e.getFirstPosition())), r = this._createConversionApi(n);
          if (this._addConsumablesForSelection(r.consumable, e, i), this.fire("selection", { selection: e }, r), e.isCollapsed) {
            for (const s of i) {
              const a = s.getRange();
              if (!f0(e.getFirstPosition(), s, r.mapper)) continue;
              const l = { item: e, markerName: s.name, markerRange: a };
              r.consumable.test(e, "addMarker:" + s.name) && this.fire(`addMarker:${s.name}`, l, r);
            }
            for (const s of e.getAttributeKeys()) {
              const a = { item: e, range: e.getFirstRange(), attributeKey: s, attributeOldValue: null, attributeNewValue: e.getAttribute(s) };
              r.consumable.test(e, "attribute:" + a.attributeKey) && this.fire(`attribute:${a.attributeKey}:$text`, a, r);
            }
          }
        }
        _convertInsert(e, t, n = {}) {
          n.doNotAddConsumables || this._addConsumablesForInsert(t.consumable, Array.from(e));
          for (const i of Array.from(e.getWalker({ shallow: !0 })).map(pu)) this._testAndFire("insert", i, t);
        }
        _convertRemove(e, t, n, i) {
          this.fire(`remove:${n}`, { position: e, length: t }, i);
        }
        _convertAttribute(e, t, n, i, r) {
          this._addConsumablesForRange(r.consumable, e, `attribute:${t}`);
          for (const s of e) {
            const a = { item: s.item, range: V._createFromPositionAndShift(s.previousPosition, s.length), attributeKey: t, attributeOldValue: n, attributeNewValue: i };
            this._testAndFire(`attribute:${t}`, a, r);
          }
        }
        _convertReinsert(e, t) {
          const n = Array.from(e.getWalker({ shallow: !0 }));
          this._addConsumablesForInsert(t.consumable, n);
          for (const i of n.map(pu)) this._testAndFire("insert", gu($s({}, i), { reconversion: !0 }), t);
        }
        _convertMarkerAdd(e, t, n) {
          if (t.root.rootName == "$graveyard") return;
          const i = `addMarker:${e}`;
          if (n.consumable.add(t, i), this.fire(i, { markerName: e, markerRange: t }, n), n.consumable.consume(t, i)) {
            this._addConsumablesForRange(n.consumable, t, i);
            for (const r of t.getItems()) {
              if (!n.consumable.test(r, i)) continue;
              const s = { item: r, range: V._createOn(r), markerName: e, markerRange: t };
              this.fire(i, s, n);
            }
          }
        }
        _convertMarkerRemove(e, t, n) {
          t.root.rootName != "$graveyard" && this.fire(`removeMarker:${e}`, { markerName: e, markerRange: t }, n);
        }
        _reduceChanges(e) {
          const t = { changes: e };
          return this.fire("reduceChanges", t), t.changes;
        }
        _addConsumablesForInsert(e, t) {
          for (const n of t) {
            const i = n.item;
            if (e.test(i, "insert") === null) {
              e.add(i, "insert");
              for (const r of i.getAttributeKeys()) e.add(i, "attribute:" + r);
            }
          }
          return e;
        }
        _addConsumablesForRange(e, t, n) {
          for (const i of t.getItems()) e.add(i, n);
          return e;
        }
        _addConsumablesForSelection(e, t, n) {
          e.add(t, "selection");
          for (const i of n) e.add(t, "addMarker:" + i.name);
          for (const i of t.getAttributeKeys()) e.add(t, "attribute:" + i);
          return e;
        }
        _testAndFire(e, t, n) {
          const i = function(l, c) {
            const d = c.item.is("element") ? c.item.name : "$text";
            return `${l}:${d}`;
          }(e, t), r = t.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(t.item) : t.item, s = this._firedEventsMap.get(n), a = s.get(r);
          if (a) {
            if (a.has(i)) return;
            a.add(i);
          } else s.set(r, /* @__PURE__ */ new Set([i]));
          this.fire(i, t, n);
        }
        _testAndFireAddAttributes(e, t) {
          const n = { item: e, range: V._createOn(e) };
          for (const i of n.item.getAttributeKeys()) n.attributeKey = i, n.attributeOldValue = null, n.attributeNewValue = n.item.getAttribute(i), this._testAndFire(`attribute:${i}`, n, t);
        }
        _createConversionApi(e, t = /* @__PURE__ */ new Set(), n = {}) {
          const i = gu($s({}, this._conversionApi), { consumable: new d0(), writer: e, options: n, convertItem: (r) => this._convertInsert(V._createOn(r), i), convertChildren: (r) => this._convertInsert(V._createIn(r), i, { doNotAddConsumables: !0 }), convertAttributes: (r) => this._testAndFireAddAttributes(r, i), canReuseView: (r) => !t.has(i.mapper.toModelElement(r)) });
          return this._firedEventsMap.set(i, /* @__PURE__ */ new Map()), i;
        }
      }
      function f0(o, e, t) {
        const n = e.getRange(), i = Array.from(o.getAncestors());
        return i.shift(), i.reverse(), !i.some((r) => {
          if (n.containsItem(r))
            return !!t.toViewElement(r).getCustomProperty("addHighlight");
        });
      }
      function pu(o) {
        return { item: o.item, range: V._createFromPositionAndShift(o.previousPosition, o.length) };
      }
      class ft extends _e(sn) {
        constructor(...e) {
          super(), this._lastRangeBackward = !1, this._attrs = /* @__PURE__ */ new Map(), this._ranges = [], e.length && this.setTo(...e);
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const e = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? e.end : e.start;
          }
          return null;
        }
        get focus() {
          if (this._ranges.length > 0) {
            const e = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? e.start : e.end;
          }
          return null;
        }
        get isCollapsed() {
          return this._ranges.length === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        isEqual(e) {
          if (this.rangeCount != e.rangeCount) return !1;
          if (this.rangeCount === 0) return !0;
          if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus)) return !1;
          for (const t of this._ranges) {
            let n = !1;
            for (const i of e._ranges) if (t.isEqual(i)) {
              n = !0;
              break;
            }
            if (!n) return !1;
          }
          return !0;
        }
        *getRanges() {
          for (const e of this._ranges) yield new V(e.start, e.end);
        }
        getFirstRange() {
          let e = null;
          for (const t of this._ranges) e && !t.start.isBefore(e.start) || (e = t);
          return e ? new V(e.start, e.end) : null;
        }
        getLastRange() {
          let e = null;
          for (const t of this._ranges) e && !t.end.isAfter(e.end) || (e = t);
          return e ? new V(e.start, e.end) : null;
        }
        getFirstPosition() {
          const e = this.getFirstRange();
          return e ? e.start.clone() : null;
        }
        getLastPosition() {
          const e = this.getLastRange();
          return e ? e.end.clone() : null;
        }
        setTo(...e) {
          let [t, n, i] = e;
          if (typeof n == "object" && (i = n, n = void 0), t === null) this._setRanges([]);
          else if (t instanceof ft) this._setRanges(t.getRanges(), t.isBackward);
          else if (t && typeof t.getRanges == "function") this._setRanges(t.getRanges(), t.isBackward);
          else if (t instanceof V) this._setRanges([t], !!i && !!i.backward);
          else if (t instanceof U) this._setRanges([new V(t)]);
          else if (t instanceof xn) {
            const r = !!i && !!i.backward;
            let s;
            if (n == "in") s = V._createIn(t);
            else if (n == "on") s = V._createOn(t);
            else {
              if (n === void 0) throw new T("model-selection-setto-required-second-parameter", [this, t]);
              s = new V(U._createAt(t, n));
            }
            this._setRanges([s], r);
          } else {
            if (!gt(t)) throw new T("model-selection-setto-not-selectable", [this, t]);
            this._setRanges(t, i && !!i.backward);
          }
        }
        _setRanges(e, t = !1) {
          const n = Array.from(e), i = n.some((r) => {
            if (!(r instanceof V)) throw new T("model-selection-set-ranges-not-range", [this, e]);
            return this._ranges.every((s) => !s.isEqual(r));
          });
          (n.length !== this._ranges.length || i) && (this._replaceAllRanges(n), this._lastRangeBackward = !!t, this.fire("change:range", { directChange: !0 }));
        }
        setFocus(e, t) {
          if (this.anchor === null) throw new T("model-selection-setfocus-no-ranges", [this, e]);
          const n = U._createAt(e, t);
          if (n.compareWith(this.focus) == "same") return;
          const i = this.anchor;
          this._ranges.length && this._popRange(), n.compareWith(i) == "before" ? (this._pushRange(new V(n, i)), this._lastRangeBackward = !0) : (this._pushRange(new V(i, n)), this._lastRangeBackward = !1), this.fire("change:range", { directChange: !0 });
        }
        getAttribute(e) {
          return this._attrs.get(e);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        hasAttribute(e) {
          return this._attrs.has(e);
        }
        removeAttribute(e) {
          this.hasAttribute(e) && (this._attrs.delete(e), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
        }
        setAttribute(e, t) {
          this.getAttribute(e) !== t && (this._attrs.set(e, t), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
        }
        getSelectedElement() {
          return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
        }
        *getSelectedBlocks() {
          const e = /* @__PURE__ */ new WeakSet();
          for (const t of this.getRanges()) {
            const n = bu(t.start, e);
            k0(n, t) && (yield n);
            for (const r of t.getWalker()) {
              const s = r.item;
              r.type == "elementEnd" && b0(s, e, t) && (yield s);
            }
            const i = bu(t.end, e);
            w0(i, t) && (yield i);
          }
        }
        containsEntireContent(e = this.anchor.root) {
          const t = U._createAt(e, 0), n = U._createAt(e, "end");
          return t.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition());
        }
        _pushRange(e) {
          this._checkRange(e), this._ranges.push(new V(e.start, e.end));
        }
        _checkRange(e) {
          for (let t = 0; t < this._ranges.length; t++) if (e.isIntersecting(this._ranges[t])) throw new T("model-selection-range-intersects", [this, e], { addedRange: e, intersectingRange: this._ranges[t] });
        }
        _replaceAllRanges(e) {
          this._removeAllRanges();
          for (const t of e) this._pushRange(t);
        }
        _removeAllRanges() {
          for (; this._ranges.length > 0; ) this._popRange();
        }
        _popRange() {
          this._ranges.pop();
        }
      }
      function fu(o, e) {
        return !e.has(o) && (e.add(o), o.root.document.model.schema.isBlock(o) && !!o.parent);
      }
      function b0(o, e, t) {
        return fu(o, e) && Hs(o, t);
      }
      function bu(o, e) {
        const t = o.parent.root.document.model.schema, n = o.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
        let i = !1;
        const r = n.find((s) => !i && (i = t.isLimit(s), !i && fu(s, e)));
        return n.forEach((s) => e.add(s)), r;
      }
      function Hs(o, e) {
        const t = function(n) {
          const i = n.root.document.model.schema;
          let r = n.parent;
          for (; r; ) {
            if (i.isBlock(r)) return r;
            r = r.parent;
          }
        }(o);
        return t ? !e.containsRange(V._createOn(t), !0) : !0;
      }
      function k0(o, e) {
        return !!o && (!(!e.isCollapsed && !o.isEmpty) || !e.start.isTouching(U._createAt(o, o.maxOffset)) && Hs(o, e));
      }
      function w0(o, e) {
        return !!o && (!(!e.isCollapsed && !o.isEmpty) || !e.end.isTouching(U._createAt(o, 0)) && Hs(o, e));
      }
      ft.prototype.is = function(o) {
        return o === "selection" || o === "model:selection";
      };
      class qt extends _e(V) {
        constructor(e, t) {
          super(e, t), A0.call(this);
        }
        detach() {
          this.stopListening();
        }
        toRange() {
          return new V(this.start, this.end);
        }
        static fromRange(e) {
          return new qt(e.start, e.end);
        }
      }
      function A0() {
        this.listenTo(this.root.document.model, "applyOperation", (o, e) => {
          const t = e[0];
          t.isDocumentOperation && _0.call(this, t);
        }, { priority: "low" });
      }
      function _0(o) {
        const e = this.getTransformedByOperation(o), t = V._createFromRanges(e), n = !t.isEqual(this), i = function(s, a) {
          switch (a.type) {
            case "insert":
              return s.containsPosition(a.position);
            case "move":
            case "remove":
            case "reinsert":
            case "merge":
              return s.containsPosition(a.sourcePosition) || s.start.isEqual(a.sourcePosition) || s.containsPosition(a.targetPosition);
            case "split":
              return s.containsPosition(a.splitPosition) || s.containsPosition(a.insertionPosition);
          }
          return !1;
        }(this, o);
        let r = null;
        if (n) {
          t.root.rootName == "$graveyard" && (r = o.type == "remove" ? o.sourcePosition : o.deletionPosition);
          const s = this.toRange();
          this.start = t.start, this.end = t.end, this.fire("change:range", s, { deletionPosition: r });
        } else i && this.fire("change:content", this.toRange(), { deletionPosition: r });
      }
      qt.prototype.is = function(o) {
        return o === "liveRange" || o === "model:liveRange" || o == "range" || o === "model:range";
      };
      const ji = "selection:";
      class St extends _e(sn) {
        constructor(e) {
          super(), this._selection = new v0(e), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden;
        }
        get markers() {
          return this._selection.markers;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        getRanges() {
          return this._selection.getRanges();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        containsEntireContent(e) {
          return this._selection.containsEntireContent(e);
        }
        destroy() {
          this._selection.destroy();
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys();
        }
        getAttributes() {
          return this._selection.getAttributes();
        }
        getAttribute(e) {
          return this._selection.getAttribute(e);
        }
        hasAttribute(e) {
          return this._selection.hasAttribute(e);
        }
        refresh() {
          this._selection.updateMarkers(), this._selection._updateAttributes(!1);
        }
        observeMarkers(e) {
          this._selection.observeMarkers(e);
        }
        _setFocus(e, t) {
          this._selection.setFocus(e, t);
        }
        _setTo(...e) {
          this._selection.setTo(...e);
        }
        _setAttribute(e, t) {
          this._selection.setAttribute(e, t);
        }
        _removeAttribute(e) {
          this._selection.removeAttribute(e);
        }
        _getStoredAttributes() {
          return this._selection.getStoredAttributes();
        }
        _overrideGravity() {
          return this._selection.overrideGravity();
        }
        _restoreGravity(e) {
          this._selection.restoreGravity(e);
        }
        static _getStoreAttributeKey(e) {
          return ji + e;
        }
        static _isStoreAttributeKey(e) {
          return e.startsWith(ji);
        }
      }
      St.prototype.is = function(o) {
        return o === "selection" || o == "model:selection" || o == "documentSelection" || o == "model:documentSelection";
      };
      class v0 extends ft {
        constructor(e) {
          super(), this.markers = new _t({ idProperty: "name" }), this._attributePriority = /* @__PURE__ */ new Map(), this._selectionRestorePosition = null, this._hasChangedRange = !1, this._overriddenGravityRegister = /* @__PURE__ */ new Set(), this._observedMarkers = /* @__PURE__ */ new Set(), this._model = e.model, this._document = e, this.listenTo(this._model, "applyOperation", (t, n) => {
            const i = n[0];
            i.isDocumentOperation && i.type != "marker" && i.type != "rename" && i.type != "noop" && (this._ranges.length == 0 && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = !1, this.fire("change:range", { directChange: !1 })));
          }, { priority: "lowest" }), this.on("change:range", () => {
            this._validateSelectionRanges(this.getRanges());
          }), this.listenTo(this._model.markers, "update", (t, n, i, r) => {
            this._updateMarker(n, r);
          }), this.listenTo(this._document, "change", (t, n) => {
            (function(i, r) {
              const s = i.document.differ;
              for (const a of s.getChanges()) {
                if (a.type != "insert") continue;
                const l = a.position.parent;
                a.length === l.maxOffset && i.enqueueChange(r, (c) => {
                  const d = Array.from(l.getAttributeKeys()).filter((u) => u.startsWith(ji));
                  for (const u of d) c.removeAttribute(u, l);
                });
              }
            })(this._model, n);
          });
        }
        get isCollapsed() {
          return this._ranges.length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
        }
        get anchor() {
          return super.anchor || this._document._getDefaultRange().start;
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end;
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1;
        }
        get hasOwnRange() {
          return this._ranges.length > 0;
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size;
        }
        destroy() {
          for (let e = 0; e < this._ranges.length; e++) this._ranges[e].detach();
          this.stopListening();
        }
        *getRanges() {
          this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
        }
        getFirstRange() {
          return super.getFirstRange() || this._document._getDefaultRange();
        }
        getLastRange() {
          return super.getLastRange() || this._document._getDefaultRange();
        }
        setTo(...e) {
          super.setTo(...e), this._updateAttributes(!0), this.updateMarkers();
        }
        setFocus(e, t) {
          super.setFocus(e, t), this._updateAttributes(!0), this.updateMarkers();
        }
        setAttribute(e, t) {
          if (this._setAttribute(e, t)) {
            const n = [e];
            this.fire("change:attribute", { attributeKeys: n, directChange: !0 });
          }
        }
        removeAttribute(e) {
          if (this._removeAttribute(e)) {
            const t = [e];
            this.fire("change:attribute", { attributeKeys: t, directChange: !0 });
          }
        }
        overrideGravity() {
          const e = Q();
          return this._overriddenGravityRegister.add(e), this._overriddenGravityRegister.size === 1 && this._updateAttributes(!0), e;
        }
        restoreGravity(e) {
          if (!this._overriddenGravityRegister.has(e)) throw new T("document-selection-gravity-wrong-restore", this, { uid: e });
          this._overriddenGravityRegister.delete(e), this.isGravityOverridden || this._updateAttributes(!0);
        }
        observeMarkers(e) {
          this._observedMarkers.add(e), this.updateMarkers();
        }
        _replaceAllRanges(e) {
          this._validateSelectionRanges(e), super._replaceAllRanges(e);
        }
        _popRange() {
          this._ranges.pop().detach();
        }
        _pushRange(e) {
          const t = this._prepareRange(e);
          t && this._ranges.push(t);
        }
        _validateSelectionRanges(e) {
          for (const t of e) if (!this._document._validateSelectionRange(t)) throw new T("document-selection-wrong-position", this, { range: t });
        }
        _prepareRange(e) {
          if (this._checkRange(e), e.root == this._document.graveyard) return;
          const t = qt.fromRange(e);
          return t.on("change:range", (n, i, r) => {
            if (this._hasChangedRange = !0, t.root == this._document.graveyard) {
              this._selectionRestorePosition = r.deletionPosition;
              const s = this._ranges.indexOf(t);
              this._ranges.splice(s, 1), t.detach();
            }
          }), t;
        }
        updateMarkers() {
          if (!this._observedMarkers.size) return;
          const e = [];
          let t = !1;
          for (const i of this._model.markers) {
            const r = i.name.split(":", 1)[0];
            if (!this._observedMarkers.has(r)) continue;
            const s = i.getRange();
            for (const a of this.getRanges()) s.containsRange(a, !a.isCollapsed) && e.push(i);
          }
          const n = Array.from(this.markers);
          for (const i of e) this.markers.has(i) || (this.markers.add(i), t = !0);
          for (const i of Array.from(this.markers)) e.includes(i) || (this.markers.remove(i), t = !0);
          t && this.fire("change:marker", { oldMarkers: n, directChange: !1 });
        }
        _updateMarker(e, t) {
          const n = e.name.split(":", 1)[0];
          if (!this._observedMarkers.has(n)) return;
          let i = !1;
          const r = Array.from(this.markers), s = this.markers.has(e);
          if (t) {
            let a = !1;
            for (const l of this.getRanges()) if (t.containsRange(l, !l.isCollapsed)) {
              a = !0;
              break;
            }
            a && !s ? (this.markers.add(e), i = !0) : !a && s && (this.markers.remove(e), i = !0);
          } else s && (this.markers.remove(e), i = !0);
          i && this.fire("change:marker", { oldMarkers: r, directChange: !1 });
        }
        _updateAttributes(e) {
          const t = Ht(this._getSurroundingAttributes()), n = Ht(this.getAttributes());
          if (e) this._attributePriority = /* @__PURE__ */ new Map(), this._attrs = /* @__PURE__ */ new Map();
          else for (const [r, s] of this._attributePriority) s == "low" && (this._attrs.delete(r), this._attributePriority.delete(r));
          this._setAttributesTo(t);
          const i = [];
          for (const [r, s] of this.getAttributes()) n.has(r) && n.get(r) === s || i.push(r);
          for (const [r] of n) this.hasAttribute(r) || i.push(r);
          i.length > 0 && this.fire("change:attribute", { attributeKeys: i, directChange: !1 });
        }
        _setAttribute(e, t, n = !0) {
          const i = n ? "normal" : "low";
          return i == "low" && this._attributePriority.get(e) == "normal" ? !1 : super.getAttribute(e) !== t && (this._attrs.set(e, t), this._attributePriority.set(e, i), !0);
        }
        _removeAttribute(e, t = !0) {
          const n = t ? "normal" : "low";
          return (n != "low" || this._attributePriority.get(e) != "normal") && (this._attributePriority.set(e, n), !!super.hasAttribute(e) && (this._attrs.delete(e), !0));
        }
        _setAttributesTo(e) {
          const t = /* @__PURE__ */ new Set();
          for (const [n, i] of this.getAttributes()) e.get(n) !== i && this._removeAttribute(n, !1);
          for (const [n, i] of e)
            this._setAttribute(n, i, !1) && t.add(n);
          return t;
        }
        *getStoredAttributes() {
          const e = this.getFirstPosition().parent;
          if (this.isCollapsed && e.isEmpty) for (const t of e.getAttributeKeys()) t.startsWith(ji) && (yield [t.substr(10), e.getAttribute(t)]);
        }
        _getSurroundingAttributes() {
          const e = this.getFirstPosition(), t = this._model.schema;
          let n = null;
          if (this.isCollapsed) {
            const i = e.textNode ? e.textNode : e.nodeBefore, r = e.textNode ? e.textNode : e.nodeAfter;
            if (this.isGravityOverridden || (n = $i(i)), n || (n = $i(r)), !this.isGravityOverridden && !n) {
              let s = i;
              for (; s && !t.isInline(s) && !n; ) s = s.previousSibling, n = $i(s);
            }
            if (!n) {
              let s = r;
              for (; s && !t.isInline(s) && !n; ) s = s.nextSibling, n = $i(s);
            }
            n || (n = this.getStoredAttributes());
          } else {
            const i = this.getFirstRange();
            for (const r of i) {
              if (r.item.is("element") && t.isObject(r.item)) break;
              if (r.type == "text") {
                n = r.item.getAttributes();
                break;
              }
            }
          }
          return n;
        }
        _fixGraveyardSelection(e) {
          const t = this._model.schema.getNearestSelectionRange(e);
          t && this._pushRange(t);
        }
      }
      function $i(o) {
        return o instanceof xt || o instanceof ye ? o.getAttributes() : null;
      }
      class ku {
        constructor(e) {
          this._dispatchers = e;
        }
        add(e) {
          for (const t of this._dispatchers) e(t);
          return this;
        }
      }
      const an = function(o) {
        return ns(o, 5);
      };
      class C0 extends ku {
        elementToElement(e) {
          return this.add(function(t) {
            const n = _u(t.model), i = qo(t.view, "container");
            return n.attributes.length && (n.children = !0), (r) => {
              r.on(`insert:${n.name}`, /* @__PURE__ */ function(s, a = E0) {
                return (l, c, d) => {
                  if (!a(c.item, d.consumable, { preflight: !0 })) return;
                  const u = s(c.item, d, c);
                  if (!u) return;
                  a(c.item, d.consumable);
                  const g = d.mapper.toViewPosition(c.range.start);
                  d.mapper.bindElements(c.item, u), d.writer.insert(g, u), d.convertAttributes(c.item), xu(u, c.item.getChildren(), d, { reconversion: c.reconversion });
                };
              }(i, Eu(n)), { priority: t.converterPriority || "normal" }), (n.children || n.attributes.length) && r.on("reduceChanges", yu(n), { priority: "low" });
            };
          }(e));
        }
        elementToStructure(e) {
          return this.add(function(t) {
            const n = _u(t.model), i = qo(t.view, "container");
            return n.children = !0, (r) => {
              if (r._conversionApi.schema.checkChild(n.name, "$text")) throw new T("conversion-element-to-structure-disallowed-text", r, { elementName: n.name });
              var s, a;
              r.on(`insert:${n.name}`, (s = i, a = Eu(n), (l, c, d) => {
                if (!a(c.item, d.consumable, { preflight: !0 })) return;
                const u = /* @__PURE__ */ new Map();
                d.writer._registerSlotFactory(/* @__PURE__ */ function(b, w, y) {
                  return (I, z) => {
                    const H = I.createContainerElement("$slot");
                    let X = null;
                    if (z === "children") X = Array.from(b.getChildren());
                    else {
                      if (typeof z != "function") throw new T("conversion-slot-mode-unknown", y.dispatcher, { modeOrFilter: z });
                      X = Array.from(b.getChildren()).filter((ce) => z(ce));
                    }
                    return w.set(H, X), H;
                  };
                }(c.item, u, d));
                const g = s(c.item, d, c);
                if (d.writer._clearSlotFactory(), !g) return;
                (function(b, w, y) {
                  const I = Array.from(w.values()).flat(), z = new Set(I);
                  if (z.size != I.length) throw new T("conversion-slot-filter-overlap", y.dispatcher, { element: b });
                  if (z.size != b.childCount) throw new T("conversion-slot-filter-incomplete", y.dispatcher, { element: b });
                })(c.item, u, d), a(c.item, d.consumable);
                const p = d.mapper.toViewPosition(c.range.start);
                d.mapper.bindElements(c.item, g), d.writer.insert(p, g), d.convertAttributes(c.item), function(b, w, y, I) {
                  y.mapper.on("modelToViewPosition", X, { priority: "highest" });
                  let z = null, H = null;
                  for ([z, H] of w) xu(b, H, y, I), y.writer.move(y.writer.createRangeIn(z), y.writer.createPositionBefore(z)), y.writer.remove(z);
                  function X(ce, Oe) {
                    const be = Oe.modelPosition.nodeAfter, Qt = H.indexOf(be);
                    Qt < 0 || (Oe.viewPosition = Oe.mapper.findPositionIn(z, Qt));
                  }
                  y.mapper.off("modelToViewPosition", X);
                }(g, u, d, { reconversion: c.reconversion });
              }), { priority: t.converterPriority || "normal" }), r.on("reduceChanges", yu(n), { priority: "low" });
            };
          }(e));
        }
        attributeToElement(e) {
          return this.add(function(t) {
            t = an(t);
            let n = t.model;
            typeof n == "string" && (n = { key: n });
            let i = `attribute:${n.key}`;
            if (n.name && (i += ":" + n.name), n.values) for (const s of n.values) t.view[s] = qo(t.view[s], "attribute");
            else t.view = qo(t.view, "attribute");
            const r = vu(t);
            return (s) => {
              s.on(i, /* @__PURE__ */ function(a) {
                return (l, c, d) => {
                  if (!d.consumable.test(c.item, l.name)) return;
                  const u = a(c.attributeOldValue, d, c), g = a(c.attributeNewValue, d, c);
                  if (!u && !g) return;
                  d.consumable.consume(c.item, l.name);
                  const p = d.writer, b = p.document.selection;
                  if (c.item instanceof ft || c.item instanceof St) p.wrap(b.getFirstRange(), g);
                  else {
                    let w = d.mapper.toViewRange(c.range);
                    c.attributeOldValue !== null && u && (w = p.unwrap(w, u)), c.attributeNewValue !== null && g && p.wrap(w, g);
                  }
                };
              }(r), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        attributeToAttribute(e) {
          return this.add(function(t) {
            t = an(t);
            let n = t.model;
            typeof n == "string" && (n = { key: n });
            let i = `attribute:${n.key}`;
            if (n.name && (i += ":" + n.name), n.values) for (const s of n.values) t.view[s] = Cu(t.view[s]);
            else t.view = Cu(t.view);
            const r = vu(t);
            return (s) => {
              var a;
              s.on(i, (a = r, (l, c, d) => {
                if (!d.consumable.test(c.item, l.name)) return;
                const u = a(c.attributeOldValue, d, c), g = a(c.attributeNewValue, d, c);
                if (!u && !g) return;
                d.consumable.consume(c.item, l.name);
                const p = d.mapper.toViewElement(c.item), b = d.writer;
                if (!p) throw new T("conversion-attribute-to-attribute-on-text", d.dispatcher, c);
                if (c.attributeOldValue !== null && u) if (u.key == "class") {
                  const w = $e(u.value);
                  for (const y of w) b.removeClass(y, p);
                } else if (u.key == "style") {
                  const w = Object.keys(u.value);
                  for (const y of w) b.removeStyle(y, p);
                } else b.removeAttribute(u.key, p);
                if (c.attributeNewValue !== null && g) if (g.key == "class") {
                  const w = $e(g.value);
                  for (const y of w) b.addClass(y, p);
                } else if (g.key == "style") {
                  const w = Object.keys(g.value);
                  for (const y of w) b.setStyle(y, g.value[y], p);
                } else b.setAttribute(g.key, g.value, p);
              }), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        markerToElement(e) {
          return this.add(function(t) {
            const n = qo(t.view, "ui");
            return (i) => {
              var r;
              i.on(`addMarker:${t.model}`, (r = n, (s, a, l) => {
                a.isOpening = !0;
                const c = r(a, l);
                a.isOpening = !1;
                const d = r(a, l);
                if (!c || !d) return;
                const u = a.markerRange;
                if (u.isCollapsed && !l.consumable.consume(u, s.name)) return;
                for (const b of u) if (!l.consumable.consume(b.item, s.name)) return;
                const g = l.mapper, p = l.writer;
                p.insert(g.toViewPosition(u.start), c), l.mapper.bindElementToMarker(c, a.markerName), u.isCollapsed || (p.insert(g.toViewPosition(u.end), d), l.mapper.bindElementToMarker(d, a.markerName)), s.stop();
              }), { priority: t.converterPriority || "normal" }), i.on(`removeMarker:${t.model}`, (s, a, l) => {
                const c = l.mapper.markerNameToElements(a.markerName);
                if (c) {
                  for (const d of c) l.mapper.unbindElementFromMarkerName(d, a.markerName), l.writer.clear(l.writer.createRangeOn(d), d);
                  l.writer.clearClonedElementsGroup(a.markerName), s.stop();
                }
              }, { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        markerToHighlight(e) {
          return this.add(/* @__PURE__ */ function(t) {
            return (n) => {
              var i;
              n.on(`addMarker:${t.model}`, (i = t.view, (r, s, a) => {
                if (!s.item || !(s.item instanceof ft || s.item instanceof St || s.item.is("$textProxy"))) return;
                const l = qs(i, s, a);
                if (!l || !a.consumable.consume(s.item, r.name)) return;
                const c = a.writer, d = wu(c, l), u = c.document.selection;
                if (s.item instanceof ft || s.item instanceof St) c.wrap(u.getFirstRange(), d);
                else {
                  const g = a.mapper.toViewRange(s.range), p = c.wrap(g, d);
                  for (const b of p.getItems()) if (b.is("attributeElement") && b.isSimilar(d)) {
                    a.mapper.bindElementToMarker(b, s.markerName);
                    break;
                  }
                }
              }), { priority: t.converterPriority || "normal" }), n.on(`addMarker:${t.model}`, /* @__PURE__ */ function(r) {
                return (s, a, l) => {
                  if (!a.item || !(a.item instanceof Ee)) return;
                  const c = qs(r, a, l);
                  if (!c || !l.consumable.test(a.item, s.name)) return;
                  const d = l.mapper.toViewElement(a.item);
                  if (d && d.getCustomProperty("addHighlight")) {
                    l.consumable.consume(a.item, s.name);
                    for (const u of V._createIn(a.item)) l.consumable.consume(u.item, s.name);
                    d.getCustomProperty("addHighlight")(d, c, l.writer), l.mapper.bindElementToMarker(d, a.markerName);
                  }
                };
              }(t.view), { priority: t.converterPriority || "normal" }), n.on(`removeMarker:${t.model}`, /* @__PURE__ */ function(r) {
                return (s, a, l) => {
                  if (a.markerRange.isCollapsed) return;
                  const c = qs(r, a, l);
                  if (!c) return;
                  const d = wu(l.writer, c), u = l.mapper.markerNameToElements(a.markerName);
                  if (u) {
                    for (const g of u) l.mapper.unbindElementFromMarkerName(g, a.markerName), g.is("attributeElement") ? l.writer.unwrap(l.writer.createRangeOn(g), d) : g.getCustomProperty("removeHighlight")(g, c.id, l.writer);
                    l.writer.clearClonedElementsGroup(a.markerName), s.stop();
                  }
                };
              }(t.view), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
        markerToData(e) {
          return this.add(function(t) {
            t = an(t);
            const n = t.model;
            let i = t.view;
            return i || (i = (r) => ({ group: n, name: r.substr(t.model.length + 1) })), (r) => {
              var s;
              r.on(`addMarker:${n}`, (s = i, (a, l, c) => {
                const d = s(l.markerName, c);
                if (!d) return;
                const u = l.markerRange;
                c.consumable.consume(u, a.name) && (Au(u, !1, c, l, d), Au(u, !0, c, l, d), a.stop());
              }), { priority: t.converterPriority || "normal" }), r.on(`removeMarker:${n}`, /* @__PURE__ */ function(a) {
                return (l, c, d) => {
                  const u = a(c.markerName, d);
                  if (!u) return;
                  const g = d.mapper.markerNameToElements(c.markerName);
                  if (g) {
                    for (const b of g) d.mapper.unbindElementFromMarkerName(b, c.markerName), b.is("containerElement") ? (p(`data-${u.group}-start-before`, b), p(`data-${u.group}-start-after`, b), p(`data-${u.group}-end-before`, b), p(`data-${u.group}-end-after`, b)) : d.writer.clear(d.writer.createRangeOn(b), b);
                    d.writer.clearClonedElementsGroup(c.markerName), l.stop();
                  }
                  function p(b, w) {
                    if (w.hasAttribute(b)) {
                      const y = new Set(w.getAttribute(b).split(","));
                      y.delete(u.name), y.size == 0 ? d.writer.removeAttribute(b, w) : d.writer.setAttribute(b, Array.from(y).join(","), w);
                    }
                  }
                };
              }(i), { priority: t.converterPriority || "normal" });
            };
          }(e));
        }
      }
      function wu(o, e) {
        const t = o.createAttributeElement("span", e.attributes);
        return e.classes && t._addClass(e.classes), typeof e.priority == "number" && (t._priority = e.priority), t._id = e.id, t;
      }
      function Au(o, e, t, n, i) {
        const r = e ? o.start : o.end, s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null, a = r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null;
        if (s || a) {
          let l, c;
          e && s || !e && !a ? (l = s, c = !0) : (l = a, c = !1);
          const d = t.mapper.toViewElement(l);
          if (d) return void function(u, g, p, b, w, y) {
            const I = `data-${y.group}-${g ? "start" : "end"}-${p ? "before" : "after"}`, z = u.hasAttribute(I) ? u.getAttribute(I).split(",") : [];
            z.unshift(y.name), b.writer.setAttribute(I, z.join(","), u), b.mapper.bindElementToMarker(u, w.markerName);
          }(d, e, c, t, n, i);
        }
        (function(l, c, d, u, g) {
          const p = `${g.group}-${c ? "start" : "end"}`, b = g.name ? { name: g.name } : null, w = d.writer.createUIElement(p, b);
          d.writer.insert(l, w), d.mapper.bindElementToMarker(w, u.markerName);
        })(t.mapper.toViewPosition(r), e, t, n, i);
      }
      function _u(o) {
        return typeof o == "string" && (o = { name: o }), o.attributes ? Array.isArray(o.attributes) || (o.attributes = [o.attributes]) : o.attributes = [], o.children = !!o.children, o;
      }
      function qo(o, e) {
        return typeof o == "function" ? o : (t, n) => function(i, r, s) {
          typeof i == "string" && (i = { name: i });
          let a;
          const l = r.writer, c = Object.assign({}, i.attributes);
          if (s == "container") a = l.createContainerElement(i.name, c);
          else if (s == "attribute") {
            const d = { priority: i.priority || yn.DEFAULT_PRIORITY };
            a = l.createAttributeElement(i.name, c, d);
          } else a = l.createUIElement(i.name, c);
          if (i.styles) {
            const d = Object.keys(i.styles);
            for (const u of d) l.setStyle(u, i.styles[u], a);
          }
          if (i.classes) {
            const d = i.classes;
            if (typeof d == "string") l.addClass(d, a);
            else for (const u of d) l.addClass(u, a);
          }
          return a;
        }(o, n, e);
      }
      function vu(o) {
        return o.model.values ? (e, t, n) => {
          const i = o.view[e];
          return i ? i(e, t, n) : null;
        } : o.view;
      }
      function Cu(o) {
        return typeof o == "string" ? (e) => ({ key: o, value: e }) : typeof o == "object" ? o.value ? () => o : (e) => ({ key: o.key, value: e }) : o;
      }
      function qs(o, e, t) {
        const n = typeof o == "function" ? o(e, t) : o;
        return n ? (n.priority || (n.priority = 10), n.id || (n.id = e.markerName), n) : null;
      }
      function yu(o) {
        const e = /* @__PURE__ */ function(t) {
          return (n, i) => {
            if (!n.is("element", t.name)) return !1;
            if (i.type == "attribute") {
              if (t.attributes.includes(i.attributeKey)) return !0;
            } else if (t.children) return !0;
            return !1;
          };
        }(o);
        return (t, n) => {
          const i = [];
          n.reconvertedElements || (n.reconvertedElements = /* @__PURE__ */ new Set());
          for (const r of n.changes) {
            const s = r.type == "attribute" ? r.range.start.nodeAfter : r.position.parent;
            if (s && e(s, r)) {
              if (!n.reconvertedElements.has(s)) {
                n.reconvertedElements.add(s);
                const a = U._createBefore(s);
                let l = i.length;
                for (let c = i.length - 1; c >= 0; c--) {
                  const d = i[c], u = (d.type == "attribute" ? d.range.start : d.position).compareWith(a);
                  if (u == "before" || d.type == "remove" && u == "same") break;
                  l = c;
                }
                i.splice(l, 0, { type: "remove", name: s.name, position: a, length: 1 }, { type: "reinsert", name: s.name, position: a, length: 1 });
              }
            } else i.push(r);
          }
          n.changes = i;
        };
      }
      function Eu(o) {
        return (e, t, n = {}) => {
          const i = ["insert"];
          for (const r of o.attributes) e.hasAttribute(r) && i.push(`attribute:${r}`);
          return !!i.every((r) => t.test(e, r)) && (n.preflight || i.forEach((r) => t.consume(e, r)), !0);
        };
      }
      function xu(o, e, t, n) {
        for (const i of e) y0(o.root, i, t, n) || t.convertItem(i);
      }
      function y0(o, e, t, n) {
        const { writer: i, mapper: r } = t;
        if (!n.reconversion) return !1;
        const s = r.toViewElement(e);
        return !(!s || s.root == o) && !!t.canReuseView(s) && (i.move(i.createRangeOn(s), r.toViewPosition(U._createBefore(e))), !0);
      }
      function E0(o, e, { preflight: t } = {}) {
        return t ? e.test(o, "insert") : e.consume(o, "insert");
      }
      function Su(o) {
        const { schema: e, document: t } = o.model;
        for (const n of t.getRootNames()) {
          const i = t.getRoot(n);
          if (i.isEmpty && !e.checkChild(i, "$text") && e.checkChild(i, "paragraph")) return o.insertElement("paragraph", i), !0;
        }
        return !1;
      }
      function Du(o, e, t) {
        const n = t.createContext(o);
        return !!t.checkChild(n, "paragraph") && !!t.checkChild(n.push("paragraph"), e);
      }
      function Bu(o, e) {
        const t = e.createElement("paragraph");
        return e.insert(t, o), e.createPositionAt(t, 0);
      }
      var x0 = Object.defineProperty, S0 = Object.defineProperties, D0 = Object.getOwnPropertyDescriptors, Tu = Object.getOwnPropertySymbols, B0 = Object.prototype.hasOwnProperty, T0 = Object.prototype.propertyIsEnumerable, Iu = (o, e, t) => e in o ? x0(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class I0 extends ku {
        elementToElement(e) {
          return this.add(Pu(e));
        }
        elementToAttribute(e) {
          return this.add(function(t) {
            t = an(t), Ru(t);
            const n = Ou(t, !1), i = Us(t.view), r = i ? `element:${i}` : "element";
            return (s) => {
              s.on(r, n, { priority: t.converterPriority || "low" });
            };
          }(e));
        }
        attributeToAttribute(e) {
          return this.add(function(t) {
            t = an(t);
            let n = null;
            (typeof t.view == "string" || t.view.key) && (n = function(r) {
              typeof r.view == "string" && (r.view = { key: r.view });
              const s = r.view.key;
              let a;
              return s == "class" || s == "style" ? a = { [s == "class" ? "classes" : "styles"]: r.view.value } : a = { attributes: { [s]: r.view.value === void 0 ? /[\s\S]*/ : r.view.value } }, r.view.name && (a.name = r.view.name), r.view = a, s;
            }(t)), Ru(t, n);
            const i = Ou(t, !0);
            return (r) => {
              r.on("element", i, { priority: t.converterPriority || "low" });
            };
          }(e));
        }
        elementToMarker(e) {
          return this.add(function(t) {
            const n = /* @__PURE__ */ function(s) {
              return (a, l) => {
                const c = typeof s == "string" ? s : s(a, l);
                return l.writer.createElement("$marker", { "data-name": c });
              };
            }(t.model);
            return Pu((i = ((s, a) => {
              for (var l in a || (a = {})) B0.call(a, l) && Iu(s, l, a[l]);
              if (Tu) for (var l of Tu(a)) T0.call(a, l) && Iu(s, l, a[l]);
              return s;
            })({}, t), r = { model: n }, S0(i, D0(r))));
            var i, r;
          }(e));
        }
        dataToMarker(e) {
          return this.add(function(t) {
            t = an(t), t.model || (t.model = (s) => s ? t.view + ":" + s : t.view);
            const n = { view: t.view, model: t.model }, i = Ws(zu(n, "start")), r = Ws(zu(n, "end"));
            return (s) => {
              s.on(`element:${t.view}-start`, i, { priority: t.converterPriority || "normal" }), s.on(`element:${t.view}-end`, r, { priority: t.converterPriority || "normal" });
              const a = se.get("low"), l = se.get("highest"), c = se.get(t.converterPriority) / l;
              s.on("element", /* @__PURE__ */ function(d) {
                return (u, g, p) => {
                  const b = `data-${d.view}`;
                  function w(y, I) {
                    for (const z of I) {
                      const H = d.model(z, p), X = p.writer.createElement("$marker", { "data-name": H });
                      p.writer.insert(X, y), g.modelCursor.isEqual(y) ? g.modelCursor = g.modelCursor.getShiftedBy(1) : g.modelCursor = g.modelCursor._getTransformedByInsertion(y, 1), g.modelRange = g.modelRange._getTransformedByInsertion(y, 1)[0];
                    }
                  }
                  (p.consumable.test(g.viewItem, { attributes: b + "-end-after" }) || p.consumable.test(g.viewItem, { attributes: b + "-start-after" }) || p.consumable.test(g.viewItem, { attributes: b + "-end-before" }) || p.consumable.test(g.viewItem, { attributes: b + "-start-before" })) && (g.modelRange || Object.assign(g, p.convertChildren(g.viewItem, g.modelCursor)), p.consumable.consume(g.viewItem, { attributes: b + "-end-after" }) && w(g.modelRange.end, g.viewItem.getAttribute(b + "-end-after").split(",")), p.consumable.consume(g.viewItem, { attributes: b + "-start-after" }) && w(g.modelRange.end, g.viewItem.getAttribute(b + "-start-after").split(",")), p.consumable.consume(g.viewItem, { attributes: b + "-end-before" }) && w(g.modelRange.start, g.viewItem.getAttribute(b + "-end-before").split(",")), p.consumable.consume(g.viewItem, { attributes: b + "-start-before" }) && w(g.modelRange.start, g.viewItem.getAttribute(b + "-start-before").split(",")));
                };
              }(n), { priority: a + c });
            };
          }(e));
        }
      }
      function Pu(o) {
        const e = Ws(o = an(o)), t = Us(o.view), n = t ? `element:${t}` : "element";
        return (i) => {
          i.on(n, e, { priority: o.converterPriority || "normal" });
        };
      }
      function Us(o) {
        return typeof o == "string" ? o : typeof o == "object" && typeof o.name == "string" ? o.name : null;
      }
      function Ws(o) {
        const e = new no(o.view);
        return (t, n, i) => {
          const r = e.match(n.viewItem);
          if (!r) return;
          const s = r.match;
          if (s.name = !0, !i.consumable.test(n.viewItem, s)) return;
          const a = function(l, c, d) {
            return l instanceof Function ? l(c, d) : d.writer.createElement(l);
          }(o.model, n.viewItem, i);
          a && i.safeInsert(a, n.modelCursor) && (i.consumable.consume(n.viewItem, s), i.convertChildren(n.viewItem, a), i.updateConversionResult(a, n));
        };
      }
      function Ru(o, e = null) {
        const t = e === null || ((r) => r.getAttribute(e)), n = typeof o.model != "object" ? o.model : o.model.key, i = typeof o.model != "object" || o.model.value === void 0 ? t : o.model.value;
        o.model = { key: n, value: i };
      }
      function Ou(o, e) {
        const t = new no(o.view);
        return (n, i, r) => {
          if (!i.modelRange && e) return;
          const s = t.match(i.viewItem);
          if (!s || (function(d, u) {
            const g = typeof d == "function" ? d(u) : d;
            return typeof g == "object" && !Us(g) ? !1 : !g.classes && !g.attributes && !g.styles;
          }(o.view, i.viewItem) ? s.match.name = !0 : delete s.match.name, !r.consumable.test(i.viewItem, s.match))) return;
          const a = o.model.key, l = typeof o.model.value == "function" ? o.model.value(i.viewItem, r) : o.model.value;
          if (l === null) return;
          i.modelRange || Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor)), function(d, u, g, p) {
            let b = !1;
            for (const w of Array.from(d.getItems({ shallow: g }))) p.schema.checkAttribute(w, u.key) && (b = !0, w.hasAttribute(u.key) || p.writer.setAttribute(u.key, u.value, w));
            return b;
          }(i.modelRange, { key: a, value: l }, e, r) && (r.consumable.test(i.viewItem, { name: !0 }) && (s.match.name = !0), r.consumable.consume(i.viewItem, s.match));
        };
      }
      function zu(o, e) {
        return { view: `${o.view}-${e}`, model: (t, n) => {
          const i = t.getAttribute("name"), r = o.model(i, n);
          return n.writer.createElement("$marker", { "data-name": r });
        } };
      }
      function P0(o) {
        o.document.registerPostFixer((e) => function(t, n) {
          const i = n.document.selection, r = n.schema, s = [];
          let a = !1;
          for (const l of i.getRanges()) {
            const c = Mu(l, r);
            c && !c.isEqual(l) ? (s.push(c), a = !0) : s.push(l);
          }
          return a && t.setSelection(function(l) {
            const c = [...l], d = /* @__PURE__ */ new Set();
            let u = 1;
            for (; u < c.length; ) {
              const g = c[u], p = c.slice(0, u);
              for (const [b, w] of p.entries()) if (!d.has(b)) {
                if (g.isEqual(w)) d.add(b);
                else if (g.isIntersecting(w)) {
                  d.add(b), d.add(u);
                  const y = g.getJoined(w);
                  c.push(y);
                }
              }
              u++;
            }
            return c.filter((g, p) => !d.has(p));
          }(s), { backward: i.isBackward }), !1;
        }(e, o));
      }
      function Mu(o, e) {
        return o.isCollapsed ? function(t, n) {
          const i = t.start, r = n.getNearestSelectionRange(i);
          if (!r) {
            const a = i.getAncestors().reverse().find((l) => n.isObject(l));
            return a ? V._createOn(a) : null;
          }
          if (!r.isCollapsed) return r;
          const s = r.start;
          return i.isEqual(s) ? null : new V(s);
        }(o, e) : function(t, n) {
          const { start: i, end: r } = t, s = n.checkChild(i, "$text"), a = n.checkChild(r, "$text"), l = n.getLimitElement(i), c = n.getLimitElement(r);
          if (l === c) {
            if (s && a) return null;
            if (function(g, p, b) {
              const w = g.nodeAfter && !b.isLimit(g.nodeAfter) || b.checkChild(g, "$text"), y = p.nodeBefore && !b.isLimit(p.nodeBefore) || b.checkChild(p, "$text");
              return w || y;
            }(i, r, n)) {
              const g = i.nodeAfter && n.isSelectable(i.nodeAfter) ? null : n.getNearestSelectionRange(i, "forward"), p = r.nodeBefore && n.isSelectable(r.nodeBefore) ? null : n.getNearestSelectionRange(r, "backward"), b = g ? g.start : i, w = p ? p.end : r;
              return new V(b, w);
            }
          }
          const d = l && !l.is("rootElement"), u = c && !c.is("rootElement");
          if (d || u) {
            const g = i.nodeAfter && r.nodeBefore && i.nodeAfter.parent === r.nodeBefore.parent, p = d && (!g || !Nu(i.nodeAfter, n)), b = u && (!g || !Nu(r.nodeBefore, n));
            let w = i, y = r;
            return p && (w = U._createBefore(Fu(l, n))), b && (y = U._createAfter(Fu(c, n))), new V(w, y);
          }
          return null;
        }(o, e);
      }
      function Fu(o, e) {
        let t = o, n = t;
        for (; e.isLimit(n) && n.parent; ) t = n, n = n.parent;
        return t;
      }
      function Nu(o, e) {
        return o && e.isSelectable(o);
      }
      class R0 extends ve() {
        constructor(e, t) {
          super(), this.model = e, this.view = new c0(t), this.mapper = new du(), this.downcastDispatcher = new mu({ mapper: this.mapper, schema: e.schema });
          const n = this.model.document, i = n.selection, r = this.model.markers;
          var s, a, l;
          this.listenTo(this.model, "_beforeChanges", () => {
            this.view._disableRendering(!0);
          }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
            this.view._disableRendering(!1);
          }, { priority: "lowest" }), this.listenTo(n, "change", () => {
            this.view.change((c) => {
              this.downcastDispatcher.convertChanges(n.differ, r, c), this.downcastDispatcher.convertSelection(i, r, c);
            });
          }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", /* @__PURE__ */ function(c, d) {
            return (u, g) => {
              const p = g.newSelection, b = [];
              for (const y of p.getRanges()) b.push(d.toModelRange(y));
              const w = c.createSelection(b, { backward: p.isBackward });
              w.isEqual(c.document.selection) || c.change((y) => {
                y.setSelection(w);
              });
            };
          }(this.model, this.mapper)), this.listenTo(this.view.document, "beforeinput", (s = this.mapper, a = this.model.schema, l = this.view, (c, d) => {
            if (!l.document.isComposing || f.isAndroid) for (let u = 0; u < d.targetRanges.length; u++) {
              const g = d.targetRanges[u], p = s.toModelRange(g), b = Mu(p, a);
              b && !b.isEqual(p) && (d.targetRanges[u] = s.toViewRange(b));
            }
          }), { priority: "high" }), this.downcastDispatcher.on("insert:$text", (c, d, u) => {
            if (!u.consumable.consume(d.item, c.name)) return;
            const g = u.writer, p = u.mapper.toViewPosition(d.range.start), b = g.createText(d.item.data);
            g.insert(p, b);
          }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (c, d, u) => {
            u.convertAttributes(d.item), d.reconversion || !d.item.is("element") || d.item.isEmpty || u.convertChildren(d.item);
          }, { priority: "lowest" }), this.downcastDispatcher.on("remove", (c, d, u) => {
            const g = u.mapper.toViewPosition(d.position), p = d.position.getShiftedBy(d.length), b = u.mapper.toViewPosition(p, { isPhantom: !0 }), w = u.writer.createRange(g, b), y = u.writer.remove(w.getTrimmed());
            for (const I of u.writer.createRangeIn(y).getItems()) u.mapper.unbindViewElement(I, { defer: !0 });
          }, { priority: "low" }), this.downcastDispatcher.on("selection", (c, d, u) => {
            const g = u.writer, p = g.document.selection;
            for (const b of p.getRanges()) b.isCollapsed && b.end.parent.isAttached() && u.writer.mergeAttributes(b.start);
            g.setSelection(null);
          }, { priority: "high" }), this.downcastDispatcher.on("selection", (c, d, u) => {
            const g = d.selection;
            if (g.isCollapsed || !u.consumable.consume(g, "selection")) return;
            const p = [];
            for (const b of g.getRanges()) p.push(u.mapper.toViewRange(b));
            u.writer.setSelection(p, { backward: g.isBackward });
          }, { priority: "low" }), this.downcastDispatcher.on("selection", (c, d, u) => {
            const g = d.selection;
            if (!g.isCollapsed || !u.consumable.consume(g, "selection")) return;
            const p = u.writer, b = g.getFirstPosition(), w = u.mapper.toViewPosition(b), y = p.breakAttributes(w);
            p.setSelection(y);
          }, { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((c) => {
            if (c.rootName == "$graveyard") return null;
            const d = new Td(this.view.document, c.name);
            return d.rootName = c.rootName, this.mapper.bindElements(c, d), d;
          });
        }
        destroy() {
          this.view.destroy(), this.stopListening();
        }
        reconvertMarker(e) {
          const t = typeof e == "string" ? e : e.name, n = this.model.markers.get(t);
          if (!n) throw new T("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: t });
          this.model.change(() => {
            this.model.markers._refresh(n);
          });
        }
        reconvertItem(e) {
          this.model.change(() => {
            this.model.document.differ._refreshItem(e);
          });
        }
      }
      class Uo {
        constructor() {
          this._consumables = /* @__PURE__ */ new Map();
        }
        add(e, t) {
          let n;
          e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : (this._consumables.has(e) ? n = this._consumables.get(e) : (n = new O0(e), this._consumables.set(e, n)), n.add(t));
        }
        test(e, t) {
          const n = this._consumables.get(e);
          return n === void 0 ? null : e.is("$text") || e.is("documentFragment") ? n : n.test(t);
        }
        consume(e, t) {
          return !!this.test(e, t) && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !1) : this._consumables.get(e).consume(t), !0);
        }
        revert(e, t) {
          const n = this._consumables.get(e);
          n !== void 0 && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : n.revert(t));
        }
        static consumablesFromElement(e) {
          const t = { element: e, name: !0, attributes: [], classes: [], styles: [] }, n = e.getAttributeKeys();
          for (const s of n) s != "style" && s != "class" && t.attributes.push(s);
          const i = e.getClassNames();
          for (const s of i) t.classes.push(s);
          const r = e.getStyleNames();
          for (const s of r) t.styles.push(s);
          return t;
        }
        static createFrom(e, t) {
          if (t || (t = new Uo()), e.is("$text")) return t.add(e), t;
          e.is("element") && t.add(e, Uo.consumablesFromElement(e)), e.is("documentFragment") && t.add(e);
          for (const n of e.getChildren()) t = Uo.createFrom(n, t);
          return t;
        }
      }
      const Hi = ["attributes", "classes", "styles"];
      class O0 {
        constructor(e) {
          this.element = e, this._canConsumeName = null, this._consumables = { attributes: /* @__PURE__ */ new Map(), styles: /* @__PURE__ */ new Map(), classes: /* @__PURE__ */ new Map() };
        }
        add(e) {
          e.name && (this._canConsumeName = !0);
          for (const t of Hi) t in e && this._add(t, e[t]);
        }
        test(e) {
          if (e.name && !this._canConsumeName) return this._canConsumeName;
          for (const t of Hi) if (t in e) {
            const n = this._test(t, e[t]);
            if (n !== !0) return n;
          }
          return !0;
        }
        consume(e) {
          e.name && (this._canConsumeName = !1);
          for (const t of Hi) t in e && this._consume(t, e[t]);
        }
        revert(e) {
          e.name && (this._canConsumeName = !0);
          for (const t of Hi) t in e && this._revert(t, e[t]);
        }
        _add(e, t) {
          const n = it(t) ? t : [t], i = this._consumables[e];
          for (const r of n) {
            if (e === "attributes" && (r === "class" || r === "style")) throw new T("viewconsumable-invalid-attribute", this);
            if (i.set(r, !0), e === "styles") for (const s of this.element.document.stylesProcessor.getRelatedStyles(r)) i.set(s, !0);
          }
        }
        _test(e, t) {
          const n = it(t) ? t : [t], i = this._consumables[e];
          for (const r of n) if (e !== "attributes" || r !== "class" && r !== "style") {
            const s = i.get(r);
            if (s === void 0) return null;
            if (!s) return !1;
          } else {
            const s = r == "class" ? "classes" : "styles", a = this._test(s, [...this._consumables[s].keys()]);
            if (a !== !0) return a;
          }
          return !0;
        }
        _consume(e, t) {
          const n = it(t) ? t : [t], i = this._consumables[e];
          for (const r of n) if (e !== "attributes" || r !== "class" && r !== "style") {
            if (i.set(r, !1), e == "styles") for (const s of this.element.document.stylesProcessor.getRelatedStyles(r)) i.set(s, !1);
          } else {
            const s = r == "class" ? "classes" : "styles";
            this._consume(s, [...this._consumables[s].keys()]);
          }
        }
        _revert(e, t) {
          const n = it(t) ? t : [t], i = this._consumables[e];
          for (const r of n) if (e !== "attributes" || r !== "class" && r !== "style")
            i.get(r) === !1 && i.set(r, !0);
          else {
            const s = r == "class" ? "classes" : "styles";
            this._revert(s, [...this._consumables[s].keys()]);
          }
        }
      }
      class z0 extends ve() {
        constructor() {
          super(), this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (e, t) => {
            t[0] = new Dn(t[0]);
          }, { priority: "highest" }), this.on("checkChild", (e, t) => {
            t[0] = new Dn(t[0]), t[1] = this.getDefinition(t[1]);
          }, { priority: "highest" });
        }
        register(e, t) {
          if (this._sourceDefinitions[e]) throw new T("schema-cannot-register-item-twice", this, { itemName: e });
          this._sourceDefinitions[e] = [Object.assign({}, t)], this._clearCache();
        }
        extend(e, t) {
          if (!this._sourceDefinitions[e]) throw new T("schema-cannot-extend-missing-item", this, { itemName: e });
          this._sourceDefinitions[e].push(Object.assign({}, t)), this._clearCache();
        }
        getDefinitions() {
          return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
        }
        getDefinition(e) {
          let t;
          return t = typeof e == "string" ? e : "is" in e && (e.is("$text") || e.is("$textProxy")) ? "$text" : e.name, this.getDefinitions()[t];
        }
        isRegistered(e) {
          return !!this.getDefinition(e);
        }
        isBlock(e) {
          const t = this.getDefinition(e);
          return !(!t || !t.isBlock);
        }
        isLimit(e) {
          const t = this.getDefinition(e);
          return !!t && !(!t.isLimit && !t.isObject);
        }
        isObject(e) {
          const t = this.getDefinition(e);
          return !!t && !!(t.isObject || t.isLimit && t.isSelectable && t.isContent);
        }
        isInline(e) {
          const t = this.getDefinition(e);
          return !(!t || !t.isInline);
        }
        isSelectable(e) {
          const t = this.getDefinition(e);
          return !!t && !(!t.isSelectable && !t.isObject);
        }
        isContent(e) {
          const t = this.getDefinition(e);
          return !!t && !(!t.isContent && !t.isObject);
        }
        checkChild(e, t) {
          return !!t && this._checkContextMatch(t, e);
        }
        checkAttribute(e, t) {
          const n = this.getDefinition(e.last);
          return !!n && n.allowAttributes.includes(t);
        }
        checkMerge(e, t) {
          if (e instanceof U) {
            const n = e.nodeBefore, i = e.nodeAfter;
            if (!(n instanceof Ee)) throw new T("schema-check-merge-no-element-before", this);
            if (!(i instanceof Ee)) throw new T("schema-check-merge-no-element-after", this);
            return this.checkMerge(n, i);
          }
          for (const n of t.getChildren()) if (!this.checkChild(e, n)) return !1;
          return !0;
        }
        addChildCheck(e) {
          this.on("checkChild", (t, [n, i]) => {
            if (!i) return;
            const r = e(n, i);
            typeof r == "boolean" && (t.stop(), t.return = r);
          }, { priority: "high" });
        }
        addAttributeCheck(e) {
          this.on("checkAttribute", (t, [n, i]) => {
            const r = e(n, i);
            typeof r == "boolean" && (t.stop(), t.return = r);
          }, { priority: "high" });
        }
        setAttributeProperties(e, t) {
          this._attributeProperties[e] = Object.assign(this.getAttributeProperties(e), t);
        }
        getAttributeProperties(e) {
          return this._attributeProperties[e] || {};
        }
        getLimitElement(e) {
          let t;
          for (e instanceof U ? t = e.parent : t = (e instanceof V ? [e] : Array.from(e.getRanges())).reduce((n, i) => {
            const r = i.getCommonAncestor();
            return n ? n.getCommonAncestor(r, { includeSelf: !0 }) : r;
          }, null); !this.isLimit(t) && t.parent; ) t = t.parent;
          return t;
        }
        checkAttributeInSelection(e, t) {
          if (e.isCollapsed) {
            const n = [...e.getFirstPosition().getAncestors(), new ye("", e.getAttributes())];
            return this.checkAttribute(n, t);
          }
          {
            const n = e.getRanges();
            for (const i of n) for (const r of i) if (this.checkAttribute(r.item, t)) return !0;
          }
          return !1;
        }
        *getValidRanges(e, t) {
          e = function* (n) {
            for (const i of n) yield* i.getMinimalFlatRanges();
          }(e);
          for (const n of e) yield* this._getValidRangesForRange(n, t);
        }
        getNearestSelectionRange(e, t = "both") {
          if (this.checkChild(e, "$text")) return new V(e);
          let n, i;
          const r = e.getAncestors().reverse().find((s) => this.isLimit(s)) || e.root;
          t != "both" && t != "backward" || (n = new Ft({ boundaries: V._createIn(r), startPosition: e, direction: "backward" })), t != "both" && t != "forward" || (i = new Ft({ boundaries: V._createIn(r), startPosition: e }));
          for (const s of function* (a, l) {
            let c = !1;
            for (; !c; ) {
              if (c = !0, a) {
                const d = a.next();
                d.done || (c = !1, yield { walker: a, value: d.value });
              }
              if (l) {
                const d = l.next();
                d.done || (c = !1, yield { walker: l, value: d.value });
              }
            }
          }(n, i)) {
            const a = s.walker == n ? "elementEnd" : "elementStart", l = s.value;
            if (l.type == a && this.isObject(l.item)) return V._createOn(l.item);
            if (this.checkChild(l.nextPosition, "$text")) return new V(l.nextPosition);
          }
          return null;
        }
        findAllowedParent(e, t) {
          let n = e.parent;
          for (; n; ) {
            if (this.checkChild(n, t)) return n;
            if (this.isLimit(n)) return null;
            n = n.parent;
          }
          return null;
        }
        setAllowedAttributes(e, t, n) {
          const i = n.model;
          for (const [r, s] of Object.entries(t)) i.schema.checkAttribute(e, r) && n.setAttribute(r, s, e);
        }
        removeDisallowedAttributes(e, t) {
          for (const n of e) if (n.is("$text")) Vu(this, n, t);
          else {
            const i = V._createIn(n).getPositions();
            for (const r of i)
              Vu(this, r.nodeBefore || r.parent, t);
          }
        }
        getAttributesWithProperty(e, t, n) {
          const i = {};
          for (const [r, s] of e.getAttributes()) {
            const a = this.getAttributeProperties(r);
            a[t] !== void 0 && (n !== void 0 && n !== a[t] || (i[r] = s));
          }
          return i;
        }
        createContext(e) {
          return new Dn(e);
        }
        _clearCache() {
          this._compiledDefinitions = null;
        }
        _compile() {
          const e = {}, t = this._sourceDefinitions, n = Object.keys(t);
          for (const i of n) e[i] = M0(t[i], i);
          for (const i of n) F0(e, i);
          for (const i of n) N0(e, i);
          for (const i of n) V0(e, i);
          for (const i of n) L0(e, i), j0(e, i);
          for (const i of n) $0(e, i), H0(e, i), q0(e, i);
          this._compiledDefinitions = e;
        }
        _checkContextMatch(e, t, n = t.length - 1) {
          const i = t.getItem(n);
          if (e.allowIn.includes(i.name)) {
            if (n == 0) return !0;
            {
              const r = this.getDefinition(i);
              return this._checkContextMatch(r, t, n - 1);
            }
          }
          return !1;
        }
        *_getValidRangesForRange(e, t) {
          let n = e.start, i = e.start;
          for (const r of e.getItems({ shallow: !0 })) r.is("element") && (yield* this._getValidRangesForRange(V._createIn(r), t)), this.checkAttribute(r, t) || (n.isEqual(i) || (yield new V(n, i)), n = U._createAfter(r)), i = U._createAfter(r);
          n.isEqual(i) || (yield new V(n, i));
        }
      }
      class Dn {
        constructor(e) {
          if (e instanceof Dn) return e;
          let t;
          t = typeof e == "string" ? [e] : Array.isArray(e) ? e : e.getAncestors({ includeSelf: !0 }), this._items = t.map(W0);
        }
        get length() {
          return this._items.length;
        }
        get last() {
          return this._items[this._items.length - 1];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
        push(e) {
          const t = new Dn([e]);
          return t._items = [...this._items, ...t._items], t;
        }
        getItem(e) {
          return this._items[e];
        }
        *getNames() {
          yield* this._items.map((e) => e.name);
        }
        endsWith(e) {
          return Array.from(this.getNames()).join(" ").endsWith(e);
        }
        startsWith(e) {
          return Array.from(this.getNames()).join(" ").startsWith(e);
        }
      }
      function M0(o, e) {
        const t = { name: e, allowIn: [], allowContentOf: [], allowWhere: [], allowAttributes: [], allowAttributesOf: [], allowChildren: [], inheritTypesFrom: [] };
        return function(n, i) {
          for (const r of n) {
            const s = Object.keys(r).filter((a) => a.startsWith("is"));
            for (const a of s) i[a] = !!r[a];
          }
        }(o, t), Bn(o, t, "allowIn"), Bn(o, t, "allowContentOf"), Bn(o, t, "allowWhere"), Bn(o, t, "allowAttributes"), Bn(o, t, "allowAttributesOf"), Bn(o, t, "allowChildren"), Bn(o, t, "inheritTypesFrom"), function(n, i) {
          for (const r of n) {
            const s = r.inheritAllFrom;
            s && (i.allowContentOf.push(s), i.allowWhere.push(s), i.allowAttributesOf.push(s), i.inheritTypesFrom.push(s));
          }
        }(o, t), t;
      }
      function F0(o, e) {
        const t = o[e];
        for (const n of t.allowChildren) {
          const i = o[n];
          i && i.allowIn.push(e);
        }
        t.allowChildren.length = 0;
      }
      function N0(o, e) {
        for (const t of o[e].allowContentOf) o[t] && U0(o, t).forEach((n) => {
          n.allowIn.push(e);
        });
        delete o[e].allowContentOf;
      }
      function V0(o, e) {
        for (const t of o[e].allowWhere) {
          const n = o[t];
          if (n) {
            const i = n.allowIn;
            o[e].allowIn.push(...i);
          }
        }
        delete o[e].allowWhere;
      }
      function L0(o, e) {
        for (const t of o[e].allowAttributesOf) {
          const n = o[t];
          if (n) {
            const i = n.allowAttributes;
            o[e].allowAttributes.push(...i);
          }
        }
        delete o[e].allowAttributesOf;
      }
      function j0(o, e) {
        const t = o[e];
        for (const n of t.inheritTypesFrom) {
          const i = o[n];
          if (i) {
            const r = Object.keys(i).filter((s) => s.startsWith("is"));
            for (const s of r) s in t || (t[s] = i[s]);
          }
        }
        delete t.inheritTypesFrom;
      }
      function $0(o, e) {
        const t = o[e], n = t.allowIn.filter((i) => o[i]);
        t.allowIn = Array.from(new Set(n));
      }
      function H0(o, e) {
        const t = o[e];
        for (const n of t.allowIn)
          o[n].allowChildren.push(e);
      }
      function q0(o, e) {
        const t = o[e];
        t.allowAttributes = Array.from(new Set(t.allowAttributes));
      }
      function Bn(o, e, t) {
        for (const n of o) {
          const i = n[t];
          typeof i == "string" ? e[t].push(i) : Array.isArray(i) && e[t].push(...i);
        }
      }
      function U0(o, e) {
        const t = o[e];
        return (n = o, Object.keys(n).map((i) => n[i])).filter((i) => i.allowIn.includes(t.name));
        var n;
      }
      function W0(o) {
        return typeof o == "string" || o.is("documentFragment") ? { name: typeof o == "string" ? o : "$documentFragment", *getAttributeKeys() {
        }, getAttribute() {
        } } : { name: o.is("element") ? o.name : "$text", *getAttributeKeys() {
          yield* o.getAttributeKeys();
        }, getAttribute: (e) => o.getAttribute(e) };
      }
      function Vu(o, e, t) {
        for (const n of e.getAttributeKeys()) o.checkAttribute(e, n) || t.removeAttribute(n, e);
      }
      var K0 = Object.defineProperty, G0 = Object.defineProperties, Z0 = Object.getOwnPropertyDescriptors, Lu = Object.getOwnPropertySymbols, J0 = Object.prototype.hasOwnProperty, Y0 = Object.prototype.propertyIsEnumerable, ju = (o, e, t) => e in o ? K0(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class Q0 extends _e() {
        constructor(e) {
          var t;
          super(), this._splitParts = /* @__PURE__ */ new Map(), this._cursorParents = /* @__PURE__ */ new Map(), this._modelCursor = null, this._emptyElementsToKeep = /* @__PURE__ */ new Set(), this.conversionApi = (t = ((n, i) => {
            for (var r in i || (i = {})) J0.call(i, r) && ju(n, r, i[r]);
            if (Lu) for (var r of Lu(i)) Y0.call(i, r) && ju(n, r, i[r]);
            return n;
          })({}, e), G0(t, Z0({ consumable: null, writer: null, store: null, convertItem: (n, i) => this._convertItem(n, i), convertChildren: (n, i) => this._convertChildren(n, i), safeInsert: (n, i) => this._safeInsert(n, i), updateConversionResult: (n, i) => this._updateConversionResult(n, i), splitToAllowedParent: (n, i) => this._splitToAllowedParent(n, i), getSplitParts: (n) => this._getSplitParts(n), keepEmptyElement: (n) => this._keepEmptyElement(n) })));
        }
        convert(e, t, n = ["$root"]) {
          this.fire("viewCleanup", e), this._modelCursor = function(s, a) {
            let l;
            for (const c of new Dn(s)) {
              const d = {};
              for (const g of c.getAttributeKeys()) d[g] = c.getAttribute(g);
              const u = a.createElement(c.name, d);
              l && a.insert(u, l), l = U._createAt(u, 0);
            }
            return l;
          }(n, t), this.conversionApi.writer = t, this.conversionApi.consumable = Uo.createFrom(e), this.conversionApi.store = {};
          const { modelRange: i } = this._convertItem(e, this._modelCursor), r = t.createDocumentFragment();
          if (i) {
            this._removeEmptyElements();
            for (const s of Array.from(this._modelCursor.parent.getChildren())) t.append(s, r);
            r.markers = function(s, a) {
              const l = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Map(), d = V._createIn(s).getItems();
              for (const u of d) u.is("element", "$marker") && l.add(u);
              for (const u of l) {
                const g = u.getAttribute("data-name"), p = a.createPositionBefore(u);
                c.has(g) ? c.get(g).end = p.clone() : c.set(g, new V(p.clone())), a.remove(u);
              }
              return c;
            }(r, t);
          }
          return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, r;
        }
        _convertItem(e, t) {
          const n = { viewItem: e, modelCursor: t, modelRange: null };
          if (e.is("element") ? this.fire(`element:${e.name}`, n, this.conversionApi) : e.is("$text") ? this.fire("text", n, this.conversionApi) : this.fire("documentFragment", n, this.conversionApi), n.modelRange && !(n.modelRange instanceof V)) throw new T("view-conversion-dispatcher-incorrect-result", this);
          return { modelRange: n.modelRange, modelCursor: n.modelCursor };
        }
        _convertChildren(e, t) {
          let n = t.is("position") ? t : U._createAt(t, 0);
          const i = new V(n);
          for (const r of Array.from(e.getChildren())) {
            const s = this._convertItem(r, n);
            s.modelRange instanceof V && (i.end = s.modelRange.end, n = s.modelCursor);
          }
          return { modelRange: i, modelCursor: n };
        }
        _safeInsert(e, t) {
          const n = this._splitToAllowedParent(e, t);
          return !!n && (this.conversionApi.writer.insert(e, n.position), !0);
        }
        _updateConversionResult(e, t) {
          const n = this._getSplitParts(e), i = this.conversionApi.writer;
          t.modelRange || (t.modelRange = i.createRange(i.createPositionBefore(e), i.createPositionAfter(n[n.length - 1])));
          const r = this._cursorParents.get(e);
          t.modelCursor = r ? i.createPositionAt(r, 0) : t.modelRange.end;
        }
        _splitToAllowedParent(e, t) {
          const { schema: n, writer: i } = this.conversionApi;
          let r = n.findAllowedParent(t, e);
          if (r) {
            if (r === t.parent) return { position: t };
            this._modelCursor.parent.getAncestors().includes(r) && (r = null);
          }
          if (!r) return Du(t, e, n) ? { position: Bu(t, i) } : null;
          const s = this.conversionApi.writer.split(t, r), a = [];
          for (const c of s.range.getWalker()) if (c.type == "elementEnd") a.push(c.item);
          else {
            const d = a.pop(), u = c.item;
            this._registerSplitPair(d, u);
          }
          const l = s.range.end.parent;
          return this._cursorParents.set(e, l), { position: s.position, cursorParent: l };
        }
        _registerSplitPair(e, t) {
          this._splitParts.has(e) || this._splitParts.set(e, [e]);
          const n = this._splitParts.get(e);
          this._splitParts.set(t, n), n.push(t);
        }
        _getSplitParts(e) {
          let t;
          return t = this._splitParts.has(e) ? this._splitParts.get(e) : [e], t;
        }
        _keepEmptyElement(e) {
          this._emptyElementsToKeep.add(e);
        }
        _removeEmptyElements() {
          let e = !1;
          for (const t of this._splitParts.keys()) t.isEmpty && !this._emptyElementsToKeep.has(t) && (this.conversionApi.writer.remove(t), this._splitParts.delete(t), e = !0);
          e && this._removeEmptyElements();
        }
      }
      class X0 {
        getHtml(e) {
          const t = document.implementation.createHTMLDocument("").createElement("div");
          return t.appendChild(e), t.innerHTML;
        }
      }
      class e_ {
        constructor(e) {
          this.skipComments = !0, this.domParser = new DOMParser(), this.domConverter = new Wd(e, { renderingMode: "data" }), this.htmlWriter = new X0();
        }
        toData(e) {
          const t = this.domConverter.viewToDom(e);
          return this.htmlWriter.getHtml(t);
        }
        toView(e) {
          const t = this._toDom(e);
          return this.domConverter.domToView(t, { skipComments: this.skipComments });
        }
        registerRawContentMatcher(e) {
          this.domConverter.registerRawContentMatcher(e);
        }
        useFillerType(e) {
          this.domConverter.blockFillerMode = e == "marked" ? "markedNbsp" : "nbsp";
        }
        _toDom(e) {
          e.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (e = `<body>${e}</body>`);
          const t = this.domParser.parseFromString(e, "text/html"), n = t.createDocumentFragment(), i = t.body.childNodes;
          for (; i.length > 0; ) n.appendChild(i[0]);
          return n;
        }
      }
      class t_ extends _e() {
        constructor(e, t) {
          super(), this.model = e, this.mapper = new du(), this.downcastDispatcher = new mu({ mapper: this.mapper, schema: e.schema }), this.downcastDispatcher.on("insert:$text", (n, i, r) => {
            if (!r.consumable.consume(i.item, n.name)) return;
            const s = r.writer, a = r.mapper.toViewPosition(i.range.start), l = s.createText(i.item.data);
            s.insert(a, l);
          }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (n, i, r) => {
            r.convertAttributes(i.item), i.reconversion || !i.item.is("element") || i.item.isEmpty || r.convertChildren(i.item);
          }, { priority: "lowest" }), this.upcastDispatcher = new Q0({ schema: e.schema }), this.viewDocument = new Pd(t), this.stylesProcessor = t, this.htmlProcessor = new e_(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new Rd(this.viewDocument), this.upcastDispatcher.on("text", (n, i, { schema: r, consumable: s, writer: a }) => {
            let l = i.modelCursor;
            if (!s.test(i.viewItem)) return;
            if (!r.checkChild(l, "$text")) {
              if (!Du(l, "$text", r) || i.viewItem.data.trim().length == 0) return;
              const d = l.nodeBefore;
              l = Bu(l, a), d && d.is("element", "$marker") && (a.move(a.createRangeOn(d), l), l = a.createPositionAfter(d));
            }
            s.consume(i.viewItem);
            const c = a.createText(i.viewItem.data);
            a.insert(c, l), i.modelRange = a.createRange(l, l.getShiftedBy(c.offsetSize)), i.modelCursor = i.modelRange.end;
          }, { priority: "lowest" }), this.upcastDispatcher.on("element", (n, i, r) => {
            if (!i.modelRange && r.consumable.consume(i.viewItem, { name: !0 })) {
              const { modelRange: s, modelCursor: a } = r.convertChildren(i.viewItem, i.modelCursor);
              i.modelRange = s, i.modelCursor = a;
            }
          }, { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", (n, i, r) => {
            if (!i.modelRange && r.consumable.consume(i.viewItem, { name: !0 })) {
              const { modelRange: s, modelCursor: a } = r.convertChildren(i.viewItem, i.modelCursor);
              i.modelRange = s, i.modelCursor = a;
            }
          }, { priority: "lowest" }), ve().prototype.decorate.call(this, "init"), ve().prototype.decorate.call(this, "set"), ve().prototype.decorate.call(this, "get"), ve().prototype.decorate.call(this, "toView"), ve().prototype.decorate.call(this, "toModel"), this.on("init", () => {
            this.fire("ready");
          }, { priority: "lowest" }), this.on("ready", () => {
            this.model.enqueueChange({ isUndoable: !1 }, Su);
          }, { priority: "lowest" });
        }
        get(e = {}) {
          const { rootName: t = "main", trim: n = "empty" } = e;
          if (!this._checkIfRootsExists([t])) throw new T("datacontroller-get-non-existent-root", this);
          const i = this.model.document.getRoot(t);
          return i.isAttached() || ee("datacontroller-get-detached-root", this), n !== "empty" || this.model.hasContent(i, { ignoreWhitespaces: !0 }) ? this.stringify(i, e) : "";
        }
        stringify(e, t = {}) {
          const n = this.toView(e, t);
          return this.processor.toData(n);
        }
        toView(e, t = {}) {
          const n = this.viewDocument, i = this._viewWriter;
          this.mapper.clearBindings();
          const r = V._createIn(e), s = new En(n);
          this.mapper.bindElements(e, s);
          const a = e.is("documentFragment") ? e.markers : function(l) {
            const c = [], d = l.root.document;
            if (!d) return /* @__PURE__ */ new Map();
            const u = V._createIn(l);
            for (const g of d.model.markers) {
              const p = g.getRange(), b = p.isCollapsed, w = p.start.isEqual(u.start) || p.end.isEqual(u.end);
              if (b && w) c.push([g.name, p]);
              else {
                const y = u.getIntersection(p);
                y && c.push([g.name, y]);
              }
            }
            return c.sort(([g, p], [b, w]) => {
              if (p.end.compareWith(w.start) !== "after") return 1;
              if (p.start.compareWith(w.end) !== "before") return -1;
              switch (p.start.compareWith(w.start)) {
                case "before":
                  return 1;
                case "after":
                  return -1;
                default:
                  switch (p.end.compareWith(w.end)) {
                    case "before":
                      return 1;
                    case "after":
                      return -1;
                    default:
                      return b.localeCompare(g);
                  }
              }
            }), new Map(c);
          }(e);
          return this.downcastDispatcher.convert(r, a, i, t), s;
        }
        init(e) {
          if (this.model.document.version) throw new T("datacontroller-init-document-not-empty", this);
          let t = {};
          if (typeof e == "string" ? t.main = e : t = e, !this._checkIfRootsExists(Object.keys(t))) throw new T("datacontroller-init-non-existent-root", this);
          return this.model.enqueueChange({ isUndoable: !1 }, (n) => {
            for (const i of Object.keys(t)) {
              const r = this.model.document.getRoot(i);
              n.insert(this.parse(t[i], r), r, 0);
            }
          }), Promise.resolve();
        }
        set(e, t = {}) {
          let n = {};
          if (typeof e == "string" ? n.main = e : n = e, !this._checkIfRootsExists(Object.keys(n))) throw new T("datacontroller-set-non-existent-root", this);
          this.model.enqueueChange(t.batchType || {}, (i) => {
            i.setSelection(null), i.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
            for (const r of Object.keys(n)) {
              const s = this.model.document.getRoot(r);
              i.remove(i.createRangeIn(s)), i.insert(this.parse(n[r], s), s, 0);
            }
          });
        }
        parse(e, t = "$root") {
          const n = this.processor.toView(e);
          return this.toModel(n, t);
        }
        toModel(e, t = "$root") {
          return this.model.change((n) => this.upcastDispatcher.convert(e, n, t));
        }
        addStyleProcessorRules(e) {
          e(this.stylesProcessor);
        }
        registerRawContentMatcher(e) {
          this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(e), this.htmlProcessor.registerRawContentMatcher(e);
        }
        destroy() {
          this.stopListening();
        }
        _checkIfRootsExists(e) {
          for (const t of e) if (!this.model.document.getRoot(t)) return !1;
          return !0;
        }
      }
      class n_ {
        constructor(e, t) {
          this._helpers = /* @__PURE__ */ new Map(), this._downcast = $e(e), this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: !0 }), this._upcast = $e(t), this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: !1 });
        }
        addAlias(e, t) {
          const n = this._downcast.includes(t);
          if (!this._upcast.includes(t) && !n) throw new T("conversion-add-alias-dispatcher-not-registered", this);
          this._createConversionHelpers({ name: e, dispatchers: [t], isDowncast: n });
        }
        for(e) {
          if (!this._helpers.has(e)) throw new T("conversion-for-unknown-group", this);
          return this._helpers.get(e);
        }
        elementToElement(e) {
          this.for("downcast").elementToElement(e);
          for (const { model: t, view: n } of Ks(e)) this.for("upcast").elementToElement({ model: t, view: n, converterPriority: e.converterPriority });
        }
        attributeToElement(e) {
          this.for("downcast").attributeToElement(e);
          for (const { model: t, view: n } of Ks(e)) this.for("upcast").elementToAttribute({ view: n, model: t, converterPriority: e.converterPriority });
        }
        attributeToAttribute(e) {
          this.for("downcast").attributeToAttribute(e);
          for (const { model: t, view: n } of Ks(e)) this.for("upcast").attributeToAttribute({ view: n, model: t });
        }
        _createConversionHelpers({ name: e, dispatchers: t, isDowncast: n }) {
          if (this._helpers.has(e)) throw new T("conversion-group-exists", this);
          const i = n ? new C0(t) : new I0(t);
          this._helpers.set(e, i);
        }
      }
      function* Ks(o) {
        if (o.model.values) for (const e of o.model.values) {
          const t = { key: o.model.key, value: e }, n = o.view[e], i = o.upcastAlso ? o.upcastAlso[e] : void 0;
          yield* $u(t, n, i);
        }
        else yield* $u(o.model, o.view, o.upcastAlso);
      }
      function* $u(o, e, t) {
        if (yield { model: o, view: e }, t) for (const n of $e(t)) yield { model: o, view: n };
      }
      class bt {
        constructor(e) {
          this.baseVersion = e, this.isDocumentOperation = this.baseVersion !== null, this.batch = null;
        }
        _validate() {
        }
        toJSON() {
          const e = Object.assign({}, this);
          return e.__className = this.constructor.className, delete e.batch, delete e.isDocumentOperation, e;
        }
        static get className() {
          return "Operation";
        }
        static fromJSON(e, t) {
          return new this(e.baseVersion);
        }
      }
      function Gs(o, e) {
        const t = qu(e), n = t.reduce((s, a) => s + a.offsetSize, 0), i = o.parent;
        Go(o);
        const r = o.index;
        return i._insertChild(r, t), Ko(i, r + t.length), Ko(i, r), new V(o, o.getShiftedBy(n));
      }
      function Hu(o) {
        if (!o.isFlat) throw new T("operation-utils-remove-range-not-flat", this);
        const e = o.start.parent;
        Go(o.start), Go(o.end);
        const t = e._removeChildren(o.start.index, o.end.index - o.start.index);
        return Ko(e, o.start.index), t;
      }
      function Wo(o, e) {
        if (!o.isFlat) throw new T("operation-utils-move-range-not-flat", this);
        const t = Hu(o);
        return Gs(e = e._getTransformedByDeletion(o.start, o.end.offset - o.start.offset), t);
      }
      function qu(o) {
        const e = [];
        (function t(n) {
          if (typeof n == "string") e.push(new ye(n));
          else if (n instanceof xt) e.push(new ye(n.data, n.getAttributes()));
          else if (n instanceof xn) e.push(n);
          else if (gt(n)) for (const i of n) t(i);
        })(o);
        for (let t = 1; t < e.length; t++) {
          const n = e[t], i = e[t - 1];
          n instanceof ye && i instanceof ye && Uu(n, i) && (e.splice(t - 1, 2, new ye(i.data + n.data, i.getAttributes())), t--);
        }
        return e;
      }
      function Ko(o, e) {
        const t = o.getChild(e - 1), n = o.getChild(e);
        if (t && n && t.is("$text") && n.is("$text") && Uu(t, n)) {
          const i = new ye(t.data + n.data, t.getAttributes());
          o._removeChildren(e - 1, 2), o._insertChild(e - 1, i);
        }
      }
      function Go(o) {
        const e = o.textNode, t = o.parent;
        if (e) {
          const n = o.offset - e.startOffset, i = e.index;
          t._removeChildren(i, 1);
          const r = new ye(e.data.substr(0, n), e.getAttributes()), s = new ye(e.data.substr(n), e.getAttributes());
          t._insertChild(i, [r, s]);
        }
      }
      function Uu(o, e) {
        const t = o.getAttributes(), n = e.getAttributes();
        for (const i of t) {
          if (i[1] !== e.getAttribute(i[0])) return !1;
          n.next();
        }
        return n.next().done;
      }
      class fe extends bt {
        constructor(e, t, n, i) {
          super(i), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNone";
        }
        get type() {
          return this.targetPosition.root.rootName == "$graveyard" ? "remove" : this.sourcePosition.root.rootName == "$graveyard" ? "reinsert" : "move";
        }
        get affectedSelectable() {
          return [V._createFromPositionAndShift(this.sourcePosition, this.howMany), V._createFromPositionAndShift(this.targetPosition, 0)];
        }
        clone() {
          return new fe(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
        }
        getReversed() {
          const e = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
          return new fe(this.getMovedRangeStart(), this.howMany, e, this.baseVersion + 1);
        }
        _validate() {
          const e = this.sourcePosition.parent, t = this.targetPosition.parent, n = this.sourcePosition.offset, i = this.targetPosition.offset;
          if (n + this.howMany > e.maxOffset) throw new T("move-operation-nodes-do-not-exist", this);
          if (e === t && n < i && i < n + this.howMany) throw new T("move-operation-range-into-itself", this);
          if (this.sourcePosition.root == this.targetPosition.root && ot(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
            const r = this.sourcePosition.path.length - 1;
            if (this.targetPosition.path[r] >= n && this.targetPosition.path[r] < n + this.howMany) throw new T("move-operation-node-into-itself", this);
          }
        }
        _execute() {
          Wo(V._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
        }
        toJSON() {
          const e = super.toJSON();
          return e.sourcePosition = this.sourcePosition.toJSON(), e.targetPosition = this.targetPosition.toJSON(), e;
        }
        static get className() {
          return "MoveOperation";
        }
        static fromJSON(e, t) {
          const n = U.fromJSON(e.sourcePosition, t), i = U.fromJSON(e.targetPosition, t);
          return new this(n, e.howMany, i, e.baseVersion);
        }
      }
      class et extends bt {
        constructor(e, t, n) {
          super(n), this.position = e.clone(), this.position.stickiness = "toNone", this.nodes = new $o(qu(t)), this.shouldReceiveAttributes = !1;
        }
        get type() {
          return "insert";
        }
        get howMany() {
          return this.nodes.maxOffset;
        }
        get affectedSelectable() {
          return this.position.clone();
        }
        clone() {
          const e = new $o([...this.nodes].map((n) => n._clone(!0))), t = new et(this.position, e, this.baseVersion);
          return t.shouldReceiveAttributes = this.shouldReceiveAttributes, t;
        }
        getReversed() {
          const e = this.position.root.document.graveyard, t = new U(e, [0]);
          return new fe(this.position, this.nodes.maxOffset, t, this.baseVersion + 1);
        }
        _validate() {
          const e = this.position.parent;
          if (!e || e.maxOffset < this.position.offset) throw new T("insert-operation-position-invalid", this);
        }
        _execute() {
          const e = this.nodes;
          this.nodes = new $o([...e].map((t) => t._clone(!0))), Gs(this.position, e);
        }
        toJSON() {
          const e = super.toJSON();
          return e.position = this.position.toJSON(), e.nodes = this.nodes.toJSON(), e;
        }
        static get className() {
          return "InsertOperation";
        }
        static fromJSON(e, t) {
          const n = [];
          for (const r of e.nodes) r.name ? n.push(Ee.fromJSON(r)) : n.push(ye.fromJSON(r));
          const i = new et(U.fromJSON(e.position, t), n, e.baseVersion);
          return i.shouldReceiveAttributes = e.shouldReceiveAttributes, i;
        }
      }
      class xe extends bt {
        constructor(e, t, n, i, r) {
          super(r), this.splitPosition = e.clone(), this.splitPosition.stickiness = "toNext", this.howMany = t, this.insertionPosition = n, this.graveyardPosition = i ? i.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
        }
        get type() {
          return "split";
        }
        get moveTargetPosition() {
          const e = this.insertionPosition.path.slice();
          return e.push(0), new U(this.insertionPosition.root, e);
        }
        get movedRange() {
          const e = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new V(this.splitPosition, e);
        }
        get affectedSelectable() {
          const e = [V._createFromPositionAndShift(this.splitPosition, 0), V._createFromPositionAndShift(this.insertionPosition, 0)];
          return this.graveyardPosition && e.push(V._createFromPositionAndShift(this.graveyardPosition, 0)), e;
        }
        clone() {
          return new xe(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
        }
        getReversed() {
          const e = this.splitPosition.root.document.graveyard, t = new U(e, [0]);
          return new He(this.moveTargetPosition, this.howMany, this.splitPosition, t, this.baseVersion + 1);
        }
        _validate() {
          const e = this.splitPosition.parent, t = this.splitPosition.offset;
          if (!e || e.maxOffset < t) throw new T("split-operation-position-invalid", this);
          if (!e.parent) throw new T("split-operation-split-in-root", this);
          if (this.howMany != e.maxOffset - this.splitPosition.offset) throw new T("split-operation-how-many-invalid", this);
          if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) throw new T("split-operation-graveyard-position-invalid", this);
        }
        _execute() {
          const e = this.splitPosition.parent;
          if (this.graveyardPosition) Wo(V._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
          else {
            const t = e._clone();
            Gs(this.insertionPosition, t);
          }
          Wo(new V(U._createAt(e, this.splitPosition.offset), U._createAt(e, e.maxOffset)), this.moveTargetPosition);
        }
        toJSON() {
          const e = super.toJSON();
          return e.splitPosition = this.splitPosition.toJSON(), e.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (e.graveyardPosition = this.graveyardPosition.toJSON()), e;
        }
        static get className() {
          return "SplitOperation";
        }
        static getInsertionPosition(e) {
          const t = e.path.slice(0, -1);
          return t[t.length - 1]++, new U(e.root, t, "toPrevious");
        }
        static fromJSON(e, t) {
          const n = U.fromJSON(e.splitPosition, t), i = U.fromJSON(e.insertionPosition, t), r = e.graveyardPosition ? U.fromJSON(e.graveyardPosition, t) : null;
          return new this(n, e.howMany, i, r, e.baseVersion);
        }
      }
      class He extends bt {
        constructor(e, t, n, i, r) {
          super(r), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = i.clone();
        }
        get type() {
          return "merge";
        }
        get deletionPosition() {
          return new U(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
        }
        get movedRange() {
          const e = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new V(this.sourcePosition, e);
        }
        get affectedSelectable() {
          const e = this.sourcePosition.parent;
          return [V._createOn(e), V._createFromPositionAndShift(this.targetPosition, 0), V._createFromPositionAndShift(this.graveyardPosition, 0)];
        }
        clone() {
          return new He(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
        }
        getReversed() {
          const e = this.targetPosition._getTransformedByMergeOperation(this), t = this.sourcePosition.path.slice(0, -1), n = new U(this.sourcePosition.root, t)._getTransformedByMergeOperation(this);
          return new xe(e, this.howMany, n, this.graveyardPosition, this.baseVersion + 1);
        }
        _validate() {
          const e = this.sourcePosition.parent, t = this.targetPosition.parent;
          if (!e.parent) throw new T("merge-operation-source-position-invalid", this);
          if (!t.parent) throw new T("merge-operation-target-position-invalid", this);
          if (this.howMany != e.maxOffset) throw new T("merge-operation-how-many-invalid", this);
        }
        _execute() {
          const e = this.sourcePosition.parent;
          Wo(V._createIn(e), this.targetPosition), Wo(V._createOn(e), this.graveyardPosition);
        }
        toJSON() {
          const e = super.toJSON();
          return e.sourcePosition = e.sourcePosition.toJSON(), e.targetPosition = e.targetPosition.toJSON(), e.graveyardPosition = e.graveyardPosition.toJSON(), e;
        }
        static get className() {
          return "MergeOperation";
        }
        static fromJSON(e, t) {
          const n = U.fromJSON(e.sourcePosition, t), i = U.fromJSON(e.targetPosition, t), r = U.fromJSON(e.graveyardPosition, t);
          return new this(n, e.howMany, i, r, e.baseVersion);
        }
      }
      class lt extends bt {
        constructor(e, t, n, i, r, s) {
          super(s), this.name = e, this.oldRange = t ? t.clone() : null, this.newRange = n ? n.clone() : null, this.affectsData = r, this._markers = i;
        }
        get type() {
          return "marker";
        }
        get affectedSelectable() {
          const e = [];
          return this.oldRange && e.push(this.oldRange.clone()), this.newRange && (this.oldRange ? e.push(...this.newRange.getDifference(this.oldRange)) : e.push(this.newRange.clone())), e;
        }
        clone() {
          return new lt(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
        }
        getReversed() {
          return new lt(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
        }
        _execute() {
          this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name);
        }
        toJSON() {
          const e = super.toJSON();
          return this.oldRange && (e.oldRange = this.oldRange.toJSON()), this.newRange && (e.newRange = this.newRange.toJSON()), delete e._markers, e;
        }
        static get className() {
          return "MarkerOperation";
        }
        static fromJSON(e, t) {
          return new lt(e.name, e.oldRange ? V.fromJSON(e.oldRange, t) : null, e.newRange ? V.fromJSON(e.newRange, t) : null, t.model.markers, e.affectsData, e.baseVersion);
        }
      }
      const qi = function(o, e) {
        return ou(o, e);
      };
      class Ge extends bt {
        constructor(e, t, n, i, r) {
          super(r), this.range = e.clone(), this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = i === void 0 ? null : i;
        }
        get type() {
          return this.oldValue === null ? "addAttribute" : this.newValue === null ? "removeAttribute" : "changeAttribute";
        }
        get affectedSelectable() {
          return this.range.clone();
        }
        clone() {
          return new Ge(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new Ge(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        toJSON() {
          const e = super.toJSON();
          return e.range = this.range.toJSON(), e;
        }
        _validate() {
          if (!this.range.isFlat) throw new T("attribute-operation-range-not-flat", this);
          for (const e of this.range.getItems({ shallow: !0 })) {
            if (this.oldValue !== null && !qi(e.getAttribute(this.key), this.oldValue)) throw new T("attribute-operation-wrong-old-value", this, { item: e, key: this.key, value: this.oldValue });
            if (this.oldValue === null && this.newValue !== null && e.hasAttribute(this.key)) throw new T("attribute-operation-attribute-exists", this, { node: e, key: this.key });
          }
        }
        _execute() {
          qi(this.oldValue, this.newValue) || function(e, t, n) {
            Go(e.start), Go(e.end);
            for (const i of e.getItems({ shallow: !0 })) {
              const r = i.is("$textProxy") ? i.textNode : i;
              n !== null ? r._setAttribute(t, n) : r._removeAttribute(t), Ko(r.parent, r.index);
            }
            Ko(e.end.parent, e.end.index);
          }(this.range, this.key, this.newValue);
        }
        static get className() {
          return "AttributeOperation";
        }
        static fromJSON(e, t) {
          return new Ge(V.fromJSON(e.range, t), e.key, e.oldValue, e.newValue, e.baseVersion);
        }
      }
      class Xe extends bt {
        get type() {
          return "noop";
        }
        get affectedSelectable() {
          return null;
        }
        clone() {
          return new Xe(this.baseVersion);
        }
        getReversed() {
          return new Xe(this.baseVersion + 1);
        }
        _execute() {
        }
        static get className() {
          return "NoOperation";
        }
      }
      class ct extends bt {
        constructor(e, t, n, i) {
          super(i), this.position = e, this.position.stickiness = "toNext", this.oldName = t, this.newName = n;
        }
        get type() {
          return "rename";
        }
        get affectedSelectable() {
          return this.position.nodeAfter;
        }
        clone() {
          return new ct(this.position.clone(), this.oldName, this.newName, this.baseVersion);
        }
        getReversed() {
          return new ct(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
        }
        _validate() {
          const e = this.position.nodeAfter;
          if (!(e instanceof Ee)) throw new T("rename-operation-wrong-position", this);
          if (e.name !== this.oldName) throw new T("rename-operation-wrong-name", this);
        }
        _execute() {
          this.position.nodeAfter.name = this.newName;
        }
        toJSON() {
          const e = super.toJSON();
          return e.position = this.position.toJSON(), e;
        }
        static get className() {
          return "RenameOperation";
        }
        static fromJSON(e, t) {
          return new ct(U.fromJSON(e.position, t), e.oldName, e.newName, e.baseVersion);
        }
      }
      class Ut extends bt {
        constructor(e, t, n, i, r) {
          super(r), this.root = e, this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = i === void 0 ? null : i;
        }
        get type() {
          return this.oldValue === null ? "addRootAttribute" : this.newValue === null ? "removeRootAttribute" : "changeRootAttribute";
        }
        get affectedSelectable() {
          return this.root;
        }
        clone() {
          return new Ut(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new Ut(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        _validate() {
          if (this.root != this.root.root || this.root.is("documentFragment")) throw new T("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
          if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) throw new T("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
          if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) throw new T("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
        }
        _execute() {
          this.newValue !== null ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
        }
        toJSON() {
          const e = super.toJSON();
          return e.root = this.root.toJSON(), e;
        }
        static get className() {
          return "RootAttributeOperation";
        }
        static fromJSON(e, t) {
          if (!t.getRoot(e.root)) throw new T("rootattribute-operation-fromjson-no-root", this, { rootName: e.root });
          return new Ut(t.getRoot(e.root), e.key, e.oldValue, e.newValue, e.baseVersion);
        }
      }
      class Nt extends bt {
        constructor(e, t, n, i, r) {
          super(r), this.rootName = e, this.elementName = t, this.isAdd = n, this._document = i, !this._document.getRoot(this.rootName) && (this._document.createRoot(this.elementName, this.rootName)._isAttached = !1);
        }
        get type() {
          return this.isAdd ? "addRoot" : "detachRoot";
        }
        get affectedSelectable() {
          return this._document.getRoot(this.rootName);
        }
        clone() {
          return new Nt(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
        }
        getReversed() {
          return new Nt(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
        }
        _validate() {
          const e = this._document.getRoot(this.rootName);
          if (e.isAttached() && this.isAdd) throw new T("root-operation-root-attached", this);
          if (!e.isAttached() && !this.isAdd) throw new T("root-operation-root-detached", this);
        }
        _execute() {
          this._document.getRoot(this.rootName)._isAttached = this.isAdd;
        }
        toJSON() {
          const e = super.toJSON();
          return delete e._document, e;
        }
        static get className() {
          return "RootOperation";
        }
        static fromJSON(e, t) {
          return new Nt(e.rootName, e.elementName, e.isAdd, t, e.baseVersion);
        }
      }
      const vt = {};
      vt[Ge.className] = Ge, vt[et.className] = et, vt[lt.className] = lt, vt[fe.className] = fe, vt[Xe.className] = Xe, vt[bt.className] = bt, vt[ct.className] = ct, vt[Ut.className] = Ut, vt[Nt.className] = Nt, vt[xe.className] = xe, vt[He.className] = He;
      class o_ {
        static fromJSON(e, t) {
          return vt[e.__className].fromJSON(e, t);
        }
      }
      const Zs = /* @__PURE__ */ new Map();
      function me(o, e, t) {
        let n = Zs.get(o);
        n || (n = /* @__PURE__ */ new Map(), Zs.set(o, n)), n.set(e, t);
      }
      function i_(o) {
        return [o];
      }
      function Wu(o, e, t = {}) {
        const n = function(i, r) {
          const s = Zs.get(i);
          return s && s.has(r) ? s.get(r) : i_;
        }(o.constructor, e.constructor);
        try {
          return n(o = o.clone(), e, t);
        } catch (i) {
          throw i;
        }
      }
      function r_(o, e, t) {
        o = o.slice(), e = e.slice();
        const n = new s_(t.document, t.useRelations, t.forceWeakRemove);
        n.setOriginalOperations(o), n.setOriginalOperations(e);
        const i = n.originalOperations;
        if (o.length == 0 || e.length == 0) return { operationsA: o, operationsB: e, originalOperations: i };
        const r = /* @__PURE__ */ new WeakMap();
        for (const l of o) r.set(l, 0);
        const s = { nextBaseVersionA: o[o.length - 1].baseVersion + 1, nextBaseVersionB: e[e.length - 1].baseVersion + 1, originalOperationsACount: o.length, originalOperationsBCount: e.length };
        let a = 0;
        for (; a < o.length; ) {
          const l = o[a], c = r.get(l);
          if (c == e.length) {
            a++;
            continue;
          }
          const d = e[c], u = Wu(l, d, n.getContext(l, d, !0)), g = Wu(d, l, n.getContext(d, l, !1));
          n.updateRelation(l, d), n.setOriginalOperations(u, l), n.setOriginalOperations(g, d);
          for (const p of u) r.set(p, c + g.length);
          o.splice(a, 1, ...u), e.splice(c, 1, ...g);
        }
        return Ku(o, s.nextBaseVersionB), Ku(e, s.nextBaseVersionA), { operationsA: o, operationsB: e, originalOperations: i };
      }
      class s_ {
        constructor(e, t, n = !1) {
          this.originalOperations = /* @__PURE__ */ new Map(), this._history = e.history, this._useRelations = t, this._forceWeakRemove = !!n, this._relations = /* @__PURE__ */ new Map();
        }
        setOriginalOperations(e, t = null) {
          const n = t ? this.originalOperations.get(t) : null;
          for (const i of e) this.originalOperations.set(i, n || i);
        }
        updateRelation(e, t) {
          if (e instanceof fe) t instanceof He ? e.targetPosition.isEqual(t.sourcePosition) || t.movedRange.containsPosition(e.targetPosition) ? this._setRelation(e, t, "insertAtSource") : e.targetPosition.isEqual(t.deletionPosition) ? this._setRelation(e, t, "insertBetween") : e.targetPosition.isAfter(t.sourcePosition) && this._setRelation(e, t, "moveTargetAfter") : t instanceof fe && (e.targetPosition.isEqual(t.sourcePosition) || e.targetPosition.isBefore(t.sourcePosition) ? this._setRelation(e, t, "insertBefore") : this._setRelation(e, t, "insertAfter"));
          else if (e instanceof xe) {
            if (t instanceof He) e.splitPosition.isBefore(t.sourcePosition) && this._setRelation(e, t, "splitBefore");
            else if (t instanceof fe) if (e.splitPosition.isEqual(t.sourcePosition) || e.splitPosition.isBefore(t.sourcePosition)) this._setRelation(e, t, "splitBefore");
            else {
              const n = V._createFromPositionAndShift(t.sourcePosition, t.howMany);
              if (e.splitPosition.hasSameParentAs(t.sourcePosition) && n.containsPosition(e.splitPosition)) {
                const i = n.end.offset - e.splitPosition.offset, r = e.splitPosition.offset - n.start.offset;
                this._setRelation(e, t, { howMany: i, offset: r });
              }
            }
          } else if (e instanceof He) t instanceof He ? (e.targetPosition.isEqual(t.sourcePosition) || this._setRelation(e, t, "mergeTargetNotMoved"), e.sourcePosition.isEqual(t.targetPosition) && this._setRelation(e, t, "mergeSourceNotMoved"), e.sourcePosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeSameElement")) : t instanceof xe && e.sourcePosition.isEqual(t.splitPosition) && this._setRelation(e, t, "splitAtSource");
          else if (e instanceof lt) {
            const n = e.newRange;
            if (!n) return;
            if (t instanceof fe) {
              const i = V._createFromPositionAndShift(t.sourcePosition, t.howMany), r = i.containsPosition(n.start) || i.start.isEqual(n.start), s = i.containsPosition(n.end) || i.end.isEqual(n.end);
              !r && !s || i.containsRange(n) || this._setRelation(e, t, { side: r ? "left" : "right", path: r ? n.start.path.slice() : n.end.path.slice() });
            } else if (t instanceof He) {
              const i = n.start.isEqual(t.targetPosition), r = n.start.isEqual(t.deletionPosition), s = n.end.isEqual(t.deletionPosition), a = n.end.isEqual(t.sourcePosition);
              (i || r || s || a) && this._setRelation(e, t, { wasInLeftElement: i, wasStartBeforeMergedElement: r, wasEndBeforeMergedElement: s, wasInRightElement: a });
            }
          }
        }
        getContext(e, t, n) {
          return { aIsStrong: n, aWasUndone: this._wasUndone(e), bWasUndone: this._wasUndone(t), abRelation: this._useRelations ? this._getRelation(e, t) : null, baRelation: this._useRelations ? this._getRelation(t, e) : null, forceWeakRemove: this._forceWeakRemove };
        }
        _wasUndone(e) {
          const t = this.originalOperations.get(e);
          return t.wasUndone || this._history.isUndoneOperation(t);
        }
        _getRelation(e, t) {
          const n = this.originalOperations.get(t), i = this._history.getUndoneOperation(n);
          if (!i) return null;
          const r = this.originalOperations.get(e), s = this._relations.get(r);
          return s && s.get(i) || null;
        }
        _setRelation(e, t, n) {
          const i = this.originalOperations.get(e), r = this.originalOperations.get(t);
          let s = this._relations.get(i);
          s || (s = /* @__PURE__ */ new Map(), this._relations.set(i, s)), s.set(r, n);
        }
      }
      function Ku(o, e) {
        for (const t of o) t.baseVersion = e++;
      }
      function Gu(o, e, t) {
        const n = o.nodes.getNode(0).getAttribute(e);
        if (n == t) return null;
        const i = new V(o.position, o.position.getShiftedBy(o.howMany));
        return new Ge(i, e, n, t, 0);
      }
      function Zu(o, e) {
        return o.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null;
      }
      function so(o, e) {
        const t = [];
        for (let n = 0; n < o.length; n++) {
          const i = o[n], r = new fe(i.start, i.end.offset - i.start.offset, e, 0);
          t.push(r);
          for (let s = n + 1; s < o.length; s++) o[s] = o[s]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0];
          e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany);
        }
        return t;
      }
      me(Ge, Ge, (o, e, t) => {
        if (o.key === e.key && o.range.start.hasSameParentAs(e.range.start)) {
          const n = o.range.getDifference(e.range).map((r) => new Ge(r, o.key, o.oldValue, o.newValue, 0)), i = o.range.getIntersection(e.range);
          return i && t.aIsStrong && n.push(new Ge(i, e.key, e.newValue, o.newValue, 0)), n.length == 0 ? [new Xe(0)] : n;
        }
        return [o];
      }), me(Ge, et, (o, e) => {
        if (o.range.start.hasSameParentAs(e.position) && o.range.containsPosition(e.position)) {
          const t = o.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes).map((n) => new Ge(n, o.key, o.oldValue, o.newValue, o.baseVersion));
          if (e.shouldReceiveAttributes) {
            const n = Gu(e, o.key, o.oldValue);
            n && t.unshift(n);
          }
          return t;
        }
        return o.range = o.range._getTransformedByInsertion(e.position, e.howMany, !1)[0], [o];
      }), me(Ge, He, (o, e) => {
        const t = [];
        o.range.start.hasSameParentAs(e.deletionPosition) && (o.range.containsPosition(e.deletionPosition) || o.range.start.isEqual(e.deletionPosition)) && t.push(V._createFromPositionAndShift(e.graveyardPosition, 1));
        const n = o.range._getTransformedByMergeOperation(e);
        return n.isCollapsed || t.push(n), t.map((i) => new Ge(i, o.key, o.oldValue, o.newValue, o.baseVersion));
      }), me(Ge, fe, (o, e) => function(n, i) {
        const r = V._createFromPositionAndShift(i.sourcePosition, i.howMany);
        let s = null, a = [];
        r.containsRange(n, !0) ? s = n : n.start.hasSameParentAs(r.start) ? (a = n.getDifference(r), s = n.getIntersection(r)) : a = [n];
        const l = [];
        for (let c of a) {
          c = c._getTransformedByDeletion(i.sourcePosition, i.howMany);
          const d = i.getMovedRangeStart(), u = c.start.hasSameParentAs(d), g = c._getTransformedByInsertion(d, i.howMany, u);
          l.push(...g);
        }
        return s && l.push(s._getTransformedByMove(i.sourcePosition, i.targetPosition, i.howMany, !1)[0]), l;
      }(o.range, e).map((n) => new Ge(n, o.key, o.oldValue, o.newValue, o.baseVersion))), me(Ge, xe, (o, e) => {
        if (o.range.end.isEqual(e.insertionPosition)) return e.graveyardPosition || o.range.end.offset++, [o];
        if (o.range.start.hasSameParentAs(e.splitPosition) && o.range.containsPosition(e.splitPosition)) {
          const t = o.clone();
          return t.range = new V(e.moveTargetPosition.clone(), o.range.end._getCombined(e.splitPosition, e.moveTargetPosition)), o.range.end = e.splitPosition.clone(), o.range.end.stickiness = "toPrevious", [o, t];
        }
        return o.range = o.range._getTransformedBySplitOperation(e), [o];
      }), me(et, Ge, (o, e) => {
        const t = [o];
        if (o.shouldReceiveAttributes && o.position.hasSameParentAs(e.range.start) && e.range.containsPosition(o.position)) {
          const n = Gu(o, e.key, e.newValue);
          n && t.push(n);
        }
        return t;
      }), me(et, et, (o, e, t) => (o.position.isEqual(e.position) && t.aIsStrong || (o.position = o.position._getTransformedByInsertOperation(e)), [o])), me(et, fe, (o, e) => (o.position = o.position._getTransformedByMoveOperation(e), [o])), me(et, xe, (o, e) => (o.position = o.position._getTransformedBySplitOperation(e), [o])), me(et, He, (o, e) => (o.position = o.position._getTransformedByMergeOperation(e), [o])), me(lt, et, (o, e) => (o.oldRange && (o.oldRange = o.oldRange._getTransformedByInsertOperation(e)[0]), o.newRange && (o.newRange = o.newRange._getTransformedByInsertOperation(e)[0]), [o])), me(lt, lt, (o, e, t) => {
        if (o.name == e.name) {
          if (!t.aIsStrong) return [new Xe(0)];
          o.oldRange = e.newRange ? e.newRange.clone() : null;
        }
        return [o];
      }), me(lt, He, (o, e) => (o.oldRange && (o.oldRange = o.oldRange._getTransformedByMergeOperation(e)), o.newRange && (o.newRange = o.newRange._getTransformedByMergeOperation(e)), [o])), me(lt, fe, (o, e, t) => {
        if (o.oldRange && (o.oldRange = V._createFromRanges(o.oldRange._getTransformedByMoveOperation(e))), o.newRange) {
          if (t.abRelation) {
            const n = V._createFromRanges(o.newRange._getTransformedByMoveOperation(e));
            if (t.abRelation.side == "left" && e.targetPosition.isEqual(o.newRange.start)) return o.newRange.end = n.end, o.newRange.start.path = t.abRelation.path, [o];
            if (t.abRelation.side == "right" && e.targetPosition.isEqual(o.newRange.end)) return o.newRange.start = n.start, o.newRange.end.path = t.abRelation.path, [o];
          }
          o.newRange = V._createFromRanges(o.newRange._getTransformedByMoveOperation(e));
        }
        return [o];
      }), me(lt, xe, (o, e, t) => {
        if (o.oldRange && (o.oldRange = o.oldRange._getTransformedBySplitOperation(e)), o.newRange) {
          if (t.abRelation) {
            const n = o.newRange._getTransformedBySplitOperation(e);
            return o.newRange.start.isEqual(e.splitPosition) && t.abRelation.wasStartBeforeMergedElement ? o.newRange.start = U._createAt(e.insertionPosition) : o.newRange.start.isEqual(e.splitPosition) && !t.abRelation.wasInLeftElement && (o.newRange.start = U._createAt(e.moveTargetPosition)), o.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasInRightElement ? o.newRange.end = U._createAt(e.moveTargetPosition) : o.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasEndBeforeMergedElement ? o.newRange.end = U._createAt(e.insertionPosition) : o.newRange.end = n.end, [o];
          }
          o.newRange = o.newRange._getTransformedBySplitOperation(e);
        }
        return [o];
      }), me(He, et, (o, e) => (o.sourcePosition.hasSameParentAs(e.position) && (o.howMany += e.howMany), o.sourcePosition = o.sourcePosition._getTransformedByInsertOperation(e), o.targetPosition = o.targetPosition._getTransformedByInsertOperation(e), [o])), me(He, He, (o, e, t) => {
        if (o.sourcePosition.isEqual(e.sourcePosition) && o.targetPosition.isEqual(e.targetPosition)) {
          if (t.bWasUndone) {
            const n = e.graveyardPosition.path.slice();
            return n.push(0), o.sourcePosition = new U(e.graveyardPosition.root, n), o.howMany = 0, [o];
          }
          return [new Xe(0)];
        }
        if (o.sourcePosition.isEqual(e.sourcePosition) && !o.targetPosition.isEqual(e.targetPosition) && !t.bWasUndone && t.abRelation != "splitAtSource") {
          const n = o.targetPosition.root.rootName == "$graveyard", i = e.targetPosition.root.rootName == "$graveyard";
          if (i && !n || !(n && !i) && t.aIsStrong) {
            const r = e.targetPosition._getTransformedByMergeOperation(e), s = o.targetPosition._getTransformedByMergeOperation(e);
            return [new fe(r, o.howMany, s, 0)];
          }
          return [new Xe(0)];
        }
        return o.sourcePosition.hasSameParentAs(e.targetPosition) && (o.howMany += e.howMany), o.sourcePosition = o.sourcePosition._getTransformedByMergeOperation(e), o.targetPosition = o.targetPosition._getTransformedByMergeOperation(e), o.graveyardPosition.isEqual(e.graveyardPosition) && t.aIsStrong || (o.graveyardPosition = o.graveyardPosition._getTransformedByMergeOperation(e)), [o];
      }), me(He, fe, (o, e, t) => {
        const n = V._createFromPositionAndShift(e.sourcePosition, e.howMany);
        return e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && o.deletionPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(o.sourcePosition) ? [new Xe(0)] : (o.sourcePosition.hasSameParentAs(e.targetPosition) && (o.howMany += e.howMany), o.sourcePosition.hasSameParentAs(e.sourcePosition) && (o.howMany -= e.howMany), o.sourcePosition = o.sourcePosition._getTransformedByMoveOperation(e), o.targetPosition = o.targetPosition._getTransformedByMoveOperation(e), o.graveyardPosition.isEqual(e.targetPosition) || (o.graveyardPosition = o.graveyardPosition._getTransformedByMoveOperation(e)), [o]);
      }), me(He, xe, (o, e, t) => {
        if (e.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1), o.deletionPosition.isEqual(e.graveyardPosition) && (o.howMany = e.howMany)), o.targetPosition.isEqual(e.splitPosition)) {
          const n = e.howMany != 0, i = e.graveyardPosition && o.deletionPosition.isEqual(e.graveyardPosition);
          if (n || i || t.abRelation == "mergeTargetNotMoved") return o.sourcePosition = o.sourcePosition._getTransformedBySplitOperation(e), [o];
        }
        if (o.sourcePosition.isEqual(e.splitPosition)) {
          if (t.abRelation == "mergeSourceNotMoved") return o.howMany = 0, o.targetPosition = o.targetPosition._getTransformedBySplitOperation(e), [o];
          if (t.abRelation == "mergeSameElement" || o.sourcePosition.offset > 0) return o.sourcePosition = e.moveTargetPosition.clone(), o.targetPosition = o.targetPosition._getTransformedBySplitOperation(e), [o];
        }
        return o.sourcePosition.hasSameParentAs(e.splitPosition) && (o.howMany = e.splitPosition.offset), o.sourcePosition = o.sourcePosition._getTransformedBySplitOperation(e), o.targetPosition = o.targetPosition._getTransformedBySplitOperation(e), [o];
      }), me(fe, et, (o, e) => {
        const t = V._createFromPositionAndShift(o.sourcePosition, o.howMany)._getTransformedByInsertOperation(e, !1)[0];
        return o.sourcePosition = t.start, o.howMany = t.end.offset - t.start.offset, o.targetPosition.isEqual(e.position) || (o.targetPosition = o.targetPosition._getTransformedByInsertOperation(e)), [o];
      }), me(fe, fe, (o, e, t) => {
        const n = V._createFromPositionAndShift(o.sourcePosition, o.howMany), i = V._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let r, s = t.aIsStrong, a = !t.aIsStrong;
        if (t.abRelation == "insertBefore" || t.baRelation == "insertAfter" ? a = !0 : t.abRelation != "insertAfter" && t.baRelation != "insertBefore" || (a = !1), r = o.targetPosition.isEqual(e.targetPosition) && a ? o.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) : o.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Zu(o, e) && Zu(e, o)) return [e.getReversed()];
        if (n.containsPosition(e.targetPosition) && n.containsRange(i, !0)) return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), so([n], r);
        if (i.containsPosition(o.targetPosition) && i.containsRange(n, !0)) return n.start = n.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), n.end = n.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), so([n], r);
        const l = ot(o.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
        if (l == "prefix" || l == "extension") return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), so([n], r);
        o.type != "remove" || e.type == "remove" || t.aWasUndone || t.forceWeakRemove ? o.type == "remove" || e.type != "remove" || t.bWasUndone || t.forceWeakRemove || (s = !1) : s = !0;
        const c = [], d = n.getDifference(i);
        for (const g of d) {
          g.start = g.start._getTransformedByDeletion(e.sourcePosition, e.howMany), g.end = g.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
          const p = ot(g.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same", b = g._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, p);
          c.push(...b);
        }
        const u = n.getIntersection(i);
        return u !== null && s && (u.start = u.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), u.end = u.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), c.length === 0 ? c.push(u) : c.length == 1 ? i.start.isBefore(n.start) || i.start.isEqual(n.start) ? c.unshift(u) : c.push(u) : c.splice(1, 0, u)), c.length === 0 ? [new Xe(o.baseVersion)] : so(c, r);
      }), me(fe, xe, (o, e, t) => {
        let n = o.targetPosition.clone();
        o.targetPosition.isEqual(e.insertionPosition) && e.graveyardPosition && t.abRelation != "moveTargetAfter" || (n = o.targetPosition._getTransformedBySplitOperation(e));
        const i = V._createFromPositionAndShift(o.sourcePosition, o.howMany);
        if (i.end.isEqual(e.insertionPosition)) return e.graveyardPosition || o.howMany++, o.targetPosition = n, [o];
        if (i.start.hasSameParentAs(e.splitPosition) && i.containsPosition(e.splitPosition)) {
          let s = new V(e.splitPosition, i.end);
          return s = s._getTransformedBySplitOperation(e), so([new V(i.start, e.splitPosition), s], n);
        }
        o.targetPosition.isEqual(e.splitPosition) && t.abRelation == "insertAtSource" && (n = e.moveTargetPosition), o.targetPosition.isEqual(e.insertionPosition) && t.abRelation == "insertBetween" && (n = o.targetPosition);
        const r = [i._getTransformedBySplitOperation(e)];
        if (e.graveyardPosition) {
          const s = i.start.isEqual(e.graveyardPosition) || i.containsPosition(e.graveyardPosition);
          o.howMany > 1 && s && !t.aWasUndone && r.push(V._createFromPositionAndShift(e.insertionPosition, 1));
        }
        return so(r, n);
      }), me(fe, He, (o, e, t) => {
        const n = V._createFromPositionAndShift(o.sourcePosition, o.howMany);
        if (e.deletionPosition.hasSameParentAs(o.sourcePosition) && n.containsPosition(e.sourcePosition)) {
          if (o.type != "remove" || t.forceWeakRemove) {
            if (o.howMany == 1) return t.bWasUndone ? (o.sourcePosition = e.graveyardPosition.clone(), o.targetPosition = o.targetPosition._getTransformedByMergeOperation(e), [o]) : [new Xe(0)];
          } else if (!t.aWasUndone) {
            const r = [];
            let s = e.graveyardPosition.clone(), a = e.targetPosition._getTransformedByMergeOperation(e);
            o.howMany > 1 && (r.push(new fe(o.sourcePosition, o.howMany - 1, o.targetPosition, 0)), s = s._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany - 1), a = a._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany - 1));
            const l = e.deletionPosition._getCombined(o.sourcePosition, o.targetPosition), c = new fe(s, 1, l, 0), d = c.getMovedRangeStart().path.slice();
            d.push(0);
            const u = new U(c.targetPosition.root, d);
            a = a._getTransformedByMove(s, l, 1);
            const g = new fe(a, e.howMany, u, 0);
            return r.push(c), r.push(g), r;
          }
        }
        const i = V._createFromPositionAndShift(o.sourcePosition, o.howMany)._getTransformedByMergeOperation(e);
        return o.sourcePosition = i.start, o.howMany = i.end.offset - i.start.offset, o.targetPosition = o.targetPosition._getTransformedByMergeOperation(e), [o];
      }), me(ct, et, (o, e) => (o.position = o.position._getTransformedByInsertOperation(e), [o])), me(ct, He, (o, e) => o.position.isEqual(e.deletionPosition) ? (o.position = e.graveyardPosition.clone(), o.position.stickiness = "toNext", [o]) : (o.position = o.position._getTransformedByMergeOperation(e), [o])), me(ct, fe, (o, e) => (o.position = o.position._getTransformedByMoveOperation(e), [o])), me(ct, ct, (o, e, t) => {
        if (o.position.isEqual(e.position)) {
          if (!t.aIsStrong) return [new Xe(0)];
          o.oldName = e.newName;
        }
        return [o];
      }), me(ct, xe, (o, e) => {
        if (ot(o.position.path, e.splitPosition.getParentPath()) == "same" && !e.graveyardPosition) {
          const t = new ct(o.position.getShiftedBy(1), o.oldName, o.newName, 0);
          return [o, t];
        }
        return o.position = o.position._getTransformedBySplitOperation(e), [o];
      }), me(Ut, Ut, (o, e, t) => {
        if (o.root === e.root && o.key === e.key) {
          if (!t.aIsStrong || o.newValue === e.newValue) return [new Xe(0)];
          o.oldValue = e.newValue;
        }
        return [o];
      }), me(Nt, Nt, (o, e, t) => o.rootName !== e.rootName || o.isAdd !== e.isAdd || t.bWasUndone ? [o] : [new Xe(0)]), me(xe, et, (o, e) => (o.splitPosition.hasSameParentAs(e.position) && o.splitPosition.offset < e.position.offset && (o.howMany += e.howMany), o.splitPosition = o.splitPosition._getTransformedByInsertOperation(e), o.insertionPosition = o.insertionPosition._getTransformedByInsertOperation(e), [o])), me(xe, He, (o, e, t) => {
        if (!o.graveyardPosition && !t.bWasUndone && o.splitPosition.hasSameParentAs(e.sourcePosition)) {
          const n = e.graveyardPosition.path.slice();
          n.push(0);
          const i = new U(e.graveyardPosition.root, n), r = xe.getInsertionPosition(new U(e.graveyardPosition.root, n)), s = new xe(i, 0, r, null, 0);
          return o.splitPosition = o.splitPosition._getTransformedByMergeOperation(e), o.insertionPosition = xe.getInsertionPosition(o.splitPosition), o.graveyardPosition = s.insertionPosition.clone(), o.graveyardPosition.stickiness = "toNext", [s, o];
        }
        return o.splitPosition.hasSameParentAs(e.deletionPosition) && !o.splitPosition.isAfter(e.deletionPosition) && o.howMany--, o.splitPosition.hasSameParentAs(e.targetPosition) && (o.howMany += e.howMany), o.splitPosition = o.splitPosition._getTransformedByMergeOperation(e), o.insertionPosition = xe.getInsertionPosition(o.splitPosition), o.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedByMergeOperation(e)), [o];
      }), me(xe, fe, (o, e, t) => {
        const n = V._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (o.graveyardPosition) {
          const r = n.start.isEqual(o.graveyardPosition) || n.containsPosition(o.graveyardPosition);
          if (!t.bWasUndone && r) {
            const s = o.splitPosition._getTransformedByMoveOperation(e), a = o.graveyardPosition._getTransformedByMoveOperation(e), l = a.path.slice();
            l.push(0);
            const c = new U(a.root, l);
            return [new fe(s, o.howMany, c, 0)];
          }
          o.graveyardPosition = o.graveyardPosition._getTransformedByMoveOperation(e);
        }
        const i = o.splitPosition.isEqual(e.targetPosition);
        if (i && (t.baRelation == "insertAtSource" || t.abRelation == "splitBefore")) return o.howMany += e.howMany, o.splitPosition = o.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany), o.insertionPosition = xe.getInsertionPosition(o.splitPosition), [o];
        if (i && t.abRelation && t.abRelation.howMany) {
          const { howMany: r, offset: s } = t.abRelation;
          return o.howMany += r, o.splitPosition = o.splitPosition.getShiftedBy(s), [o];
        }
        if (o.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(o.splitPosition)) {
          const r = e.howMany - (o.splitPosition.offset - e.sourcePosition.offset);
          return o.howMany -= r, o.splitPosition.hasSameParentAs(e.targetPosition) && o.splitPosition.offset < e.targetPosition.offset && (o.howMany += e.howMany), o.splitPosition = e.sourcePosition.clone(), o.insertionPosition = xe.getInsertionPosition(o.splitPosition), [o];
        }
        return e.sourcePosition.isEqual(e.targetPosition) || (o.splitPosition.hasSameParentAs(e.sourcePosition) && o.splitPosition.offset <= e.sourcePosition.offset && (o.howMany -= e.howMany), o.splitPosition.hasSameParentAs(e.targetPosition) && o.splitPosition.offset < e.targetPosition.offset && (o.howMany += e.howMany)), o.splitPosition.stickiness = "toNone", o.splitPosition = o.splitPosition._getTransformedByMoveOperation(e), o.splitPosition.stickiness = "toNext", o.graveyardPosition ? o.insertionPosition = o.insertionPosition._getTransformedByMoveOperation(e) : o.insertionPosition = xe.getInsertionPosition(o.splitPosition), [o];
      }), me(xe, xe, (o, e, t) => {
        if (o.splitPosition.isEqual(e.splitPosition)) {
          if (!o.graveyardPosition && !e.graveyardPosition) return [new Xe(0)];
          if (o.graveyardPosition && e.graveyardPosition && o.graveyardPosition.isEqual(e.graveyardPosition)) return [new Xe(0)];
          if (t.abRelation == "splitBefore") return o.howMany = 0, o.graveyardPosition = o.graveyardPosition._getTransformedBySplitOperation(e), [o];
        }
        if (o.graveyardPosition && e.graveyardPosition && o.graveyardPosition.isEqual(e.graveyardPosition)) {
          const n = o.splitPosition.root.rootName == "$graveyard", i = e.splitPosition.root.rootName == "$graveyard";
          if (i && !n || !(n && !i) && t.aIsStrong) {
            const r = [];
            return e.howMany && r.push(new fe(e.moveTargetPosition, e.howMany, e.splitPosition, 0)), o.howMany && r.push(new fe(o.splitPosition, o.howMany, o.moveTargetPosition, 0)), r;
          }
          return [new Xe(0)];
        }
        if (o.graveyardPosition && (o.graveyardPosition = o.graveyardPosition._getTransformedBySplitOperation(e)), o.splitPosition.isEqual(e.insertionPosition) && t.abRelation == "splitBefore") return o.howMany++, [o];
        if (e.splitPosition.isEqual(o.insertionPosition) && t.baRelation == "splitBefore") {
          const n = e.insertionPosition.path.slice();
          n.push(0);
          const i = new U(e.insertionPosition.root, n);
          return [o, new fe(o.insertionPosition, 1, i, 0)];
        }
        return o.splitPosition.hasSameParentAs(e.splitPosition) && o.splitPosition.offset < e.splitPosition.offset && (o.howMany -= e.howMany), o.splitPosition = o.splitPosition._getTransformedBySplitOperation(e), o.insertionPosition = xe.getInsertionPosition(o.splitPosition), [o];
      });
      class dt extends _e(U) {
        constructor(e, t, n = "toNone") {
          if (super(e, t, n), !this.root.is("rootElement")) throw new T("model-liveposition-root-not-rootelement", e);
          a_.call(this);
        }
        detach() {
          this.stopListening();
        }
        toPosition() {
          return new U(this.root, this.path.slice(), this.stickiness);
        }
        static fromPosition(e, t) {
          return new this(e.root, e.path.slice(), t || e.stickiness);
        }
      }
      function a_() {
        this.listenTo(this.root.document.model, "applyOperation", (o, e) => {
          const t = e[0];
          t.isDocumentOperation && l_.call(this, t);
        }, { priority: "low" });
      }
      function l_(o) {
        const e = this.getTransformedByOperation(o);
        if (!this.isEqual(e)) {
          const t = this.toPosition();
          this.path = e.path, this.root = e.root, this.fire("change", t);
        }
      }
      dt.prototype.is = function(o) {
        return o === "livePosition" || o === "model:livePosition" || o == "position" || o === "model:position";
      };
      class ao {
        constructor(e = {}) {
          typeof e == "string" && (e = e === "transparent" ? { isUndoable: !1 } : {}, ee("batch-constructor-deprecated-string-type"));
          const { isUndoable: t = !0, isLocal: n = !0, isUndo: i = !1, isTyping: r = !1 } = e;
          this.operations = [], this.isUndoable = t, this.isLocal = n, this.isUndo = i, this.isTyping = r;
        }
        get type() {
          return ee("batch-type-deprecated"), "default";
        }
        get baseVersion() {
          for (const e of this.operations) if (e.baseVersion !== null) return e.baseVersion;
          return null;
        }
        addOperation(e) {
          return e.batch = this, this.operations.push(e), e;
        }
      }
      var c_ = Object.defineProperty, Ju = Object.getOwnPropertySymbols, d_ = Object.prototype.hasOwnProperty, u_ = Object.prototype.propertyIsEnumerable, Yu = (o, e, t) => e in o ? c_(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class h_ {
        constructor(e) {
          this._changesInElement = /* @__PURE__ */ new Map(), this._elementSnapshots = /* @__PURE__ */ new Map(), this._changedMarkers = /* @__PURE__ */ new Map(), this._changedRoots = /* @__PURE__ */ new Map(), this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = /* @__PURE__ */ new Set(), this._markerCollection = e;
        }
        get isEmpty() {
          return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
        }
        bufferOperation(e) {
          const t = e;
          switch (t.type) {
            case "insert":
              if (this._isInInsertedElement(t.position.parent)) return;
              this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
              break;
            case "addAttribute":
            case "removeAttribute":
            case "changeAttribute":
              for (const n of t.range.getItems({ shallow: !0 })) this._isInInsertedElement(n.parent) || this._markAttribute(n);
              break;
            case "remove":
            case "move":
            case "reinsert": {
              if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition)) return;
              const n = this._isInInsertedElement(t.sourcePosition.parent), i = this._isInInsertedElement(t.targetPosition.parent);
              n || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany), i || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
              break;
            }
            case "rename": {
              if (this._isInInsertedElement(t.position.parent)) return;
              this._markRemove(t.position.parent, t.position.offset, 1), this._markInsert(t.position.parent, t.position.offset, 1);
              const n = V._createFromPositionAndShift(t.position, 1);
              for (const i of this._markerCollection.getMarkersIntersectingRange(n)) {
                const r = i.getData();
                this.bufferMarkerChange(i.name, r, r);
              }
              break;
            }
            case "split": {
              const n = t.splitPosition.parent;
              this._isInInsertedElement(n) || this._markRemove(n, t.splitPosition.offset, t.howMany), this._isInInsertedElement(t.insertionPosition.parent) || this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1), t.graveyardPosition && this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1);
              break;
            }
            case "merge": {
              const n = t.sourcePosition.parent;
              this._isInInsertedElement(n.parent) || this._markRemove(n.parent, n.startOffset, 1);
              const i = t.graveyardPosition.parent;
              this._markInsert(i, t.graveyardPosition.offset, 1);
              const r = t.targetPosition.parent;
              this._isInInsertedElement(r) || this._markInsert(r, t.targetPosition.offset, n.maxOffset);
              break;
            }
            case "detachRoot":
            case "addRoot":
              this._bufferRootStateChange(t.rootName, t.isAdd);
              break;
            case "addRootAttribute":
            case "removeRootAttribute":
            case "changeRootAttribute": {
              const n = t.root.rootName;
              this._bufferRootAttributeChange(n, t.key, t.oldValue, t.newValue);
              break;
            }
          }
          this._cachedChanges = null;
        }
        bufferMarkerChange(e, t, n) {
          const i = this._changedMarkers.get(e);
          i ? (i.newMarkerData = n, i.oldMarkerData.range == null && n.range == null && this._changedMarkers.delete(e)) : this._changedMarkers.set(e, { newMarkerData: n, oldMarkerData: t });
        }
        getMarkersToRemove() {
          const e = [];
          for (const [t, n] of this._changedMarkers) n.oldMarkerData.range != null && e.push({ name: t, range: n.oldMarkerData.range });
          return e;
        }
        getMarkersToAdd() {
          const e = [];
          for (const [t, n] of this._changedMarkers) n.newMarkerData.range != null && e.push({ name: t, range: n.newMarkerData.range });
          return e;
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map(([e, t]) => ({ name: e, data: { oldRange: t.oldMarkerData.range, newRange: t.newMarkerData.range } }));
        }
        hasDataChanges() {
          if (this._changesInElement.size > 0 || this._changedRoots.size > 0) return !0;
          for (const { newMarkerData: e, oldMarkerData: t } of this._changedMarkers.values()) {
            if (e.affectsData !== t.affectsData) return !0;
            if (e.affectsData) {
              const n = e.range && !t.range, i = !e.range && t.range, r = e.range && t.range && !e.range.isEqual(t.range);
              if (n || i || r) return !0;
            }
          }
          return !1;
        }
        getChanges(e = {}) {
          if (this._cachedChanges) return e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
          let t = [];
          for (const n of this._changesInElement.keys()) {
            const i = this._changesInElement.get(n).sort((d, u) => d.offset === u.offset ? d.type != u.type ? d.type == "remove" ? -1 : 1 : 0 : d.offset < u.offset ? -1 : 1), r = this._elementSnapshots.get(n), s = Qu(n.getChildren()), a = g_(r.length, i);
            let l = 0, c = 0;
            for (const d of a) if (d === "i") t.push(this._getInsertDiff(n, l, s[l])), l++;
            else if (d === "r") t.push(this._getRemoveDiff(n, l, r[c])), c++;
            else if (d === "a") {
              const u = s[l].attributes, g = r[c].attributes;
              let p;
              if (s[l].name == "$text") p = new V(U._createAt(n, l), U._createAt(n, l + 1));
              else {
                const b = n.offsetToIndex(l);
                p = new V(U._createAt(n, l), U._createAt(n.getChild(b), 0));
              }
              t.push(...this._getAttributesDiff(p, g, u)), l++, c++;
            } else l++, c++;
          }
          t.sort((n, i) => n.position.root != i.position.root ? n.position.root.rootName < i.position.root.rootName ? -1 : 1 : n.position.isEqual(i.position) ? n.changeCount - i.changeCount : n.position.isBefore(i.position) ? -1 : 1);
          for (let n = 1, i = 0; n < t.length; n++) {
            const r = t[i], s = t[n], a = r.type == "remove" && s.type == "remove" && r.name == "$text" && s.name == "$text" && r.position.isEqual(s.position), l = r.type == "insert" && s.type == "insert" && r.name == "$text" && s.name == "$text" && r.position.parent == s.position.parent && r.position.offset + r.length == s.position.offset, c = r.type == "attribute" && s.type == "attribute" && r.position.parent == s.position.parent && r.range.isFlat && s.range.isFlat && r.position.offset + r.length == s.position.offset && r.attributeKey == s.attributeKey && r.attributeOldValue == s.attributeOldValue && r.attributeNewValue == s.attributeNewValue;
            a || l || c ? (r.length++, c && (r.range.end = r.range.end.getShiftedBy(1)), t[n] = null) : i = n;
          }
          t = t.filter((n) => n);
          for (const n of t) delete n.changeCount, n.type == "attribute" && (delete n.position, delete n.length);
          return this._changeCount = 0, this._cachedChangesWithGraveyard = t, this._cachedChanges = t.filter(m_), e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
        }
        getChangedRoots() {
          return Array.from(this._changedRoots.values()).map((e) => {
            const t = ((n, i) => {
              for (var r in i || (i = {})) d_.call(i, r) && Yu(n, r, i[r]);
              if (Ju) for (var r of Ju(i)) u_.call(i, r) && Yu(n, r, i[r]);
              return n;
            })({}, e);
            return t.state !== void 0 && delete t.attributes, t;
          });
        }
        getRefreshedItems() {
          return new Set(this._refreshedItems);
        }
        reset() {
          this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems = /* @__PURE__ */ new Set(), this._cachedChanges = null;
        }
        _bufferRootStateChange(e, t) {
          if (!this._changedRoots.has(e)) return void this._changedRoots.set(e, { name: e, state: t ? "attached" : "detached" });
          const n = this._changedRoots.get(e);
          n.state !== void 0 ? (delete n.state, n.attributes === void 0 && this._changedRoots.delete(e)) : n.state = t ? "attached" : "detached";
        }
        _bufferRootAttributeChange(e, t, n, i) {
          const r = this._changedRoots.get(e) || { name: e }, s = r.attributes || {};
          if (s[t]) {
            const a = s[t];
            i === a.oldValue ? delete s[t] : a.newValue = i;
          } else s[t] = { oldValue: n, newValue: i };
          Object.entries(s).length === 0 ? (delete r.attributes, r.state === void 0 && this._changedRoots.delete(e)) : (r.attributes = s, this._changedRoots.set(e, r));
        }
        _refreshItem(e) {
          if (this._isInInsertedElement(e.parent)) return;
          this._markRemove(e.parent, e.startOffset, e.offsetSize), this._markInsert(e.parent, e.startOffset, e.offsetSize), this._refreshedItems.add(e);
          const t = V._createOn(e);
          for (const n of this._markerCollection.getMarkersIntersectingRange(t)) {
            const i = n.getData();
            this.bufferMarkerChange(n.name, i, i);
          }
          this._cachedChanges = null;
        }
        _markInsert(e, t, n) {
          const i = { type: "insert", offset: t, howMany: n, count: this._changeCount++ };
          this._markChange(e, i);
        }
        _markRemove(e, t, n) {
          const i = { type: "remove", offset: t, howMany: n, count: this._changeCount++ };
          this._markChange(e, i), this._removeAllNestedChanges(e, t, n);
        }
        _markAttribute(e) {
          const t = { type: "attribute", offset: e.startOffset, howMany: e.offsetSize, count: this._changeCount++ };
          this._markChange(e.parent, t);
        }
        _markChange(e, t) {
          this._makeSnapshot(e);
          const n = this._getChangesForElement(e);
          this._handleChange(t, n), n.push(t);
          for (let i = 0; i < n.length; i++) n[i].howMany < 1 && (n.splice(i, 1), i--);
        }
        _getChangesForElement(e) {
          let t;
          return this._changesInElement.has(e) ? t = this._changesInElement.get(e) : (t = [], this._changesInElement.set(e, t)), t;
        }
        _makeSnapshot(e) {
          this._elementSnapshots.has(e) || this._elementSnapshots.set(e, Qu(e.getChildren()));
        }
        _handleChange(e, t) {
          e.nodesToHandle = e.howMany;
          for (const n of t) {
            const i = e.offset + e.howMany, r = n.offset + n.howMany;
            if (e.type == "insert" && (n.type == "insert" && (e.offset <= n.offset ? n.offset += e.howMany : e.offset < r && (n.howMany += e.nodesToHandle, e.nodesToHandle = 0)), n.type == "remove" && e.offset < n.offset && (n.offset += e.howMany), n.type == "attribute")) {
              if (e.offset <= n.offset) n.offset += e.howMany;
              else if (e.offset < r) {
                const s = n.howMany;
                n.howMany = e.offset - n.offset, t.unshift({ type: "attribute", offset: i, howMany: s - n.howMany, count: this._changeCount++ });
              }
            }
            if (e.type == "remove") {
              if (n.type == "insert") {
                if (i <= n.offset) n.offset -= e.howMany;
                else if (i <= r) if (e.offset < n.offset) {
                  const s = i - n.offset;
                  n.offset = e.offset, n.howMany -= s, e.nodesToHandle -= s;
                } else n.howMany -= e.nodesToHandle, e.nodesToHandle = 0;
                else if (e.offset <= n.offset) e.nodesToHandle -= n.howMany, n.howMany = 0;
                else if (e.offset < r) {
                  const s = r - e.offset;
                  n.howMany -= s, e.nodesToHandle -= s;
                }
              }
              if (n.type == "remove" && (i <= n.offset ? n.offset -= e.howMany : e.offset < n.offset && (e.nodesToHandle += n.howMany, n.howMany = 0)), n.type == "attribute") {
                if (i <= n.offset) n.offset -= e.howMany;
                else if (e.offset < n.offset) {
                  const s = i - n.offset;
                  n.offset = e.offset, n.howMany -= s;
                } else if (e.offset < r) if (i <= r) {
                  const s = n.howMany;
                  n.howMany = e.offset - n.offset;
                  const a = s - n.howMany - e.nodesToHandle;
                  t.unshift({ type: "attribute", offset: e.offset, howMany: a, count: this._changeCount++ });
                } else n.howMany -= r - e.offset;
              }
            }
            if (e.type == "attribute") {
              if (n.type == "insert") if (e.offset < n.offset && i > n.offset) {
                if (i > r) {
                  const s = { type: "attribute", offset: r, howMany: i - r, count: this._changeCount++ };
                  this._handleChange(s, t), t.push(s);
                }
                e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle;
              } else e.offset >= n.offset && e.offset < r && (i > r ? (e.nodesToHandle = i - r, e.offset = r) : e.nodesToHandle = 0);
              if (n.type == "remove" && e.offset < n.offset && i > n.offset) {
                const s = { type: "attribute", offset: n.offset, howMany: i - n.offset, count: this._changeCount++ };
                this._handleChange(s, t), t.push(s), e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle;
              }
              n.type == "attribute" && (e.offset >= n.offset && i <= r ? (e.nodesToHandle = 0, e.howMany = 0, e.offset = 0) : e.offset <= n.offset && i >= r && (n.howMany = 0));
            }
          }
          e.howMany = e.nodesToHandle, delete e.nodesToHandle;
        }
        _getInsertDiff(e, t, n) {
          return { type: "insert", position: U._createAt(e, t), name: n.name, attributes: new Map(n.attributes), length: 1, changeCount: this._changeCount++ };
        }
        _getRemoveDiff(e, t, n) {
          return { type: "remove", position: U._createAt(e, t), name: n.name, attributes: new Map(n.attributes), length: 1, changeCount: this._changeCount++ };
        }
        _getAttributesDiff(e, t, n) {
          const i = [];
          n = new Map(n);
          for (const [r, s] of t) {
            const a = n.has(r) ? n.get(r) : null;
            a !== s && i.push({ type: "attribute", position: e.start, range: e.clone(), length: 1, attributeKey: r, attributeOldValue: s, attributeNewValue: a, changeCount: this._changeCount++ }), n.delete(r);
          }
          for (const [r, s] of n) i.push({ type: "attribute", position: e.start, range: e.clone(), length: 1, attributeKey: r, attributeOldValue: null, attributeNewValue: s, changeCount: this._changeCount++ });
          return i;
        }
        _isInInsertedElement(e) {
          const t = e.parent;
          if (!t) return !1;
          const n = this._changesInElement.get(t), i = e.startOffset;
          if (n) {
            for (const r of n) if (r.type == "insert" && i >= r.offset && i < r.offset + r.howMany) return !0;
          }
          return this._isInInsertedElement(t);
        }
        _removeAllNestedChanges(e, t, n) {
          const i = new V(U._createAt(e, t), U._createAt(e, t + n));
          for (const r of i.getItems({ shallow: !0 })) r.is("element") && (this._elementSnapshots.delete(r), this._changesInElement.delete(r), this._removeAllNestedChanges(r, 0, r.maxOffset));
        }
      }
      function Qu(o) {
        const e = [];
        for (const t of o) if (t.is("$text")) for (let n = 0; n < t.data.length; n++) e.push({ name: "$text", attributes: new Map(t.getAttributes()) });
        else e.push({ name: t.name, attributes: new Map(t.getAttributes()) });
        return e;
      }
      function g_(o, e) {
        const t = [];
        let n = 0, i = 0;
        for (const r of e) {
          if (r.offset > n) {
            for (let s = 0; s < r.offset - n; s++) t.push("e");
            i += r.offset - n;
          }
          if (r.type == "insert") {
            for (let s = 0; s < r.howMany; s++) t.push("i");
            n = r.offset + r.howMany;
          } else if (r.type == "remove") {
            for (let s = 0; s < r.howMany; s++) t.push("r");
            n = r.offset, i += r.howMany;
          } else t.push(..."a".repeat(r.howMany).split("")), n = r.offset + r.howMany, i += r.howMany;
        }
        if (i < o) for (let r = 0; r < o - i - n; r++) t.push("e");
        return t;
      }
      function m_(o) {
        const e = "position" in o && o.position.root.rootName == "$graveyard", t = "range" in o && o.range.root.rootName == "$graveyard";
        return !e && !t;
      }
      class p_ {
        constructor() {
          this._operations = [], this._undoPairs = /* @__PURE__ */ new Map(), this._undoneOperations = /* @__PURE__ */ new Set(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map(), this._version = 0, this._gaps = /* @__PURE__ */ new Map();
        }
        get version() {
          return this._version;
        }
        set version(e) {
          this._operations.length && e > this._version + 1 && this._gaps.set(this._version, e), this._version = e;
        }
        get lastOperation() {
          return this._operations[this._operations.length - 1];
        }
        addOperation(e) {
          if (e.baseVersion !== this.version) throw new T("model-document-history-addoperation-incorrect-version", this, { operation: e, historyVersion: this.version });
          this._operations.push(e), this._version++, this._baseVersionToOperationIndex.set(e.baseVersion, this._operations.length - 1);
        }
        getOperations(e, t = this.version) {
          if (!this._operations.length) return [];
          const n = this._operations[0];
          e === void 0 && (e = n.baseVersion);
          let i = t - 1;
          for (const [a, l] of this._gaps) e > a && e < l && (e = l), i > a && i < l && (i = a - 1);
          if (i < n.baseVersion || e > this.lastOperation.baseVersion) return [];
          let r = this._baseVersionToOperationIndex.get(e);
          r === void 0 && (r = 0);
          let s = this._baseVersionToOperationIndex.get(i);
          return s === void 0 && (s = this._operations.length - 1), this._operations.slice(r, s + 1);
        }
        getOperation(e) {
          const t = this._baseVersionToOperationIndex.get(e);
          if (t !== void 0) return this._operations[t];
        }
        setOperationAsUndone(e, t) {
          this._undoPairs.set(t, e), this._undoneOperations.add(e);
        }
        isUndoingOperation(e) {
          return this._undoPairs.has(e);
        }
        isUndoneOperation(e) {
          return this._undoneOperations.has(e);
        }
        getUndoneOperation(e) {
          return this._undoPairs.get(e);
        }
        reset() {
          this._version = 0, this._undoPairs = /* @__PURE__ */ new Map(), this._operations = [], this._undoneOperations = /* @__PURE__ */ new Set(), this._gaps = /* @__PURE__ */ new Map(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
        }
      }
      class Ui extends Ee {
        constructor(e, t, n = "main") {
          super(t), this._isAttached = !0, this._document = e, this.rootName = n;
        }
        get document() {
          return this._document;
        }
        isAttached() {
          return this._isAttached;
        }
        toJSON() {
          return this.rootName;
        }
      }
      Ui.prototype.is = function(o, e) {
        return e ? e === this.name && (o === "rootElement" || o === "model:rootElement" || o === "element" || o === "model:element") : o === "rootElement" || o === "model:rootElement" || o === "element" || o === "model:element" || o === "node" || o === "model:node";
      };
      var f_ = Object.defineProperty, b_ = Object.defineProperties, k_ = Object.getOwnPropertyDescriptors, Xu = Object.getOwnPropertySymbols, w_ = Object.prototype.hasOwnProperty, A_ = Object.prototype.propertyIsEnumerable, eh = (o, e, t) => e in o ? f_(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, th = (o, e) => {
        for (var t in e || (e = {})) w_.call(e, t) && eh(o, t, e[t]);
        if (Xu) for (var t of Xu(e)) A_.call(e, t) && eh(o, t, e[t]);
        return o;
      }, nh = (o, e) => b_(o, k_(e));
      const Js = "$graveyard";
      class __ extends _e() {
        constructor(e) {
          super(), this.model = e, this.history = new p_(), this.selection = new St(this), this.roots = new _t({ idProperty: "rootName" }), this.differ = new h_(e.markers), this.isReadOnly = !1, this._postFixers = /* @__PURE__ */ new Set(), this._hasSelectionChangedFromTheLastChangeBlock = !1, this.createRoot("$root", Js), this.listenTo(e, "applyOperation", (t, n) => {
            const i = n[0];
            i.isDocumentOperation && this.differ.bufferOperation(i);
          }, { priority: "high" }), this.listenTo(e, "applyOperation", (t, n) => {
            const i = n[0];
            i.isDocumentOperation && this.history.addOperation(i);
          }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
            this._hasSelectionChangedFromTheLastChangeBlock = !0;
          }), this.listenTo(e.markers, "update", (t, n, i, r, s) => {
            const a = nh(th({}, n.getData()), { range: r });
            this.differ.bufferMarkerChange(n.name, s, a), i === null && n.on("change", (l, c) => {
              const d = n.getData();
              this.differ.bufferMarkerChange(n.name, nh(th({}, d), { range: c }), d);
            });
          }), this.registerPostFixer((t) => {
            let n = !1;
            for (const i of this.roots) i.isAttached() || i.isEmpty || (t.remove(t.createRangeIn(i)), n = !0);
            for (const i of this.model.markers) i.getRange().root.isAttached() || (t.removeMarker(i), n = !0);
            return n;
          });
        }
        get version() {
          return this.history.version;
        }
        set version(e) {
          this.history.version = e;
        }
        get graveyard() {
          return this.getRoot(Js);
        }
        createRoot(e = "$root", t = "main") {
          if (this.roots.get(t)) throw new T("model-document-createroot-name-exists", this, { name: t });
          const n = new Ui(this, e, t);
          return this.roots.add(n), n;
        }
        destroy() {
          this.selection.destroy(), this.stopListening();
        }
        getRoot(e = "main") {
          return this.roots.get(e);
        }
        getRootNames(e = !1) {
          return Array.from(this.roots).filter((t) => t.rootName != Js && (e || t.isAttached())).map((t) => t.rootName);
        }
        registerPostFixer(e) {
          this._postFixers.add(e);
        }
        toJSON() {
          const e = bd(this);
          return e.selection = "[engine.model.DocumentSelection]", e.model = "[engine.model.Model]", e;
        }
        _handleChangeBlock(e) {
          this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(e), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", e.batch) : this.fire("change", e.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = !1;
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
        }
        _getDefaultRoot() {
          for (const e of this.roots) if (e !== this.graveyard) return e;
          return this.graveyard;
        }
        _getDefaultRange() {
          const e = this._getDefaultRoot(), t = this.model, n = t.schema, i = t.createPositionFromPath(e, [0]);
          return n.getNearestSelectionRange(i) || t.createRange(i);
        }
        _validateSelectionRange(e) {
          return oh(e.start) && oh(e.end);
        }
        _callPostFixers(e) {
          let t = !1;
          do
            for (const n of this._postFixers) if (this.selection.refresh(), t = n(e), t) break;
          while (t);
        }
      }
      function oh(o) {
        const e = o.textNode;
        if (e) {
          const t = e.data, n = o.offset - e.startOffset;
          return !ds(t, n) && !us(t, n);
        }
        return !0;
      }
      var v_ = Object.defineProperty, C_ = Object.defineProperties, y_ = Object.getOwnPropertyDescriptors, ih = Object.getOwnPropertySymbols, E_ = Object.prototype.hasOwnProperty, x_ = Object.prototype.propertyIsEnumerable, rh = (o, e, t) => e in o ? v_(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class S_ extends _e() {
        constructor() {
          super(...arguments), this._markers = /* @__PURE__ */ new Map();
        }
        [Symbol.iterator]() {
          return this._markers.values();
        }
        has(e) {
          const t = e instanceof lo ? e.name : e;
          return this._markers.has(t);
        }
        get(e) {
          return this._markers.get(e) || null;
        }
        _set(e, t, n = !1, i = !1) {
          const r = e instanceof lo ? e.name : e;
          if (r.includes(",")) throw new T("markercollection-incorrect-marker-name", this);
          const s = this._markers.get(r);
          if (s) {
            const d = s.getData(), u = s.getRange();
            let g = !1;
            return u.isEqual(t) || (s._attachLiveRange(qt.fromRange(t)), g = !0), n != s.managedUsingOperations && (s._managedUsingOperations = n, g = !0), typeof i == "boolean" && i != s.affectsData && (s._affectsData = i, g = !0), g && this.fire(`update:${r}`, s, u, t, d), s;
          }
          const a = qt.fromRange(t), l = new lo(r, a, n, i);
          var c;
          return this._markers.set(r, l), this.fire(`update:${r}`, l, null, t, (c = ((d, u) => {
            for (var g in u || (u = {})) E_.call(u, g) && rh(d, g, u[g]);
            if (ih) for (var g of ih(u)) x_.call(u, g) && rh(d, g, u[g]);
            return d;
          })({}, l.getData()), C_(c, y_({ range: null })))), l;
        }
        _remove(e) {
          const t = e instanceof lo ? e.name : e, n = this._markers.get(t);
          return !!n && (this._markers.delete(t), this.fire(`update:${t}`, n, n.getRange(), null, n.getData()), this._destroyMarker(n), !0);
        }
        _refresh(e) {
          const t = e instanceof lo ? e.name : e, n = this._markers.get(t);
          if (!n) throw new T("markercollection-refresh-marker-not-exists", this);
          const i = n.getRange();
          this.fire(`update:${t}`, n, i, i, n.getData());
        }
        *getMarkersAtPosition(e) {
          for (const t of this) t.getRange().containsPosition(e) && (yield t);
        }
        *getMarkersIntersectingRange(e) {
          for (const t of this) t.getRange().getIntersection(e) !== null && (yield t);
        }
        destroy() {
          for (const e of this._markers.values()) this._destroyMarker(e);
          this._markers = null, this.stopListening();
        }
        *getMarkersGroup(e) {
          for (const t of this._markers.values()) t.name.startsWith(e + ":") && (yield t);
        }
        _destroyMarker(e) {
          e.stopListening(), e._detachLiveRange();
        }
      }
      class lo extends _e(sn) {
        constructor(e, t, n, i) {
          super(), this.name = e, this._liveRange = this._attachLiveRange(t), this._managedUsingOperations = n, this._affectsData = i;
        }
        get managedUsingOperations() {
          if (!this._liveRange) throw new T("marker-destroyed", this);
          return this._managedUsingOperations;
        }
        get affectsData() {
          if (!this._liveRange) throw new T("marker-destroyed", this);
          return this._affectsData;
        }
        getData() {
          return { range: this.getRange(), affectsData: this.affectsData, managedUsingOperations: this.managedUsingOperations };
        }
        getStart() {
          if (!this._liveRange) throw new T("marker-destroyed", this);
          return this._liveRange.start.clone();
        }
        getEnd() {
          if (!this._liveRange) throw new T("marker-destroyed", this);
          return this._liveRange.end.clone();
        }
        getRange() {
          if (!this._liveRange) throw new T("marker-destroyed", this);
          return this._liveRange.toRange();
        }
        _attachLiveRange(e) {
          return this._liveRange && this._detachLiveRange(), e.delegate("change:range").to(this), e.delegate("change:content").to(this), this._liveRange = e, e;
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
        }
      }
      lo.prototype.is = function(o) {
        return o === "marker" || o === "model:marker";
      };
      class D_ extends bt {
        constructor(e, t) {
          super(null), this.sourcePosition = e.clone(), this.howMany = t;
        }
        get type() {
          return "detach";
        }
        get affectedSelectable() {
          return null;
        }
        toJSON() {
          const e = super.toJSON();
          return e.sourcePosition = this.sourcePosition.toJSON(), e;
        }
        _validate() {
          if (this.sourcePosition.root.document) throw new T("detach-operation-on-document-node", this);
        }
        _execute() {
          Hu(V._createFromPositionAndShift(this.sourcePosition, this.howMany));
        }
        static get className() {
          return "DetachOperation";
        }
      }
      class Wt extends sn {
        constructor(e) {
          super(), this.markers = /* @__PURE__ */ new Map(), this._children = new $o(), e && this._insertChild(0, e);
        }
        [Symbol.iterator]() {
          return this.getChildren();
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get nextSibling() {
          return null;
        }
        get previousSibling() {
          return null;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get document() {
          return null;
        }
        isAttached() {
          return !1;
        }
        getAncestors() {
          return [];
        }
        getChild(e) {
          return this._children.getNode(e);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(e) {
          return this._children.getNodeIndex(e);
        }
        getChildStartOffset(e) {
          return this._children.getNodeStartOffset(e);
        }
        getPath() {
          return [];
        }
        getNodeByPath(e) {
          let t = this;
          for (const n of e) t = t.getChild(t.offsetToIndex(n));
          return t;
        }
        offsetToIndex(e) {
          return this._children.offsetToIndex(e);
        }
        toJSON() {
          const e = [];
          for (const t of this._children) e.push(t.toJSON());
          return e;
        }
        static fromJSON(e) {
          const t = [];
          for (const n of e) n.name ? t.push(Ee.fromJSON(n)) : t.push(ye.fromJSON(n));
          return new Wt(t);
        }
        _appendChild(e) {
          this._insertChild(this.childCount, e);
        }
        _insertChild(e, t) {
          const n = function(i) {
            return typeof i == "string" ? [new ye(i)] : (gt(i) || (i = [i]), Array.from(i).map((r) => typeof r == "string" ? new ye(r) : r instanceof xt ? new ye(r.data, r.getAttributes()) : r));
          }(t);
          for (const i of n) i.parent !== null && i._remove(), i.parent = this;
          this._children._insertNodes(e, n);
        }
        _removeChildren(e, t = 1) {
          const n = this._children._removeNodes(e, t);
          for (const i of n) i.parent = null;
          return n;
        }
      }
      Wt.prototype.is = function(o) {
        return o === "documentFragment" || o === "model:documentFragment";
      };
      class B_ {
        constructor(e, t) {
          this.model = e, this.batch = t;
        }
        createText(e, t) {
          return new ye(e, t);
        }
        createElement(e, t) {
          return new Ee(e, t);
        }
        createDocumentFragment() {
          return new Wt();
        }
        cloneElement(e, t = !0) {
          return e._clone(t);
        }
        insert(e, t, n = 0) {
          if (this._assertWriterUsedCorrectly(), e instanceof ye && e.data == "") return;
          const i = U._createAt(t, n);
          if (e.parent) {
            if (lh(e.root, i.root)) return void this.move(V._createOn(e), i);
            if (e.root.document) throw new T("model-writer-insert-forbidden-move", this);
            this.remove(e);
          }
          const r = i.root.document ? i.root.document.version : null, s = new et(i, e, r);
          if (e instanceof ye && (s.shouldReceiveAttributes = !0), this.batch.addOperation(s), this.model.applyOperation(s), e instanceof Wt) for (const [a, l] of e.markers) {
            const c = U._createAt(l.root, 0), d = { range: new V(l.start._getCombined(c, i), l.end._getCombined(c, i)), usingOperation: !0, affectsData: !0 };
            this.model.markers.has(a) ? this.updateMarker(a, d) : this.addMarker(a, d);
          }
        }
        insertText(e, t, n, i) {
          t instanceof Wt || t instanceof Ee || t instanceof U ? this.insert(this.createText(e), t, n) : this.insert(this.createText(e, t), n, i);
        }
        insertElement(e, t, n, i) {
          t instanceof Wt || t instanceof Ee || t instanceof U ? this.insert(this.createElement(e), t, n) : this.insert(this.createElement(e, t), n, i);
        }
        append(e, t) {
          this.insert(e, t, "end");
        }
        appendText(e, t, n) {
          t instanceof Wt || t instanceof Ee ? this.insert(this.createText(e), t, "end") : this.insert(this.createText(e, t), n, "end");
        }
        appendElement(e, t, n) {
          t instanceof Wt || t instanceof Ee ? this.insert(this.createElement(e), t, "end") : this.insert(this.createElement(e, t), n, "end");
        }
        setAttribute(e, t, n) {
          if (this._assertWriterUsedCorrectly(), n instanceof V) {
            const i = n.getMinimalFlatRanges();
            for (const r of i) sh(this, e, t, r);
          } else ah(this, e, t, n);
        }
        setAttributes(e, t) {
          for (const [n, i] of Ht(e)) this.setAttribute(n, i, t);
        }
        removeAttribute(e, t) {
          if (this._assertWriterUsedCorrectly(), t instanceof V) {
            const n = t.getMinimalFlatRanges();
            for (const i of n) sh(this, e, null, i);
          } else ah(this, e, null, t);
        }
        clearAttributes(e) {
          this._assertWriterUsedCorrectly();
          const t = (n) => {
            for (const i of n.getAttributeKeys()) this.removeAttribute(i, n);
          };
          if (e instanceof V) for (const n of e.getItems()) t(n);
          else t(e);
        }
        move(e, t, n) {
          if (this._assertWriterUsedCorrectly(), !(e instanceof V)) throw new T("writer-move-invalid-range", this);
          if (!e.isFlat) throw new T("writer-move-range-not-flat", this);
          const i = U._createAt(t, n);
          if (i.isEqual(e.start)) return;
          if (this._addOperationForAffectedMarkers("move", e), !lh(e.root, i.root)) throw new T("writer-move-different-document", this);
          const r = e.root.document ? e.root.document.version : null, s = new fe(e.start, e.end.offset - e.start.offset, i, r);
          this.batch.addOperation(s), this.model.applyOperation(s);
        }
        remove(e) {
          this._assertWriterUsedCorrectly();
          const t = (e instanceof V ? e : V._createOn(e)).getMinimalFlatRanges().reverse();
          for (const n of t) this._addOperationForAffectedMarkers("move", n), T_(n.start, n.end.offset - n.start.offset, this.batch, this.model);
        }
        merge(e) {
          this._assertWriterUsedCorrectly();
          const t = e.nodeBefore, n = e.nodeAfter;
          if (this._addOperationForAffectedMarkers("merge", e), !(t instanceof Ee)) throw new T("writer-merge-no-element-before", this);
          if (!(n instanceof Ee)) throw new T("writer-merge-no-element-after", this);
          e.root.document ? this._merge(e) : this._mergeDetached(e);
        }
        createPositionFromPath(e, t, n) {
          return this.model.createPositionFromPath(e, t, n);
        }
        createPositionAt(e, t) {
          return this.model.createPositionAt(e, t);
        }
        createPositionAfter(e) {
          return this.model.createPositionAfter(e);
        }
        createPositionBefore(e) {
          return this.model.createPositionBefore(e);
        }
        createRange(e, t) {
          return this.model.createRange(e, t);
        }
        createRangeIn(e) {
          return this.model.createRangeIn(e);
        }
        createRangeOn(e) {
          return this.model.createRangeOn(e);
        }
        createSelection(...e) {
          return this.model.createSelection(...e);
        }
        _mergeDetached(e) {
          const t = e.nodeBefore, n = e.nodeAfter;
          this.move(V._createIn(n), U._createAt(t, "end")), this.remove(n);
        }
        _merge(e) {
          const t = U._createAt(e.nodeBefore, "end"), n = U._createAt(e.nodeAfter, 0), i = e.root.document.graveyard, r = new U(i, [0]), s = e.root.document.version, a = new He(n, e.nodeAfter.maxOffset, t, r, s);
          this.batch.addOperation(a), this.model.applyOperation(a);
        }
        rename(e, t) {
          if (this._assertWriterUsedCorrectly(), !(e instanceof Ee)) throw new T("writer-rename-not-element-instance", this);
          const n = e.root.document ? e.root.document.version : null, i = new ct(U._createBefore(e), e.name, t, n);
          this.batch.addOperation(i), this.model.applyOperation(i);
        }
        split(e, t) {
          this._assertWriterUsedCorrectly();
          let n, i, r = e.parent;
          if (!r.parent) throw new T("writer-split-element-no-parent", this);
          if (t || (t = r.parent), !e.parent.getAncestors({ includeSelf: !0 }).includes(t)) throw new T("writer-split-invalid-limit-element", this);
          do {
            const s = r.root.document ? r.root.document.version : null, a = r.maxOffset - e.offset, l = xe.getInsertionPosition(e), c = new xe(e, a, l, null, s);
            this.batch.addOperation(c), this.model.applyOperation(c), n || i || (n = r, i = e.parent.nextSibling), r = (e = this.createPositionAfter(e.parent)).parent;
          } while (r !== t);
          return { position: e, range: new V(U._createAt(n, "end"), U._createAt(i, 0)) };
        }
        wrap(e, t) {
          if (this._assertWriterUsedCorrectly(), !e.isFlat) throw new T("writer-wrap-range-not-flat", this);
          const n = t instanceof Ee ? t : new Ee(t);
          if (n.childCount > 0) throw new T("writer-wrap-element-not-empty", this);
          if (n.parent !== null) throw new T("writer-wrap-element-attached", this);
          this.insert(n, e.start);
          const i = new V(e.start.getShiftedBy(1), e.end.getShiftedBy(1));
          this.move(i, U._createAt(n, 0));
        }
        unwrap(e) {
          if (this._assertWriterUsedCorrectly(), e.parent === null) throw new T("writer-unwrap-element-no-parent", this);
          this.move(V._createIn(e), this.createPositionAfter(e)), this.remove(e);
        }
        addMarker(e, t) {
          if (this._assertWriterUsedCorrectly(), !t || typeof t.usingOperation != "boolean") throw new T("writer-addmarker-no-usingoperation", this);
          const n = t.usingOperation, i = t.range, r = t.affectsData !== void 0 && t.affectsData;
          if (this.model.markers.has(e)) throw new T("writer-addmarker-marker-exists", this);
          if (!i) throw new T("writer-addmarker-no-range", this);
          return n ? (Zo(this, e, null, i, r), this.model.markers.get(e)) : this.model.markers._set(e, i, n, r);
        }
        updateMarker(e, t) {
          this._assertWriterUsedCorrectly();
          const n = typeof e == "string" ? e : e.name, i = this.model.markers.get(n);
          if (!i) throw new T("writer-updatemarker-marker-not-exists", this);
          if (!t) return ee("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n }), void this.model.markers._refresh(i);
          const r = typeof t.usingOperation == "boolean", s = typeof t.affectsData == "boolean", a = s ? t.affectsData : i.affectsData;
          if (!r && !t.range && !s) throw new T("writer-updatemarker-wrong-options", this);
          const l = i.getRange(), c = t.range ? t.range : l;
          r && t.usingOperation !== i.managedUsingOperations ? t.usingOperation ? Zo(this, n, null, c, a) : (Zo(this, n, l, null, a), this.model.markers._set(n, c, void 0, a)) : i.managedUsingOperations ? Zo(this, n, l, c, a) : this.model.markers._set(n, c, void 0, a);
        }
        removeMarker(e) {
          this._assertWriterUsedCorrectly();
          const t = typeof e == "string" ? e : e.name;
          if (!this.model.markers.has(t)) throw new T("writer-removemarker-no-marker", this);
          const n = this.model.markers.get(t);
          if (!n.managedUsingOperations) return void this.model.markers._remove(t);
          Zo(this, t, n.getRange(), null, n.affectsData);
        }
        addRoot(e, t = "$root") {
          this._assertWriterUsedCorrectly();
          const n = this.model.document.getRoot(e);
          if (n && n.isAttached()) throw new T("writer-addroot-root-exists", this);
          const i = this.model.document, r = new Nt(e, t, !0, i, i.version);
          return this.batch.addOperation(r), this.model.applyOperation(r), this.model.document.getRoot(e);
        }
        detachRoot(e) {
          this._assertWriterUsedCorrectly();
          const t = typeof e == "string" ? this.model.document.getRoot(e) : e;
          if (!t || !t.isAttached()) throw new T("writer-detachroot-no-root", this);
          for (const r of this.model.markers) r.getRange().root === t && this.removeMarker(r);
          for (const r of t.getAttributeKeys()) this.removeAttribute(r, t);
          this.remove(this.createRangeIn(t));
          const n = this.model.document, i = new Nt(t.rootName, t.name, !1, n, n.version);
          this.batch.addOperation(i), this.model.applyOperation(i);
        }
        setSelection(...e) {
          this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...e);
        }
        setSelectionFocus(e, t) {
          this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(e, t);
        }
        setSelectionAttribute(e, t) {
          if (this._assertWriterUsedCorrectly(), typeof e == "string") this._setSelectionAttribute(e, t);
          else for (const [n, i] of Ht(e)) this._setSelectionAttribute(n, i);
        }
        removeSelectionAttribute(e) {
          if (this._assertWriterUsedCorrectly(), typeof e == "string") this._removeSelectionAttribute(e);
          else for (const t of e) this._removeSelectionAttribute(t);
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity();
        }
        restoreSelectionGravity(e) {
          this.model.document.selection._restoreGravity(e);
        }
        _setSelectionAttribute(e, t) {
          const n = this.model.document.selection;
          if (n.isCollapsed && n.anchor.parent.isEmpty) {
            const i = St._getStoreAttributeKey(e);
            this.setAttribute(i, t, n.anchor.parent);
          }
          n._setAttribute(e, t);
        }
        _removeSelectionAttribute(e) {
          const t = this.model.document.selection;
          if (t.isCollapsed && t.anchor.parent.isEmpty) {
            const n = St._getStoreAttributeKey(e);
            this.removeAttribute(n, t.anchor.parent);
          }
          t._removeAttribute(e);
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this) throw new T("writer-incorrect-use", this);
        }
        _addOperationForAffectedMarkers(e, t) {
          for (const n of this.model.markers) {
            if (!n.managedUsingOperations) continue;
            const i = n.getRange();
            let r = !1;
            if (e === "move") {
              const s = t;
              r = s.containsPosition(i.start) || s.start.isEqual(i.start) || s.containsPosition(i.end) || s.end.isEqual(i.end);
            } else {
              const s = t, a = s.nodeBefore, l = s.nodeAfter, c = i.start.parent == a && i.start.isAtEnd, d = i.end.parent == l && i.end.offset == 0, u = i.end.nodeAfter == l, g = i.start.nodeAfter == l;
              r = c || d || u || g;
            }
            r && this.updateMarker(n.name, { range: i });
          }
        }
      }
      function sh(o, e, t, n) {
        const i = o.model, r = i.document;
        let s, a, l, c = n.start;
        for (const u of n.getWalker({ shallow: !0 })) l = u.item.getAttribute(e), s && a != l && (a != t && d(), c = s), s = u.nextPosition, a = l;
        function d() {
          const u = new V(c, s), g = u.root.document ? r.version : null, p = new Ge(u, e, a, t, g);
          o.batch.addOperation(p), i.applyOperation(p);
        }
        s instanceof U && s != c && a != t && d();
      }
      function ah(o, e, t, n) {
        const i = o.model, r = i.document, s = n.getAttribute(e);
        let a, l;
        if (s != t) {
          if (n.root === n) {
            const c = n.document ? r.version : null;
            l = new Ut(n, e, s, t, c);
          } else {
            a = new V(U._createBefore(n), o.createPositionAfter(n));
            const c = a.root.document ? r.version : null;
            l = new Ge(a, e, s, t, c);
          }
          o.batch.addOperation(l), i.applyOperation(l);
        }
      }
      function Zo(o, e, t, n, i) {
        const r = o.model, s = r.document, a = new lt(e, t, n, r.markers, !!i, s.version);
        o.batch.addOperation(a), r.applyOperation(a);
      }
      function T_(o, e, t, n) {
        let i;
        if (o.root.document) {
          const r = n.document, s = new U(r.graveyard, [0]);
          i = new fe(o, e, s, r.version);
        } else i = new D_(o, e);
        t.addOperation(i), n.applyOperation(i);
      }
      function lh(o, e) {
        return o === e || o instanceof Ui && e instanceof Ui;
      }
      function I_(o, e, t = {}) {
        if (e.isCollapsed) return;
        const n = e.getFirstRange();
        if (n.root.rootName == "$graveyard") return;
        const i = o.schema;
        o.change((r) => {
          if (!t.doNotResetEntireContent && function(c, d) {
            const u = c.getLimitElement(d);
            if (!d.containsEntireContent(u)) return !1;
            const g = d.getFirstRange();
            return g.start.parent == g.end.parent ? !1 : c.checkChild(u, "paragraph");
          }(i, e)) return void function(c, d) {
            const u = c.model.schema.getLimitElement(d);
            c.remove(c.createRangeIn(u)), uh(c, c.createPositionAt(u, 0), d);
          }(r, e);
          const s = {};
          if (!t.doNotAutoparagraph) {
            const c = e.getSelectedElement();
            c && Object.assign(s, i.getAttributesWithProperty(c, "copyOnReplace", !0));
          }
          const [a, l] = function(c) {
            const d = c.root.document.model, u = c.start;
            let g = c.end;
            if (d.hasContent(c, { ignoreMarkers: !0 })) {
              const p = function(b) {
                const w = b.parent, y = w.root.document.model.schema, I = w.getAncestors({ parentFirst: !0, includeSelf: !0 });
                for (const z of I) {
                  if (y.isLimit(z)) return null;
                  if (y.isBlock(z)) return z;
                }
              }(g);
              if (p && g.isTouching(d.createPositionAt(p, 0))) {
                const b = d.createSelection(c);
                d.modifySelection(b, { direction: "backward" });
                const w = b.getLastPosition(), y = d.createRange(w, g);
                d.hasContent(y, { ignoreMarkers: !0 }) || (g = w);
              }
            }
            return [dt.fromPosition(u, "toPrevious"), dt.fromPosition(g, "toNext")];
          }(n);
          a.isTouching(l) || r.remove(r.createRange(a, l)), t.leaveUnmerged || (function(c, d, u) {
            const g = c.model;
            if (!Ys(c.model.schema, d, u)) return;
            const [p, b] = function(w, y) {
              const I = w.getAncestors(), z = y.getAncestors();
              let H = 0;
              for (; I[H] && I[H] == z[H]; ) H++;
              return [I[H], z[H]];
            }(d, u);
            !p || !b || (!g.hasContent(p, { ignoreMarkers: !0 }) && g.hasContent(b, { ignoreMarkers: !0 }) ? dh(c, d, u, p.parent) : ch(c, d, u, p.parent));
          }(r, a, l), i.removeDisallowedAttributes(a.parent.getChildren(), r)), hh(r, e, a), !t.doNotAutoparagraph && function(c, d) {
            const u = c.checkChild(d, "$text"), g = c.checkChild(d, "paragraph");
            return !u && g;
          }(i, a) && uh(r, a, e, s), a.detach(), l.detach();
        });
      }
      function ch(o, e, t, n) {
        const i = e.parent, r = t.parent;
        if (i != n && r != n) {
          for (e = o.createPositionAfter(i), (t = o.createPositionBefore(r)).isEqual(e) || o.insert(r, e), o.merge(e); t.parent.isEmpty; ) {
            const s = t.parent;
            t = o.createPositionBefore(s), o.remove(s);
          }
          Ys(o.model.schema, e, t) && ch(o, e, t, n);
        }
      }
      function dh(o, e, t, n) {
        const i = e.parent, r = t.parent;
        if (i != n && r != n) {
          for (e = o.createPositionAfter(i), (t = o.createPositionBefore(r)).isEqual(e) || o.insert(i, t); e.parent.isEmpty; ) {
            const s = e.parent;
            e = o.createPositionBefore(s), o.remove(s);
          }
          t = o.createPositionBefore(r), function(s, a) {
            const l = a.nodeBefore, c = a.nodeAfter;
            l.name != c.name && s.rename(l, c.name), s.clearAttributes(l), s.setAttributes(Object.fromEntries(c.getAttributes()), l), s.merge(a);
          }(o, t), Ys(o.model.schema, e, t) && dh(o, e, t, n);
        }
      }
      function Ys(o, e, t) {
        const n = e.parent, i = t.parent;
        return n != i && !o.isLimit(n) && !o.isLimit(i) && function(r, s, a) {
          const l = new V(r, s);
          for (const c of l.getWalker()) if (a.isLimit(c.item)) return !1;
          return !0;
        }(e, t, o);
      }
      function uh(o, e, t, n = {}) {
        const i = o.createElement("paragraph");
        o.model.schema.setAllowedAttributes(i, n, o), o.insert(i, e), hh(o, t, o.createPositionAt(i, 0));
      }
      function hh(o, e, t) {
        e instanceof St ? o.setSelection(t) : e.setTo(t);
      }
      function gh(o, e) {
        const t = [];
        Array.from(o.getItems({ direction: "backward" })).map((n) => e.createRangeOn(n)).filter((n) => (n.start.isAfter(o.start) || n.start.isEqual(o.start)) && (n.end.isBefore(o.end) || n.end.isEqual(o.end))).forEach((n) => {
          t.push(n.start.parent), e.remove(n);
        }), t.forEach((n) => {
          let i = n;
          for (; i.parent && i.isEmpty; ) {
            const r = e.createRangeOn(i);
            i = i.parent, e.remove(r);
          }
        });
      }
      class P_ {
        constructor(e, t, n) {
          this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null, this._nodeToSelect = null, this.model = e, this.writer = t, this.position = n, this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]), this.schema = e.schema, this._documentFragment = t.createDocumentFragment(), this._documentFragmentPosition = t.createPositionAt(this._documentFragment, 0);
        }
        handleNodes(e) {
          for (const t of Array.from(e)) this._handleNode(t);
          this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
        }
        _updateLastNodeFromAutoParagraph(e) {
          const t = this.writer.createPositionAfter(this._lastNode), n = this.writer.createPositionAfter(e);
          if (n.isAfter(t)) {
            if (this._lastNode = e, this.position.parent != e || !this.position.isAtEnd) throw new T("insertcontent-invalid-insertion-position", this);
            this.position = n, this._setAffectedBoundaries(this.position);
          }
        }
        getSelectionRange() {
          return this._nodeToSelect ? V._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
        }
        getAffectedRange() {
          return this._affectedStart ? new V(this._affectedStart, this._affectedEnd) : null;
        }
        destroy() {
          this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
        }
        _handleNode(e) {
          if (this.schema.isObject(e)) return void this._handleObject(e);
          let t = this._checkAndAutoParagraphToAllowedPosition(e);
          t || (t = this._checkAndSplitToAllowedPosition(e), t) ? (this._appendToFragment(e), this._firstNode || (this._firstNode = e), this._lastNode = e) : this._handleDisallowedNode(e);
        }
        _insertPartialFragment() {
          if (this._documentFragment.isEmpty) return;
          const e = dt.fromPosition(this.position, "toNext");
          this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = e.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = e.toPosition(), e.detach();
        }
        _handleObject(e) {
          this._checkAndSplitToAllowedPosition(e) ? this._appendToFragment(e) : this._tryAutoparagraphing(e);
        }
        _handleDisallowedNode(e) {
          e.is("element") ? this.handleNodes(e.getChildren()) : this._tryAutoparagraphing(e);
        }
        _appendToFragment(e) {
          if (!this.schema.checkChild(this.position, e)) throw new T("insertcontent-wrong-position", this, { node: e, position: this.position });
          this.writer.insert(e, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(e.offsetSize), this.schema.isObject(e) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = e : this._nodeToSelect = null, this._filterAttributesOf.push(e);
        }
        _setAffectedBoundaries(e) {
          this._affectedStart || (this._affectedStart = dt.fromPosition(e, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(e) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = dt.fromPosition(e, "toNext"));
        }
        _mergeOnLeft() {
          const e = this._firstNode;
          if (!(e instanceof Ee) || !this._canMergeLeft(e)) return;
          const t = dt._createBefore(e);
          t.stickiness = "toNext";
          const n = dt.fromPosition(this.position, "toNext");
          this._affectedStart.isEqual(t) && (this._affectedStart.detach(), this._affectedStart = dt._createAt(t.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = dt._createAt(t.nodeBefore, "end", "toNext")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
        }
        _mergeOnRight() {
          const e = this._lastNode;
          if (!(e instanceof Ee) || !this._canMergeRight(e)) return;
          const t = dt._createAfter(e);
          if (t.stickiness = "toNext", !this.position.isEqual(t)) throw new T("insertcontent-invalid-insertion-position", this);
          this.position = U._createAt(t.nodeBefore, "end");
          const n = dt.fromPosition(this.position, "toPrevious");
          this._affectedEnd.isEqual(t) && (this._affectedEnd.detach(), this._affectedEnd = dt._createAt(t.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = dt._createAt(t.nodeBefore, 0, "toPrevious")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
        }
        _canMergeLeft(e) {
          const t = e.previousSibling;
          return t instanceof Ee && this.canMergeWith.has(t) && this.model.schema.checkMerge(t, e);
        }
        _canMergeRight(e) {
          const t = e.nextSibling;
          return t instanceof Ee && this.canMergeWith.has(t) && this.model.schema.checkMerge(e, t);
        }
        _tryAutoparagraphing(e) {
          const t = this.writer.createElement("paragraph");
          this._getAllowedIn(this.position.parent, t) && this.schema.checkChild(t, e) && (t._appendChild(e), this._handleNode(t));
        }
        _checkAndAutoParagraphToAllowedPosition(e) {
          if (this.schema.checkChild(this.position.parent, e)) return !0;
          if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", e)) return !1;
          this._insertPartialFragment();
          const t = this.writer.createElement("paragraph");
          return this.writer.insert(t, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = t, this.position = this.writer.createPositionAt(t, 0), !0;
        }
        _checkAndSplitToAllowedPosition(e) {
          const t = this._getAllowedIn(this.position.parent, e);
          if (!t) return !1;
          for (t != this.position.parent && this._insertPartialFragment(); t != this.position.parent; ) if (this.position.isAtStart) {
            const n = this.position.parent;
            this.position = this.writer.createPositionBefore(n), n.isEmpty && n.parent === t && this.writer.remove(n);
          } else if (this.position.isAtEnd) this.position = this.writer.createPositionAfter(this.position.parent);
          else {
            const n = this.writer.createPositionAfter(this.position.parent);
            this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = n, this.canMergeWith.add(this.position.nodeAfter);
          }
          return !0;
        }
        _getAllowedIn(e, t) {
          return this.schema.checkChild(e, t) ? e : this.schema.isLimit(e) ? null : this._getAllowedIn(e.parent, t);
        }
      }
      function mh(o, e, t = "auto") {
        const n = o.getSelectedElement();
        if (n && e.schema.isObject(n) && !e.schema.isInline(n)) return t == "before" || t == "after" ? e.createRange(e.createPositionAt(n, t)) : e.createRangeOn(n);
        const i = Ke(o.getSelectedBlocks());
        if (!i) return e.createRange(o.focus);
        if (i.isEmpty) return e.createRange(e.createPositionAt(i, 0));
        const r = e.createPositionAfter(i);
        return o.focus.isTouching(r) ? e.createRange(r) : e.createRange(e.createPositionBefore(i));
      }
      function R_(o, e, t, n = {}) {
        if (!o.schema.isObject(e)) throw new T("insertobject-element-not-an-object", o, { object: e });
        const i = t || o.document.selection;
        let r = i;
        n.findOptimalPosition && o.schema.isBlock(e) && (r = o.createSelection(mh(i, o, n.findOptimalPosition)));
        const s = Ke(i.getSelectedBlocks()), a = {};
        return s && Object.assign(a, o.schema.getAttributesWithProperty(s, "copyOnReplace", !0)), o.change((l) => {
          r.isCollapsed || o.deleteContent(r, { doNotAutoparagraph: !0 });
          let c = e;
          const d = r.anchor.parent;
          !o.schema.checkChild(d, e) && o.schema.checkChild(d, "paragraph") && o.schema.checkChild("paragraph", e) && (c = l.createElement("paragraph"), l.insert(e, c)), o.schema.setAllowedAttributes(c, a, l);
          const u = o.insertContent(c, r);
          return u.isCollapsed || n.setSelection && function(g, p, b, w) {
            const y = g.model;
            if (b == "on") return void g.setSelection(p, "on");
            if (b != "after") throw new T("insertobject-invalid-place-parameter-value", y);
            let I = p.nextSibling;
            if (y.schema.isInline(p)) return void g.setSelection(p, "after");
            !(I && y.schema.checkChild(I, "$text")) && y.schema.checkChild(p.parent, "paragraph") && (I = g.createElement("paragraph"), y.schema.setAllowedAttributes(I, w, g), y.insertContent(I, g.createPositionAfter(p))), I && g.setSelection(I, 0);
          }(l, e, n.setSelection, a), u;
        });
      }
      const O_ = ' ,.?!:;"-()';
      function z_(o, e) {
        const { isForward: t, walker: n, unit: i, schema: r, treatEmojiAsSingleUnit: s } = o, { type: a, item: l, nextPosition: c } = e;
        if (a == "text") return o.unit === "word" ? function(d, u) {
          let g = d.position.textNode;
          for (g || (g = u ? d.position.nodeAfter : d.position.nodeBefore); g && g.is("$text"); ) {
            const p = d.position.offset - g.startOffset;
            if (N_(g, p, u)) g = u ? d.position.nodeAfter : d.position.nodeBefore;
            else {
              if (F_(g.data, p, u)) break;
              d.next();
            }
          }
          return d.position;
        }(n, t) : function(d, u, g) {
          const p = d.position.textNode;
          if (p) {
            const b = p.data;
            let w = d.position.offset - p.startOffset;
            for (; ds(b, w) || u == "character" && us(b, w) || g && Fc(b, w); ) d.next(), w = d.position.offset - p.startOffset;
          }
          return d.position;
        }(n, i, s);
        if (a == (t ? "elementStart" : "elementEnd")) {
          if (r.isSelectable(l)) return U._createAt(l, t ? "after" : "before");
          if (r.checkChild(c, "$text")) return c;
        } else {
          if (r.isLimit(l)) return void n.skip(() => !0);
          if (r.checkChild(c, "$text")) return c;
        }
      }
      function M_(o, e) {
        const t = o.root, n = U._createAt(t, e ? "end" : 0);
        return e ? new V(o, n) : new V(n, o);
      }
      function F_(o, e, t) {
        const n = e + (t ? 0 : -1);
        return O_.includes(o.charAt(n));
      }
      function N_(o, e, t) {
        return e === (t ? o.offsetSize : 0);
      }
      class V_ extends ve() {
        constructor() {
          super(), this.markers = new S_(), this.document = new __(this), this.schema = new z0(), this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((e) => this.decorate(e)), this.on("applyOperation", (e, t) => {
            t[0]._validate();
          }, { priority: "highest" }), this.schema.register("$root", { isLimit: !0 }), this.schema.register("$container", { allowIn: ["$root", "$container"] }), this.schema.register("$block", { allowIn: ["$root", "$container"], isBlock: !0 }), this.schema.register("$blockObject", { allowWhere: "$block", isBlock: !0, isObject: !0 }), this.schema.register("$inlineObject", { allowWhere: "$text", allowAttributesOf: "$text", isInline: !0, isObject: !0 }), this.schema.register("$text", { allowIn: "$block", isInline: !0, isContent: !0 }), this.schema.register("$clipboardHolder", { allowContentOf: "$root", allowChildren: "$text", isLimit: !0 }), this.schema.register("$documentFragment", { allowContentOf: "$root", allowChildren: "$text", isLimit: !0 }), this.schema.register("$marker"), this.schema.addChildCheck((e, t) => {
            if (t.name === "$marker") return !0;
          }), P0(this), this.document.registerPostFixer(Su), this.on("insertContent", (e, [t, n]) => {
            e.return = function(i, r, s) {
              return i.change((a) => {
                const l = s || i.document.selection;
                l.isCollapsed || i.deleteContent(l, { doNotAutoparagraph: !0 });
                const c = new P_(i, a, l.anchor), d = [];
                let u;
                if (r.is("documentFragment")) {
                  if (r.markers.size) {
                    const b = [];
                    for (const [w, y] of r.markers) {
                      const { start: I, end: z } = y, H = I.isEqual(z);
                      b.push({ position: I, name: w, isCollapsed: H }, { position: z, name: w, isCollapsed: H });
                    }
                    b.sort(({ position: w }, { position: y }) => w.isBefore(y) ? 1 : -1);
                    for (const { position: w, name: y, isCollapsed: I } of b) {
                      let z = null, H = null;
                      const X = w.parent === r && w.isAtStart, ce = w.parent === r && w.isAtEnd;
                      X || ce ? I && (H = X ? "start" : "end") : (z = a.createElement("$marker"), a.insert(z, w)), d.push({ name: y, element: z, collapsed: H });
                    }
                  }
                  u = r.getChildren();
                } else u = [r];
                c.handleNodes(u);
                let g = c.getSelectionRange();
                if (r.is("documentFragment") && d.length) {
                  const b = g ? qt.fromRange(g) : null, w = {};
                  for (let y = d.length - 1; y >= 0; y--) {
                    const { name: I, element: z, collapsed: H } = d[y], X = !w[I];
                    if (X && (w[I] = []), z) {
                      const ce = a.createPositionAt(z, "before");
                      w[I].push(ce), a.remove(z);
                    } else {
                      const ce = c.getAffectedRange();
                      if (!ce) {
                        H && w[I].push(c.position);
                        continue;
                      }
                      H ? w[I].push(ce[H]) : w[I].push(X ? ce.start : ce.end);
                    }
                  }
                  for (const [y, [I, z]] of Object.entries(w)) I && z && I.root === z.root && a.addMarker(y, { usingOperation: !0, affectsData: !0, range: new V(I, z) });
                  b && (g = b.toRange(), b.detach());
                }
                g && (l instanceof St ? a.setSelection(g) : l.setTo(g));
                const p = c.getAffectedRange() || i.createRange(l.anchor);
                return c.destroy(), p;
              });
            }(this, t, n);
          }), this.on("insertObject", (e, [t, n, i]) => {
            e.return = R_(this, t, n, i);
          }), this.on("canEditAt", (e) => {
            const t = !this.document.isReadOnly;
            e.return = t, t || e.stop();
          });
        }
        change(e) {
          try {
            return this._pendingChanges.length === 0 ? (this._pendingChanges.push({ batch: new ao(), callback: e }), this._runPendingChanges()[0]) : e(this._currentWriter);
          } catch (t) {
            T.rethrowUnexpectedError(t, this);
          }
        }
        enqueueChange(e, t) {
          try {
            e ? typeof e == "function" ? (t = e, e = new ao()) : e instanceof ao || (e = new ao(e)) : e = new ao(), this._pendingChanges.push({ batch: e, callback: t }), this._pendingChanges.length == 1 && this._runPendingChanges();
          } catch (n) {
            T.rethrowUnexpectedError(n, this);
          }
        }
        applyOperation(e) {
          e._execute();
        }
        insertContent(e, t, n, ...i) {
          const r = Qs(t, n);
          return this.fire("insertContent", [e, r, n, ...i]);
        }
        insertObject(e, t, n, i, ...r) {
          const s = Qs(t, n);
          return this.fire("insertObject", [e, s, i, i, ...r]);
        }
        deleteContent(e, t) {
          I_(this, e, t);
        }
        modifySelection(e, t) {
          (function(n, i, r = {}) {
            const s = n.schema, a = r.direction != "backward", l = r.unit ? r.unit : "character", c = !!r.treatEmojiAsSingleUnit, d = i.focus, u = new Ft({ boundaries: M_(d, a), singleCharacters: !0, direction: a ? "forward" : "backward" }), g = { walker: u, schema: s, isForward: a, unit: l, treatEmojiAsSingleUnit: c };
            let p;
            for (; p = u.next(); ) {
              if (p.done) return;
              const b = z_(g, p.value);
              if (b) return void (i instanceof St ? n.change((w) => {
                w.setSelectionFocus(b);
              }) : i.setFocus(b));
            }
          })(this, e, t);
        }
        getSelectedContent(e) {
          return function(t, n) {
            return t.change((i) => {
              const r = i.createDocumentFragment(), s = n.getFirstRange();
              if (!s || s.isCollapsed) return r;
              const a = s.start.root, l = s.start.getCommonPath(s.end), c = a.getNodeByPath(l);
              let d;
              d = s.start.parent == s.end.parent ? s : i.createRange(i.createPositionAt(c, s.start.path[l.length]), i.createPositionAt(c, s.end.path[l.length] + 1));
              const u = d.end.offset - d.start.offset;
              for (const g of d.getItems({ shallow: !0 })) g.is("$textProxy") ? i.appendText(g.data, g.getAttributes(), r) : i.append(i.cloneElement(g, !0), r);
              if (d != s) {
                const g = s._getTransformedByMove(d.start, i.createPositionAt(r, 0), u)[0], p = i.createRange(i.createPositionAt(r, 0), g.start);
                gh(i.createRange(g.end, i.createPositionAt(r, "end")), i), gh(p, i);
              }
              return r;
            });
          }(this, e);
        }
        hasContent(e, t = {}) {
          const n = e instanceof V ? e : V._createIn(e);
          if (n.isCollapsed) return !1;
          const { ignoreWhitespaces: i = !1, ignoreMarkers: r = !1 } = t;
          if (!r) {
            for (const s of this.markers.getMarkersIntersectingRange(n)) if (s.affectsData) return !0;
          }
          for (const s of n.getItems()) if (this.schema.isContent(s) && (!s.is("$textProxy") || !i || s.data.search(/\S/) !== -1))
            return !0;
          return !1;
        }
        canEditAt(e) {
          const t = Qs(e);
          return this.fire("canEditAt", [t]);
        }
        createPositionFromPath(e, t, n) {
          return new U(e, t, n);
        }
        createPositionAt(e, t) {
          return U._createAt(e, t);
        }
        createPositionAfter(e) {
          return U._createAfter(e);
        }
        createPositionBefore(e) {
          return U._createBefore(e);
        }
        createRange(e, t) {
          return new V(e, t);
        }
        createRangeIn(e) {
          return V._createIn(e);
        }
        createRangeOn(e) {
          return V._createOn(e);
        }
        createSelection(...e) {
          return new ft(...e);
        }
        createBatch(e) {
          return new ao(e);
        }
        createOperationFromJSON(e) {
          return o_.fromJSON(e, this.document);
        }
        destroy() {
          this.document.destroy(), this.stopListening();
        }
        _runPendingChanges() {
          const e = [];
          this.fire("_beforeChanges");
          try {
            for (; this._pendingChanges.length; ) {
              const t = this._pendingChanges[0].batch;
              this._currentWriter = new B_(this, t);
              const n = this._pendingChanges[0].callback(this._currentWriter);
              e.push(n), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
            }
          } finally {
            this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges");
          }
          return e;
        }
      }
      function Qs(o, e) {
        if (o) return o instanceof ft || o instanceof St ? o : o instanceof xn ? e || e === 0 ? new ft(o, e) : o.is("rootElement") ? new ft(o, "in") : new ft(o, "on") : new ft(o);
      }
      class L_ extends rn {
        constructor() {
          super(...arguments), this.domEventType = "click";
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
      }
      class Xs extends rn {
        constructor() {
          super(...arguments), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
      }
      class Wi {
        constructor(e) {
          this.document = e;
        }
        createDocumentFragment(e) {
          return new En(this.document, e);
        }
        createElement(e, t, n) {
          return new mt(this.document, e, t, n);
        }
        createText(e) {
          return new Ce(this.document, e);
        }
        clone(e, t = !1) {
          return e._clone(t);
        }
        appendChild(e, t) {
          return t._appendChild(e);
        }
        insertChild(e, t, n) {
          return n._insertChild(e, t);
        }
        removeChildren(e, t, n) {
          return n._removeChildren(e, t);
        }
        remove(e) {
          const t = e.parent;
          return t ? this.removeChildren(t.getChildIndex(e), 1, t) : [];
        }
        replace(e, t) {
          const n = e.parent;
          if (n) {
            const i = n.getChildIndex(e);
            return this.removeChildren(i, 1, n), this.insertChild(i, t, n), !0;
          }
          return !1;
        }
        unwrapElement(e) {
          const t = e.parent;
          if (t) {
            const n = t.getChildIndex(e);
            this.remove(e), this.insertChild(n, e.getChildren(), t);
          }
        }
        rename(e, t) {
          const n = new mt(this.document, e, t.getAttributes(), t.getChildren());
          return this.replace(t, n) ? n : null;
        }
        setAttribute(e, t, n) {
          n._setAttribute(e, t);
        }
        removeAttribute(e, t) {
          t._removeAttribute(e);
        }
        addClass(e, t) {
          t._addClass(e);
        }
        removeClass(e, t) {
          t._removeClass(e);
        }
        setStyle(e, t, n) {
          at(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t);
        }
        removeStyle(e, t) {
          t._removeStyle(e);
        }
        setCustomProperty(e, t, n) {
          n._setCustomProperty(e, t);
        }
        removeCustomProperty(e, t) {
          return t._removeCustomProperty(e);
        }
        createPositionAt(e, t) {
          return G._createAt(e, t);
        }
        createPositionAfter(e) {
          return G._createAfter(e);
        }
        createPositionBefore(e) {
          return G._createBefore(e);
        }
        createRange(e, t) {
          return new te(e, t);
        }
        createRangeOn(e) {
          return te._createOn(e);
        }
        createRangeIn(e) {
          return te._createIn(e);
        }
        createSelection(...e) {
          return new Ot(...e);
        }
      }
      function j_(o = "") {
        if (o === "") return { top: void 0, right: void 0, bottom: void 0, left: void 0 };
        const e = o.replace(/, /g, ",").split(" ").map((r) => r.replace(/,/g, ", ")), t = e[0], n = e[2] || t, i = e[1] || t;
        return { top: t, bottom: n, right: i, left: e[3] || i };
      }
      function $_({ top: o, right: e, bottom: t, left: n }) {
        const i = [];
        return n !== e ? i.push(o, e, t, n) : t !== o ? i.push(o, e, t) : e !== o ? i.push(o, e) : i.push(o), i.join(" ");
      }
      function H_(o) {
        var e, t;
        o.setNormalizer("margin", (e = "margin", (n) => ({ path: e, value: j_(n) }))), o.setNormalizer("margin-top", (n) => ({ path: "margin.top", value: n })), o.setNormalizer("margin-right", (n) => ({ path: "margin.right", value: n })), o.setNormalizer("margin-bottom", (n) => ({ path: "margin.bottom", value: n })), o.setNormalizer("margin-left", (n) => ({ path: "margin.left", value: n })), o.setReducer("margin", (t = "margin", (n) => {
          const { top: i, right: r, bottom: s, left: a } = n, l = [];
          return [i, r, a, s].every((c) => !!c) ? l.push([t, $_(n)]) : (i && l.push([t + "-top", i]), r && l.push([t + "-right", r]), s && l.push([t + "-bottom", s]), a && l.push([t + "-left", a])), l;
        })), o.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"]);
      }
      class q_ {
        constructor() {
          this._commands = /* @__PURE__ */ new Map();
        }
        add(e, t) {
          this._commands.set(e, t);
        }
        get(e) {
          return this._commands.get(e);
        }
        execute(e, ...t) {
          const n = this.get(e);
          if (!n) throw new T("commandcollection-command-not-found", this, { commandName: e });
          return n.execute(...t);
        }
        *names() {
          yield* this._commands.keys();
        }
        *commands() {
          yield* this._commands.values();
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]();
        }
        destroy() {
          for (const e of this.commands()) e.destroy();
        }
      }
      class U_ extends ve() {
        constructor(e = {}) {
          super();
          const t = this.constructor, n = e.language || t.defaultConfig && t.defaultConfig.language;
          this._context = e.context || new md({ language: n }), this._context._addEditor(this, !e.context);
          const i = Array.from(t.builtinPlugins || []);
          this.config = new pc(e, t.defaultConfig), this.config.define("plugins", i), this.config.define(this._context._getEditorConfig()), this.plugins = new gd(this, i, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = /* @__PURE__ */ new Set(), this.commands = new q_(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.model = new V_(), this.on("change:isReadOnly", () => {
            this.model.document.isReadOnly = this.isReadOnly;
          });
          const r = new fA();
          this.data = new t_(this.model, r), this.editing = new R0(this.model, r), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new n_([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new Fw(this), this.keystrokes.listenTo(this.editing.view.document);
        }
        get isReadOnly() {
          return this._readOnlyLocks.size > 0;
        }
        set isReadOnly(e) {
          throw new T("editor-isreadonly-has-no-setter");
        }
        enableReadOnlyMode(e) {
          if (typeof e != "string" && typeof e != "symbol") throw new T("editor-read-only-lock-id-invalid", null, { lockId: e });
          this._readOnlyLocks.has(e) || (this._readOnlyLocks.add(e), this._readOnlyLocks.size === 1 && this.fire("change:isReadOnly", "isReadOnly", !0, !1));
        }
        disableReadOnlyMode(e) {
          if (typeof e != "string" && typeof e != "symbol") throw new T("editor-read-only-lock-id-invalid", null, { lockId: e });
          this._readOnlyLocks.has(e) && (this._readOnlyLocks.delete(e), this._readOnlyLocks.size === 0 && this.fire("change:isReadOnly", "isReadOnly", !1, !0));
        }
        initPlugins() {
          const e = this.config, t = e.get("plugins"), n = e.get("removePlugins") || [], i = e.get("extraPlugins") || [], r = e.get("substitutePlugins") || [];
          return this.plugins.init(t.concat(i), n, r);
        }
        destroy() {
          let e = Promise.resolve();
          return this.state == "initializing" && (e = new Promise((t) => this.once("ready", t))), e.then(() => {
            this.fire("destroy"), this.stopListening(), this.commands.destroy();
          }).then(() => this.plugins.destroy()).then(() => {
            this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
          }).then(() => this._context._removeEditor(this));
        }
        execute(e, ...t) {
          try {
            return this.commands.execute(e, ...t);
          } catch (n) {
            T.rethrowUnexpectedError(n, this);
          }
        }
        focus() {
          this.editing.view.focus();
        }
        static create(...e) {
          throw new Error("This is an abstract method.");
        }
      }
      function Ki(o) {
        return class extends o {
          setData(e) {
            this.data.set(e);
          }
          getData(e) {
            return this.data.get(e);
          }
        };
      }
      {
        const o = Ki(Object);
        Ki.setData = o.prototype.setData, Ki.getData = o.prototype.getData;
      }
      function ea(o) {
        return class extends o {
          updateSourceElement(e = this.data.get()) {
            if (!this.sourceElement) throw new T("editor-missing-sourceelement", this);
            const t = this.config.get("updateSourceElementOnDestroy"), n = this.sourceElement instanceof HTMLTextAreaElement;
            aw(this.sourceElement, t || n ? e : "");
          }
        };
      }
      ea.updateSourceElement = ea(Object).prototype.updateSourceElement;
      class Gi extends Bi {
        static get pluginName() {
          return "PendingActions";
        }
        init() {
          this.set("hasAny", !1), this._actions = new _t({ idProperty: "_id" }), this._actions.delegate("add", "remove").to(this);
        }
        add(e) {
          if (typeof e != "string") throw new T("pendingactions-add-invalid-message", this);
          const t = new (ve())();
          return t.set("message", e), this._actions.add(t), this.hasAny = !0, t;
        }
        remove(e) {
          this._actions.remove(e), this.hasAny = !!this._actions.length;
        }
        get first() {
          return this._actions.get(0);
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]();
        }
      }
      const Pe = { bold: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', cancel: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>', caption: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>', check: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>', eraser: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>', image: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>', lowVision: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>', importExport: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path clip-rule="evenodd" d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>', paragraph: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>', plus: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>', text: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path clip-rule="evenodd" d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>', alignBottom: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>', alignMiddle: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>', alignTop: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>', alignLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', alignCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>', alignRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>', alignJustify: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', objectLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>', objectRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectFullWidth: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>', objectInline: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectSizeFull: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>', objectSizeLarge: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>', objectSizeSmall: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>', objectSizeMedium: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>', pencil: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>', pilcrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>', quote: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', threeVerticalDots: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>' };
      var ph = D(5542), W_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(ph.Z, W_), ph.Z.locals;
      const { threeVerticalDots: fh } = Pe, K_ = { alignLeft: Pe.alignLeft, bold: Pe.bold, importExport: Pe.importExport, paragraph: Pe.paragraph, plus: Pe.plus, text: Pe.text, threeVerticalDots: Pe.threeVerticalDots };
      class ta extends de {
        constructor(e, t) {
          super(e);
          const n = this.bindTemplate, i = this.t;
          this.options = t || {}, this.set("ariaLabel", i("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new Et(), this.keystrokes = new $t(), this.set("class", void 0), this.set("isCompact", !1), this.itemsView = new G_(e), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
          const r = e.uiLanguageDirection === "rtl";
          this._focusCycler = new Mo({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: [r ? "arrowright" : "arrowleft", "arrowup"], focusNext: [r ? "arrowleft" : "arrowright", "arrowdown"] } });
          const s = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")];
          var a;
          this.options.shouldGroupWhenFull && this.options.isFloating && s.push("ck-toolbar_floating"), this.setTemplate({ tag: "div", attributes: { class: s, role: "toolbar", "aria-label": n.to("ariaLabel"), style: { maxWidth: n.to("maxWidth") }, tabindex: -1 }, children: this.children, on: { mousedown: (a = this, a.bindTemplate.to((l) => {
            l.target === a.element && l.preventDefault();
          })) } }), this._behavior = this.options.shouldGroupWhenFull ? new J_(this) : new Z_(this);
        }
        render() {
          super.render(), this.focusTracker.add(this.element);
          for (const e of this.items) this.focusTracker.add(e.element);
          this.items.on("add", (e, t) => {
            this.focusTracker.add(t.element);
          }), this.items.on("remove", (e, t) => {
            this.focusTracker.remove(t.element);
          }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
        }
        destroy() {
          return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        fillFromConfig(e, t, n) {
          this.items.addMany(this._buildItemsFromConfig(e, t, n));
        }
        _buildItemsFromConfig(e, t, n) {
          const i = cd(e), r = n || i.removeItems;
          return this._cleanItemsConfiguration(i.items, t, r).map((s) => ze(s) ? this._createNestedToolbarDropdown(s, t, r) : s === "|" ? new ld() : s === "-" ? new Mw() : t.create(s)).filter((s) => !!s);
        }
        _cleanItemsConfiguration(e, t, n) {
          const i = e.filter((r, s, a) => r === "|" || n.indexOf(r) === -1 && (r === "-" ? !this.options.shouldGroupWhenFull || (ee("toolbarview-line-break-ignored-when-grouping-items", a), !1) : !(!ze(r) && !t.has(r)) || (ee("toolbarview-item-unavailable", { item: r }), !1)));
          return this._cleanSeparatorsAndLineBreaks(i);
        }
        _cleanSeparatorsAndLineBreaks(e) {
          const t = (s) => s !== "-" && s !== "|", n = e.length, i = e.findIndex(t);
          if (i === -1) return [];
          const r = n - e.slice().reverse().findIndex(t);
          return e.slice(i, r).filter((s, a, l) => t(s) ? !0 : !(a > 0 && l[a - 1] === s));
        }
        _createNestedToolbarDropdown(e, t, n) {
          let { label: i, icon: r, items: s, tooltip: a = !0, withText: l = !1 } = e;
          if (s = this._cleanItemsConfiguration(s, t, n), !s.length) return null;
          const c = Kt(this.locale);
          return i || ee("toolbarview-nested-toolbar-dropdown-missing-label", e), c.class = "ck-toolbar__nested-toolbar-dropdown", c.buttonView.set({ label: i, tooltip: a, withText: !!l }), r !== !1 ? c.buttonView.icon = K_[r] || r || fh : c.buttonView.withText = !0, Zi(c, () => c.toolbarView._buildItemsFromConfig(s, t, n)), c;
        }
      }
      class G_ extends de {
        constructor(e) {
          super(e), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar__items"] }, children: this.children });
        }
      }
      class Z_ {
        constructor(e) {
          const t = e.bindTemplate;
          e.set("isVertical", !1), e.itemsView.children.bindTo(e.items).using((n) => n), e.focusables.bindTo(e.items).using((n) => n), e.extendTemplate({ attributes: { class: [t.if("isVertical", "ck-toolbar_vertical")] } });
        }
        render() {
        }
        destroy() {
        }
      }
      class J_ {
        constructor(e) {
          this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = !1, this.view = e, this.viewChildren = e.children, this.viewFocusables = e.focusables, this.viewItemsView = e.itemsView, this.viewFocusTracker = e.focusTracker, this.viewLocale = e.locale, this.ungroupedItems = e.createCollection(), this.groupedItems = e.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), e.itemsView.children.bindTo(this.ungroupedItems).using((t) => t), this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this)), e.children.on("change", this._updateFocusCycleableItems.bind(this)), e.items.on("change", (t, n) => {
            const i = n.index, r = Array.from(n.added);
            for (const s of n.removed) i >= this.ungroupedItems.length ? this.groupedItems.remove(s) : this.ungroupedItems.remove(s);
            for (let s = i; s < i + r.length; s++) {
              const a = r[s - i];
              s > this.ungroupedItems.length ? this.groupedItems.add(a, s - this.ungroupedItems.length) : this.ungroupedItems.add(a, s);
            }
            this._updateGrouping();
          }), e.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
        }
        render(e) {
          this.viewElement = e.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(e);
        }
        destroy() {
          this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
        }
        _updateGrouping() {
          if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) return;
          if (!kn(this.viewElement)) return void (this.shouldUpdateGroupingOnNextResize = !0);
          const e = this.groupedItems.length;
          let t;
          for (; this._areItemsOverflowing; ) this._groupLastItem(), t = !0;
          if (!t && this.groupedItems.length) {
            for (; this.groupedItems.length && !this._areItemsOverflowing; ) this._ungroupFirstItem();
            this._areItemsOverflowing && this._groupLastItem();
          }
          this.groupedItems.length !== e && this.view.fire("groupedItemsUpdate");
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length) return !1;
          const e = this.viewElement, t = this.viewLocale.uiLanguageDirection, n = new Fe(e.lastChild), i = new Fe(e);
          if (!this.cachedPadding) {
            const r = le.window.getComputedStyle(e), s = t === "ltr" ? "paddingRight" : "paddingLeft";
            this.cachedPadding = Number.parseInt(r[s]);
          }
          return t === "ltr" ? n.right > i.right - this.cachedPadding : n.left < i.left + this.cachedPadding;
        }
        _enableGroupingOnResize() {
          let e;
          this.resizeObserver = new Ci(this.viewElement, (t) => {
            e && e === t.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = !1, this._updateGrouping(), e = t.contentRect.width);
          }), this._updateGrouping();
        }
        _enableGroupingOnMaxWidthChange(e) {
          e.on("change:maxWidth", () => {
            this._updateGrouping();
          });
        }
        _groupLastItem() {
          this.groupedItems.length || (this.viewChildren.add(new ld()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
        }
        _createGroupedItemsDropdown() {
          const e = this.viewLocale, t = e.t, n = Kt(e);
          return n.class = "ck-toolbar__grouped-dropdown", n.panelPosition = e.uiLanguageDirection === "ltr" ? "sw" : "se", Zi(n, this.groupedItems), n.buttonView.set({ label: t("Show more items"), tooltip: !0, tooltipPosition: e.uiLanguageDirection === "rtl" ? "se" : "sw", icon: fh }), n;
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear(), this.ungroupedItems.map((e) => {
            this.viewFocusables.add(e);
          }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
        }
      }
      var bh = D(1046), Y_ = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(bh.Z, Y_), bh.Z.locals;
      class Q_ extends de {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.items = this.createCollection(), this.focusTracker = new Et(), this.keystrokes = new $t(), this._focusCycler = new Mo({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowup", focusNext: "arrowdown" } }), this.set("ariaLabel", void 0), this.set("role", void 0), this.setTemplate({ tag: "ul", attributes: { class: ["ck", "ck-reset", "ck-list"], role: t.to("role"), "aria-label": t.to("ariaLabel") }, children: this.items });
        }
        render() {
          super.render();
          for (const e of this.items) this.focusTracker.add(e.element);
          this.items.on("add", (e, t) => {
            this.focusTracker.add(t.element);
          }), this.items.on("remove", (e, t) => {
            this.focusTracker.remove(t.element);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
      }
      class kh extends de {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("isVisible", !0), this.children = this.createCollection(), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__item", t.if("isVisible", "ck-hidden", (n) => !n)], role: "presentation" }, children: this.children });
        }
        focus() {
          this.children.first.focus();
        }
      }
      class X_ extends de {
        constructor(e) {
          super(e), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } });
        }
      }
      var wh = D(7686), ev = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(wh.Z, ev), wh.Z.locals;
      class na extends de {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isToggleable", !1), this.set("isVisible", !0), this.set("keystroke", void 0), this.set("withKeystroke", !1), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.children = this.createCollection(), this.actionView = this._createActionView(), this.arrowView = this._createArrowView(), this.keystrokes = new $t(), this.focusTracker = new Et(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-splitbutton", t.to("class"), t.if("isVisible", "ck-hidden", (n) => !n), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")] }, children: this.children });
        }
        render() {
          super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (e, t) => {
            this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), t());
          }), this.keystrokes.set("arrowleft", (e, t) => {
            this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), t());
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this.actionView.focus();
        }
        _createActionView() {
          const e = new De();
          return e.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), e.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }), e.delegate("execute").to(this), e;
        }
        _createArrowView() {
          const e = new De(), t = e.bindTemplate;
          return e.icon = sd, e.extendTemplate({ attributes: { class: ["ck-splitbutton__arrow"], "data-cke-tooltip-disabled": t.to("isOn"), "aria-haspopup": !0, "aria-expanded": t.to("isOn", (n) => String(n)) } }), e.bind("isEnabled").to(this), e.bind("label").to(this), e.bind("tooltip").to(this), e.delegate("execute").to(this, "open"), e;
        }
      }
      var Ah = D(7339), tv = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Ah.Z, tv), Ah.Z.locals;
      var _h = D(3949), nv = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(_h.Z, nv), _h.Z.locals;
      function Kt(o, e = ad) {
        const t = new e(o), n = new Ow(o), i = new ps(o, t, n);
        return t.bind("isEnabled").to(i), t instanceof na ? t.arrowView.bind("isOn").to(i, "isOpen") : t.bind("isOn").to(i, "isOpen"), function(r) {
          (function(s) {
            s.on("render", () => {
              k({ emitter: s, activator: () => s.isOpen, callback: () => {
                s.isOpen = !1;
              }, contextElements: [s.element] });
            });
          })(r), function(s) {
            s.on("execute", (a) => {
              a.source instanceof Di || (s.isOpen = !1);
            });
          }(r), function(s) {
            s.focusTracker.on("change:isFocused", (a, l, c) => {
              s.isOpen && !c && (s.isOpen = !1);
            });
          }(r), function(s) {
            s.keystrokes.set("arrowdown", (a, l) => {
              s.isOpen && (s.panelView.focus(), l());
            }), s.keystrokes.set("arrowup", (a, l) => {
              s.isOpen && (s.panelView.focusLast(), l());
            });
          }(r), function(s) {
            s.on("change:isOpen", (a, l, c) => {
              if (c) return;
              const d = s.panelView.element;
              d && d.contains(le.document.activeElement) && s.buttonView.focus();
            });
          }(r), function(s) {
            s.on("change:isOpen", (a, l, c) => {
              c && s.panelView.focus();
            }, { priority: "low" });
          }(r);
        }(i), i;
      }
      function Zi(o, e, t = {}) {
        o.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }), o.isOpen ? vh(o, e, t) : o.once("change:isOpen", () => vh(o, e, t), { priority: "highest" }), t.enableActiveItemFocusOnDropdownOpen && yh(o, () => o.toolbarView.items.find((n) => n.isOn));
      }
      function vh(o, e, t) {
        const n = o.locale, i = n.t, r = o.toolbarView = new ta(n), s = typeof e == "function" ? e() : e;
        r.ariaLabel = t.ariaLabel || i("Dropdown toolbar"), t.maxWidth && (r.maxWidth = t.maxWidth), t.class && (r.class = t.class), t.isCompact && (r.isCompact = t.isCompact), t.isVertical && (r.isVertical = !0), s instanceof wn ? r.items.bindTo(s).using((a) => a) : r.items.addMany(s), o.panelView.children.add(r), r.items.delegate("execute").to(o);
      }
      function oa(o, e, t = {}) {
        o.isOpen ? Ch(o, e, t) : o.once("change:isOpen", () => Ch(o, e, t), { priority: "highest" }), yh(o, () => o.listView.items.find((n) => n instanceof kh && n.children.first.isOn));
      }
      function Ch(o, e, t) {
        const n = o.locale, i = o.listView = new Q_(n), r = typeof e == "function" ? e() : e;
        i.ariaLabel = t.ariaLabel, i.role = t.role, i.items.bindTo(r).using((s) => {
          if (s.type === "separator") return new X_(n);
          if (s.type === "button" || s.type === "switchbutton") {
            const a = new kh(n);
            let l;
            return l = s.type === "button" ? new De(n) : new Di(n), l.bind(...Object.keys(s.model)).to(s.model), l.delegate("execute").to(a), a.children.add(l), a;
          }
          return null;
        }), o.panelView.children.add(i), i.items.delegate("execute").to(o);
      }
      function yh(o, e) {
        o.on("change:isOpen", () => {
          if (!o.isOpen) return;
          const t = e();
          t && (typeof t.focus == "function" ? t.focus() : ee("ui-dropdown-focus-child-on-open-child-missing-focus", { view: t }));
        }, { priority: se.low - 10 });
      }
      function Eh(o, e, t) {
        const n = new Rw(o.locale);
        return n.set({ id: e, ariaDescribedById: t }), n.bind("isReadOnly").to(o, "isEnabled", (i) => !i), n.bind("hasError").to(o, "errorText", (i) => !!i), n.on("input", () => {
          o.errorText = null;
        }), o.bind("isEmpty", "isFocused", "placeholder").to(n), n;
      }
      const Jo = (o, e = 0, t = 1) => o > t ? t : o < e ? e : o, tt = (o, e = 0, t = Math.pow(10, e)) => Math.round(t * o) / t, ia = (o) => (o[0] === "#" && (o = o.substring(1)), o.length < 6 ? { r: parseInt(o[0] + o[0], 16), g: parseInt(o[1] + o[1], 16), b: parseInt(o[2] + o[2], 16), a: o.length === 4 ? tt(parseInt(o[3] + o[3], 16) / 255, 2) : 1 } : { r: parseInt(o.substring(0, 2), 16), g: parseInt(o.substring(2, 4), 16), b: parseInt(o.substring(4, 6), 16), a: o.length === 8 ? tt(parseInt(o.substring(6, 8), 16) / 255, 2) : 1 }), ov = ({ h: o, s: e, v: t, a: n }) => {
        const i = (200 - e) * t / 100;
        return { h: tt(o), s: tt(i > 0 && i < 200 ? e * t / 100 / (i <= 100 ? i : 200 - i) * 100 : 0), l: tt(i / 2), a: tt(n, 2) };
      }, ra = (o) => {
        const { h: e, s: t, l: n } = ov(o);
        return `hsl(${e}, ${t}%, ${n}%)`;
      }, iv = ({ h: o, s: e, v: t, a: n }) => {
        o = o / 360 * 6, e /= 100, t /= 100;
        const i = Math.floor(o), r = t * (1 - e), s = t * (1 - (o - i) * e), a = t * (1 - (1 - o + i) * e), l = i % 6;
        return { r: tt(255 * [t, s, r, r, a, t][l]), g: tt(255 * [a, t, t, s, r, r][l]), b: tt(255 * [r, r, a, t, t, s][l]), a: tt(n, 2) };
      }, Ji = (o) => {
        const e = o.toString(16);
        return e.length < 2 ? "0" + e : e;
      }, rv = ({ r: o, g: e, b: t, a: n }) => {
        const i = n < 1 ? Ji(tt(255 * n)) : "";
        return "#" + Ji(o) + Ji(e) + Ji(t) + i;
      }, sv = ({ r: o, g: e, b: t, a: n }) => {
        const i = Math.max(o, e, t), r = i - Math.min(o, e, t), s = r ? i === o ? (e - t) / r : i === e ? 2 + (t - o) / r : 4 + (o - e) / r : 0;
        return { h: tt(60 * (s < 0 ? s + 6 : s)), s: tt(i ? r / i * 100 : 0), v: tt(i / 255 * 100), a: n };
      }, xh = (o, e) => {
        if (o === e) return !0;
        for (const t in o) if (o[t] !== e[t]) return !1;
        return !0;
      }, Sh = {}, Dh = (o) => {
        let e = Sh[o];
        return e || (e = document.createElement("template"), e.innerHTML = o, Sh[o] = e), e;
      }, sa = (o, e, t) => {
        o.dispatchEvent(new CustomEvent(e, { bubbles: !0, detail: t }));
      };
      let co = !1;
      const aa = (o) => "touches" in o, Bh = (o, e) => {
        const t = aa(e) ? e.touches[0] : e, n = o.el.getBoundingClientRect();
        sa(o.el, "move", o.getMove({ x: Jo((t.pageX - (n.left + window.pageXOffset)) / n.width), y: Jo((t.pageY - (n.top + window.pageYOffset)) / n.height) }));
      };
      class Th {
        constructor(e, t, n, i) {
          const r = Dh(`<div role="slider" tabindex="0" part="${t}" ${n}><div part="${t}-pointer"></div></div>`);
          e.appendChild(r.content.cloneNode(!0));
          const s = e.querySelector(`[part=${t}]`);
          s.addEventListener("mousedown", this), s.addEventListener("touchstart", this), s.addEventListener("keydown", this), this.el = s, this.xy = i, this.nodes = [s.firstChild, s];
        }
        set dragging(e) {
          const t = e ? document.addEventListener : document.removeEventListener;
          t(co ? "touchmove" : "mousemove", this), t(co ? "touchend" : "mouseup", this);
        }
        handleEvent(e) {
          switch (e.type) {
            case "mousedown":
            case "touchstart":
              if (e.preventDefault(), !((t) => !(co && !aa(t) || (co || (co = aa(t)), 0)))(e) || !co && e.button != 0) return;
              this.el.focus(), Bh(this, e), this.dragging = !0;
              break;
            case "mousemove":
            case "touchmove":
              e.preventDefault(), Bh(this, e);
              break;
            case "mouseup":
            case "touchend":
              this.dragging = !1;
              break;
            case "keydown":
              ((t, n) => {
                const i = n.keyCode;
                i > 40 || t.xy && i < 37 || i < 33 || (n.preventDefault(), sa(t.el, "move", t.getMove({ x: i === 39 ? 0.01 : i === 37 ? -0.01 : i === 34 ? 0.05 : i === 33 ? -0.05 : i === 35 ? 1 : i === 36 ? -1 : 0, y: i === 40 ? 0.01 : i === 38 ? -0.01 : 0 }, !0)));
              })(this, e);
          }
        }
        style(e) {
          e.forEach((t, n) => {
            for (const i in t) this.nodes[n].style.setProperty(i, t[i]);
          });
        }
      }
      class av extends Th {
        constructor(e) {
          super(e, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', !1);
        }
        update({ h: e }) {
          this.h = e, this.style([{ left: e / 360 * 100 + "%", color: ra({ h: e, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuenow", `${tt(e)}`);
        }
        getMove(e, t) {
          return { h: t ? Jo(this.h + 360 * e.x, 0, 360) : 360 * e.x };
        }
      }
      class lv extends Th {
        constructor(e) {
          super(e, "saturation", 'aria-label="Color"', !0);
        }
        update(e) {
          this.hsva = e, this.style([{ top: 100 - e.v + "%", left: `${e.s}%`, color: ra(e) }, { "background-color": ra({ h: e.h, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuetext", `Saturation ${tt(e.s)}%, Brightness ${tt(e.v)}%`);
        }
        getMove(e, t) {
          return { s: t ? Jo(this.hsva.s + 100 * e.x, 0, 100) : 100 * e.x, v: t ? Jo(this.hsva.v - 100 * e.y, 0, 100) : Math.round(100 - 100 * e.y) };
        }
      }
      const Yi = Symbol("same"), la = Symbol("color"), Ih = Symbol("hsva"), ca = Symbol("update"), Ph = Symbol("parts"), Rh = Symbol("css"), Oh = Symbol("sliders");
      class cv extends HTMLElement {
        static get observedAttributes() {
          return ["color"];
        }
        get [Rh]() {
          return [':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}', "[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}", "[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}"];
        }
        get [Oh]() {
          return [lv, av];
        }
        get color() {
          return this[la];
        }
        set color(e) {
          if (!this[Yi](e)) {
            const t = this.colorModel.toHsva(e);
            this[ca](t), this[la] = e;
          }
        }
        constructor() {
          super();
          const e = Dh(`<style>${this[Rh].join("")}</style>`), t = this.attachShadow({ mode: "open" });
          t.appendChild(e.content.cloneNode(!0)), t.addEventListener("move", this), this[Ph] = this[Oh].map((n) => new n(t));
        }
        connectedCallback() {
          if (this.hasOwnProperty("color")) {
            const e = this.color;
            delete this.color, this.color = e;
          } else this.color || (this.color = this.colorModel.defaultColor);
        }
        attributeChangedCallback(e, t, n) {
          const i = this.colorModel.fromAttr(n);
          this[Yi](i) || (this.color = i);
        }
        handleEvent(e) {
          const t = this[Ih], n = { ...t, ...e.detail };
          let i;
          this[ca](n), xh(n, t) || this[Yi](i = this.colorModel.fromHsva(n)) || (this[la] = i, sa(this, "color-changed", { value: i }));
        }
        [Yi](e) {
          return this.color && this.colorModel.equal(e, this.color);
        }
        [ca](e) {
          this[Ih] = e, this[Ph].forEach((t) => t.update(e));
        }
      }
      const dv = { defaultColor: "#000", toHsva: (o) => sv(ia(o)), fromHsva: ({ h: o, s: e, v: t }) => rv(iv({ h: o, s: e, v: t, a: 1 })), equal: (o, e) => o.toLowerCase() === e.toLowerCase() || xh(ia(o), ia(e)), fromAttr: (o) => o };
      class uv extends cv {
        get colorModel() {
          return dv;
        }
      }
      customElements.define("hex-color-picker", class extends uv {
      });
      var zh = D(3398), hv = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(zh.Z, hv), zh.Z.locals;
      class gv {
        constructor(e) {
          this._components = /* @__PURE__ */ new Map(), this.editor = e;
        }
        *names() {
          for (const e of this._components.values()) yield e.originalName;
        }
        add(e, t) {
          this._components.set(da(e), { callback: t, originalName: e });
        }
        create(e) {
          if (!this.has(e)) throw new T("componentfactory-item-missing", this, { name: e });
          return this._components.get(da(e)).callback(this.editor.locale);
        }
        has(e) {
          return this._components.has(da(e));
        }
      }
      function da(o) {
        return String(o).toLowerCase();
      }
      var Mh = D(8793), mv = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Mh.Z, mv), Mh.Z.locals;
      var pv = Object.defineProperty, Fh = Object.getOwnPropertySymbols, fv = Object.prototype.hasOwnProperty, bv = Object.prototype.propertyIsEnumerable, Nh = (o, e, t) => e in o ? pv(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, pe = (o, e) => {
        for (var t in e || (e = {})) fv.call(e, t) && Nh(o, t, e[t]);
        if (Fh) for (var t of Fh(e)) bv.call(e, t) && Nh(o, t, e[t]);
        return o;
      };
      const Vh = rs("px"), Lh = le.document.body, ua = class extends de {
        constructor(o) {
          super(o);
          const e = this.bindTemplate;
          this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", !1), this.set("withArrow", !0), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-panel", e.to("position", (t) => `ck-balloon-panel_${t}`), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")], style: { top: e.to("top", Vh), left: e.to("left", Vh) } }, children: this.content });
        }
        show() {
          this.isVisible = !0;
        }
        hide() {
          this.isVisible = !1;
        }
        attachTo(o) {
          this.show();
          const e = ua.defaultPositions, t = Object.assign({}, { element: this.element, positions: [e.southArrowNorth, e.southArrowNorthMiddleWest, e.southArrowNorthMiddleEast, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthMiddleWest, e.northArrowSouthMiddleEast, e.northArrowSouthWest, e.northArrowSouthEast, e.viewportStickyNorth], limiter: Lh, fitInViewport: !0 }, o), n = ua._getOptimalPosition(t), i = parseInt(n.left), r = parseInt(n.top), s = n.name, a = n.config || {}, { withArrow: l = !0 } = a;
          this.top = r, this.left = i, this.position = s, this.withArrow = l;
        }
        pin(o) {
          this.unpin(), this._pinWhenIsVisibleCallback = () => {
            this.isVisible ? this._startPinning(o) : this._stopPinning();
          }, this._startPinning(o), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
        }
        unpin() {
          this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
        }
        _startPinning(o) {
          this.attachTo(o);
          const e = ha(o.target), t = o.limiter ? ha(o.limiter) : Lh;
          this.listenTo(le.document, "scroll", (n, i) => {
            const r = i.target, s = e && r.contains(e), a = t && r.contains(t);
            !s && !a && e && t || this.attachTo(o);
          }, { useCapture: !0 }), this.listenTo(le.window, "resize", () => {
            this.attachTo(o);
          });
        }
        _stopPinning() {
          this.stopListening(le.document, "scroll"), this.stopListening(le.window, "resize");
        }
      };
      let ut = ua;
      function ha(o) {
        return Qn(o) ? o : _i(o) ? o.commonAncestorContainer : typeof o == "function" ? ha(o()) : null;
      }
      function jh(o = {}) {
        const { sideOffset: e = ut.arrowSideOffset, heightOffset: t = ut.arrowHeightOffset, stickyVerticalOffset: n = ut.stickyVerticalOffset, config: i } = o;
        return { northWestArrowSouthWest: (a, l) => pe({ top: r(a, l), left: a.left - e, name: "arrow_sw" }, i && { config: i }), northWestArrowSouthMiddleWest: (a, l) => pe({ top: r(a, l), left: a.left - 0.25 * l.width - e, name: "arrow_smw" }, i && { config: i }), northWestArrowSouth: (a, l) => pe({ top: r(a, l), left: a.left - l.width / 2, name: "arrow_s" }, i && { config: i }), northWestArrowSouthMiddleEast: (a, l) => pe({ top: r(a, l), left: a.left - 0.75 * l.width + e, name: "arrow_sme" }, i && { config: i }), northWestArrowSouthEast: (a, l) => pe({ top: r(a, l), left: a.left - l.width + e, name: "arrow_se" }, i && { config: i }), northArrowSouthWest: (a, l) => pe({ top: r(a, l), left: a.left + a.width / 2 - e, name: "arrow_sw" }, i && { config: i }), northArrowSouthMiddleWest: (a, l) => pe({ top: r(a, l), left: a.left + a.width / 2 - 0.25 * l.width - e, name: "arrow_smw" }, i && { config: i }), northArrowSouth: (a, l) => pe({ top: r(a, l), left: a.left + a.width / 2 - l.width / 2, name: "arrow_s" }, i && { config: i }), northArrowSouthMiddleEast: (a, l) => pe({ top: r(a, l), left: a.left + a.width / 2 - 0.75 * l.width + e, name: "arrow_sme" }, i && { config: i }), northArrowSouthEast: (a, l) => pe({ top: r(a, l), left: a.left + a.width / 2 - l.width + e, name: "arrow_se" }, i && { config: i }), northEastArrowSouthWest: (a, l) => pe({ top: r(a, l), left: a.right - e, name: "arrow_sw" }, i && { config: i }), northEastArrowSouthMiddleWest: (a, l) => pe({ top: r(a, l), left: a.right - 0.25 * l.width - e, name: "arrow_smw" }, i && { config: i }), northEastArrowSouth: (a, l) => pe({ top: r(a, l), left: a.right - l.width / 2, name: "arrow_s" }, i && { config: i }), northEastArrowSouthMiddleEast: (a, l) => pe({ top: r(a, l), left: a.right - 0.75 * l.width + e, name: "arrow_sme" }, i && { config: i }), northEastArrowSouthEast: (a, l) => pe({ top: r(a, l), left: a.right - l.width + e, name: "arrow_se" }, i && { config: i }), southWestArrowNorthWest: (a) => pe({ top: s(a), left: a.left - e, name: "arrow_nw" }, i && { config: i }), southWestArrowNorthMiddleWest: (a, l) => pe({ top: s(a), left: a.left - 0.25 * l.width - e, name: "arrow_nmw" }, i && { config: i }), southWestArrowNorth: (a, l) => pe({ top: s(a), left: a.left - l.width / 2, name: "arrow_n" }, i && { config: i }), southWestArrowNorthMiddleEast: (a, l) => pe({ top: s(a), left: a.left - 0.75 * l.width + e, name: "arrow_nme" }, i && { config: i }), southWestArrowNorthEast: (a, l) => pe({ top: s(a), left: a.left - l.width + e, name: "arrow_ne" }, i && { config: i }), southArrowNorthWest: (a) => pe({ top: s(a), left: a.left + a.width / 2 - e, name: "arrow_nw" }, i && { config: i }), southArrowNorthMiddleWest: (a, l) => pe({ top: s(a), left: a.left + a.width / 2 - 0.25 * l.width - e, name: "arrow_nmw" }, i && { config: i }), southArrowNorth: (a, l) => pe({ top: s(a), left: a.left + a.width / 2 - l.width / 2, name: "arrow_n" }, i && { config: i }), southArrowNorthMiddleEast: (a, l) => pe({ top: s(a), left: a.left + a.width / 2 - 0.75 * l.width + e, name: "arrow_nme" }, i && { config: i }), southArrowNorthEast: (a, l) => pe({ top: s(a), left: a.left + a.width / 2 - l.width + e, name: "arrow_ne" }, i && { config: i }), southEastArrowNorthWest: (a) => pe({ top: s(a), left: a.right - e, name: "arrow_nw" }, i && { config: i }), southEastArrowNorthMiddleWest: (a, l) => pe({ top: s(a), left: a.right - 0.25 * l.width - e, name: "arrow_nmw" }, i && { config: i }), southEastArrowNorth: (a, l) => pe({ top: s(a), left: a.right - l.width / 2, name: "arrow_n" }, i && { config: i }), southEastArrowNorthMiddleEast: (a, l) => pe({ top: s(a), left: a.right - 0.75 * l.width + e, name: "arrow_nme" }, i && { config: i }), southEastArrowNorthEast: (a, l) => pe({ top: s(a), left: a.right - l.width + e, name: "arrow_ne" }, i && { config: i }), westArrowEast: (a, l) => pe({ top: a.top + a.height / 2 - l.height / 2, left: a.left - l.width - t, name: "arrow_e" }, i && { config: i }), eastArrowWest: (a, l) => pe({ top: a.top + a.height / 2 - l.height / 2, left: a.right + t, name: "arrow_w" }, i && { config: i }), viewportStickyNorth: (a, l, c) => a.getIntersection(c) ? { top: c.top + n, left: a.left + a.width / 2 - l.width / 2, name: "arrowless", config: pe({ withArrow: !1 }, i) } : null };
        function r(a, l) {
          return a.top - l.height - t;
        }
        function s(a) {
          return a.bottom + t;
        }
      }
      ut.arrowSideOffset = 25, ut.arrowHeightOffset = 10, ut.stickyVerticalOffset = 20, ut._getOptimalPosition = Sc, ut.defaultPositions = jh();
      var $h = D(3332), kv = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()($h.Z, kv), $h.Z.locals;
      const Hh = "ck-tooltip", ht = class extends on() {
        constructor(o) {
          if (super(), this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver = null, ht._editors.add(o), ht._instance) return ht._instance;
          ht._instance = this, this.tooltipTextView = new de(o.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-tooltip__text"] }, children: [{ text: this.tooltipTextView.bindTemplate.to("text") }] }), this.balloonPanelView = new ut(o.locale), this.balloonPanelView.class = Hh, this.balloonPanelView.content.add(this.tooltipTextView), this._pinTooltipDebounced = jo(this._pinTooltip, 600), this.listenTo(le.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(le.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(le.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(le.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(le.document, "scroll", this._onScroll.bind(this), { useCapture: !0 }), this._watchdogExcluded = !0;
        }
        destroy(o) {
          const e = o.ui.view && o.ui.view.body;
          ht._editors.delete(o), this.stopListening(o.ui), e && e.has(this.balloonPanelView) && e.remove(this.balloonPanelView), ht._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), ht._instance = null);
        }
        static getPositioningFunctions(o) {
          const e = ht.defaultBalloonPositions;
          return { s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest], n: [e.northArrowSouth], e: [e.eastArrowWest], w: [e.westArrowEast], sw: [e.southArrowNorthEast], se: [e.southArrowNorthWest] }[o];
        }
        _onEnterOrFocus(o, { target: e }) {
          const t = ga(e);
          var n;
          t && t !== this._currentElementWithTooltip && (this._unpinTooltip(), this._pinTooltipDebounced(t, { text: (n = t).dataset.ckeTooltipText, position: n.dataset.ckeTooltipPosition || "s", cssClass: n.dataset.ckeTooltipClass || "" }));
        }
        _onLeaveOrBlur(o, { target: e, relatedTarget: t }) {
          if (o.name === "mouseleave") {
            if (!Qn(e) || this._currentElementWithTooltip && e !== this._currentElementWithTooltip) return;
            const n = ga(e), i = ga(t);
            n && n !== i && this._unpinTooltip();
          } else {
            if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) return;
            this._unpinTooltip();
          }
        }
        _onScroll(o, { target: e }) {
          this._currentElementWithTooltip && (e.contains(this.balloonPanelView.element) && e.contains(this._currentElementWithTooltip) || this._unpinTooltip());
        }
        _pinTooltip(o, { text: e, position: t, cssClass: n }) {
          const i = Ke(ht._editors.values()).ui.view.body;
          i.has(this.balloonPanelView) || i.add(this.balloonPanelView), this.tooltipTextView.text = e, this.balloonPanelView.pin({ target: o, positions: ht.getPositioningFunctions(t) }), this._resizeObserver = new Ci(o, () => {
            kn(o) || this._unpinTooltip();
          }), this.balloonPanelView.class = [Hh, n].filter((r) => r).join(" ");
          for (const r of ht._editors) this.listenTo(r.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
          this._currentElementWithTooltip = o, this._currentTooltipPosition = t;
        }
        _unpinTooltip() {
          this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
          for (const o of ht._editors) this.stopListening(o.ui, "update");
          this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver && this._resizeObserver.destroy();
        }
        _updateTooltipPosition() {
          kn(this._currentElementWithTooltip) ? this.balloonPanelView.pin({ target: this._currentElementWithTooltip, positions: ht.getPositioningFunctions(this._currentTooltipPosition) }) : this._unpinTooltip();
        }
      };
      let Qi = ht;
      function ga(o) {
        return Qn(o) ? o.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null;
      }
      Qi.defaultBalloonPositions = jh({ heightOffset: 5, sideOffset: 13 }), Qi._editors = /* @__PURE__ */ new Set(), Qi._instance = null;
      const ma = function(o, e, t) {
        var n = !0, i = !0;
        if (typeof o != "function") throw new TypeError("Expected a function");
        return ze(t) && (n = "leading" in t ? !!t.leading : n, i = "trailing" in t ? !!t.trailing : i), jo(o, e, { leading: n, maxWait: e, trailing: i });
      };
      var wv = Object.defineProperty, qh = Object.getOwnPropertySymbols, Av = Object.prototype.hasOwnProperty, _v = Object.prototype.propertyIsEnumerable, Uh = (o, e, t) => e in o ? wv(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, vv = (o, e) => {
        for (var t in e || (e = {})) Av.call(e, t) && Uh(o, t, e[t]);
        if (qh) for (var t of qh(e)) _v.call(e, t) && Uh(o, t, e[t]);
        return o;
      };
      const Cv = 50, yv = 350, Ev = "Powered by", Xi = { top: -99999, left: -99999, name: "invalid", config: { withArrow: !1 } };
      class xv extends on() {
        constructor(e) {
          super(), this.editor = e, this._balloonView = null, this._lastFocusedEditableElement = null, this._showBalloonThrottled = ma(this._showBalloon.bind(this), 50, { leading: !0 }), e.on("ready", this._handleEditorReady.bind(this));
        }
        destroy() {
          const e = this._balloonView;
          e && (e.unpin(), this._balloonView = null), this._showBalloonThrottled.cancel(), this.stopListening();
        }
        _handleEditorReady() {
          const e = this.editor;
          (function(t) {
            function n(p) {
              return p.match(/^[a-zA-Z0-9+/=$]+$/g) && p.length >= 40 && p.length <= 255 ? "VALID" : "INVALID";
            }
            let i = "", r = "";
            if (!t) return "INVALID";
            try {
              i = atob(t);
            } catch {
              return "INVALID";
            }
            const s = i.split("-"), a = s[0], l = s[1];
            if (!l) return n(t);
            try {
              atob(l);
            } catch {
              try {
                if (atob(a), !atob(a).length) return n(t);
              } catch {
                return n(t);
              }
            }
            if (a.length < 40 || a.length > 255) return "INVALID";
            try {
              atob(a);
            } catch {
              return "INVALID";
            }
            try {
              r = atob(l);
            } catch {
              return "INVALID";
            }
            if (r.length !== 8) return "INVALID";
            const c = Number(r.substring(0, 4)), d = Number(r.substring(4, 6)) - 1, u = Number(r.substring(6, 8)), g = new Date(c, d, u);
            return g < en || isNaN(Number(g)) ? "INVALID" : "VALID";
          })(e.config.get("licenseKey")) !== "VALID" && e.ui.view && (e.ui.focusTracker.on("change:isFocused", (t, n, i) => {
            this._updateLastFocusedEditableElement(), i ? this._showBalloon() : this._hideBalloon();
          }), e.ui.focusTracker.on("change:focusedElement", (t, n, i) => {
            this._updateLastFocusedEditableElement(), i && this._showBalloon();
          }), e.ui.on("update", () => {
            this._showBalloonThrottled();
          }));
        }
        _createBalloonView() {
          const e = this.editor, t = this._balloonView = new ut(), n = Kh(e), i = new Sv(e.locale, n.label);
          t.content.add(i), t.set({ class: "ck-powered-by-balloon" }), e.ui.view.body.add(t), e.ui.focusTracker.add(t.element), this._balloonView = t;
        }
        _showBalloon() {
          if (!this._lastFocusedEditableElement) return;
          const e = function(t, n) {
            const i = Kh(t), r = i.side === "right" ? function(s, a) {
              return Wh(s, a, (l, c) => l.left + l.width - c.width - a.horizontalOffset);
            }(n, i) : function(s, a) {
              return Wh(s, a, (l) => l.left + a.horizontalOffset);
            }(n, i);
            return { target: n, positions: [r] };
          }(this.editor, this._lastFocusedEditableElement);
          e && (this._balloonView || this._createBalloonView(), this._balloonView.pin(e));
        }
        _hideBalloon() {
          this._balloonView && this._balloonView.unpin();
        }
        _updateLastFocusedEditableElement() {
          const e = this.editor, t = e.ui.focusTracker.isFocused, n = e.ui.focusTracker.focusedElement;
          if (!t || !n) return void (this._lastFocusedEditableElement = null);
          const i = Array.from(e.ui.getEditableElementsNames()).map((r) => e.ui.getEditableElement(r));
          i.includes(n) ? this._lastFocusedEditableElement = n : this._lastFocusedEditableElement = i[0];
        }
      }
      class Sv extends de {
        constructor(e, t) {
          super(e);
          const n = new zo(), i = this.bindTemplate;
          n.set({ content: `<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><g clip-path="url(#a)"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h52.4v10H0z"/></clipPath></defs></svg>
`, isColorInherited: !1 }), n.extendTemplate({ attributes: { style: { width: "53px", height: "10px" } } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-powered-by"], "aria-hidden": !0 }, children: [{ tag: "a", attributes: { href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo", target: "_blank", tabindex: "-1" }, children: [...t ? [{ tag: "span", attributes: { class: ["ck", "ck-powered-by__label"] }, children: [t] }] : [], n], on: { dragstart: i.to((r) => r.preventDefault()) } }] });
        }
      }
      function Wh(o, e, t) {
        return (n, i) => {
          const r = n.getVisible();
          if (!r || n.width < yv || n.height < Cv) return Xi;
          let s;
          s = e.position === "inside" ? n.bottom - i.height : n.bottom - i.height / 2, s -= e.verticalOffset;
          const a = t(n, i);
          if (e.position === "inside") {
            const l = i.clone().moveTo(a, s);
            if (l.getIntersectionArea(r) < l.getArea()) return Xi;
          } else {
            const l = function(c) {
              let d = c.parentElement;
              if (!d) return null;
              for (; d.tagName != "BODY"; ) {
                const u = d.style.overflowY || le.window.getComputedStyle(d).overflowY;
                if (u === "auto" || u === "scroll") break;
                if (d = d.parentElement, !d) return null;
              }
              return d;
            }(o);
            if (l) {
              const c = new Fe(l);
              if (r.bottom + i.height / 2 > c.bottom) return Xi;
            }
          }
          return { top: s, left: a, name: `position_${e.position}-side_${e.side}`, config: { withArrow: !1 } };
        };
      }
      function Kh(o) {
        const e = o.config.get("ui.poweredBy"), t = e && e.position || "border";
        return vv({ position: t, label: Ev, verticalOffset: t === "inside" ? 5 : 0, horizontalOffset: 5, side: o.locale.contentLanguageDirection === "ltr" ? "right" : "left" }, e);
      }
      class Dv extends ve() {
        constructor(e) {
          super(), this.isReady = !1, this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [], this.editor = e, this.componentFactory = new gv(e), this.focusTracker = new Et(), this.tooltipManager = new Qi(e), this.poweredBy = new xv(e), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.once("ready", () => {
            this.isReady = !0;
          }), this.listenTo(e.editing.view.document, "layoutChanged", () => this.update()), this._initFocusTracking();
        }
        get element() {
          return null;
        }
        update() {
          this.fire("update");
        }
        destroy() {
          this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor), this.poweredBy.destroy();
          for (const e of this._editableElementsMap.values()) e.ckeditorInstance = null, this.editor.keystrokes.stopListening(e);
          this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
        }
        setEditableElement(e, t) {
          this._editableElementsMap.set(e, t), t.ckeditorInstance || (t.ckeditorInstance = this.editor), this.focusTracker.add(t);
          const n = () => {
            this.editor.editing.view.getDomRoot(e) || this.editor.keystrokes.listenTo(t);
          };
          this.isReady ? n() : this.once("ready", n);
        }
        removeEditableElement(e) {
          const t = this._editableElementsMap.get(e);
          t && (this._editableElementsMap.delete(e), this.editor.keystrokes.stopListening(t), this.focusTracker.remove(t), t.ckeditorInstance = null);
        }
        getEditableElement(e = "main") {
          return this._editableElementsMap.get(e);
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys();
        }
        addToolbar(e, t = {}) {
          e.isRendered ? (this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element)) : e.once("render", () => {
            this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element);
          }), this._focusableToolbarDefinitions.push({ toolbarView: e, options: t });
        }
        get _editableElements() {
          return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
        }
        _readViewportOffsetFromConfig() {
          const e = this.editor, t = e.config.get("ui.viewportOffset");
          if (t) return t;
          const n = e.config.get("toolbar.viewportTopOffset");
          return n ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), { top: n }) : { top: 0 };
        }
        _initFocusTracking() {
          const e = this.editor, t = e.editing.view;
          let n, i;
          e.keystrokes.set("Alt+F10", (r, s) => {
            const a = this.focusTracker.focusedElement;
            Array.from(this._editableElementsMap.values()).includes(a) && !Array.from(t.domRoots.values()).includes(a) && (n = a);
            const l = this._getCurrentFocusedToolbarDefinition();
            l && i || (i = this._getFocusableCandidateToolbarDefinitions());
            for (let c = 0; c < i.length; c++) {
              const d = i.shift();
              if (i.push(d), d !== l && this._focusFocusableCandidateToolbar(d)) {
                l && l.options.afterBlur && l.options.afterBlur();
                break;
              }
            }
            s();
          }), e.keystrokes.set("Esc", (r, s) => {
            const a = this._getCurrentFocusedToolbarDefinition();
            a && (n ? (n.focus(), n = null) : e.editing.view.focus(), a.options.afterBlur && a.options.afterBlur(), s());
          });
        }
        _getFocusableCandidateToolbarDefinitions() {
          const e = [];
          for (const t of this._focusableToolbarDefinitions) {
            const { toolbarView: n, options: i } = t;
            (kn(n.element) || i.beforeFocus) && e.push(t);
          }
          return e.sort((t, n) => Gh(t) - Gh(n)), e;
        }
        _getCurrentFocusedToolbarDefinition() {
          for (const e of this._focusableToolbarDefinitions) if (e.toolbarView.element && e.toolbarView.element.contains(this.focusTracker.focusedElement)) return e;
          return null;
        }
        _focusFocusableCandidateToolbar(e) {
          const { toolbarView: t, options: { beforeFocus: n } } = e;
          return n && n(), !!kn(t.element) && (t.focus(), !0);
        }
      }
      function Gh(o) {
        const { toolbarView: e, options: t } = o;
        let n = 10;
        return kn(e.element) && n--, t.isContextual && n--, n;
      }
      var Zh = D(9688), Bv = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Zh.Z, Bv), Zh.Z.locals;
      class Tv extends de {
        constructor(e) {
          super(e), this.body = new yw(e);
        }
        render() {
          super.render(), this.body.attachToDom();
        }
        destroy() {
          return this.body.detachFromDom(), super.destroy();
        }
      }
      class Iv extends Tv {
        constructor(e) {
          super(e), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"], role: "application", dir: e.uiLanguageDirection, lang: e.uiLanguage, "aria-labelledby": this._voiceLabelView.id }, children: [this._voiceLabelView, { tag: "div", attributes: { class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation" }, children: this.top }, { tag: "div", attributes: { class: ["ck", "ck-editor__main"], role: "presentation" }, children: this.main }] });
        }
        _createVoiceLabel() {
          const e = this.t, t = new td();
          return t.text = e("Rich Text Editor"), t.extendTemplate({ attributes: { class: "ck-voice-label" } }), t;
        }
      }
      class Pv extends de {
        constructor(e, t, n) {
          super(e), this.name = null, this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"], lang: e.contentLanguage, dir: e.contentLanguageDirection } }), this.set("isFocused", !1), this._editableElement = n, this._hasExternalElement = !!this._editableElement, this._editingView = t;
        }
        render() {
          super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
        }
        destroy() {
          this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
        }
        get hasExternalElement() {
          return this._hasExternalElement;
        }
        _updateIsFocusedClasses() {
          const e = this._editingView;
          function t(n) {
            e.change((i) => {
              const r = e.document.getRoot(n.name);
              i.addClass(n.isFocused ? "ck-focused" : "ck-blurred", r), i.removeClass(n.isFocused ? "ck-blurred" : "ck-focused", r);
            });
          }
          e.isRenderingInProgress ? function n(i) {
            e.once("change:isRenderingInProgress", (r, s, a) => {
              a ? n(i) : t(i);
            });
          }(this) : t(this);
        }
      }
      class Rv extends Pv {
        constructor(e, t, n, i = {}) {
          super(e, t, n);
          const r = e.t;
          this.extendTemplate({ attributes: { role: "textbox", class: "ck-editor__editable_inline" } }), this._generateLabel = i.label || (() => r("Editor editing area: %0", this.name));
        }
        render() {
          super.render();
          const e = this._editingView;
          e.change((t) => {
            const n = e.document.getRoot(this.name);
            t.setAttribute("aria-label", this._generateLabel(this), n);
          });
        }
      }
      var Jh = D(8847), Ov = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Jh.Z, Ov), Jh.Z.locals;
      class Yh extends Bi {
        static get pluginName() {
          return "Notification";
        }
        init() {
          this.on("show:warning", (e, t) => {
            window.alert(t.message);
          }, { priority: "lowest" });
        }
        showSuccess(e, t = {}) {
          this._showNotification({ message: e, type: "success", namespace: t.namespace, title: t.title });
        }
        showInfo(e, t = {}) {
          this._showNotification({ message: e, type: "info", namespace: t.namespace, title: t.title });
        }
        showWarning(e, t = {}) {
          this._showNotification({ message: e, type: "warning", namespace: t.namespace, title: t.title });
        }
        _showNotification(e) {
          const t = e.namespace ? `show:${e.type}:${e.namespace}` : `show:${e.type}`;
          this.fire(t, { message: e.message, type: e.type, title: e.title || "" });
        }
      }
      class pa extends ve() {
        constructor(e, t) {
          super(), t && Jd(this, t), e && this.set(e);
        }
      }
      var Qh = D(4650), zv = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Qh.Z, zv), Qh.Z.locals;
      var Xh = D(7676), Mv = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Xh.Z, Mv), Xh.Z.locals;
      const er = rs("px");
      class tr extends K {
        constructor(e) {
          super(e), this._viewToStack = /* @__PURE__ */ new Map(), this._idToStack = /* @__PURE__ */ new Map(), this._view = null, this._rotatorView = null, this._fakePanelsView = null, this.positionLimiter = () => {
            const t = this.editor.editing.view, n = t.document.selection.editableElement;
            return n ? t.domConverter.mapViewToDom(n.root) : null;
          }, this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", !1);
        }
        static get pluginName() {
          return "ContextualBalloon";
        }
        destroy() {
          super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy();
        }
        get view() {
          return this._view || this._createPanelView(), this._view;
        }
        hasView(e) {
          return Array.from(this._viewToStack.keys()).includes(e);
        }
        add(e) {
          if (this._view || this._createPanelView(), this.hasView(e.view)) throw new T("contextualballoon-add-view-exist", [this, e]);
          const t = e.stackId || "main";
          if (!this._idToStack.has(t)) return this._idToStack.set(t, /* @__PURE__ */ new Map([[e.view, e]])), this._viewToStack.set(e.view, this._idToStack.get(t)), this._numberOfStacks = this._idToStack.size, void (this._visibleStack && !e.singleViewMode || this.showStack(t));
          const n = this._idToStack.get(t);
          e.singleViewMode && this.showStack(t), n.set(e.view, e), this._viewToStack.set(e.view, n), n === this._visibleStack && this._showView(e);
        }
        remove(e) {
          if (!this.hasView(e)) throw new T("contextualballoon-remove-view-not-exist", [this, e]);
          const t = this._viewToStack.get(e);
          this._singleViewMode && this.visibleView === e && (this._singleViewMode = !1), this.visibleView === e && (t.size === 1 ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(t.values())[t.size - 2])), t.size === 1 ? (this._idToStack.delete(this._getStackId(t)), this._numberOfStacks = this._idToStack.size) : t.delete(e), this._viewToStack.delete(e);
        }
        updatePosition(e) {
          e && (this._visibleStack.get(this.visibleView).position = e), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition();
        }
        showStack(e) {
          this.visibleStack = e;
          const t = this._idToStack.get(e);
          if (!t) throw new T("contextualballoon-showstack-stack-not-exist", this);
          this._visibleStack !== t && this._showView(Array.from(t.values()).pop());
        }
        _createPanelView() {
          this._view = new ut(this.editor.locale), this.editor.ui.view.body.add(this._view), this.editor.ui.focusTracker.add(this._view.element), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView);
        }
        _getStackId(e) {
          return Array.from(this._idToStack.entries()).find((t) => t[1] === e)[0];
        }
        _showNextStack() {
          const e = Array.from(this._idToStack.values());
          let t = e.indexOf(this._visibleStack) + 1;
          e[t] || (t = 0), this.showStack(this._getStackId(e[t]));
        }
        _showPrevStack() {
          const e = Array.from(this._idToStack.values());
          let t = e.indexOf(this._visibleStack) - 1;
          e[t] || (t = e.length - 1), this.showStack(this._getStackId(e[t]));
        }
        _createRotatorView() {
          const e = new Fv(this.editor.locale), t = this.editor.locale.t;
          return this.view.content.add(e), e.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (n, i) => !i && n > 1), e.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), e.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (n, i) => {
            if (i < 2) return "";
            const r = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
            return t("%0 of %1", [r, i]);
          }), e.buttonNextView.on("execute", () => {
            e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
          }), e.buttonPrevView.on("execute", () => {
            e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
          }), e;
        }
        _createFakePanelsView() {
          const e = new Nv(this.editor.locale, this.view);
          return e.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, n) => !n && t >= 2 ? Math.min(t - 1, 2) : 0), e.listenTo(this.view, "change:top", () => e.updatePosition()), e.listenTo(this.view, "change:left", () => e.updatePosition()), this.editor.ui.view.body.add(e), e;
        }
        _showView({ view: e, balloonClassName: t = "", withArrow: n = !0, singleViewMode: i = !1 }) {
          this.view.class = t, this.view.withArrow = n, this._rotatorView.showView(e), this.visibleView = e, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), i && (this._singleViewMode = !0);
        }
        _getBalloonPosition() {
          let e = Array.from(this._visibleStack.values()).pop().position;
          return e && (e.limiter || (e = Object.assign({}, e, { limiter: this.positionLimiter })), e = Object.assign({}, e, { viewportOffsetConfig: this.editor.ui.viewportOffset })), e;
        }
      }
      class Fv extends de {
        constructor(e) {
          super(e);
          const t = e.t, n = this.bindTemplate;
          this.set("isNavigationVisible", !0), this.focusTracker = new Et(), this.buttonPrevView = this._createButtonView(t("Previous"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'), this.buttonNextView = this._createButtonView(t("Next"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" }, children: [{ tag: "div", attributes: { class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", (i) => i ? "" : "ck-hidden")] }, children: [this.buttonPrevView, { tag: "span", attributes: { class: ["ck-balloon-rotator__counter"] }, children: [{ text: n.to("counter") }] }, this.buttonNextView] }, { tag: "div", attributes: { class: "ck-balloon-rotator__content" }, children: this.content }] });
        }
        render() {
          super.render(), this.focusTracker.add(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy();
        }
        showView(e) {
          this.hideView(), this.content.add(e);
        }
        hideView() {
          this.content.clear();
        }
        _createButtonView(e, t) {
          const n = new De(this.locale);
          return n.set({ label: e, icon: t, tooltip: !0 }), n;
        }
      }
      class Nv extends de {
        constructor(e, t) {
          super(e);
          const n = this.bindTemplate;
          this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = t, this.setTemplate({ tag: "div", attributes: { class: ["ck-fake-panel", n.to("numberOfPanels", (i) => i ? "" : "ck-hidden")], style: { top: n.to("top", er), left: n.to("left", er), width: n.to("width", er), height: n.to("height", er) } }, children: this.content }), this.on("change:numberOfPanels", (i, r, s, a) => {
            s > a ? this._addPanels(s - a) : this._removePanels(a - s), this.updatePosition();
          });
        }
        _addPanels(e) {
          for (; e--; ) {
            const t = new de();
            t.setTemplate({ tag: "div" }), this.content.add(t), this.registerChild(t);
          }
        }
        _removePanels(e) {
          for (; e--; ) {
            const t = this.content.last;
            this.content.remove(t), this.deregisterChild(t), t.destroy();
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: e, left: t } = this._balloonPanelView, { width: n, height: i } = new Fe(this._balloonPanelView.element);
            Object.assign(this, { top: e, left: t, width: n, height: i });
          }
        }
      }
      var eg = D(5868), Vv = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(eg.Z, Vv), eg.Z.locals;
      const Yo = rs("px");
      class Lv extends de {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.set("isActive", !1), this.set("isSticky", !1), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheLimiter", !1), this.set("_hasViewportTopOffset", !1), this.content = this.createCollection(), this._contentPanelPlaceholder = new Pt({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__placeholder"], style: { display: t.to("isSticky", (n) => n ? "block" : "none"), height: t.to("isSticky", (n) => n ? Yo(this._panelRect.height) : null) } } }).render(), this._contentPanel = new Pt({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__content", t.if("isSticky", "ck-sticky-panel__content_sticky"), t.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")], style: { width: t.to("isSticky", (n) => n ? Yo(this._contentPanelPlaceholder.getBoundingClientRect().width) : null), top: t.to("_hasViewportTopOffset", (n) => n ? Yo(this.viewportTopOffset) : null), bottom: t.to("_isStickyToTheLimiter", (n) => n ? Yo(this.limiterBottomOffset) : null), marginLeft: t.to("_marginLeft") } }, children: this.content }).render(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel"] }, children: [this._contentPanelPlaceholder, this._contentPanel] });
        }
        render() {
          super.render(), this._checkIfShouldBeSticky(), this.listenTo(le.window, "scroll", () => {
            this._checkIfShouldBeSticky();
          }), this.listenTo(this, "change:isActive", () => {
            this._checkIfShouldBeSticky();
          });
        }
        _checkIfShouldBeSticky() {
          const e = this._panelRect = this._contentPanel.getBoundingClientRect();
          let t;
          this.limiterElement ? (t = this._limiterRect = this.limiterElement.getBoundingClientRect(), this.isSticky = this.isActive && t.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < t.height) : this.isSticky = !1, this.isSticky ? (this._isStickyToTheLimiter = t.bottom < e.height + this.limiterBottomOffset + this.viewportTopOffset, this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset, this._marginLeft = this._isStickyToTheLimiter ? null : Yo(-le.window.scrollX)) : (this._isStickyToTheLimiter = !1, this._hasViewportTopOffset = !1, this._marginLeft = null);
        }
      }
      var tg = D(9695), jv = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(tg.Z, jv), tg.Z.locals;
      class $v extends Dv {
        constructor(e, t) {
          super(e), this.view = t, this._toolbarConfig = cd(e.config.get("toolbar")), this._elementReplacer = new xl();
        }
        get element() {
          return this.view.element;
        }
        init(e) {
          const t = this.editor, n = this.view, i = t.editing.view, r = n.editable, s = i.document.getRoot();
          r.name = s.rootName, n.render();
          const a = r.element;
          this.setEditableElement(r.name, a), n.editable.bind("isFocused").to(this.focusTracker), i.attachDomRoot(a), e && this._elementReplacer.replace(e, this.element), this._initPlaceholder(), this._initToolbar(), this.fire("ready");
        }
        destroy() {
          super.destroy();
          const e = this.view, t = this.editor.editing.view;
          this._elementReplacer.restore(), t.detachDomRoot(e.editable.name), e.destroy();
        }
        _initToolbar() {
          const e = this.view;
          e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), e.stickyPanel.limiterElement = e.element, e.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: t }) => t || 0), e.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(e.toolbar);
        }
        _initPlaceholder() {
          const e = this.editor, t = e.editing.view, n = t.document.getRoot(), i = e.sourceElement;
          let r;
          const s = e.config.get("placeholder");
          s && (r = typeof s == "string" ? s : s[this.view.editable.name]), !r && i && i.tagName.toLowerCase() === "textarea" && (r = i.getAttribute("placeholder")), r && function({ view: a, element: l, text: c, isDirectHost: d = !0, keepOnFocus: u = !1 }) {
            const g = a.document;
            Ti.has(g) || (Ti.set(g, /* @__PURE__ */ new Map()), g.registerPostFixer((p) => bs(g, p)), g.on("change:isComposing", () => {
              a.change((p) => bs(g, p));
            }, { priority: "high" })), Ti.get(g).set(l, { text: c, isDirectHost: d, keepOnFocus: u, hostElement: d ? l : null }), a.change((p) => bs(g, p));
          }({ view: t, element: n, text: r, isDirectHost: !1, keepOnFocus: !0 });
        }
      }
      var ng = D(3143), Hv = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(ng.Z, Hv), ng.Z.locals;
      class qv extends Iv {
        constructor(e, t, n = {}) {
          super(e), this.stickyPanel = new Lv(e), this.toolbar = new ta(e, { shouldGroupWhenFull: n.shouldToolbarGroupWhenFull }), this.editable = new Rv(e, t);
        }
        render() {
          super.render(), this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable);
        }
      }
      class og {
        constructor(e) {
          if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = typeof e.crashNumberLimit == "number" ? e.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = typeof e.minimumNonErrorTimePeriod == "number" ? e.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (t) => {
            const n = "error" in t ? t.error : t.reason;
            n instanceof Error && this._handleError(n, t);
          }, this._listeners = {}, !this._restart) throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
        }
        destroy() {
          this._stopErrorHandling(), this._listeners = {};
        }
        on(e, t) {
          this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t);
        }
        off(e, t) {
          this._listeners[e] = this._listeners[e].filter((n) => n !== t);
        }
        _fire(e, ...t) {
          const n = this._listeners[e] || [];
          for (const i of n) i.apply(this, [null, ...t]);
        }
        _startErrorHandling() {
          window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _stopErrorHandling() {
          window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _handleError(e, t) {
          if (this._shouldReactToError(e)) {
            this.crashes.push({ message: e.message, stack: e.stack, filename: t instanceof ErrorEvent ? t.filename : void 0, lineno: t instanceof ErrorEvent ? t.lineno : void 0, colno: t instanceof ErrorEvent ? t.colno : void 0, date: this._now() });
            const n = this._shouldRestart();
            this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: e, causesRestart: n }), n ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
          }
        }
        _shouldReactToError(e) {
          return e.is && e.is("CKEditorError") && e.context !== void 0 && e.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(e);
        }
        _shouldRestart() {
          return this.crashes.length <= this._crashNumberLimit ? !0 : (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
        }
      }
      function fa(o, e = /* @__PURE__ */ new Set()) {
        const t = [o], n = /* @__PURE__ */ new Set();
        let i = 0;
        for (; t.length > i; ) {
          const r = t[i++];
          if (!n.has(r) && Uv(r) && !e.has(r)) if (n.add(r), Symbol.iterator in r) try {
            for (const s of r) t.push(s);
          } catch {
          }
          else for (const s in r) s !== "defaultValue" && t.push(r[s]);
        }
        return n;
      }
      function Uv(o) {
        const e = Object.prototype.toString.call(o), t = typeof o;
        return !(t === "number" || t === "boolean" || t === "string" || t === "symbol" || t === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || o == null || o._watchdogExcluded || o instanceof EventTarget || o instanceof Event);
      }
      function ig(o, e, t = /* @__PURE__ */ new Set()) {
        if (o === e && typeof (n = o) == "object" && n !== null) return !0;
        var n;
        const i = fa(o, t), r = fa(e, t);
        for (const s of i) if (r.has(s)) return !0;
        return !1;
      }
      class rg extends og {
        constructor(e, t = {}) {
          super(t), this._editor = null, this._throttledSave = ma(this._save.bind(this), typeof t.saveInterval == "number" ? t.saveInterval : 5e3), e && (this._creator = (n, i) => e.create(n, i)), this._destructor = (n) => n.destroy();
        }
        get editor() {
          return this._editor;
        }
        get _item() {
          return this._editor;
        }
        setCreator(e) {
          this._creator = e;
        }
        setDestructor(e) {
          this._destructor = e;
        }
        _restart() {
          return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((e) => {
            console.error("An error happened during the editor destroying.", e);
          }).then(() => {
            if (typeof this._elementOrData == "string") return this.create(this._data, this._config, this._config.context);
            {
              const e = Object.assign({}, this._config, { initialData: this._data });
              return this.create(this._elementOrData, e, e.context);
            }
          }).then(() => {
            this._fire("restart");
          });
        }
        create(e = this._elementOrData, t = this._config, n) {
          return Promise.resolve().then(() => (super._startErrorHandling(), this._elementOrData = e, this._config = this._cloneEditorConfiguration(t) || {}, this._config.context = n, this._creator(e, this._config))).then((i) => {
            this._editor = i, i.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = i.model.document.version, this._data = this._getData(), this.state = "ready", this._fire("stateChange");
          });
        }
        destroy() {
          return Promise.resolve().then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling(), this._throttledSave.flush();
            const e = this._editor;
            return this._editor = null, e.model.document.off("change:data", this._throttledSave), this._destructor(e);
          });
        }
        _save() {
          const e = this._editor.model.document.version;
          try {
            this._data = this._getData(), this._lastDocumentVersion = e;
          } catch (t) {
            console.error(t, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
          }
        }
        _setExcludedProperties(e) {
          this._excludedProps = e;
        }
        _getData() {
          const e = {};
          for (const t of this._editor.model.document.getRootNames()) e[t] = this._editor.data.get({ rootName: t });
          return e;
        }
        _isErrorComingFromThisItem(e) {
          return ig(this._editor, e.context, this._excludedProps);
        }
        _cloneEditorConfiguration(e) {
          return os(e, (t, n) => Qn(t) || n === "context" ? t : void 0);
        }
      }
      const Qo = Symbol("MainQueueId");
      class Wv {
        constructor() {
          this._onEmptyCallbacks = [], this._queues = /* @__PURE__ */ new Map(), this._activeActions = 0;
        }
        onEmpty(e) {
          this._onEmptyCallbacks.push(e);
        }
        enqueue(e, t) {
          const n = e === Qo;
          this._activeActions++, this._queues.get(e) || this._queues.set(e, Promise.resolve());
          const i = (n ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Qo), this._queues.get(e)])).then(t), r = i.catch(() => {
          });
          return this._queues.set(e, r), i.finally(() => {
            this._activeActions--, this._queues.get(e) === r && this._activeActions === 0 && this._onEmptyCallbacks.forEach((s) => s());
          });
        }
      }
      function sg(o) {
        return Array.isArray(o) ? o : [o];
      }
      class nr extends Ki(ea(U_)) {
        constructor(e, t = {}) {
          if (!or(e) && t.initialData !== void 0) throw new T("editor-create-initial-data", null);
          super(t), this.config.get("initialData") === void 0 && this.config.set("initialData", function(r) {
            return or(r) ? (s = r, s instanceof HTMLTextAreaElement ? s.value : s.innerHTML) : r;
            var s;
          }(e)), or(e) && (this.sourceElement = e), this.model.document.createRoot();
          const n = !this.config.get("toolbar.shouldNotGroupWhenFull"), i = new qv(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: n });
          this.ui = new $v(this, i), function(r) {
            if (!mn(r.updateSourceElement)) throw new T("attachtoform-missing-elementapi-interface", r);
            const s = r.sourceElement;
            if (function(a) {
              return !!a && a.tagName.toLowerCase() === "textarea";
            }(s) && s.form) {
              let a;
              const l = s.form, c = () => r.updateSourceElement();
              mn(l.submit) && (a = l.submit, l.submit = () => {
                c(), a.apply(l);
              }), l.addEventListener("submit", c), r.on("destroy", () => {
                l.removeEventListener("submit", c), a && (l.submit = a);
              });
            }
          }(this);
        }
        destroy() {
          return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy();
        }
        static create(e, t = {}) {
          return new Promise((n) => {
            const i = new this(e, t);
            n(i.initPlugins().then(() => i.ui.init(or(e) ? e : null)).then(() => i.data.init(i.config.get("initialData"))).then(() => i.fire("ready")).then(() => i));
          });
        }
      }
      function or(o) {
        return Qn(o);
      }
      nr.Context = md, nr.EditorWatchdog = rg, nr.ContextWatchdog = class extends og {
        constructor(o, e = {}) {
          super(e), this._watchdogs = /* @__PURE__ */ new Map(), this._context = null, this._contextProps = /* @__PURE__ */ new Set(), this._actionQueues = new Wv(), this._watchdogConfig = e, this._creator = (t) => o.create(t), this._destructor = (t) => t.destroy(), this._actionQueues.onEmpty(() => {
            this.state === "initializing" && (this.state = "ready", this._fire("stateChange"));
          });
        }
        setCreator(o) {
          this._creator = o;
        }
        setDestructor(o) {
          this._destructor = o;
        }
        get context() {
          return this._context;
        }
        create(o = {}) {
          return this._actionQueues.enqueue(Qo, () => (this._contextConfig = o, this._create()));
        }
        getItem(o) {
          return this._getWatchdog(o)._item;
        }
        getItemState(o) {
          return this._getWatchdog(o).state;
        }
        add(o) {
          const e = sg(o);
          return Promise.all(e.map((t) => this._actionQueues.enqueue(t.id, () => {
            if (this.state === "destroyed") throw new Error("Cannot add items to destroyed watchdog.");
            if (!this._context) throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
            let n;
            if (this._watchdogs.has(t.id)) throw new Error(`Item with the given id is already added: '${t.id}'.`);
            if (t.type === "editor") return n = new rg(null, this._watchdogConfig), n.setCreator(t.creator), n._setExcludedProperties(this._contextProps), t.destructor && n.setDestructor(t.destructor), this._watchdogs.set(t.id, n), n.on("error", (i, { error: r, causesRestart: s }) => {
              this._fire("itemError", { itemId: t.id, error: r }), s && this._actionQueues.enqueue(t.id, () => new Promise((a) => {
                const l = () => {
                  n.off("restart", l), this._fire("itemRestart", { itemId: t.id }), a();
                };
                n.on("restart", l);
              }));
            }), n.create(t.sourceElementOrData, t.config, this._context);
            throw new Error(`Not supported item type: '${t.type}'.`);
          })));
        }
        remove(o) {
          const e = sg(o);
          return Promise.all(e.map((t) => this._actionQueues.enqueue(t, () => {
            const n = this._getWatchdog(t);
            return this._watchdogs.delete(t), n.destroy();
          })));
        }
        destroy() {
          return this._actionQueues.enqueue(Qo, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _restart() {
          return this._actionQueues.enqueue(Qo, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((o) => {
            console.error("An error happened during destroying the context or items.", o);
          }).then(() => this._create()).then(() => this._fire("restart"))));
        }
        _create() {
          return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((o) => (this._context = o, this._contextProps = fa(this._context), Promise.all(Array.from(this._watchdogs.values()).map((e) => (e._setExcludedProperties(this._contextProps), e.create(void 0, void 0, this._context))))));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling();
            const o = this._context;
            return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((e) => e.destroy())).then(() => this._destructor(o));
          });
        }
        _getWatchdog(o) {
          const e = this._watchdogs.get(o);
          if (!e) throw new Error(`Item with the given id was not registered: ${o}.`);
          return e;
        }
        _isErrorComingFromThisItem(o) {
          for (const e of this._watchdogs.values()) if (e._isErrorComingFromThisItem(o)) return !1;
          return ig(this._context, o.context);
        }
      };
      class ba extends rn {
        constructor(e) {
          super(e), this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"];
          const t = this.document;
          function n(i) {
            return (r, s) => {
              s.preventDefault();
              const a = s.dropRange ? [s.dropRange] : null, l = new q(t, i);
              t.fire(l, { dataTransfer: s.dataTransfer, method: r.name, targetRanges: a, target: s.target, domEvent: s.domEvent }), l.stop.called && s.stopPropagation();
            };
          }
          this.listenTo(t, "paste", n("clipboardInput"), { priority: "low" }), this.listenTo(t, "drop", n("clipboardInput"), { priority: "low" }), this.listenTo(t, "dragover", n("dragging"), { priority: "low" });
        }
        onDomEvent(e) {
          const t = "clipboardData" in e ? e.clipboardData : e.dataTransfer, n = e.type == "drop" || e.type == "paste", i = { dataTransfer: new ru(t, { cacheFiles: n }) };
          e.type != "drop" && e.type != "dragover" || (i.dropRange = function(r, s) {
            const a = s.target.ownerDocument, l = s.clientX, c = s.clientY;
            let d;
            return a.caretRangeFromPoint && a.caretRangeFromPoint(l, c) ? d = a.caretRangeFromPoint(l, c) : s.rangeParent && (d = a.createRange(), d.setStart(s.rangeParent, s.rangeOffset), d.collapse(!0)), d ? r.domConverter.domRangeToView(d) : null;
          }(this.view, e)), this.fire(e.type, e, i);
        }
      }
      const ag = ["figcaption", "li"];
      function lg(o) {
        let e = "";
        if (o.is("$text") || o.is("$textProxy")) e = o.data;
        else if (o.is("element", "img") && o.hasAttribute("alt")) e = o.getAttribute("alt");
        else if (o.is("element", "br")) e = `
`;
        else {
          let t = null;
          for (const n of o.getChildren()) {
            const i = lg(n);
            t && (t.is("containerElement") || n.is("containerElement")) && (ag.includes(t.name) || ag.includes(n.name) ? e += `
` : e += `

`), e += i, t = n;
          }
        }
        return e;
      }
      class Gt extends K {
        static get pluginName() {
          return "ClipboardPipeline";
        }
        init() {
          this.editor.editing.view.addObserver(ba), this._setupPasteDrop(), this._setupCopyCut();
        }
        _setupPasteDrop() {
          const e = this.editor, t = e.model, n = e.editing.view, i = n.document;
          this.listenTo(i, "clipboardInput", (r, s) => {
            s.method != "paste" || e.model.canEditAt(e.model.document.selection) || r.stop();
          }, { priority: "highest" }), this.listenTo(i, "clipboardInput", (r, s) => {
            const a = s.dataTransfer;
            let l;
            if (s.content) l = s.content;
            else {
              let u = "";
              a.getData("text/html") ? u = function(g) {
                return g.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (p, b) => b.length == 1 ? " " : b).replace(/<!--[\s\S]*?-->/g, "");
              }(a.getData("text/html")) : a.getData("text/plain") && (((c = (c = a.getData("text/plain")).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || c.includes("<br>")) && (c = `<p>${c}</p>`), u = c), l = this.editor.data.htmlProcessor.toView(u);
            }
            var c;
            const d = new q(this, "inputTransformation");
            this.fire(d, { content: l, dataTransfer: a, targetRanges: s.targetRanges, method: s.method }), d.stop.called && r.stop(), n.scrollToTheSelection();
          }, { priority: "low" }), this.listenTo(this, "inputTransformation", (r, s) => {
            if (s.content.isEmpty) return;
            const a = this.editor.data.toModel(s.content, "$clipboardHolder");
            a.childCount != 0 && (r.stop(), t.change(() => {
              this.fire("contentInsertion", { content: a, method: s.method, dataTransfer: s.dataTransfer, targetRanges: s.targetRanges });
            }));
          }, { priority: "low" }), this.listenTo(this, "contentInsertion", (r, s) => {
            s.resultRange = t.insertContent(s.content);
          }, { priority: "low" });
        }
        _setupCopyCut() {
          const e = this.editor, t = e.model.document, n = e.editing.view.document, i = (r, s) => {
            const a = s.dataTransfer;
            s.preventDefault();
            const l = e.data.toView(e.model.getSelectedContent(t.selection));
            n.fire("clipboardOutput", { dataTransfer: a, content: l, method: r.name });
          };
          this.listenTo(n, "copy", i, { priority: "low" }), this.listenTo(n, "cut", (r, s) => {
            e.model.canEditAt(e.model.document.selection) ? i(r, s) : s.preventDefault();
          }, { priority: "low" }), this.listenTo(n, "clipboardOutput", (r, s) => {
            s.content.isEmpty || (s.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(s.content)), s.dataTransfer.setData("text/plain", lg(s.content))), s.method == "cut" && e.model.deleteContent(t.selection);
          }, { priority: "low" });
        }
      }
      class cg {
        constructor(e, t = 20) {
          this._batch = null, this.model = e, this._size = 0, this.limit = t, this._isLocked = !1, this._changeCallback = (n, i) => {
            i.isLocal && i.isUndoable && i !== this._batch && this._reset(!0);
          }, this._selectionChangeCallback = () => {
            this._reset();
          }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
        }
        get batch() {
          return this._batch || (this._batch = this.model.createBatch({ isTyping: !0 })), this._batch;
        }
        get size() {
          return this._size;
        }
        input(e) {
          this._size += e, this._size >= this.limit && this._reset(!0);
        }
        get isLocked() {
          return this._isLocked;
        }
        lock() {
          this._isLocked = !0;
        }
        unlock() {
          this._isLocked = !1;
        }
        destroy() {
          this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
        }
        _reset(e = !1) {
          this.isLocked && !e || (this._batch = null, this._size = 0);
        }
      }
      class Kv extends ae {
        constructor(e, t) {
          super(e), this._buffer = new cg(e.model, t), this._isEnabledBasedOnSelection = !1;
        }
        get buffer() {
          return this._buffer;
        }
        destroy() {
          super.destroy(), this._buffer.destroy();
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document, i = e.text || "", r = i.length;
          let s = n.selection;
          if (e.selection ? s = e.selection : e.range && (s = t.createSelection(e.range)), !t.canEditAt(s)) return;
          const a = e.resultRange;
          t.enqueueChange(this._buffer.batch, (l) => {
            this._buffer.lock(), t.deleteContent(s), i && t.insertContent(l.createText(i, n.selection.getAttributes()), s), a ? l.setSelection(a) : s.is("documentSelection") || l.setSelection(s), this._buffer.unlock(), this._buffer.input(r);
          });
        }
      }
      const dg = ["insertText", "insertReplacementText"];
      class Gv extends Mt {
        constructor(e) {
          super(e), f.isAndroid && dg.push("insertCompositionText");
          const t = e.document;
          t.on("beforeinput", (n, i) => {
            if (!this.isEnabled) return;
            const { data: r, targetRanges: s, inputType: a, domEvent: l } = i;
            if (!dg.includes(a)) return;
            const c = new q(t, "insertText");
            t.fire(c, new ro(e, l, { text: r, selection: e.createSelection(s) })), c.stop.called && n.stop();
          }), t.on("compositionend", (n, { data: i, domEvent: r }) => {
            this.isEnabled && !f.isAndroid && i && t.fire("insertText", new ro(e, r, { text: i, selection: t.selection }));
          }, { priority: "lowest" });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class ug extends K {
        static get pluginName() {
          return "Input";
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view, i = t.document.selection;
          n.addObserver(Gv);
          const r = new Kv(e, e.config.get("typing.undoStep") || 20);
          e.commands.add("insertText", r), e.commands.add("input", r), this.listenTo(n.document, "insertText", (s, a) => {
            n.document.isComposing || a.preventDefault();
            const { text: l, selection: c, resultRange: d } = a, u = Array.from(c.getRanges()).map((b) => e.editing.mapper.toModelRange(b));
            let g = l;
            if (f.isAndroid) {
              const b = Array.from(u[0].getItems()).reduce((w, y) => w + (y.is("$textProxy") ? y.data : ""), "");
              b && (b.length <= g.length ? g.startsWith(b) && (g = g.substring(b.length), u[0].start = u[0].start.getShiftedBy(b.length)) : b.startsWith(g) && (u[0].start = u[0].start.getShiftedBy(g.length), g = ""));
            }
            const p = { text: g, selection: t.createSelection(u) };
            d && (p.resultRange = e.editing.mapper.toModelRange(d)), e.execute("insertText", p);
          }), f.isAndroid ? this.listenTo(n.document, "keydown", (s, a) => {
            !i.isCollapsed && a.keyCode == 229 && n.document.isComposing && hg(t, r);
          }) : this.listenTo(n.document, "compositionstart", () => {
            i.isCollapsed || hg(t, r);
          });
        }
      }
      function hg(o, e) {
        if (!e.isEnabled) return;
        const t = e.buffer;
        t.lock(), o.enqueueChange(t.batch, () => {
          o.deleteContent(o.document.selection);
        }), t.unlock();
      }
      class gg extends ae {
        constructor(e, t) {
          super(e), this.direction = t, this._buffer = new cg(e.model, e.config.get("typing.undoStep")), this._isEnabledBasedOnSelection = !1;
        }
        get buffer() {
          return this._buffer;
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document;
          t.enqueueChange(this._buffer.batch, (i) => {
            this._buffer.lock();
            const r = i.createSelection(e.selection || n.selection);
            if (!t.canEditAt(r)) return;
            const s = e.sequence || 1, a = r.isCollapsed;
            if (r.isCollapsed && t.modifySelection(r, { direction: this.direction, unit: e.unit, treatEmojiAsSingleUnit: !0 }), this._shouldEntireContentBeReplacedWithParagraph(s)) return void this._replaceEntireContentWithParagraph(i);
            if (this._shouldReplaceFirstBlockWithParagraph(r, s)) return void this.editor.execute("paragraph", { selection: r });
            if (r.isCollapsed) return;
            let l = 0;
            r.getFirstRange().getMinimalFlatRanges().forEach((c) => {
              l += zr(c.getWalker({ singleCharacters: !0, ignoreElementEnd: !0, shallow: !0 }));
            }), t.deleteContent(r, { doNotResetEntireContent: a, direction: this.direction }), this._buffer.input(l), i.setSelection(r), this._buffer.unlock();
          });
        }
        _shouldEntireContentBeReplacedWithParagraph(e) {
          if (e > 1) return !1;
          const t = this.editor.model, n = t.document.selection, i = t.schema.getLimitElement(n);
          if (!(n.isCollapsed && n.containsEntireContent(i)) || !t.schema.checkChild(i, "paragraph")) return !1;
          const r = i.getChild(0);
          return !r || !r.is("element", "paragraph");
        }
        _replaceEntireContentWithParagraph(e) {
          const t = this.editor.model, n = t.document.selection, i = t.schema.getLimitElement(n), r = e.createElement("paragraph");
          e.remove(e.createRangeIn(i)), e.insert(r, i), e.setSelection(r, 0);
        }
        _shouldReplaceFirstBlockWithParagraph(e, t) {
          const n = this.editor.model;
          if (t > 1 || this.direction != "backward" || !e.isCollapsed) return !1;
          const i = e.getFirstPosition(), r = n.schema.getLimitElement(i), s = r.getChild(0);
          return i.parent == s && !!e.containsEntireContent(s) && !!n.schema.checkChild(r, "paragraph") && s.name != "paragraph";
        }
      }
      const mg = "word", ln = "selection", uo = "backward", Xo = "forward", pg = { deleteContent: { unit: ln, direction: uo }, deleteContentBackward: { unit: "codePoint", direction: uo }, deleteWordBackward: { unit: mg, direction: uo }, deleteHardLineBackward: { unit: ln, direction: uo }, deleteSoftLineBackward: { unit: ln, direction: uo }, deleteContentForward: { unit: "character", direction: Xo }, deleteWordForward: { unit: mg, direction: Xo }, deleteHardLineForward: { unit: ln, direction: Xo }, deleteSoftLineForward: { unit: ln, direction: Xo } };
      class Zv extends Mt {
        constructor(e) {
          super(e);
          const t = e.document;
          let n = 0;
          t.on("keydown", () => {
            n++;
          }), t.on("keyup", () => {
            n = 0;
          }), t.on("beforeinput", (i, r) => {
            if (!this.isEnabled) return;
            const { targetRanges: s, domEvent: a, inputType: l } = r, c = pg[l];
            if (!c) return;
            const d = { direction: c.direction, unit: c.unit, sequence: n };
            d.unit == ln && (d.selectionToRemove = e.createSelection(s[0])), l === "deleteContentBackward" && (f.isAndroid && (d.sequence = 1), function(g) {
              if (g.length != 1 || g[0].isCollapsed) return !1;
              const p = g[0].getWalker({ direction: "backward", singleCharacters: !0, ignoreElementEnd: !0 });
              let b = 0;
              for (const { nextPosition: w } of p) {
                if (w.parent.is("$text")) {
                  const y = w.parent.data, I = w.offset;
                  if (ds(y, I) || us(y, I) || Fc(y, I)) continue;
                  b++;
                } else b++;
                if (b > 1) return !0;
              }
              return !1;
            }(s) && (d.unit = ln, d.selectionToRemove = e.createSelection(s)));
            const u = new oo(t, "delete", s[0]);
            t.fire(u, new ro(e, a, d)), u.stop.called && i.stop();
          }), f.isBlink && function(i) {
            const r = i.view, s = r.document;
            let a = null, l = !1;
            function c(u) {
              return u == ge.backspace || u == ge.delete;
            }
            function d(u) {
              return u == ge.backspace ? uo : Xo;
            }
            s.on("keydown", (u, { keyCode: g }) => {
              a = g, l = !1;
            }), s.on("keyup", (u, { keyCode: g, domEvent: p }) => {
              const b = s.selection, w = i.isEnabled && g == a && c(g) && !b.isCollapsed && !l;
              if (a = null, w) {
                const y = b.getFirstRange(), I = new oo(s, "delete", y), z = { unit: ln, direction: d(g), selectionToRemove: b };
                s.fire(I, new ro(r, p, z));
              }
            }), s.on("beforeinput", (u, { inputType: g }) => {
              const p = pg[g];
              c(a) && p && p.direction == d(a) && (l = !0);
            }, { priority: "high" }), s.on("beforeinput", (u, { inputType: g, data: p }) => {
              a == ge.delete && g == "insertText" && p == "" && u.stop();
            }, { priority: "high" });
          }(this);
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class ho extends K {
        static get pluginName() {
          return "Delete";
        }
        init() {
          const e = this.editor, t = e.editing.view, n = t.document, i = e.model.document;
          t.addObserver(Zv), this._undoOnBackspace = !1;
          const r = new gg(e, "forward");
          e.commands.add("deleteForward", r), e.commands.add("forwardDelete", r), e.commands.add("delete", new gg(e, "backward")), this.listenTo(n, "delete", (s, a) => {
            n.isComposing || a.preventDefault();
            const { direction: l, sequence: c, selectionToRemove: d, unit: u } = a, g = l === "forward" ? "deleteForward" : "delete", p = { sequence: c };
            if (u == "selection") {
              const b = Array.from(d.getRanges()).map((w) => e.editing.mapper.toModelRange(w));
              p.selection = e.model.createSelection(b);
            } else p.unit = u;
            e.execute(g, p), t.scrollToTheSelection();
          }, { priority: "low" }), this.editor.plugins.has("UndoEditing") && (this.listenTo(n, "delete", (s, a) => {
            this._undoOnBackspace && a.direction == "backward" && a.sequence == 1 && a.unit == "codePoint" && (this._undoOnBackspace = !1, e.execute("undo"), a.preventDefault(), s.stop());
          }, { context: "$capture" }), this.listenTo(i, "change", () => {
            this._undoOnBackspace = !1;
          }));
        }
        requestUndoOnBackspace() {
          this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0);
        }
      }
      class Jv extends K {
        static get requires() {
          return [ug, ho];
        }
        static get pluginName() {
          return "Typing";
        }
      }
      function fg(o, e) {
        let t = o.start;
        return { text: Array.from(o.getItems()).reduce((n, i) => i.is("$text") || i.is("$textProxy") ? n + i.data : (t = e.createPositionAfter(i), ""), ""), range: e.createRange(t, o.end) };
      }
      class bg extends ve() {
        constructor(e, t) {
          super(), this.model = e, this.testCallback = t, this._hasMatch = !1, this.set("isEnabled", !0), this.on("change:isEnabled", () => {
            this.isEnabled ? this._startListening() : (this.stopListening(e.document.selection), this.stopListening(e.document));
          }), this._startListening();
        }
        get hasMatch() {
          return this._hasMatch;
        }
        _startListening() {
          const e = this.model.document;
          this.listenTo(e.selection, "change:range", (t, { directChange: n }) => {
            n && (e.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this._hasMatch = !1));
          }), this.listenTo(e, "change:data", (t, n) => {
            !n.isUndo && n.isLocal && this._evaluateTextBeforeSelection("data", { batch: n });
          });
        }
        _evaluateTextBeforeSelection(e, t = {}) {
          const n = this.model, i = n.document.selection, r = n.createRange(n.createPositionAt(i.focus.parent, 0), i.focus), { text: s, range: a } = fg(r, n), l = this.testCallback(s);
          if (!l && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!l, l) {
            const c = Object.assign(t, { text: s, range: a });
            typeof l == "object" && Object.assign(c, l), this.fire(`matched:${e}`, c);
          }
        }
      }
      class kg extends K {
        constructor(e) {
          super(e), this.attributes = /* @__PURE__ */ new Set(), this._overrideUid = null;
        }
        static get pluginName() {
          return "TwoStepCaretMovement";
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view, i = e.locale, r = t.document.selection;
          this.listenTo(n.document, "arrowKey", (s, a) => {
            if (!r.isCollapsed || a.shiftKey || a.altKey || a.ctrlKey) return;
            const l = a.keyCode == ge.arrowright, c = a.keyCode == ge.arrowleft;
            if (!l && !c) return;
            const d = i.contentLanguageDirection;
            let u = !1;
            u = d === "ltr" && l || d === "rtl" && c ? this._handleForwardMovement(a) : this._handleBackwardMovement(a), u === !0 && s.stop();
          }, { context: "$text", priority: "highest" }), this._isNextGravityRestorationSkipped = !1, this.listenTo(r, "change:range", (s, a) => {
            this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = !1 : this._isGravityOverridden && (!a.directChange && rr(r.getFirstPosition(), this.attributes) || this._restoreGravity());
          });
        }
        registerAttribute(e) {
          this.attributes.add(e);
        }
        _handleForwardMovement(e) {
          const t = this.attributes, n = this.editor.model.document.selection, i = n.getFirstPosition();
          return !this._isGravityOverridden && (!i.isAtStart || !ka(n, t)) && !!rr(i, t) && (ir(e), this._overrideGravity(), !0);
        }
        _handleBackwardMovement(e) {
          const t = this.attributes, n = this.editor.model, i = n.document.selection, r = i.getFirstPosition();
          return this._isGravityOverridden ? (ir(e), this._restoreGravity(), wa(n, t, r), !0) : r.isAtStart ? !!ka(i, t) && (ir(e), wa(n, t, r), !0) : !!function(s, a) {
            const l = s.getShiftedBy(-1);
            return rr(l, a);
          }(r, t) && (r.isAtEnd && !ka(i, t) && rr(r, t) ? (ir(e), wa(n, t, r), !0) : (this._isNextGravityRestorationSkipped = !0, this._overrideGravity(), !1));
        }
        get _isGravityOverridden() {
          return !!this._overrideUid;
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change((e) => e.overrideSelectionGravity());
        }
        _restoreGravity() {
          this.editor.model.change((e) => {
            e.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
          });
        }
      }
      function ka(o, e) {
        for (const t of e) if (o.hasAttribute(t)) return !0;
        return !1;
      }
      function wa(o, e, t) {
        const n = t.nodeBefore;
        o.change((i) => {
          n ? i.setSelectionAttribute(n.getAttributes()) : i.removeSelectionAttribute(e);
        });
      }
      function ir(o) {
        o.preventDefault();
      }
      function rr(o, e) {
        const { nodeBefore: t, nodeAfter: n } = o;
        for (const i of e) {
          const r = t ? t.getAttribute(i) : void 0;
          if ((n ? n.getAttribute(i) : void 0) !== r) return !0;
        }
        return !1;
      }
      var wg = /[\\^$.*+?()[\]{}|]/g, Yv = RegExp(wg.source);
      const Qv = function(o) {
        return (o = As(o)) && Yv.test(o) ? o.replace(wg, "\\$&") : o;
      }, Ag = { copyright: { from: "(c)", to: "©" }, registeredTrademark: { from: "(r)", to: "®" }, trademark: { from: "(tm)", to: "™" }, oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null] }, oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null] }, twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null] }, oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null] }, threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null] }, lessThanOrEqual: { from: "<=", to: "≤" }, greaterThanOrEqual: { from: ">=", to: "≥" }, notEqual: { from: "!=", to: "≠" }, arrowLeft: { from: "<-", to: "←" }, arrowRight: { from: "->", to: "→" }, horizontalEllipsis: { from: "...", to: "…" }, enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] }, emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] }, quotesPrimary: { from: go('"'), to: [null, "“", null, "”"] }, quotesSecondary: { from: go("'"), to: [null, "‘", null, "’"] }, quotesPrimaryEnGb: { from: go("'"), to: [null, "‘", null, "’"] }, quotesSecondaryEnGb: { from: go('"'), to: [null, "“", null, "”"] }, quotesPrimaryPl: { from: go('"'), to: [null, "„", null, "”"] }, quotesSecondaryPl: { from: go("'"), to: [null, "‚", null, "’"] } }, _g = { symbols: ["copyright", "registeredTrademark", "trademark"], mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"], typography: ["horizontalEllipsis", "enDash", "emDash"], quotes: ["quotesPrimary", "quotesSecondary"] }, Xv = ["symbols", "mathematical", "typography", "quotes"];
      function eC(o) {
        return typeof o == "string" ? new RegExp(`(${Qv(o)})$`) : o;
      }
      function tC(o) {
        return typeof o == "string" ? () => [o] : o instanceof Array ? () => o : o;
      }
      function nC(o) {
        return (o.textNode ? o.textNode : o.nodeAfter).getAttributes();
      }
      function go(o) {
        return new RegExp(`(^|\\s)(${o})([^${o}]*)(${o})$`);
      }
      function mo(o, e, t, n) {
        return n.createRange(vg(o, e, t, !0, n), vg(o, e, t, !1, n));
      }
      function vg(o, e, t, n, i) {
        let r = o.textNode || (n ? o.nodeBefore : o.nodeAfter), s = null;
        for (; r && r.getAttribute(e) == t; ) s = r, r = n ? r.previousSibling : r.nextSibling;
        return s ? i.createPositionAt(s, n ? "before" : "after") : o;
      }
      function* Cg(o, e) {
        for (const t of e) t && o.getAttributeProperties(t[0]).copyOnEnter && (yield t);
      }
      class oC extends ae {
        execute() {
          this.editor.model.change((e) => {
            this.enterBlock(e), this.fire("afterExecute", { writer: e });
          });
        }
        enterBlock(e) {
          const t = this.editor.model, n = t.document.selection, i = t.schema, r = n.isCollapsed, s = n.getFirstRange(), a = s.start.parent, l = s.end.parent;
          if (i.isLimit(a) || i.isLimit(l)) return r || a != l || t.deleteContent(n), !1;
          if (r) {
            const c = Cg(e.model.schema, n.getAttributes());
            return yg(e, s.start), e.setSelectionAttribute(c), !0;
          }
          {
            const c = !(s.start.isAtStart && s.end.isAtEnd), d = a == l;
            if (t.deleteContent(n, { leaveUnmerged: c }), c) {
              if (d) return yg(e, n.focus), !0;
              e.setSelection(l, 0);
            }
          }
          return !1;
        }
      }
      function yg(o, e) {
        o.split(e), o.setSelection(e.parent.nextSibling, 0);
      }
      const iC = { insertParagraph: { isSoft: !1 }, insertLineBreak: { isSoft: !0 } };
      class Eg extends Mt {
        constructor(e) {
          super(e);
          const t = this.document;
          let n = !1;
          t.on("keydown", (i, r) => {
            n = r.shiftKey;
          }), t.on("beforeinput", (i, r) => {
            if (!this.isEnabled) return;
            let s = r.inputType;
            f.isSafari && n && s == "insertParagraph" && (s = "insertLineBreak");
            const a = r.domEvent, l = iC[s];
            if (!l) return;
            const c = new oo(t, "enter", r.targetRanges[0]);
            t.fire(c, new ro(e, a, { isSoft: l.isSoft })), c.stop.called && i.stop();
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class ei extends K {
        static get pluginName() {
          return "Enter";
        }
        init() {
          const e = this.editor, t = e.editing.view, n = t.document;
          t.addObserver(Eg), e.commands.add("enter", new oC(e)), this.listenTo(n, "enter", (i, r) => {
            n.isComposing || r.preventDefault(), r.isSoft || (e.execute("enter"), t.scrollToTheSelection());
          }, { priority: "low" });
        }
      }
      class rC extends ae {
        execute() {
          const e = this.editor.model, t = e.document;
          e.change((n) => {
            (function(i, r, s) {
              const a = s.isCollapsed, l = s.getFirstRange(), c = l.start.parent, d = l.end.parent, u = c == d;
              if (a) {
                const g = Cg(i.schema, s.getAttributes());
                xg(i, r, l.end), r.removeSelectionAttribute(s.getAttributeKeys()), r.setSelectionAttribute(g);
              } else {
                const g = !(l.start.isAtStart && l.end.isAtEnd);
                i.deleteContent(s, { leaveUnmerged: g }), u ? xg(i, r, s.focus) : g && r.setSelection(d, 0);
              }
            })(e, n, t.selection), this.fire("afterExecute", { writer: n });
          });
        }
        refresh() {
          const e = this.editor.model, t = e.document;
          this.isEnabled = function(n, i) {
            if (i.rangeCount > 1) return !1;
            const r = i.anchor;
            if (!r || !n.checkChild(r, "softBreak")) return !1;
            const s = i.getFirstRange(), a = s.start.parent, l = s.end.parent;
            return !((Aa(a, n) || Aa(l, n)) && a !== l);
          }(e.schema, t.selection);
        }
      }
      function xg(o, e, t) {
        const n = e.createElement("softBreak");
        o.insertContent(n, t), e.setSelection(n, "after");
      }
      function Aa(o, e) {
        return !o.is("rootElement") && (e.isLimit(o) || Aa(o.parent, e));
      }
      class sC extends K {
        static get pluginName() {
          return "ShiftEnter";
        }
        init() {
          const e = this.editor, t = e.model.schema, n = e.conversion, i = e.editing.view, r = i.document;
          t.register("softBreak", { allowWhere: "$text", isInline: !0 }), n.for("upcast").elementToElement({ model: "softBreak", view: "br" }), n.for("downcast").elementToElement({ model: "softBreak", view: (s, { writer: a }) => a.createEmptyElement("br") }), i.addObserver(Eg), e.commands.add("shiftEnter", new rC(e)), this.listenTo(r, "enter", (s, a) => {
            r.isComposing || a.preventDefault(), a.isSoft && (e.execute("shiftEnter"), i.scrollToTheSelection());
          }, { priority: "low" });
        }
      }
      class aC extends _e() {
        constructor() {
          super(...arguments), this._stack = [];
        }
        add(e, t) {
          const n = this._stack, i = n[0];
          this._insertDescriptor(e);
          const r = n[0];
          i === r || _a(i, r) || this.fire("change:top", { oldDescriptor: i, newDescriptor: r, writer: t });
        }
        remove(e, t) {
          const n = this._stack, i = n[0];
          this._removeDescriptor(e);
          const r = n[0];
          i === r || _a(i, r) || this.fire("change:top", { oldDescriptor: i, newDescriptor: r, writer: t });
        }
        _insertDescriptor(e) {
          const t = this._stack, n = t.findIndex((r) => r.id === e.id);
          if (_a(e, t[n])) return;
          n > -1 && t.splice(n, 1);
          let i = 0;
          for (; t[i] && lC(t[i], e); ) i++;
          t.splice(i, 0, e);
        }
        _removeDescriptor(e) {
          const t = this._stack, n = t.findIndex((i) => i.id === e);
          n > -1 && t.splice(n, 1);
        }
      }
      function _a(o, e) {
        return o && e && o.priority == e.priority && sr(o.classes) == sr(e.classes);
      }
      function lC(o, e) {
        return o.priority > e.priority || !(o.priority < e.priority) && sr(o.classes) > sr(e.classes);
      }
      function sr(o) {
        return Array.isArray(o) ? o.sort().join(",") : o;
      }
      const cC = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>', dC = "ck-widget", Sg = "ck-widget_selected";
      function Ne(o) {
        return !!o.is("element") && !!o.getCustomProperty("widget");
      }
      function va(o, e, t = {}) {
        if (!o.is("containerElement")) throw new T("widget-to-widget-wrong-element-type", null, { element: o });
        return e.setAttribute("contenteditable", "false", o), e.addClass(dC, o), e.setCustomProperty("widget", !0, o), o.getFillerOffset = mC, e.setCustomProperty("widgetLabel", [], o), t.label && function(n, i) {
          n.getCustomProperty("widgetLabel").push(i);
        }(o, t.label), t.hasSelectionHandle && function(n, i) {
          const r = i.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(s) {
            const a = this.toDomElement(s), l = new zo();
            return l.set("content", cC), l.render(), a.appendChild(l.element), a;
          });
          i.insert(i.createPositionAt(n, 0), r), i.addClass(["ck-widget_with-selection-handle"], n);
        }(o, e), Dg(o, e), o;
      }
      function uC(o, e, t) {
        if (e.classes && t.addClass($e(e.classes), o), e.attributes) for (const n in e.attributes) t.setAttribute(n, e.attributes[n], o);
      }
      function hC(o, e, t) {
        if (e.classes && t.removeClass($e(e.classes), o), e.attributes) for (const n in e.attributes) t.removeAttribute(n, o);
      }
      function Dg(o, e, t = uC, n = hC) {
        const i = new aC();
        i.on("change:top", (r, s) => {
          s.oldDescriptor && n(o, s.oldDescriptor, s.writer), s.newDescriptor && t(o, s.newDescriptor, s.writer);
        }), e.setCustomProperty("addHighlight", (r, s, a) => i.add(s, a), o), e.setCustomProperty("removeHighlight", (r, s, a) => i.remove(s, a), o);
      }
      function gC(o, e, t = {}) {
        return e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], o), e.setAttribute("role", "textbox", o), t.label && e.setAttribute("aria-label", t.label, o), e.setAttribute("contenteditable", o.isReadOnly ? "false" : "true", o), o.on("change:isReadOnly", (n, i, r) => {
          e.setAttribute("contenteditable", r ? "false" : "true", o);
        }), o.on("change:isFocused", (n, i, r) => {
          r ? e.addClass("ck-editor__nested-editable_focused", o) : e.removeClass("ck-editor__nested-editable_focused", o);
        }), Dg(o, e), o;
      }
      function mC() {
        return null;
      }
      const Zt = "widget-type-around";
      function Tn(o, e, t) {
        return !!o && Ne(o) && !t.isInline(e);
      }
      function cn(o) {
        return o.getAttribute(Zt);
      }
      var Bg = D(4921), pC = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Bg.Z, pC), Bg.Z.locals;
      const Tg = ["before", "after"], fC = new DOMParser().parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', "image/svg+xml").firstChild, Ig = "ck-widget__type-around_disabled";
      class bC extends K {
        constructor() {
          super(...arguments), this._currentFakeCaretModelElement = null;
        }
        static get pluginName() {
          return "WidgetTypeAround";
        }
        static get requires() {
          return [ei, ho];
        }
        init() {
          const e = this.editor, t = e.editing.view;
          this.on("change:isEnabled", (n, i, r) => {
            t.change((s) => {
              for (const a of t.document.roots) r ? s.removeClass(Ig, a) : s.addClass(Ig, a);
            }), r || e.model.change((s) => {
              s.removeSelectionAttribute(Zt);
            });
          }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration();
        }
        destroy() {
          super.destroy(), this._currentFakeCaretModelElement = null;
        }
        _insertParagraph(e, t) {
          const n = this.editor, i = n.editing.view, r = n.model.schema.getAttributesWithProperty(e, "copyOnReplace", !0);
          n.execute("insertParagraph", { position: n.model.createPositionAt(e, t), attributes: r }), i.focus(), i.scrollToTheSelection();
        }
        _listenToIfEnabled(e, t, n, i) {
          this.listenTo(e, t, (...r) => {
            this.isEnabled && n(...r);
          }, i);
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const e = this.editor.model.document.selection, t = cn(e);
          if (!t) return !1;
          const n = e.getSelectedElement();
          return this._insertParagraph(n, t), !0;
        }
        _enableTypeAroundUIInjection() {
          const e = this.editor, t = e.model.schema, n = e.locale.t, i = { before: n("Insert paragraph before block"), after: n("Insert paragraph after block") };
          e.editing.downcastDispatcher.on("insert", (r, s, a) => {
            const l = a.mapper.toViewElement(s.item);
            l && Tn(l, s.item, t) && (function(c, d, u) {
              const g = c.createUIElement("div", { class: "ck ck-reset_all ck-widget__type-around" }, function(p) {
                const b = this.toDomElement(p);
                return function(w, y) {
                  for (const I of Tg) {
                    const z = new Pt({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${I}`], title: y[I], "aria-hidden": "true" }, children: [w.ownerDocument.importNode(fC, !0)] });
                    w.appendChild(z.render());
                  }
                }(b, d), function(w) {
                  const y = new Pt({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] } });
                  w.appendChild(y.render());
                }(b), b;
              });
              c.insert(c.createPositionAt(u, "end"), g);
            }(a.writer, i, l), l.getCustomProperty("widgetLabel").push(() => this.isEnabled ? n("Press Enter to type after or press Shift + Enter to type before the widget") : ""));
          }, { priority: "low" });
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const e = this.editor, t = e.model, n = t.document.selection, i = t.schema, r = e.editing.view;
          function s(a) {
            return `ck-widget_type-around_show-fake-caret_${a}`;
          }
          this._listenToIfEnabled(r.document, "arrowKey", (a, l) => {
            this._handleArrowKeyPress(a, l);
          }, { context: [Ne, "$text"], priority: "high" }), this._listenToIfEnabled(n, "change:range", (a, l) => {
            l.directChange && e.model.change((c) => {
              c.removeSelectionAttribute(Zt);
            });
          }), this._listenToIfEnabled(t.document, "change:data", () => {
            const a = n.getSelectedElement();
            a && Tn(e.editing.mapper.toViewElement(a), a, i) || e.model.change((l) => {
              l.removeSelectionAttribute(Zt);
            });
          }), this._listenToIfEnabled(e.editing.downcastDispatcher, "selection", (a, l, c) => {
            const d = c.writer;
            if (this._currentFakeCaretModelElement) {
              const b = c.mapper.toViewElement(this._currentFakeCaretModelElement);
              b && (d.removeClass(Tg.map(s), b), this._currentFakeCaretModelElement = null);
            }
            const u = l.selection.getSelectedElement();
            if (!u) return;
            const g = c.mapper.toViewElement(u);
            if (!Tn(g, u, i)) return;
            const p = cn(l.selection);
            p && (d.addClass(s(p), g), this._currentFakeCaretModelElement = u);
          }), this._listenToIfEnabled(e.ui.focusTracker, "change:isFocused", (a, l, c) => {
            c || e.model.change((d) => {
              d.removeSelectionAttribute(Zt);
            });
          });
        }
        _handleArrowKeyPress(e, t) {
          const n = this.editor, i = n.model, r = i.document.selection, s = i.schema, a = n.editing.view, l = function(u, g) {
            const p = ls(u, g);
            return p === "down" || p === "right";
          }(t.keyCode, n.locale.contentLanguageDirection), c = a.document.selection.getSelectedElement();
          let d;
          Tn(c, n.editing.mapper.toModelElement(c), s) ? d = this._handleArrowKeyPressOnSelectedWidget(l) : r.isCollapsed ? d = this._handleArrowKeyPressWhenSelectionNextToAWidget(l) : t.shiftKey || (d = this._handleArrowKeyPressWhenNonCollapsedSelection(l)), d && (t.preventDefault(), e.stop());
        }
        _handleArrowKeyPressOnSelectedWidget(e) {
          const t = this.editor.model, n = cn(t.document.selection);
          return t.change((i) => n ? n !== (e ? "after" : "before") ? (i.removeSelectionAttribute(Zt), !0) : !1 : (i.setSelectionAttribute(Zt, e ? "after" : "before"), !0));
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(e) {
          const t = this.editor, n = t.model, i = n.schema, r = t.plugins.get("Widget"), s = r._getObjectElementNextToSelection(e);
          return !!Tn(t.editing.mapper.toViewElement(s), s, i) && (n.change((a) => {
            r._setSelectionOverElement(s), a.setSelectionAttribute(Zt, e ? "before" : "after");
          }), !0);
        }
        _handleArrowKeyPressWhenNonCollapsedSelection(e) {
          const t = this.editor, n = t.model, i = n.schema, r = t.editing.mapper, s = n.document.selection, a = e ? s.getLastPosition().nodeBefore : s.getFirstPosition().nodeAfter;
          return !!Tn(r.toViewElement(a), a, i) && (n.change((l) => {
            l.setSelection(a, "on"), l.setSelectionAttribute(Zt, e ? "after" : "before");
          }), !0);
        }
        _enableInsertingParagraphsOnButtonClick() {
          const e = this.editor, t = e.editing.view;
          this._listenToIfEnabled(t.document, "mousedown", (n, i) => {
            const r = i.domTarget.closest(".ck-widget__type-around__button");
            if (!r) return;
            const s = function(c) {
              return c.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
            }(r), a = function(c, d) {
              const u = c.closest(".ck-widget");
              return d.mapDomToView(u);
            }(r, t.domConverter), l = e.editing.mapper.toModelElement(a);
            this._insertParagraph(l, s), i.preventDefault(), n.stop();
          });
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const e = this.editor, t = e.model.document.selection, n = e.editing.view;
          this._listenToIfEnabled(n.document, "enter", (i, r) => {
            if (i.eventPhase != "atTarget") return;
            const s = t.getSelectedElement(), a = e.editing.mapper.toViewElement(s), l = e.model.schema;
            let c;
            this._insertParagraphAccordingToFakeCaretPosition() ? c = !0 : Tn(a, s, l) && (this._insertParagraph(s, r.isSoft ? "before" : "after"), c = !0), c && (r.preventDefault(), i.stop());
          }, { context: Ne });
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const e = this.editor.editing.view.document;
          this._listenToIfEnabled(e, "insertText", (t, n) => {
            this._insertParagraphAccordingToFakeCaretPosition() && (n.selection = e.selection);
          }, { priority: "high" }), f.isAndroid ? this._listenToIfEnabled(e, "keydown", (t, n) => {
            n.keyCode == 229 && this._insertParagraphAccordingToFakeCaretPosition();
          }) : this._listenToIfEnabled(e, "compositionstart", () => {
            this._insertParagraphAccordingToFakeCaretPosition();
          }, { priority: "high" });
        }
        _enableDeleteIntegration() {
          const e = this.editor, t = e.editing.view, n = e.model, i = n.schema;
          this._listenToIfEnabled(t.document, "delete", (r, s) => {
            if (r.eventPhase != "atTarget") return;
            const a = cn(n.document.selection);
            if (!a) return;
            const l = s.direction, c = n.document.selection.getSelectedElement(), d = l == "forward";
            if (a === "before" === d) e.execute("delete", { selection: n.createSelection(c, "on") });
            else {
              const u = i.getNearestSelectionRange(n.createPositionAt(c, a), l);
              if (u) if (u.isCollapsed) {
                const g = n.createSelection(u.start);
                if (n.modifySelection(g, { direction: l }), g.focus.isEqual(u.start)) {
                  const p = function(b, w) {
                    let y = w;
                    for (const I of w.getAncestors({ parentFirst: !0 })) {
                      if (I.childCount > 1 || b.isLimit(I)) break;
                      y = I;
                    }
                    return y;
                  }(i, u.start.parent);
                  n.deleteContent(n.createSelection(p, "on"), { doNotAutoparagraph: !0 });
                } else n.change((p) => {
                  p.setSelection(u), e.execute(d ? "deleteForward" : "delete");
                });
              } else n.change((g) => {
                g.setSelection(u), e.execute(d ? "deleteForward" : "delete");
              });
            }
            s.preventDefault(), r.stop();
          }, { context: Ne });
        }
        _enableInsertContentIntegration() {
          const e = this.editor, t = this.editor.model, n = t.document.selection;
          this._listenToIfEnabled(e.model, "insertContent", (i, [r, s]) => {
            if (s && !s.is("documentSelection")) return;
            const a = cn(n);
            return a ? (i.stop(), t.change((l) => {
              const c = n.getSelectedElement(), d = t.createPositionAt(c, a), u = l.createSelection(d), g = t.insertContent(r, u);
              return l.setSelection(u), g;
            })) : void 0;
          }, { priority: "high" });
        }
        _enableInsertObjectIntegration() {
          const e = this.editor, t = this.editor.model.document.selection;
          this._listenToIfEnabled(e.model, "insertObject", (n, i) => {
            const [, r, s = {}] = i;
            if (r && !r.is("documentSelection")) return;
            const a = cn(t);
            a && (s.findOptimalPosition = a, i[3] = s);
          }, { priority: "high" });
        }
        _enableDeleteContentIntegration() {
          const e = this.editor, t = this.editor.model.document.selection;
          this._listenToIfEnabled(e.model, "deleteContent", (n, [i]) => {
            i && !i.is("documentSelection") || cn(t) && n.stop();
          }, { priority: "high" });
        }
      }
      function kC(o) {
        const e = o.model;
        return (t, n) => {
          const i = n.keyCode == ge.arrowup, r = n.keyCode == ge.arrowdown, s = n.shiftKey, a = e.document.selection;
          if (!i && !r) return;
          const l = r;
          if (s && function(d, u) {
            return !d.isCollapsed && d.isBackward == u;
          }(a, l)) return;
          const c = function(d, u, g) {
            const p = d.model;
            if (g) {
              const b = u.isCollapsed ? u.focus : u.getLastPosition(), w = Pg(p, b, "forward");
              if (!w) return null;
              const y = p.createRange(b, w), I = Rg(p.schema, y, "backward");
              return I ? p.createRange(b, I) : null;
            }
            {
              const b = u.isCollapsed ? u.focus : u.getFirstPosition(), w = Pg(p, b, "backward");
              if (!w) return null;
              const y = p.createRange(w, b), I = Rg(p.schema, y, "forward");
              return I ? p.createRange(I, b) : null;
            }
          }(o, a, l);
          if (c) {
            if (c.isCollapsed && (a.isCollapsed || s))
              return;
            (c.isCollapsed || function(d, u, g) {
              const p = d.model, b = d.view.domConverter;
              if (g) {
                const H = p.createSelection(u.start);
                p.modifySelection(H), H.focus.isAtEnd || u.start.isEqual(H.focus) || (u = p.createRange(H.focus, u.end));
              }
              const w = d.mapper.toViewRange(u), y = b.viewRangeToDom(w), I = Fe.getDomRangeRects(y);
              let z;
              for (const H of I) if (z !== void 0) {
                if (Math.round(H.top) >= z) return !1;
                z = Math.max(z, Math.round(H.bottom));
              } else z = Math.round(H.bottom);
              return !0;
            }(o, c, l)) && (e.change((d) => {
              const u = l ? c.end : c.start;
              if (s) {
                const g = e.createSelection(a.anchor);
                g.setFocus(u), d.setSelection(g);
              } else d.setSelection(u);
            }), t.stop(), n.preventDefault(), n.stopPropagation());
          }
        };
      }
      function Pg(o, e, t) {
        const n = o.schema, i = o.createRangeIn(e.root), r = t == "forward" ? "elementStart" : "elementEnd";
        for (const { previousPosition: s, item: a, type: l } of i.getWalker({ startPosition: e, direction: t })) {
          if (n.isLimit(a) && !n.isInline(a)) return s;
          if (l == r && n.isBlock(a)) return null;
        }
        return null;
      }
      function Rg(o, e, t) {
        const n = t == "backward" ? e.end : e.start;
        if (o.checkChild(n, "$text")) return n;
        for (const { nextPosition: i } of e.getWalker({ direction: t })) if (o.checkChild(i, "$text")) return i;
        return null;
      }
      var Og = D(3488), wC = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Og.Z, wC), Og.Z.locals;
      class ti extends K {
        constructor() {
          super(...arguments), this._previouslySelected = /* @__PURE__ */ new Set();
        }
        static get pluginName() {
          return "Widget";
        }
        static get requires() {
          return [bC, ho];
        }
        init() {
          const e = this.editor, t = e.editing.view, n = t.document;
          this.editor.editing.downcastDispatcher.on("selection", (i, r, s) => {
            const a = s.writer, l = r.selection;
            if (l.isCollapsed) return;
            const c = l.getSelectedElement();
            if (!c) return;
            const d = e.editing.mapper.toViewElement(c);
            var u;
            Ne(d) && s.consumable.consume(l, "selection") && a.setSelection(a.createRangeOn(d), { fake: !0, label: (u = d, u.getCustomProperty("widgetLabel").reduce((g, p) => typeof p == "function" ? g ? g + ". " + p() : p() : g ? g + ". " + p : p, "")) });
          }), this.editor.editing.downcastDispatcher.on("selection", (i, r, s) => {
            this._clearPreviouslySelectedWidgets(s.writer);
            const a = s.writer, l = a.document.selection;
            let c = null;
            for (const d of l.getRanges()) for (const u of d) {
              const g = u.item;
              Ne(g) && !AC(g, c) && (a.addClass(Sg, g), this._previouslySelected.add(g), c = g);
            }
          }, { priority: "low" }), t.addObserver(Xs), this.listenTo(n, "mousedown", (...i) => this._onMousedown(...i)), this.listenTo(n, "arrowKey", (...i) => {
            this._handleSelectionChangeOnArrowKeyPress(...i);
          }, { context: [Ne, "$text"] }), this.listenTo(n, "arrowKey", (...i) => {
            this._preventDefaultOnArrowKeyPress(...i);
          }, { context: "$root" }), this.listenTo(n, "arrowKey", kC(this.editor.editing), { context: "$text" }), this.listenTo(n, "delete", (i, r) => {
            this._handleDelete(r.direction == "forward") && (r.preventDefault(), i.stop());
          }, { context: "$root" });
        }
        _onMousedown(e, t) {
          const n = this.editor, i = n.editing.view, r = i.document;
          let s = t.target;
          if (function(l) {
            let c = l;
            for (; c; ) {
              if (c.is("editableElement") && !c.is("rootElement")) return !0;
              if (Ne(c)) return !1;
              c = c.parent;
            }
            return !1;
          }(s)) {
            if ((f.isSafari || f.isGecko) && t.domEvent.detail >= 3) {
              const l = n.editing.mapper, c = s.is("attributeElement") ? s.findAncestor((u) => !u.is("attributeElement")) : s, d = l.toModelElement(c);
              t.preventDefault(), this.editor.model.change((u) => {
                u.setSelection(d, "in");
              });
            }
            return;
          }
          if (!Ne(s) && (s = s.findAncestor(Ne), !s)) return;
          f.isAndroid && t.preventDefault(), r.isFocused || i.focus();
          const a = n.editing.mapper.toModelElement(s);
          this._setSelectionOverElement(a);
        }
        _handleSelectionChangeOnArrowKeyPress(e, t) {
          const n = t.keyCode, i = this.editor.model, r = i.schema, s = i.document.selection, a = s.getSelectedElement(), l = ls(n, this.editor.locale.contentLanguageDirection), c = l == "down" || l == "right", d = l == "up" || l == "down";
          if (a && r.isObject(a)) {
            const g = c ? s.getLastPosition() : s.getFirstPosition(), p = r.getNearestSelectionRange(g, c ? "forward" : "backward");
            return void (p && (i.change((b) => {
              b.setSelection(p);
            }), t.preventDefault(), e.stop()));
          }
          if (!s.isCollapsed && !t.shiftKey) {
            const g = s.getFirstPosition(), p = s.getLastPosition(), b = g.nodeAfter, w = p.nodeBefore;
            return void ((b && r.isObject(b) || w && r.isObject(w)) && (i.change((y) => {
              y.setSelection(c ? p : g);
            }), t.preventDefault(), e.stop()));
          }
          if (!s.isCollapsed) return;
          const u = this._getObjectElementNextToSelection(c);
          if (u && r.isObject(u)) {
            if (r.isInline(u) && d) return;
            this._setSelectionOverElement(u), t.preventDefault(), e.stop();
          }
        }
        _preventDefaultOnArrowKeyPress(e, t) {
          const n = this.editor.model, i = n.schema, r = n.document.selection.getSelectedElement();
          r && i.isObject(r) && (t.preventDefault(), e.stop());
        }
        _handleDelete(e) {
          const t = this.editor.model.document.selection;
          if (!this.editor.model.canEditAt(t) || !t.isCollapsed) return;
          const n = this._getObjectElementNextToSelection(e);
          return n ? (this.editor.model.change((i) => {
            let r = t.anchor.parent;
            for (; r.isEmpty; ) {
              const s = r;
              r = s.parent, i.remove(s);
            }
            this._setSelectionOverElement(n);
          }), !0) : void 0;
        }
        _setSelectionOverElement(e) {
          this.editor.model.change((t) => {
            t.setSelection(t.createRangeOn(e));
          });
        }
        _getObjectElementNextToSelection(e) {
          const t = this.editor.model, n = t.schema, i = t.document.selection, r = t.createSelection(i);
          if (t.modifySelection(r, { direction: e ? "forward" : "backward" }), r.isEqual(i)) return null;
          const s = e ? r.focus.nodeBefore : r.focus.nodeAfter;
          return s && n.isObject(s) ? s : null;
        }
        _clearPreviouslySelectedWidgets(e) {
          for (const t of this._previouslySelected) e.removeClass(Sg, t);
          this._previouslySelected.clear();
        }
      }
      function AC(o, e) {
        return !!e && Array.from(o.getAncestors()).includes(e);
      }
      class ar extends K {
        constructor() {
          super(...arguments), this._toolbarDefinitions = /* @__PURE__ */ new Map();
        }
        static get requires() {
          return [tr];
        }
        static get pluginName() {
          return "WidgetToolbarRepository";
        }
        init() {
          const e = this.editor;
          if (e.plugins.has("BalloonToolbar")) {
            const t = e.plugins.get("BalloonToolbar");
            this.listenTo(t, "show", (n) => {
              (function(i) {
                const r = i.getSelectedElement();
                return !(!r || !Ne(r));
              })(e.editing.view.document.selection) && n.stop();
            }, { priority: "high" });
          }
          this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
            this._updateToolbarsVisibility();
          }), this.listenTo(e.ui, "update", () => {
            this._updateToolbarsVisibility();
          }), this.listenTo(e.ui.focusTracker, "change:isFocused", () => {
            this._updateToolbarsVisibility();
          }, { priority: "low" });
        }
        destroy() {
          super.destroy();
          for (const e of this._toolbarDefinitions.values()) e.view.destroy();
        }
        register(e, { ariaLabel: t, items: n, getRelatedElement: i, balloonClassName: r = "ck-toolbar-container" }) {
          if (!n.length) return void ee("widget-toolbar-no-items", { toolbarId: e });
          const s = this.editor, a = s.t, l = new ta(s.locale);
          if (l.ariaLabel = t || a("Widget toolbar"), this._toolbarDefinitions.has(e)) throw new T("widget-toolbar-duplicated", this, { toolbarId: e });
          const c = { view: l, getRelatedElement: i, balloonClassName: r, itemsConfig: n, initialized: !1 };
          s.ui.addToolbar(l, { isContextual: !0, beforeFocus: () => {
            const d = i(s.editing.view.document.selection);
            d && this._showToolbar(c, d);
          }, afterBlur: () => {
            this._hideToolbar(c);
          } }), this._toolbarDefinitions.set(e, c);
        }
        _updateToolbarsVisibility() {
          let e = 0, t = null, n = null;
          for (const i of this._toolbarDefinitions.values()) {
            const r = i.getRelatedElement(this.editor.editing.view.document.selection);
            if (this.isEnabled && r) if (this.editor.ui.focusTracker.isFocused) {
              const s = r.getAncestors().length;
              s > e && (e = s, t = r, n = i);
            } else this._isToolbarVisible(i) && this._hideToolbar(i);
            else this._isToolbarInBalloon(i) && this._hideToolbar(i);
          }
          n && this._showToolbar(n, t);
        }
        _hideToolbar(e) {
          this._balloon.remove(e.view), this.stopListening(this._balloon, "change:visibleView");
        }
        _showToolbar(e, t) {
          this._isToolbarVisible(e) ? zg(this.editor, t) : this._isToolbarInBalloon(e) || (e.initialized || (e.initialized = !0, e.view.fillFromConfig(e.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({ view: e.view, position: Mg(this.editor, t), balloonClassName: e.balloonClassName }), this.listenTo(this._balloon, "change:visibleView", () => {
            for (const n of this._toolbarDefinitions.values()) if (this._isToolbarVisible(n)) {
              const i = n.getRelatedElement(this.editor.editing.view.document.selection);
              zg(this.editor, i);
            }
          }));
        }
        _isToolbarVisible(e) {
          return this._balloon.visibleView === e.view;
        }
        _isToolbarInBalloon(e) {
          return this._balloon.hasView(e.view);
        }
      }
      function zg(o, e) {
        const t = o.plugins.get("ContextualBalloon"), n = Mg(o, e);
        t.updatePosition(n);
      }
      function Mg(o, e) {
        const t = o.editing.view, n = ut.defaultPositions;
        return { target: t.domConverter.mapViewToDom(e), positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast, n.viewportStickyNorth] };
      }
      var Fg = D(8506), _C = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Fg.Z, _C), Fg.Z.locals;
      var Ng = D(903), vC = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Ng.Z, vC), Ng.Z.locals;
      class CC extends K {
        static get pluginName() {
          return "DragDrop";
        }
        static get requires() {
          return [Gt, ti];
        }
        init() {
          const e = this.editor, t = e.editing.view;
          this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, this._updateDropMarkerThrottled = ma((n) => this._updateDropMarker(n), 40), this._removeDropMarkerDelayed = cs(() => this._removeDropMarker(), 40), this._clearDraggableAttributesDelayed = cs(() => this._clearDraggableAttributes(), 40), e.plugins.has("DragDropExperimental") ? this.forceDisabled("DragDropExperimental") : (t.addObserver(ba), t.addObserver(Xs), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDropMarker(), this._setupDraggableAttributeHandling(), this.listenTo(e, "change:isReadOnly", (n, i, r) => {
            r ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
          }), this.on("change:isEnabled", (n, i, r) => {
            r || this._finalizeDragging(!1);
          }), f.isAndroid && this.forceDisabled("noAndroidSupport"));
        }
        destroy() {
          return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._updateDropMarkerThrottled.cancel(), this._removeDropMarkerDelayed.cancel(), this._clearDraggableAttributesDelayed.cancel(), super.destroy();
        }
        _setupDragging() {
          const e = this.editor, t = e.model, n = t.document, i = e.editing.view, r = i.document;
          this.listenTo(r, "dragstart", (s, a) => {
            const l = n.selection;
            if (a.target && a.target.is("editableElement")) return void a.preventDefault();
            const c = a.target ? jg(a.target) : null;
            if (c) {
              const p = e.editing.mapper.toModelElement(c);
              this._draggedRange = qt.fromRange(t.createRangeOn(p)), e.plugins.has("WidgetToolbarRepository") && e.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
            } else if (!r.selection.isCollapsed) {
              const p = r.selection.getSelectedElement();
              p && Ne(p) || (this._draggedRange = qt.fromRange(l.getFirstRange()));
            }
            if (!this._draggedRange) return void a.preventDefault();
            this._draggingUid = Q();
            const d = this.isEnabled && e.model.canEditAt(this._draggedRange);
            a.dataTransfer.effectAllowed = d ? "copyMove" : "copy", a.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
            const u = t.createSelection(this._draggedRange.toRange()), g = e.data.toView(t.getSelectedContent(u));
            r.fire("clipboardOutput", { dataTransfer: a.dataTransfer, content: g, method: "dragstart" }), d || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
          }, { priority: "low" }), this.listenTo(r, "dragend", (s, a) => {
            this._finalizeDragging(!a.dataTransfer.isCanceled && a.dataTransfer.dropEffect == "move");
          }, { priority: "low" }), this.listenTo(r, "dragenter", () => {
            this.isEnabled && i.focus();
          }), this.listenTo(r, "dragleave", () => {
            this._removeDropMarkerDelayed();
          }), this.listenTo(r, "dragging", (s, a) => {
            if (!this.isEnabled) return void (a.dataTransfer.dropEffect = "none");
            this._removeDropMarkerDelayed.cancel();
            const l = Vg(e, a.targetRanges, a.target);
            e.model.canEditAt(l) ? (this._draggedRange || (a.dataTransfer.dropEffect = "copy"), f.isGecko || (a.dataTransfer.effectAllowed == "copy" ? a.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(a.dataTransfer.effectAllowed) && (a.dataTransfer.dropEffect = "move")), l && this._updateDropMarkerThrottled(l)) : a.dataTransfer.dropEffect = "none";
          }, { priority: "low" });
        }
        _setupClipboardInputIntegration() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "clipboardInput", (n, i) => {
            if (i.method != "drop") return;
            const r = Vg(e, i.targetRanges, i.target);
            if (this._removeDropMarker(), !r || !e.model.canEditAt(r)) return this._finalizeDragging(!1), void n.stop();
            if (this._draggedRange && this._draggingUid != i.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = ""), Lg(i.dataTransfer) == "move" && this._draggedRange && this._draggedRange.containsRange(r, !0)) return this._finalizeDragging(!1), void n.stop();
            i.targetRanges = [e.editing.mapper.toViewRange(r)];
          }, { priority: "high" });
        }
        _setupContentInsertionIntegration() {
          const e = this.editor.plugins.get(Gt);
          e.on("contentInsertion", (t, n) => {
            if (!this.isEnabled || n.method !== "drop") return;
            const i = n.targetRanges.map((r) => this.editor.editing.mapper.toModelRange(r));
            this.editor.model.change((r) => r.setSelection(i));
          }, { priority: "high" }), e.on("contentInsertion", (t, n) => {
            if (!this.isEnabled || n.method !== "drop") return;
            const i = Lg(n.dataTransfer) == "move", r = !n.resultRange || !n.resultRange.isCollapsed;
            this._finalizeDragging(r && i);
          }, { priority: "lowest" });
        }
        _setupDraggableAttributeHandling() {
          const e = this.editor, t = e.editing.view, n = t.document;
          this.listenTo(n, "mousedown", (i, r) => {
            if (f.isAndroid || !r) return;
            this._clearDraggableAttributesDelayed.cancel();
            let s = jg(r.target);
            if (f.isBlink && !s && !n.selection.isCollapsed) {
              const a = n.selection.getSelectedElement();
              if (!a || !Ne(a)) {
                const l = n.selection.editableElement;
                l && !l.isReadOnly && (s = l);
              }
            }
            s && (t.change((a) => {
              a.setAttribute("draggable", "true", s);
            }), this._draggableElement = e.editing.mapper.toModelElement(s));
          }), this.listenTo(n, "mouseup", () => {
            f.isAndroid || this._clearDraggableAttributesDelayed();
          });
        }
        _clearDraggableAttributes() {
          const e = this.editor.editing;
          e.view.change((t) => {
            this._draggableElement && this._draggableElement.root.rootName != "$graveyard" && t.removeAttribute("draggable", e.mapper.toViewElement(this._draggableElement)), this._draggableElement = null;
          });
        }
        _setupDropMarker() {
          const e = this.editor;
          e.conversion.for("editingDowncast").markerToHighlight({ model: "drop-target", view: { classes: ["ck-clipboard-drop-target-range"] } }), e.conversion.for("editingDowncast").markerToElement({ model: "drop-target", view: (t, { writer: n }) => {
            if (e.model.schema.checkChild(t.markerRange.start, "$text")) return n.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(i) {
              const r = this.toDomElement(i);
              return r.append("⁠", i.createElement("span"), "⁠"), r;
            });
          } });
        }
        _updateDropMarker(e) {
          const t = this.editor, n = t.model.markers;
          t.model.change((i) => {
            n.has("drop-target") ? n.get("drop-target").getRange().isEqual(e) || i.updateMarker("drop-target", { range: e }) : i.addMarker("drop-target", { range: e, usingOperation: !1, affectsData: !1 });
          });
        }
        _removeDropMarker() {
          const e = this.editor.model;
          this._removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), e.markers.has("drop-target") && e.change((t) => {
            t.removeMarker("drop-target");
          });
        }
        _finalizeDragging(e) {
          const t = this.editor, n = t.model;
          this._removeDropMarker(), this._clearDraggableAttributes(), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._draggedRange && (e && this.isEnabled && n.deleteContent(n.createSelection(this._draggedRange), { doNotAutoparagraph: !0 }), this._draggedRange.detach(), this._draggedRange = null);
        }
      }
      function Vg(o, e, t) {
        const n = o.model, i = o.editing.mapper;
        let r = null;
        const s = e ? e[0].start : null;
        if (t.is("uiElement") && (t = t.parent), r = function(c, d) {
          const u = c.model, g = c.editing.mapper;
          if (Ne(d)) return u.createRangeOn(g.toModelElement(d));
          if (!d.is("editableElement")) {
            const p = d.findAncestor((b) => Ne(b) || b.is("editableElement"));
            if (Ne(p)) return u.createRangeOn(g.toModelElement(p));
          }
          return null;
        }(o, t), r) return r;
        const a = function(c, d) {
          const u = c.editing.mapper, g = c.editing.view, p = u.toModelElement(d);
          if (p) return p;
          const b = g.createPositionBefore(d), w = u.findMappedViewAncestor(b);
          return u.toModelElement(w);
        }(o, t), l = s ? i.toModelPosition(s) : null;
        return l ? (r = function(c, d, u) {
          const g = c.model;
          if (!g.schema.checkChild(u, "$block")) return null;
          const p = g.createPositionAt(u, 0), b = d.path.slice(0, p.path.length), w = g.createPositionFromPath(d.root, b), y = w.nodeAfter;
          return y && g.schema.isObject(y) ? g.createRangeOn(y) : null;
        }(o, l, a), r || (r = n.schema.getNearestSelectionRange(l, f.isGecko ? "forward" : "backward"), r || function(c, d) {
          const u = c.model;
          let g = d;
          for (; g; ) {
            if (u.schema.isObject(g)) return u.createRangeOn(g);
            g = g.parent;
          }
          return null;
        }(o, l.parent))) : function(c, d) {
          const u = c.model, g = u.schema, p = u.createPositionAt(d, 0);
          return g.getNearestSelectionRange(p, "forward");
        }(o, a);
      }
      function Lg(o) {
        return f.isGecko ? o.dropEffect : ["all", "copyMove"].includes(o.effectAllowed) ? "move" : "copy";
      }
      function jg(o) {
        if (o.is("editableElement")) return null;
        if (o.hasClass("ck-widget__selection-handle")) return o.findAncestor(Ne);
        if (Ne(o)) return o;
        const e = o.findAncestor((t) => Ne(t) || t.is("editableElement"));
        return Ne(e) ? e : null;
      }
      class yC extends K {
        static get pluginName() {
          return "PastePlainText";
        }
        static get requires() {
          return [Gt];
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view, i = n.document, r = t.document.selection;
          let s = !1;
          n.addObserver(ba), this.listenTo(i, "keydown", (a, l) => {
            s = l.shiftKey;
          }), e.plugins.get(Gt).on("contentInsertion", (a, l) => {
            (s || function(c, d) {
              if (c.childCount > 1) return !1;
              const u = c.getChild(0);
              return d.isObject(u) ? !1 : Array.from(u.getAttributeKeys()).length == 0;
            }(l.content, t.schema)) && t.change((c) => {
              const d = Array.from(r.getAttributes()).filter(([g]) => t.schema.getAttributeProperties(g).isFormatting);
              r.isCollapsed || t.deleteContent(r, { doNotAutoparagraph: !0 }), d.push(...r.getAttributes());
              const u = c.createRangeIn(l.content);
              for (const g of u.getItems()) g.is("$textProxy") && c.setAttributes(d, g);
            });
          });
        }
      }
      class EC extends K {
        static get pluginName() {
          return "Clipboard";
        }
        static get requires() {
          return [Gt, CC, yC];
        }
      }
      class xC extends ae {
        constructor(e) {
          super(e), this.affectsData = !1;
        }
        execute() {
          const e = this.editor.model, t = e.document.selection;
          let n = e.schema.getLimitElement(t);
          if (t.containsEntireContent(n) || !$g(e.schema, n)) do
            if (n = n.parent, !n) return;
          while (!$g(e.schema, n));
          e.change((i) => {
            i.setSelection(n, "in");
          });
        }
      }
      function $g(o, e) {
        return o.isLimit(e) && (o.checkChild(e, "$text") || o.checkChild(e, "paragraph"));
      }
      const SC = Ei("Ctrl+A");
      class DC extends K {
        static get pluginName() {
          return "SelectAllEditing";
        }
        init() {
          const e = this.editor, t = e.editing.view.document;
          e.commands.add("selectAll", new xC(e)), this.listenTo(t, "keydown", (n, i) => {
            eo(i) === SC && (e.execute("selectAll"), i.preventDefault());
          });
        }
      }
      class BC extends K {
        static get pluginName() {
          return "SelectAllUI";
        }
        init() {
          const e = this.editor;
          e.ui.componentFactory.add("selectAll", (t) => {
            const n = e.commands.get("selectAll"), i = new De(t), r = t.t;
            return i.set({ label: r("Select all"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>', keystroke: "Ctrl+A", tooltip: !0 }), i.bind("isEnabled").to(n, "isEnabled"), this.listenTo(i, "execute", () => {
              e.execute("selectAll"), e.editing.view.focus();
            }), i;
          });
        }
      }
      class TC extends K {
        static get requires() {
          return [DC, BC];
        }
        static get pluginName() {
          return "SelectAll";
        }
      }
      var IC = Object.defineProperty, Hg = Object.getOwnPropertySymbols, PC = Object.prototype.hasOwnProperty, RC = Object.prototype.propertyIsEnumerable, qg = (o, e, t) => e in o ? IC(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class Ug extends ae {
        constructor(e) {
          super(e), this._stack = [], this._createdBatches = /* @__PURE__ */ new WeakSet(), this.refresh(), this._isEnabledBasedOnSelection = !1, this.listenTo(e.data, "set", (t, n) => {
            n[1] = ((r, s) => {
              for (var a in s || (s = {})) PC.call(s, a) && qg(r, a, s[a]);
              if (Hg) for (var a of Hg(s)) RC.call(s, a) && qg(r, a, s[a]);
              return r;
            })({}, n[1]);
            const i = n[1];
            i.batchType || (i.batchType = { isUndoable: !1 });
          }, { priority: "high" }), this.listenTo(e.data, "set", (t, n) => {
            n[1].batchType.isUndoable || this.clearStack();
          });
        }
        refresh() {
          this.isEnabled = this._stack.length > 0;
        }
        get createdBatches() {
          return this._createdBatches;
        }
        addBatch(e) {
          const t = this.editor.model.document.selection, n = { ranges: t.hasOwnRange ? Array.from(t.getRanges()) : [], isBackward: t.isBackward };
          this._stack.push({ batch: e, selection: n }), this.refresh();
        }
        clearStack() {
          this._stack = [], this.refresh();
        }
        _restoreSelection(e, t, n) {
          const i = this.editor.model, r = i.document, s = [], a = e.map((c) => c.getTransformedByOperations(n)), l = a.flat();
          for (const c of a) {
            const d = c.filter((u) => u.root != r.graveyard).filter((u) => !zC(u, l));
            d.length && (OC(d), s.push(d[0]));
          }
          s.length && i.change((c) => {
            c.setSelection(s, { backward: t });
          });
        }
        _undo(e, t) {
          const n = this.editor.model, i = n.document;
          this._createdBatches.add(t);
          const r = e.operations.slice().filter((s) => s.isDocumentOperation);
          r.reverse();
          for (const s of r) {
            const a = s.baseVersion + 1, l = Array.from(i.history.getOperations(a)), c = r_([s.getReversed()], l, { useRelations: !0, document: this.editor.model.document, padWithNoOps: !1, forceWeakRemove: !0 }).operationsA;
            for (let d of c) {
              const u = d.affectedSelectable;
              u && !n.canEditAt(u) && (d = new Xe(d.baseVersion)), t.addOperation(d), n.applyOperation(d), i.history.setOperationAsUndone(s, d);
            }
          }
        }
      }
      function OC(o) {
        o.sort((e, t) => e.start.isBefore(t.start) ? -1 : 1);
        for (let e = 1; e < o.length; e++) {
          const t = o[e - 1].getJoined(o[e], !0);
          t && (e--, o.splice(e, 2, t));
        }
      }
      function zC(o, e) {
        return e.some((t) => t !== o && t.containsRange(o, !0));
      }
      class MC extends Ug {
        execute(e = null) {
          const t = e ? this._stack.findIndex((r) => r.batch == e) : this._stack.length - 1, n = this._stack.splice(t, 1)[0], i = this.editor.model.createBatch({ isUndo: !0 });
          this.editor.model.enqueueChange(i, () => {
            this._undo(n.batch, i);
            const r = this.editor.model.document.history.getOperations(n.batch.baseVersion);
            this._restoreSelection(n.selection.ranges, n.selection.isBackward, r), this.fire("revert", n.batch, i);
          }), this.refresh();
        }
      }
      class FC extends Ug {
        execute() {
          const e = this._stack.pop(), t = this.editor.model.createBatch({ isUndo: !0 });
          this.editor.model.enqueueChange(t, () => {
            const n = e.batch.operations[e.batch.operations.length - 1].baseVersion + 1, i = this.editor.model.document.history.getOperations(n);
            this._restoreSelection(e.selection.ranges, e.selection.isBackward, i), this._undo(e.batch, t);
          }), this.refresh();
        }
      }
      class NC extends K {
        constructor() {
          super(...arguments), this._batchRegistry = /* @__PURE__ */ new WeakSet();
        }
        static get pluginName() {
          return "UndoEditing";
        }
        init() {
          const e = this.editor;
          this._undoCommand = new MC(e), this._redoCommand = new FC(e), e.commands.add("undo", this._undoCommand), e.commands.add("redo", this._redoCommand), this.listenTo(e.model, "applyOperation", (t, n) => {
            const i = n[0];
            if (!i.isDocumentOperation) return;
            const r = i.batch, s = this._redoCommand.createdBatches.has(r), a = this._undoCommand.createdBatches.has(r);
            this._batchRegistry.has(r) || (this._batchRegistry.add(r), r.isUndoable && (s ? this._undoCommand.addBatch(r) : a || (this._undoCommand.addBatch(r), this._redoCommand.clearStack())));
          }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (t, n, i) => {
            this._redoCommand.addBatch(i);
          }), e.keystrokes.set("CTRL+Z", "undo"), e.keystrokes.set("CTRL+Y", "redo"), e.keystrokes.set("CTRL+SHIFT+Z", "redo");
        }
      }
      const Wg = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', Kg = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
      class VC extends K {
        static get pluginName() {
          return "UndoUI";
        }
        init() {
          const e = this.editor, t = e.locale, n = e.t, i = t.uiLanguageDirection == "ltr" ? Wg : Kg, r = t.uiLanguageDirection == "ltr" ? Kg : Wg;
          this._addButton("undo", n("Undo"), "CTRL+Z", i), this._addButton("redo", n("Redo"), "CTRL+Y", r);
        }
        _addButton(e, t, n, i) {
          const r = this.editor;
          r.ui.componentFactory.add(e, (s) => {
            const a = r.commands.get(e), l = new De(s);
            return l.set({ label: t, icon: i, keystroke: n, tooltip: !0 }), l.bind("isEnabled").to(a, "isEnabled"), this.listenTo(l, "execute", () => {
              r.execute(e), r.editing.view.focus();
            }), l;
          });
        }
      }
      class LC extends K {
        static get requires() {
          return [NC, VC];
        }
        static get pluginName() {
          return "Undo";
        }
      }
      class jC extends ve() {
        constructor() {
          super();
          const e = new window.FileReader();
          this._reader = e, this._data = void 0, this.set("loaded", 0), e.onprogress = (t) => {
            this.loaded = t.loaded;
          };
        }
        get error() {
          return this._reader.error;
        }
        get data() {
          return this._data;
        }
        read(e) {
          const t = this._reader;
          return this.total = e.size, new Promise((n, i) => {
            t.onload = () => {
              const r = t.result;
              this._data = r, n(r);
            }, t.onerror = () => {
              i("error");
            }, t.onabort = () => {
              i("aborted");
            }, this._reader.readAsDataURL(e);
          });
        }
        abort() {
          this._reader.abort();
        }
      }
      class Jt extends K {
        constructor() {
          super(...arguments), this.loaders = new _t(), this._loadersMap = /* @__PURE__ */ new Map(), this._pendingAction = null;
        }
        static get pluginName() {
          return "FileRepository";
        }
        static get requires() {
          return [Gi];
        }
        init() {
          this.loaders.on("change", () => this._updatePendingAction()), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (e, t) => t ? e / t * 100 : 0);
        }
        getLoader(e) {
          return this._loadersMap.get(e) || null;
        }
        createLoader(e) {
          if (!this.createUploadAdapter) return ee("filerepository-no-upload-adapter"), null;
          const t = new Gg(Promise.resolve(e), this.createUploadAdapter);
          return this.loaders.add(t), this._loadersMap.set(e, t), e instanceof Promise && t.file.then((n) => {
            this._loadersMap.set(n, t);
          }).catch(() => {
          }), t.on("change:uploaded", () => {
            let n = 0;
            for (const i of this.loaders) n += i.uploaded;
            this.uploaded = n;
          }), t.on("change:uploadTotal", () => {
            let n = 0;
            for (const i of this.loaders) i.uploadTotal && (n += i.uploadTotal);
            this.uploadTotal = n;
          }), t;
        }
        destroyLoader(e) {
          const t = e instanceof Gg ? e : this.getLoader(e);
          t._destroy(), this.loaders.remove(t), this._loadersMap.forEach((n, i) => {
            n === t && this._loadersMap.delete(i);
          });
        }
        _updatePendingAction() {
          const e = this.editor.plugins.get(Gi);
          if (this.loaders.length) {
            if (!this._pendingAction) {
              const t = this.editor.t, n = (i) => `${t("Upload in progress")} ${parseInt(i)}%.`;
              this._pendingAction = e.add(n(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", n);
            }
          } else e.remove(this._pendingAction), this._pendingAction = null;
        }
      }
      class Gg extends ve() {
        constructor(e, t) {
          super(), this.id = Q(), this._filePromiseWrapper = this._createFilePromiseWrapper(e), this._adapter = t(this), this._reader = new jC(), this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (n, i) => i ? n / i * 100 : 0), this.set("uploadResponse", null);
        }
        get file() {
          return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((e) => this._filePromiseWrapper ? e : null) : Promise.resolve(null);
        }
        get data() {
          return this._reader.data;
        }
        read() {
          if (this.status != "idle") throw new T("filerepository-read-wrong-status", this);
          return this.status = "reading", this.file.then((e) => this._reader.read(e)).then((e) => {
            if (this.status !== "reading") throw this.status;
            return this.status = "idle", e;
          }).catch((e) => {
            throw e === "aborted" ? (this.status = "aborted", "aborted") : (this.status = "error", this._reader.error ? this._reader.error : e);
          });
        }
        upload() {
          if (this.status != "idle") throw new T("filerepository-upload-wrong-status", this);
          return this.status = "uploading", this.file.then(() => this._adapter.upload()).then((e) => (this.uploadResponse = e, this.status = "idle", e)).catch((e) => {
            throw this.status === "aborted" ? "aborted" : (this.status = "error", e);
          });
        }
        abort() {
          const e = this.status;
          this.status = "aborted", this._filePromiseWrapper.isFulfilled ? e == "reading" ? this._reader.abort() : e == "uploading" && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
          }), this._filePromiseWrapper.rejecter("aborted")), this._destroy();
        }
        _destroy() {
          this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0;
        }
        _createFilePromiseWrapper(e) {
          const t = {};
          return t.promise = new Promise((n, i) => {
            t.rejecter = i, t.isFulfilled = !1, e.then((r) => {
              t.isFulfilled = !0, n(r);
            }).catch((r) => {
              t.isFulfilled = !0, i(r);
            });
          }), t;
        }
      }
      class $C extends de {
        constructor(e) {
          super(e), this.buttonView = new De(e), this._fileInputView = new HC(e), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.setTemplate({ tag: "span", attributes: { class: "ck-file-dialog-button" }, children: [this.buttonView, this._fileInputView] }), this.buttonView.on("execute", () => {
            this._fileInputView.open();
          });
        }
        focus() {
          this.buttonView.focus();
        }
      }
      class HC extends de {
        constructor(e) {
          super(e), this.set("acceptedType", void 0), this.set("allowMultipleFiles", !1);
          const t = this.bindTemplate;
          this.setTemplate({ tag: "input", attributes: { class: ["ck-hidden"], type: "file", tabindex: "-1", accept: t.to("acceptedType"), multiple: t.to("allowMultipleFiles") }, on: { change: t.to(() => {
            this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = "";
          }) } });
        }
        open() {
          this.element.click();
        }
      }
      const Zg = "ckCsrfToken", Jg = "abcdefghijklmnopqrstuvwxyz0123456789";
      function qC() {
        let o = function(n) {
          n = n.toLowerCase();
          const i = document.cookie.split(";");
          for (const r of i) {
            const s = r.split("=");
            if (decodeURIComponent(s[0].trim().toLowerCase()) === n) return decodeURIComponent(s[1]);
          }
          return null;
        }(Zg);
        var e, t;
        return o && o.length == 40 || (o = function(n) {
          let i = "";
          const r = new Uint8Array(n);
          window.crypto.getRandomValues(r);
          for (let s = 0; s < r.length; s++) {
            const a = Jg.charAt(r[s] % Jg.length);
            i += Math.random() > 0.5 ? a.toUpperCase() : a;
          }
          return i;
        }(40), e = Zg, t = o, document.cookie = encodeURIComponent(e) + "=" + encodeURIComponent(t) + ";path=/"), o;
      }
      class UC {
        constructor(e, t, n) {
          this.loader = e, this.url = t, this.t = n;
        }
        upload() {
          return this.loader.file.then((e) => new Promise((t, n) => {
            this._initRequest(), this._initListeners(t, n, e), this._sendRequest(e);
          }));
        }
        abort() {
          this.xhr && this.xhr.abort();
        }
        _initRequest() {
          const e = this.xhr = new XMLHttpRequest();
          e.open("POST", this.url, !0), e.responseType = "json";
        }
        _initListeners(e, t, n) {
          const i = this.xhr, r = this.loader, s = (0, this.t)("Cannot upload file:") + ` ${n.name}.`;
          i.addEventListener("error", () => t(s)), i.addEventListener("abort", () => t()), i.addEventListener("load", () => {
            const a = i.response;
            if (!a || !a.uploaded) return t(a && a.error && a.error.message ? a.error.message : s);
            e({ default: a.url });
          }), i.upload && i.upload.addEventListener("progress", (a) => {
            a.lengthComputable && (r.uploadTotal = a.total, r.uploaded = a.loaded);
          });
        }
        _sendRequest(e) {
          const t = new FormData();
          t.append("upload", e), t.append("ckCsrfToken", qC()), this.xhr.send(t);
        }
      }
      class Ca extends ae {
        constructor(e, t) {
          super(e), this.attributeKey = t;
        }
        refresh() {
          const e = this.editor.model, t = e.document;
          this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey);
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document.selection, i = e.forceValue === void 0 ? !this.value : e.forceValue;
          t.change((r) => {
            if (n.isCollapsed) i ? r.setSelectionAttribute(this.attributeKey, !0) : r.removeSelectionAttribute(this.attributeKey);
            else {
              const s = t.schema.getValidRanges(n.getRanges(), this.attributeKey);
              for (const a of s) i ? r.setAttribute(this.attributeKey, i, a) : r.removeAttribute(this.attributeKey, a);
            }
          });
        }
        _getValueFromFirstAllowedNode() {
          const e = this.editor.model, t = e.schema, n = e.document.selection;
          if (n.isCollapsed) return n.hasAttribute(this.attributeKey);
          for (const i of n.getRanges()) for (const r of i.getItems()) if (t.checkAttribute(r, this.attributeKey)) return r.hasAttribute(this.attributeKey);
          return !1;
        }
      }
      const po = "bold";
      class WC extends K {
        static get pluginName() {
          return "BoldEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: po }), e.model.schema.setAttributeProperties(po, { isFormatting: !0, copyOnEnter: !0 }), e.conversion.attributeToElement({ model: po, view: "strong", upcastAlso: ["b", (t) => {
            const n = t.getStyle("font-weight");
            return n && (n == "bold" || Number(n) >= 600) ? { name: !0, styles: ["font-weight"] } : null;
          }] }), e.commands.add(po, new Ca(e, po)), e.keystrokes.set("CTRL+B", po);
        }
      }
      const ya = "bold";
      class KC extends K {
        static get pluginName() {
          return "BoldUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(ya, (n) => {
            const i = e.commands.get(ya), r = new De(n);
            return r.set({ label: t("Bold"), icon: Pe.bold, keystroke: "CTRL+B", tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(ya), e.editing.view.focus();
            }), r;
          });
        }
      }
      var Yg = D(8603), GC = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Yg.Z, GC), Yg.Z.locals;
      const fo = "italic";
      class ZC extends K {
        static get pluginName() {
          return "ItalicEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: fo }), e.model.schema.setAttributeProperties(fo, { isFormatting: !0, copyOnEnter: !0 }), e.conversion.attributeToElement({ model: fo, view: "i", upcastAlso: ["em", { styles: { "font-style": "italic" } }] }), e.commands.add(fo, new Ca(e, fo)), e.keystrokes.set("CTRL+I", fo);
        }
      }
      const Ea = "italic";
      class JC extends K {
        static get pluginName() {
          return "ItalicUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(Ea, (n) => {
            const i = e.commands.get(Ea), r = new De(n);
            return r.set({ label: t("Italic"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>', keystroke: "CTRL+I", tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(Ea), e.editing.view.focus();
            }), r;
          });
        }
      }
      const ni = "underline";
      class YC extends K {
        static get pluginName() {
          return "UnderlineEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: ni }), e.model.schema.setAttributeProperties(ni, { isFormatting: !0, copyOnEnter: !0 }), e.conversion.attributeToElement({ model: ni, view: "u", upcastAlso: { styles: { "text-decoration": "underline" } } }), e.commands.add(ni, new Ca(e, ni)), e.keystrokes.set("CTRL+U", "underline");
        }
      }
      const xa = "underline";
      class QC extends K {
        static get pluginName() {
          return "UnderlineUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(xa, (n) => {
            const i = e.commands.get(xa), r = new De(n);
            return r.set({ label: t("Underline"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>', keystroke: "CTRL+U", tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(xa), e.editing.view.focus();
            }), r;
          });
        }
      }
      class XC extends ae {
        refresh() {
          this.value = this._getValue(), this.isEnabled = this._checkEnabled();
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.schema, i = t.document.selection, r = Array.from(i.getSelectedBlocks()), s = e.forceValue === void 0 ? !this.value : e.forceValue;
          t.change((a) => {
            if (s) {
              const l = r.filter((c) => lr(c) || Xg(n, c));
              this._applyQuote(a, l);
            } else this._removeQuote(a, r.filter(lr));
          });
        }
        _getValue() {
          const e = Ke(this.editor.model.document.selection.getSelectedBlocks());
          return !(!e || !lr(e));
        }
        _checkEnabled() {
          if (this.value) return !0;
          const e = this.editor.model.document.selection, t = this.editor.model.schema, n = Ke(e.getSelectedBlocks());
          return !!n && Xg(t, n);
        }
        _removeQuote(e, t) {
          Qg(e, t).reverse().forEach((n) => {
            if (n.start.isAtStart && n.end.isAtEnd) return void e.unwrap(n.start.parent);
            if (n.start.isAtStart) {
              const r = e.createPositionBefore(n.start.parent);
              return void e.move(n, r);
            }
            n.end.isAtEnd || e.split(n.end);
            const i = e.createPositionAfter(n.end.parent);
            e.move(n, i);
          });
        }
        _applyQuote(e, t) {
          const n = [];
          Qg(e, t).reverse().forEach((i) => {
            let r = lr(i.start);
            r || (r = e.createElement("blockQuote"), e.wrap(i, r)), n.push(r);
          }), n.reverse().reduce((i, r) => i.nextSibling == r ? (e.merge(e.createPositionAfter(i)), i) : r);
        }
      }
      function lr(o) {
        return o.parent.name == "blockQuote" ? o.parent : null;
      }
      function Qg(o, e) {
        let t, n = 0;
        const i = [];
        for (; n < e.length; ) {
          const r = e[n], s = e[n + 1];
          t || (t = o.createPositionBefore(r)), s && r.nextSibling == s || (i.push(o.createRange(t, o.createPositionAfter(r))), t = null), n++;
        }
        return i;
      }
      function Xg(o, e) {
        const t = o.checkChild(e.parent, "blockQuote"), n = o.checkChild(["$root", "blockQuote"], e);
        return t && n;
      }
      class e1 extends K {
        static get pluginName() {
          return "BlockQuoteEditing";
        }
        static get requires() {
          return [ei, ho];
        }
        init() {
          const e = this.editor, t = e.model.schema;
          e.commands.add("blockQuote", new XC(e)), t.register("blockQuote", { inheritAllFrom: "$container" }), e.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }), e.model.document.registerPostFixer((s) => {
            const a = e.model.document.differ.getChanges();
            for (const l of a) if (l.type == "insert") {
              const c = l.position.nodeAfter;
              if (!c) continue;
              if (c.is("element", "blockQuote") && c.isEmpty) return s.remove(c), !0;
              if (c.is("element", "blockQuote") && !t.checkChild(l.position, c)) return s.unwrap(c), !0;
              if (c.is("element")) {
                const d = s.createRangeIn(c);
                for (const u of d.getItems()) if (u.is("element", "blockQuote") && !t.checkChild(s.createPositionBefore(u), u)) return s.unwrap(u), !0;
              }
            } else if (l.type == "remove") {
              const c = l.position.parent;
              if (c.is("element", "blockQuote") && c.isEmpty) return s.remove(c), !0;
            }
            return !1;
          });
          const n = this.editor.editing.view.document, i = e.model.document.selection, r = e.commands.get("blockQuote");
          this.listenTo(n, "enter", (s, a) => {
            !i.isCollapsed || !r.value || i.getLastPosition().parent.isEmpty && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), s.stop());
          }, { context: "blockquote" }), this.listenTo(n, "delete", (s, a) => {
            if (a.direction != "backward" || !i.isCollapsed || !r.value) return;
            const l = i.getLastPosition().parent;
            l.isEmpty && !l.previousSibling && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), s.stop());
          }, { context: "blockquote" });
        }
      }
      var em = D(3062), t1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(em.Z, t1), em.Z.locals;
      class n1 extends K {
        static get pluginName() {
          return "BlockQuoteUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add("blockQuote", (n) => {
            const i = e.commands.get("blockQuote"), r = new De(n);
            return r.set({ label: t("Block quote"), icon: Pe.quote, tooltip: !0, isToggleable: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute("blockQuote"), e.editing.view.focus();
            }), r;
          });
        }
      }
      class o1 extends K {
        static get pluginName() {
          return "CloudServicesUploadAdapter";
        }
        static get requires() {
          return ["CloudServices", Jt];
        }
        init() {
          const e = this.editor, t = e.plugins.get("CloudServices"), n = t.token, i = t.uploadUrl;
          if (!n) return;
          const r = e.plugins.get("CloudServicesCore");
          this._uploadGateway = r.createUploadGateway(n, i), e.plugins.get(Jt).createUploadAdapter = (s) => new i1(this._uploadGateway, s);
        }
      }
      class i1 {
        constructor(e, t) {
          this.uploadGateway = e, this.loader = t;
        }
        upload() {
          return this.loader.file.then((e) => (this.fileUploader = this.uploadGateway.upload(e), this.fileUploader.on("progress", (t, n) => {
            this.loader.uploadTotal = n.total, this.loader.uploaded = n.uploaded;
          }), this.fileUploader.send()));
        }
        abort() {
          this.fileUploader.abort();
        }
      }
      class r1 extends ae {
        constructor(e) {
          super(e), this._isEnabledBasedOnSelection = !1;
        }
        refresh() {
          const e = this.editor.model, t = Ke(e.document.selection.getSelectedBlocks());
          this.value = !!t && t.is("element", "paragraph"), this.isEnabled = !!t && tm(t, e.schema);
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document, i = e.selection || n.selection;
          t.canEditAt(i) && t.change((r) => {
            const s = i.getSelectedBlocks();
            for (const a of s) !a.is("element", "paragraph") && tm(a, t.schema) && r.rename(a, "paragraph");
          });
        }
      }
      function tm(o, e) {
        return e.checkChild(o.parent, "paragraph") && !e.isObject(o);
      }
      class s1 extends ae {
        constructor(e) {
          super(e), this._isEnabledBasedOnSelection = !1;
        }
        execute(e) {
          const t = this.editor.model, n = e.attributes;
          let i = e.position;
          t.canEditAt(i) && t.change((r) => {
            const s = r.createElement("paragraph");
            if (n && t.schema.setAllowedAttributes(s, n, r), !t.schema.checkChild(i.parent, s)) {
              const a = t.schema.findAllowedParent(i, s);
              if (!a) return;
              i = r.split(i, a).position;
            }
            t.insertContent(s, i), r.setSelection(s, "in");
          });
        }
      }
      const nm = class extends K {
        static get pluginName() {
          return "Paragraph";
        }
        init() {
          const o = this.editor, e = o.model;
          o.commands.add("paragraph", new r1(o)), o.commands.add("insertParagraph", new s1(o)), e.schema.register("paragraph", { inheritAllFrom: "$block" }), o.conversion.elementToElement({ model: "paragraph", view: "p" }), o.conversion.for("upcast").elementToElement({ model: (t, { writer: n }) => nm.paragraphLikeElements.has(t.name) ? t.isEmpty ? null : n.createElement("paragraph") : null, view: /.+/, converterPriority: "low" });
        }
      };
      let Sa = nm;
      Sa.paragraphLikeElements = /* @__PURE__ */ new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);
      class a1 extends ae {
        constructor(e, t) {
          super(e), this.modelElements = t;
        }
        refresh() {
          const e = Ke(this.editor.model.document.selection.getSelectedBlocks());
          this.value = !!e && this.modelElements.includes(e.name) && e.name, this.isEnabled = !!e && this.modelElements.some((t) => om(e, t, this.editor.model.schema));
        }
        execute(e) {
          const t = this.editor.model, n = t.document, i = e.value;
          t.change((r) => {
            const s = Array.from(n.selection.getSelectedBlocks()).filter((a) => om(a, i, t.schema));
            for (const a of s) a.is("element", i) || r.rename(a, i);
          });
        }
      }
      function om(o, e, t) {
        return t.checkChild(o.parent, e) && !t.isObject(o);
      }
      const im = "paragraph";
      class l1 extends K {
        static get pluginName() {
          return "HeadingEditing";
        }
        constructor(e) {
          super(e), e.config.define("heading", { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }] });
        }
        static get requires() {
          return [Sa];
        }
        init() {
          const e = this.editor, t = e.config.get("heading.options"), n = [];
          for (const i of t) i.model !== "paragraph" && (e.model.schema.register(i.model, { inheritAllFrom: "$block" }), e.conversion.elementToElement(i), n.push(i.model));
          this._addDefaultH1Conversion(e), e.commands.add("heading", new a1(e, n));
        }
        afterInit() {
          const e = this.editor, t = e.commands.get("enter"), n = e.config.get("heading.options");
          t && this.listenTo(t, "afterExecute", (i, r) => {
            const s = e.model.document.selection.getFirstPosition().parent;
            n.some((a) => s.is("element", a.model)) && !s.is("element", im) && s.childCount === 0 && r.writer.rename(s, im);
          });
        }
        _addDefaultH1Conversion(e) {
          e.conversion.for("upcast").elementToElement({ model: "heading1", view: "h1", converterPriority: se.get("low") + 1 });
        }
      }
      var rm = D(8733), c1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(rm.Z, c1), rm.Z.locals;
      class d1 extends K {
        static get pluginName() {
          return "HeadingUI";
        }
        init() {
          const e = this.editor, t = e.t, n = function(s) {
            const a = s.t, l = { Paragraph: a("Paragraph"), "Heading 1": a("Heading 1"), "Heading 2": a("Heading 2"), "Heading 3": a("Heading 3"), "Heading 4": a("Heading 4"), "Heading 5": a("Heading 5"), "Heading 6": a("Heading 6") };
            return s.config.get("heading.options").map((c) => {
              const d = l[c.title];
              return d && d != c.title && (c.title = d), c;
            });
          }(e), i = t("Choose heading"), r = t("Heading");
          e.ui.componentFactory.add("heading", (s) => {
            const a = {}, l = new _t(), c = e.commands.get("heading"), d = e.commands.get("paragraph"), u = [c];
            for (const p of n) {
              const b = { type: "button", model: new pa({ label: p.title, class: p.class, role: "menuitemradio", withText: !0 }) };
              p.model === "paragraph" ? (b.model.bind("isOn").to(d, "value"), b.model.set("commandName", "paragraph"), u.push(d)) : (b.model.bind("isOn").to(c, "value", (w) => w === p.model), b.model.set({ commandName: "heading", commandValue: p.model })), l.add(b), a[p.model] = p.title;
            }
            const g = Kt(s);
            return oa(g, l, { ariaLabel: r, role: "menu" }), g.buttonView.set({ ariaLabel: r, ariaLabelledBy: void 0, isOn: !1, withText: !0, tooltip: r }), g.extendTemplate({ attributes: { class: ["ck-heading-dropdown"] } }), g.bind("isEnabled").toMany(u, "isEnabled", (...p) => p.some((b) => b)), g.buttonView.bind("label").to(c, "value", d, "value", (p, b) => {
              const w = p || b && "paragraph";
              return typeof w == "boolean" ? i : a[w] ? a[w] : i;
            }), this.listenTo(g, "execute", (p) => {
              const { commandName: b, commandValue: w } = p.source;
              e.execute(b, w ? { value: w } : void 0), e.editing.view.focus();
            }), g;
          });
        }
      }
      function sm(o) {
        return o.createContainerElement("figure", { class: "image" }, [o.createEmptyElement("img"), o.createSlot("children")]);
      }
      function am(o, e) {
        const t = o.plugins.get("ImageUtils"), n = o.plugins.has("ImageInlineEditing") && o.plugins.has("ImageBlockEditing");
        return (r) => t.isInlineImageView(r) ? n && (r.getStyle("display") == "block" || r.findAncestor(t.isBlockImageView) ? "imageBlock" : "imageInline") !== e ? null : i(r) : null;
        function i(r) {
          const s = { name: !0 };
          return r.hasAttribute("src") && (s.attributes = ["src"]), s;
        }
      }
      function Da(o, e) {
        const t = Ke(e.getSelectedBlocks());
        return !t || o.isObject(t) || t.isEmpty && t.name != "listItem" ? "imageBlock" : "imageInline";
      }
      var u1 = Object.defineProperty, lm = Object.getOwnPropertySymbols, h1 = Object.prototype.hasOwnProperty, g1 = Object.prototype.propertyIsEnumerable, cm = (o, e, t) => e in o ? u1(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, dm = (o, e) => {
        for (var t in e || (e = {})) h1.call(e, t) && cm(o, t, e[t]);
        if (lm) for (var t of lm(e)) g1.call(e, t) && cm(o, t, e[t]);
        return o;
      };
      class Yt extends K {
        static get pluginName() {
          return "ImageUtils";
        }
        isImage(e) {
          return this.isInlineImage(e) || this.isBlockImage(e);
        }
        isInlineImageView(e) {
          return !!e && e.is("element", "img");
        }
        isBlockImageView(e) {
          return !!e && e.is("element", "figure") && e.hasClass("image");
        }
        insertImage(e = {}, t = null, n = null) {
          const i = this.editor, r = i.model, s = r.document.selection;
          n = um(i, t || s, n), e = dm(dm({}, Object.fromEntries(s.getAttributes())), e);
          for (const a in e) r.schema.checkAttribute(n, a) || delete e[a];
          return r.change((a) => {
            const l = a.createElement(n, e);
            return r.insertObject(l, t, null, { setSelection: "on", findOptimalPosition: t || n == "imageInline" ? void 0 : "auto" }), l.parent ? l : null;
          });
        }
        getClosestSelectedImageWidget(e) {
          const t = e.getFirstPosition();
          if (!t) return null;
          const n = e.getSelectedElement();
          if (n && this.isImageWidget(n)) return n;
          let i = t.parent;
          for (; i; ) {
            if (i.is("element") && this.isImageWidget(i)) return i;
            i = i.parent;
          }
          return null;
        }
        getClosestSelectedImageElement(e) {
          const t = e.getSelectedElement();
          return this.isImage(t) ? t : e.getFirstPosition().findAncestor("imageBlock");
        }
        isImageAllowed() {
          const e = this.editor.model.document.selection;
          return function(t, n) {
            if (um(t, n, null) == "imageBlock") {
              const r = function(s, a) {
                const l = function(d, u) {
                  const g = d.getSelectedElement();
                  if (g) {
                    const p = cn(d);
                    if (p) return u.createRange(u.createPositionAt(g, p));
                  }
                  return mh(d, u);
                }(s, a), c = l.start.parent;
                return c.isEmpty && !c.is("element", "$root") ? c.parent : c;
              }(n, t.model);
              if (t.model.schema.checkChild(r, "imageBlock")) return !0;
            } else if (t.model.schema.checkChild(n.focus, "imageInline")) return !0;
            return !1;
          }(this.editor, e) && function(t) {
            return [...t.focus.getAncestors()].every((n) => !n.is("element", "imageBlock"));
          }(e);
        }
        toImageWidget(e, t, n) {
          return t.setCustomProperty("image", !0, e), va(e, t, { label: () => {
            const i = this.findViewImgElement(e).getAttribute("alt");
            return i ? `${i} ${n}` : n;
          } });
        }
        isImageWidget(e) {
          return !!e.getCustomProperty("image") && Ne(e);
        }
        isBlockImage(e) {
          return !!e && e.is("element", "imageBlock");
        }
        isInlineImage(e) {
          return !!e && e.is("element", "imageInline");
        }
        findViewImgElement(e) {
          if (this.isInlineImageView(e)) return e;
          const t = this.editor.editing.view;
          for (const { item: n } of t.createRangeIn(e)) if (this.isInlineImageView(n)) return n;
        }
      }
      function um(o, e, t) {
        const n = o.model.schema, i = o.config.get("image.insert.type");
        return o.plugins.has("ImageBlockEditing") ? o.plugins.has("ImageInlineEditing") ? t || (i === "inline" ? "imageInline" : i === "block" ? "imageBlock" : e.is("selection") ? Da(n, e) : n.checkChild(e, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline";
      }
      class m1 extends ae {
        refresh() {
          const e = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
          this.isEnabled = !!e, this.isEnabled && e.hasAttribute("alt") ? this.value = e.getAttribute("alt") : this.value = !1;
        }
        execute(e) {
          const t = this.editor, n = t.plugins.get("ImageUtils"), i = t.model, r = n.getClosestSelectedImageElement(i.document.selection);
          i.change((s) => {
            s.setAttribute("alt", e.newValue, r);
          });
        }
      }
      class p1 extends K {
        static get requires() {
          return [Yt];
        }
        static get pluginName() {
          return "ImageTextAlternativeEditing";
        }
        init() {
          this.editor.commands.add("imageTextAlternative", new m1(this.editor));
        }
      }
      var hm = D(1905), f1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(hm.Z, f1), hm.Z.locals;
      var gm = D(6764), b1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(gm.Z, b1), gm.Z.locals;
      class k1 extends de {
        constructor(e) {
          super(e);
          const t = this.locale.t;
          this.focusTracker = new Et(), this.keystrokes = new $t(), this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(t("Save"), Pe.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(t("Cancel"), Pe.cancel, "ck-button-cancel", "cancel"), this._focusables = new wn(), this._focusCycler = new Mo({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.labeledInput, this.saveButtonView, this.cancelButtonView] });
        }
        render() {
          super.render(), this.keystrokes.listenTo(this.element), m({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((e) => {
            this._focusables.add(e), this.focusTracker.add(e.element);
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        _createButton(e, t, n, i) {
          const r = new De(this.locale);
          return r.set({ label: e, icon: t, tooltip: !0 }), r.extendTemplate({ attributes: { class: n } }), i && r.delegate("execute").to(this, i), r;
        }
        _createLabeledInputView() {
          const e = this.locale.t, t = new od(this.locale, Eh);
          return t.label = e("Text alternative"), t;
        }
      }
      function mm(o) {
        const e = o.editing.view, t = ut.defaultPositions, n = o.plugins.get("ImageUtils");
        return { target: e.domConverter.mapViewToDom(n.getClosestSelectedImageWidget(e.document.selection)), positions: [t.northArrowSouth, t.northArrowSouthWest, t.northArrowSouthEast, t.southArrowNorth, t.southArrowNorthWest, t.southArrowNorthEast, t.viewportStickyNorth] };
      }
      class w1 extends K {
        static get requires() {
          return [tr];
        }
        static get pluginName() {
          return "ImageTextAlternativeUI";
        }
        init() {
          this._createButton();
        }
        destroy() {
          super.destroy(), this._form && this._form.destroy();
        }
        _createButton() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add("imageTextAlternative", (n) => {
            const i = e.commands.get("imageTextAlternative"), r = new De(n);
            return r.set({ label: t("Change image text alternative"), icon: Pe.lowVision, tooltip: !0 }), r.bind("isEnabled").to(i, "isEnabled"), r.bind("isOn").to(i, "value", (s) => !!s), this.listenTo(r, "execute", () => {
              this._showForm();
            }), r;
          });
        }
        _createForm() {
          const e = this.editor, t = e.editing.view.document, n = e.plugins.get("ImageUtils");
          this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (S(k1))(e.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
            e.execute("imageTextAlternative", { newValue: this._form.labeledInput.fieldView.element.value }), this._hideForm(!0);
          }), this.listenTo(this._form, "cancel", () => {
            this._hideForm(!0);
          }), this._form.keystrokes.set("Esc", (i, r) => {
            this._hideForm(!0), r();
          }), this.listenTo(e.ui, "update", () => {
            n.getClosestSelectedImageWidget(t.selection) ? this._isVisible && function(i) {
              const r = i.plugins.get("ContextualBalloon");
              if (i.plugins.get("ImageUtils").getClosestSelectedImageWidget(i.editing.view.document.selection)) {
                const s = mm(i);
                r.updatePosition(s);
              }
            }(e) : this._hideForm(!0);
          }), k({ emitter: this._form, activator: () => this._isVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideForm() });
        }
        _showForm() {
          if (this._isVisible) return;
          this._form || this._createForm();
          const e = this.editor, t = e.commands.get("imageTextAlternative"), n = this._form.labeledInput;
          this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({ view: this._form, position: mm(e) }), n.fieldView.value = n.fieldView.element.value = t.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
        }
        _hideForm(e = !1) {
          this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), e && this.editor.editing.view.focus());
        }
        get _isVisible() {
          return !!this._balloon && this._balloon.visibleView === this._form;
        }
        get _isInBalloon() {
          return !!this._balloon && this._balloon.hasView(this._form);
        }
      }
      class pm extends K {
        static get requires() {
          return [p1, w1];
        }
        static get pluginName() {
          return "ImageTextAlternative";
        }
      }
      function fm(o, e) {
        const t = (n, i, r) => {
          if (!r.consumable.consume(i.item, n.name)) return;
          const s = r.writer, a = r.mapper.toViewElement(i.item), l = o.findViewImgElement(a);
          if (i.attributeNewValue === null) {
            const c = i.attributeOldValue;
            c && c.data && (s.removeAttribute("srcset", l), s.removeAttribute("sizes", l), c.width && s.removeAttribute("width", l));
          } else {
            const c = i.attributeNewValue;
            c && c.data && (s.setAttribute("srcset", c.data, l), s.setAttribute("sizes", "100vw", l), c.width && s.setAttribute("width", c.width, l));
          }
        };
        return (n) => {
          n.on(`attribute:srcset:${e}`, t);
        };
      }
      function cr(o, e, t) {
        const n = (i, r, s) => {
          if (!s.consumable.consume(r.item, i.name)) return;
          const a = s.writer, l = s.mapper.toViewElement(r.item), c = o.findViewImgElement(l);
          a.setAttribute(r.attributeKey, r.attributeNewValue || "", c);
        };
        return (i) => {
          i.on(`attribute:${t}:${e}`, n);
        };
      }
      class A1 extends Mt {
        observe(e) {
          this.listenTo(e, "load", (t, n) => {
            const i = n.target;
            this.checkShouldIgnoreEventFromTarget(i) || i.tagName == "IMG" && this._fireEvents(n);
          }, { useCapture: !0 });
        }
        stopObserving(e) {
          this.stopListening(e);
        }
        _fireEvents(e) {
          this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", e));
        }
      }
      var _1 = Object.defineProperty, bm = Object.getOwnPropertySymbols, v1 = Object.prototype.hasOwnProperty, C1 = Object.prototype.propertyIsEnumerable, km = (o, e, t) => e in o ? _1(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, dr = (o, e) => {
        for (var t in e || (e = {})) v1.call(e, t) && km(o, t, e[t]);
        if (bm) for (var t of bm(e)) C1.call(e, t) && km(o, t, e[t]);
        return o;
      };
      class y1 extends ae {
        constructor(e) {
          super(e);
          const t = e.config.get("image.insert.type");
          e.plugins.has("ImageBlockEditing") || t === "block" && ee("image-block-plugin-required"), e.plugins.has("ImageInlineEditing") || t === "inline" && ee("image-inline-plugin-required");
        }
        refresh() {
          const e = this.editor.plugins.get("ImageUtils");
          this.isEnabled = e.isImageAllowed();
        }
        execute(e) {
          const t = $e(e.source), n = this.editor.model.document.selection, i = this.editor.plugins.get("ImageUtils"), r = Object.fromEntries(n.getAttributes());
          t.forEach((s, a) => {
            const l = n.getSelectedElement();
            if (typeof s == "string" && (s = { src: s }), a && l && i.isImage(l)) {
              const c = this.editor.model.createPositionAfter(l);
              i.insertImage(dr(dr({}, s), r), c);
            } else i.insertImage(dr(dr({}, s), r));
          });
        }
      }
      class E1 extends ae {
        refresh() {
          const e = this.editor.plugins.get("ImageUtils"), t = this.editor.model.document.selection.getSelectedElement();
          this.isEnabled = e.isImage(t), this.value = this.isEnabled ? t.getAttribute("src") : null;
        }
        execute(e) {
          const t = this.editor.model.document.selection.getSelectedElement();
          this.editor.model.change((n) => {
            n.setAttribute("src", e.source, t), n.removeAttribute("srcset", t), n.removeAttribute("sizes", t);
          });
        }
      }
      class wm extends K {
        static get requires() {
          return [Yt];
        }
        static get pluginName() {
          return "ImageEditing";
        }
        init() {
          const e = this.editor, t = e.conversion;
          e.editing.view.addObserver(A1), t.for("upcast").attributeToAttribute({ view: { name: "img", key: "alt" }, model: "alt" }).attributeToAttribute({ view: { name: "img", key: "srcset" }, model: { key: "srcset", value: (r) => {
            const s = { data: r.getAttribute("srcset") };
            return r.hasAttribute("width") && (s.width = r.getAttribute("width")), s;
          } } });
          const n = new y1(e), i = new E1(e);
          e.commands.add("insertImage", n), e.commands.add("replaceImageSource", i), e.commands.add("imageInsert", n);
        }
      }
      class Am extends ae {
        constructor(e, t) {
          super(e), this._modelElementName = t;
        }
        refresh() {
          const e = this.editor.plugins.get("ImageUtils"), t = e.getClosestSelectedImageElement(this.editor.model.document.selection);
          this._modelElementName === "imageBlock" ? this.isEnabled = e.isInlineImage(t) : this.isEnabled = e.isBlockImage(t);
        }
        execute() {
          const e = this.editor, t = this.editor.model, n = e.plugins.get("ImageUtils"), i = n.getClosestSelectedImageElement(t.document.selection), r = Object.fromEntries(i.getAttributes());
          return r.src || r.uploadId ? t.change((s) => {
            const a = Array.from(t.markers).filter((d) => d.getRange().containsItem(i)), l = n.insertImage(r, t.createSelection(i, "on"), this._modelElementName);
            if (!l) return null;
            const c = s.createRangeOn(l);
            for (const d of a) {
              const u = d.getRange(), g = u.root.rootName != "$graveyard" ? u.getJoined(c, !0) : c;
              s.updateMarker(d, { range: g });
            }
            return { oldElement: i, newElement: l };
          }) : null;
        }
      }
      class x1 extends K {
        static get requires() {
          return [wm, Yt, Gt];
        }
        static get pluginName() {
          return "ImageBlockEditing";
        }
        init() {
          const e = this.editor;
          e.model.schema.register("imageBlock", { inheritAllFrom: "$blockObject", allowAttributes: ["alt", "src", "srcset"] }), this._setupConversion(), e.plugins.has("ImageInlineEditing") && (e.commands.add("imageTypeBlock", new Am(this.editor, "imageBlock")), this._setupClipboardIntegration());
        }
        _setupConversion() {
          const e = this.editor, t = e.t, n = e.conversion, i = e.plugins.get("ImageUtils");
          n.for("dataDowncast").elementToStructure({ model: "imageBlock", view: (r, { writer: s }) => sm(s) }), n.for("editingDowncast").elementToStructure({ model: "imageBlock", view: (r, { writer: s }) => i.toImageWidget(sm(s), s, t("image widget")) }), n.for("downcast").add(cr(i, "imageBlock", "src")).add(cr(i, "imageBlock", "alt")).add(fm(i, "imageBlock")), n.for("upcast").elementToElement({ view: am(e, "imageBlock"), model: (r, { writer: s }) => s.createElement("imageBlock", r.hasAttribute("src") ? { src: r.getAttribute("src") } : void 0) }).add(/* @__PURE__ */ function(r) {
            const s = (a, l, c) => {
              if (!c.consumable.test(l.viewItem, { name: !0, classes: "image" })) return;
              const d = r.findViewImgElement(l.viewItem);
              if (!d || !c.consumable.test(d, { name: !0 })) return;
              c.consumable.consume(l.viewItem, { name: !0, classes: "image" });
              const u = Ke(c.convertItem(d, l.modelCursor).modelRange.getItems());
              u ? (c.convertChildren(l.viewItem, u), c.updateConversionResult(u, l)) : c.consumable.revert(l.viewItem, { name: !0, classes: "image" });
            };
            return (a) => {
              a.on("element:figure", s);
            };
          }(i));
        }
        _setupClipboardIntegration() {
          const e = this.editor, t = e.model, n = e.editing.view, i = e.plugins.get("ImageUtils"), r = e.plugins.get("ClipboardPipeline");
          this.listenTo(r, "inputTransformation", (s, a) => {
            const l = Array.from(a.content.getChildren());
            let c;
            if (!l.every(i.isInlineImageView)) return;
            c = a.targetRanges ? e.editing.mapper.toModelRange(a.targetRanges[0]) : t.document.selection.getFirstRange();
            const d = t.createSelection(c);
            if (Da(t.schema, d) === "imageBlock") {
              const u = new Wi(n.document), g = l.map((p) => u.createElement("figure", { class: "image" }, p));
              a.content = u.createDocumentFragment(g);
            }
          });
        }
      }
      var _m = D(3508), S1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(_m.Z, S1), _m.Z.locals;
      class D1 extends K {
        static get requires() {
          return [x1, ti, pm];
        }
        static get pluginName() {
          return "ImageBlock";
        }
      }
      class B1 extends K {
        static get requires() {
          return [wm, Yt, Gt];
        }
        static get pluginName() {
          return "ImageInlineEditing";
        }
        init() {
          const e = this.editor, t = e.model.schema;
          t.register("imageInline", { inheritAllFrom: "$inlineObject", allowAttributes: ["alt", "src", "srcset"] }), t.addChildCheck((n, i) => {
            if (n.endsWith("caption") && i.name === "imageInline") return !1;
          }), this._setupConversion(), e.plugins.has("ImageBlockEditing") && (e.commands.add("imageTypeInline", new Am(this.editor, "imageInline")), this._setupClipboardIntegration());
        }
        _setupConversion() {
          const e = this.editor, t = e.t, n = e.conversion, i = e.plugins.get("ImageUtils");
          n.for("dataDowncast").elementToElement({ model: "imageInline", view: (r, { writer: s }) => s.createEmptyElement("img") }), n.for("editingDowncast").elementToStructure({ model: "imageInline", view: (r, { writer: s }) => i.toImageWidget(function(a) {
            return a.createContainerElement("span", { class: "image-inline" }, a.createEmptyElement("img"));
          }(s), s, t("image widget")) }), n.for("downcast").add(cr(i, "imageInline", "src")).add(cr(i, "imageInline", "alt")).add(fm(i, "imageInline")), n.for("upcast").elementToElement({ view: am(e, "imageInline"), model: (r, { writer: s }) => s.createElement("imageInline", r.hasAttribute("src") ? { src: r.getAttribute("src") } : void 0) });
        }
        _setupClipboardIntegration() {
          const e = this.editor, t = e.model, n = e.editing.view, i = e.plugins.get("ImageUtils"), r = e.plugins.get("ClipboardPipeline");
          this.listenTo(r, "inputTransformation", (s, a) => {
            const l = Array.from(a.content.getChildren());
            let c;
            if (!l.every(i.isBlockImageView)) return;
            c = a.targetRanges ? e.editing.mapper.toModelRange(a.targetRanges[0]) : t.document.selection.getFirstRange();
            const d = t.createSelection(c);
            if (Da(t.schema, d) === "imageInline") {
              const u = new Wi(n.document), g = l.map((p) => p.childCount === 1 ? (Array.from(p.getAttributes()).forEach((b) => u.setAttribute(...b, i.findViewImgElement(p))), p.getChild(0)) : p);
              a.content = u.createDocumentFragment(g);
            }
          });
        }
      }
      class T1 extends K {
        static get requires() {
          return [B1, ti, pm];
        }
        static get pluginName() {
          return "ImageInline";
        }
      }
      var vm = D(2640), I1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(vm.Z, I1), vm.Z.locals;
      function Cm(o) {
        const e = o.map((t) => t.replace("+", "\\+"));
        return new RegExp(`^image\\/(${e.join("|")})$`);
      }
      function P1(o) {
        return new Promise((e, t) => {
          const n = o.getAttribute("src");
          fetch(n).then((i) => i.blob()).then((i) => {
            const r = ym(i, n), s = r.replace("image/", ""), a = new File([i], `image.${s}`, { type: r });
            e(a);
          }).catch((i) => i && i.name === "TypeError" ? function(r) {
            return function(s) {
              return new Promise((a, l) => {
                const c = le.document.createElement("img");
                c.addEventListener("load", () => {
                  const d = le.document.createElement("canvas");
                  d.width = c.width, d.height = c.height, d.getContext("2d").drawImage(c, 0, 0), d.toBlob((u) => u ? a(u) : l());
                }), c.addEventListener("error", () => l()), c.src = s;
              });
            }(r).then((s) => {
              const a = ym(s, r), l = a.replace("image/", "");
              return new File([s], `image.${l}`, { type: a });
            });
          }(n).then(e).catch(t) : t(i));
        });
      }
      function ym(o, e) {
        return o.type ? o.type : e.match(/data:(image\/\w+);base64/) ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg";
      }
      class R1 extends K {
        static get pluginName() {
          return "ImageUploadUI";
        }
        init() {
          const e = this.editor, t = e.t, n = (i) => {
            const r = new $C(i), s = e.commands.get("uploadImage"), a = e.config.get("image.upload.types"), l = Cm(a);
            return r.set({ acceptedType: a.map((c) => `image/${c}`).join(","), allowMultipleFiles: !0 }), r.buttonView.set({ label: t("Insert image"), icon: Pe.image, tooltip: !0 }), r.buttonView.bind("isEnabled").to(s), r.on("done", (c, d) => {
              const u = Array.from(d).filter((g) => l.test(g.type));
              u.length && (e.execute("uploadImage", { file: u }), e.editing.view.focus());
            }), r;
          };
          e.ui.componentFactory.add("uploadImage", n), e.ui.componentFactory.add("imageUpload", n);
        }
      }
      var Em = D(3689), O1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Em.Z, O1), Em.Z.locals;
      var xm = D(4036), z1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(xm.Z, z1), xm.Z.locals;
      var Sm = D(3773), M1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Sm.Z, M1), Sm.Z.locals;
      class F1 extends K {
        constructor(e) {
          super(e), this.uploadStatusChange = (t, n, i) => {
            const r = this.editor, s = n.item, a = s.getAttribute("uploadId");
            if (!i.consumable.consume(n.item, t.name)) return;
            const l = r.plugins.get("ImageUtils"), c = r.plugins.get(Jt), d = a ? n.attributeNewValue : null, u = this.placeholder, g = r.editing.mapper.toViewElement(s), p = i.writer;
            if (d == "reading") return Dm(g, p), void Bm(l, u, g, p);
            if (d == "uploading") {
              const b = c.loaders.get(a);
              return Dm(g, p), void (b ? (Tm(g, p), function(w, y, I, z) {
                const H = function(X) {
                  const ce = X.createUIElement("div", { class: "ck-progress-bar" });
                  return X.setCustomProperty("progressBar", !0, ce), ce;
                }(y);
                y.insert(y.createPositionAt(w, "end"), H), I.on("change:uploadedPercent", (X, ce, Oe) => {
                  z.change((be) => {
                    be.setStyle("width", Oe + "%", H);
                  });
                });
              }(g, p, b, r.editing.view), function(w, y, I, z) {
                if (z.data) {
                  const H = w.findViewImgElement(y);
                  I.setAttribute("src", z.data, H);
                }
              }(l, g, p, b)) : Bm(l, u, g, p));
            }
            d == "complete" && c.loaders.get(a) && function(b, w, y) {
              const I = w.createUIElement("div", { class: "ck-image-upload-complete-icon" });
              w.insert(w.createPositionAt(b, "end"), I), setTimeout(() => {
                y.change((z) => z.remove(z.createRangeOn(I)));
              }, 3e3);
            }(g, p, r.editing.view), function(b, w) {
              Pm(b, w, "progressBar");
            }(g, p), Tm(g, p), function(b, w) {
              w.removeClass("ck-appear", b);
            }(g, p);
          }, this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        }
        static get pluginName() {
          return "ImageUploadProgress";
        }
        init() {
          const e = this.editor;
          e.plugins.has("ImageBlockEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange), e.plugins.has("ImageInlineEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange);
        }
      }
      function Dm(o, e) {
        o.hasClass("ck-appear") || e.addClass("ck-appear", o);
      }
      function Bm(o, e, t, n) {
        t.hasClass("ck-image-upload-placeholder") || n.addClass("ck-image-upload-placeholder", t);
        const i = o.findViewImgElement(t);
        i.getAttribute("src") !== e && n.setAttribute("src", e, i), Im(t, "placeholder") || n.insert(n.createPositionAfter(i), function(r) {
          const s = r.createUIElement("div", { class: "ck-upload-placeholder-loader" });
          return r.setCustomProperty("placeholder", !0, s), s;
        }(n));
      }
      function Tm(o, e) {
        o.hasClass("ck-image-upload-placeholder") && e.removeClass("ck-image-upload-placeholder", o), Pm(o, e, "placeholder");
      }
      function Im(o, e) {
        for (const t of o.getChildren()) if (t.getCustomProperty(e)) return t;
      }
      function Pm(o, e, t) {
        const n = Im(o, t);
        n && e.remove(e.createRangeOn(n));
      }
      var N1 = Object.defineProperty, V1 = Object.defineProperties, L1 = Object.getOwnPropertyDescriptors, Rm = Object.getOwnPropertySymbols, j1 = Object.prototype.hasOwnProperty, $1 = Object.prototype.propertyIsEnumerable, Om = (o, e, t) => e in o ? N1(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
      class H1 extends ae {
        refresh() {
          const e = this.editor, t = e.plugins.get("ImageUtils"), n = e.model.document.selection.getSelectedElement();
          this.isEnabled = t.isImageAllowed() || t.isImage(n);
        }
        execute(e) {
          const t = $e(e.file), n = this.editor.model.document.selection, i = this.editor.plugins.get("ImageUtils"), r = Object.fromEntries(n.getAttributes());
          t.forEach((s, a) => {
            const l = n.getSelectedElement();
            if (a && l && i.isImage(l)) {
              const c = this.editor.model.createPositionAfter(l);
              this._uploadImage(s, r, c);
            } else this._uploadImage(s, r);
          });
        }
        _uploadImage(e, t, n) {
          const i = this.editor, r = i.plugins.get(Jt).createLoader(e), s = i.plugins.get("ImageUtils");
          var a, l;
          r && s.insertImage((a = ((c, d) => {
            for (var u in d || (d = {})) j1.call(d, u) && Om(c, u, d[u]);
            if (Rm) for (var u of Rm(d)) $1.call(d, u) && Om(c, u, d[u]);
            return c;
          })({}, t), l = { uploadId: r.id }, V1(a, L1(l))), n);
        }
      }
      class q1 extends K {
        constructor(e) {
          super(e), e.config.define("image", { upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] } }), this._uploadImageElements = /* @__PURE__ */ new Map();
        }
        static get requires() {
          return [Jt, Yh, Gt, Yt];
        }
        static get pluginName() {
          return "ImageUploadEditing";
        }
        init() {
          const e = this.editor, t = e.model.document, n = e.conversion, i = e.plugins.get(Jt), r = e.plugins.get("ImageUtils"), s = e.plugins.get("ClipboardPipeline"), a = Cm(e.config.get("image.upload.types")), l = new H1(e);
          e.commands.add("uploadImage", l), e.commands.add("imageUpload", l), n.for("upcast").attributeToAttribute({ view: { name: "img", key: "uploadId" }, model: "uploadId" }), this.listenTo(e.editing.view.document, "clipboardInput", (c, d) => {
            if (u = d.dataTransfer, Array.from(u.types).includes("text/html") && u.getData("text/html") !== "") return;
            var u;
            const g = Array.from(d.dataTransfer.files).filter((p) => !!p && a.test(p.type));
            g.length && (c.stop(), e.model.change((p) => {
              d.targetRanges && p.setSelection(d.targetRanges.map((b) => e.editing.mapper.toModelRange(b))), e.model.enqueueChange(() => {
                e.execute("uploadImage", { file: g });
              });
            }));
          }), this.listenTo(s, "inputTransformation", (c, d) => {
            const u = Array.from(e.editing.view.createRangeIn(d.content)).map((p) => p.item).filter((p) => function(b, w) {
              return !(!b.isInlineImageView(w) || !w.getAttribute("src") || !w.getAttribute("src").match(/^data:image\/\w+;base64,/g) && !w.getAttribute("src").match(/^blob:/g));
            }(r, p) && !p.getAttribute("uploadProcessed")).map((p) => ({ promise: P1(p), imageElement: p }));
            if (!u.length) return;
            const g = new Wi(e.editing.view.document);
            for (const p of u) {
              g.setAttribute("uploadProcessed", !0, p.imageElement);
              const b = i.createLoader(p.promise);
              b && (g.setAttribute("src", "", p.imageElement), g.setAttribute("uploadId", b.id, p.imageElement));
            }
          }), e.editing.view.document.on("dragover", (c, d) => {
            d.preventDefault();
          }), t.on("change", () => {
            const c = t.differ.getChanges({ includeChangesInGraveyard: !0 }).reverse(), d = /* @__PURE__ */ new Set();
            for (const u of c) if (u.type == "insert" && u.name != "$text") {
              const g = u.position.nodeAfter, p = u.position.root.rootName == "$graveyard";
              for (const b of U1(e, g)) {
                const w = b.getAttribute("uploadId");
                if (!w) continue;
                const y = i.loaders.get(w);
                y && (p ? d.has(w) || y.abort() : (d.add(w), this._uploadImageElements.set(w, b), y.status == "idle" && this._readAndUpload(y)));
              }
            }
          }), this.on("uploadComplete", (c, { imageElement: d, data: u }) => {
            const g = u.urls ? u.urls : u;
            this.editor.model.change((p) => {
              p.setAttribute("src", g.default, d), this._parseAndSetSrcsetAttributeOnImage(g, d, p);
            });
          }, { priority: "low" });
        }
        afterInit() {
          const e = this.editor.model.schema;
          this.editor.plugins.has("ImageBlockEditing") && e.extend("imageBlock", { allowAttributes: ["uploadId", "uploadStatus"] }), this.editor.plugins.has("ImageInlineEditing") && e.extend("imageInline", { allowAttributes: ["uploadId", "uploadStatus"] });
        }
        _readAndUpload(e) {
          const t = this.editor, n = t.model, i = t.locale.t, r = t.plugins.get(Jt), s = t.plugins.get(Yh), a = t.plugins.get("ImageUtils"), l = this._uploadImageElements;
          return n.enqueueChange({ isUndoable: !1 }, (d) => {
            d.setAttribute("uploadStatus", "reading", l.get(e.id));
          }), e.read().then(() => {
            const d = e.upload(), u = l.get(e.id);
            if (f.isSafari) {
              const g = t.editing.mapper.toViewElement(u), p = a.findViewImgElement(g);
              t.editing.view.once("render", () => {
                if (!p.parent) return;
                const b = t.editing.view.domConverter.mapViewToDom(p.parent);
                if (!b) return;
                const w = b.style.display;
                b.style.display = "none", b._ckHack = b.offsetHeight, b.style.display = w;
              });
            }
            return n.enqueueChange({ isUndoable: !1 }, (g) => {
              g.setAttribute("uploadStatus", "uploading", u);
            }), d;
          }).then((d) => {
            n.enqueueChange({ isUndoable: !1 }, (u) => {
              const g = l.get(e.id);
              u.setAttribute("uploadStatus", "complete", g), this.fire("uploadComplete", { data: d, imageElement: g });
            }), c();
          }).catch((d) => {
            if (e.status !== "error" && e.status !== "aborted") throw d;
            e.status == "error" && d && s.showWarning(d, { title: i("Upload failed"), namespace: "upload" }), n.enqueueChange({ isUndoable: !1 }, (u) => {
              u.remove(l.get(e.id));
            }), c();
          });
          function c() {
            n.enqueueChange({ isUndoable: !1 }, (d) => {
              const u = l.get(e.id);
              d.removeAttribute("uploadId", u), d.removeAttribute("uploadStatus", u), l.delete(e.id);
            }), r.destroyLoader(e);
          }
        }
        _parseAndSetSrcsetAttributeOnImage(e, t, n) {
          let i = 0;
          const r = Object.keys(e).filter((s) => {
            const a = parseInt(s, 10);
            if (!isNaN(a)) return i = Math.max(i, a), !0;
          }).map((s) => `${e[s]} ${s}w`).join(", ");
          r != "" && n.setAttribute("srcset", { data: r, width: i }, t);
        }
      }
      function U1(o, e) {
        const t = o.plugins.get("ImageUtils");
        return Array.from(o.model.createRangeOn(e)).filter((n) => t.isImage(n.item)).map((n) => n.item);
      }
      var zm = D(1568), W1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(zm.Z, W1), zm.Z.locals;
      var Mm = D(3535), K1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Mm.Z, K1), Mm.Z.locals;
      class G1 extends ae {
        refresh() {
          const e = this.editor, t = e.plugins.get("ImageUtils").getClosestSelectedImageElement(e.model.document.selection);
          this.isEnabled = !!t, t && t.hasAttribute("width") ? this.value = { width: t.getAttribute("width"), height: null } : this.value = null;
        }
        execute(e) {
          const t = this.editor, n = t.model, i = t.plugins.get("ImageUtils").getClosestSelectedImageElement(n.document.selection);
          this.value = { width: e.width, height: null }, i && n.change((r) => {
            r.setAttribute("width", e.width, i);
          });
        }
      }
      class Z1 extends K {
        static get requires() {
          return [Yt];
        }
        static get pluginName() {
          return "ImageResizeEditing";
        }
        constructor(e) {
          super(e), e.config.define("image", { resizeUnit: "%", resizeOptions: [{ name: "resizeImage:original", value: null, icon: "original" }, { name: "resizeImage:25", value: "25", icon: "small" }, { name: "resizeImage:50", value: "50", icon: "medium" }, { name: "resizeImage:75", value: "75", icon: "large" }] });
        }
        init() {
          const e = this.editor, t = new G1(e);
          this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline"), e.commands.add("resizeImage", t), e.commands.add("imageResize", t);
        }
        _registerSchema() {
          this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: "width" }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: "width" });
        }
        _registerConverters(e) {
          const t = this.editor;
          t.conversion.for("downcast").add((n) => n.on(`attribute:width:${e}`, (i, r, s) => {
            if (!s.consumable.consume(r.item, i.name)) return;
            const a = s.writer, l = s.mapper.toViewElement(r.item);
            r.attributeNewValue !== null ? (a.setStyle("width", r.attributeNewValue, l), a.addClass("image_resized", l)) : (a.removeStyle("width", l), a.removeClass("image_resized", l));
          })), t.conversion.for("upcast").attributeToAttribute({ view: { name: e === "imageBlock" ? "figure" : "img", styles: { width: /.+/ } }, model: { key: "width", value: (n) => n.getStyle("width") } });
        }
      }
      const Ba = { small: Pe.objectSizeSmall, medium: Pe.objectSizeMedium, large: Pe.objectSizeLarge, original: Pe.objectSizeFull };
      function Fm(o) {
        return (e) => o === null && e === o || e !== null && e.width === o;
      }
      var Nm = D(6270), J1 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Nm.Z, J1), Nm.Z.locals;
      class Y1 extends ae {
        constructor(e, t) {
          super(e), this._defaultStyles = { imageBlock: !1, imageInline: !1 }, this._styles = new Map(t.map((n) => {
            if (n.isDefault) for (const i of n.modelElements) this._defaultStyles[i] = n.name;
            return [n.name, n];
          }));
        }
        refresh() {
          const e = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
          this.isEnabled = !!e, this.isEnabled ? e.hasAttribute("imageStyle") ? this.value = e.getAttribute("imageStyle") : this.value = this._defaultStyles[e.name] : this.value = !1;
        }
        execute(e = {}) {
          const t = this.editor, n = t.model, i = t.plugins.get("ImageUtils");
          n.change((r) => {
            const s = e.value;
            let a = i.getClosestSelectedImageElement(n.document.selection);
            s && this.shouldConvertImageType(s, a) && (this.editor.execute(i.isBlockImage(a) ? "imageTypeInline" : "imageTypeBlock"), a = i.getClosestSelectedImageElement(n.document.selection)), !s || this._styles.get(s).isDefault ? r.removeAttribute("imageStyle", a) : r.setAttribute("imageStyle", s, a);
          });
        }
        shouldConvertImageType(e, t) {
          return !this._styles.get(e).modelElements.includes(t.name);
        }
      }
      var Q1 = Object.defineProperty, Vm = Object.getOwnPropertySymbols, X1 = Object.prototype.hasOwnProperty, ey = Object.prototype.propertyIsEnumerable, Lm = (o, e, t) => e in o ? Q1(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, jm = (o, e) => {
        for (var t in e || (e = {})) X1.call(e, t) && Lm(o, t, e[t]);
        if (Vm) for (var t of Vm(e)) ey.call(e, t) && Lm(o, t, e[t]);
        return o;
      };
      const { objectFullWidth: ty, objectInline: $m, objectLeft: Hm, objectRight: Ta, objectCenter: Ia, objectBlockLeft: qm, objectBlockRight: Um } = Pe, ur = { get inline() {
        return { name: "inline", title: "In line", icon: $m, modelElements: ["imageInline"], isDefault: !0 };
      }, get alignLeft() {
        return { name: "alignLeft", title: "Left aligned image", icon: Hm, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-left" };
      }, get alignBlockLeft() {
        return { name: "alignBlockLeft", title: "Left aligned image", icon: qm, modelElements: ["imageBlock"], className: "image-style-block-align-left" };
      }, get alignCenter() {
        return { name: "alignCenter", title: "Centered image", icon: Ia, modelElements: ["imageBlock"], className: "image-style-align-center" };
      }, get alignRight() {
        return { name: "alignRight", title: "Right aligned image", icon: Ta, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-right" };
      }, get alignBlockRight() {
        return { name: "alignBlockRight", title: "Right aligned image", icon: Um, modelElements: ["imageBlock"], className: "image-style-block-align-right" };
      }, get block() {
        return { name: "block", title: "Centered image", icon: Ia, modelElements: ["imageBlock"], isDefault: !0 };
      }, get side() {
        return { name: "side", title: "Side image", icon: Ta, modelElements: ["imageBlock"], className: "image-style-side" };
      } }, Wm = { full: ty, left: qm, right: Um, center: Ia, inlineLeft: Hm, inlineRight: Ta, inline: $m }, Km = [{ name: "imageStyle:wrapText", title: "Wrap text", defaultItem: "imageStyle:alignLeft", items: ["imageStyle:alignLeft", "imageStyle:alignRight"] }, { name: "imageStyle:breakText", title: "Break text", defaultItem: "imageStyle:block", items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"] }];
      function Gm(o) {
        ee("image-style-configuration-definition-invalid", o);
      }
      const Pa = { normalizeStyles: function(o) {
        return (o.configuredStyles.options || []).map((e) => function(t) {
          return t = typeof t == "string" ? ur[t] ? jm({}, ur[t]) : { name: t } : function(n, i) {
            const r = jm({}, i);
            for (const s in n) Object.prototype.hasOwnProperty.call(i, s) || (r[s] = n[s]);
            return r;
          }(ur[t.name], t), typeof t.icon == "string" && (t.icon = Wm[t.icon] || t.icon), t;
        }(e)).filter((e) => function(t, { isBlockPluginLoaded: n, isInlinePluginLoaded: i }) {
          const { modelElements: r, name: s } = t;
          if (!(r && r.length && s)) return Gm({ style: t }), !1;
          {
            const a = [n ? "imageBlock" : null, i ? "imageInline" : null];
            if (!r.some((l) => a.includes(l))) return ee("image-style-missing-dependency", { style: t, missingPlugins: r.map((l) => l === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing") }), !1;
          }
          return !0;
        }(e, o));
      }, getDefaultStylesConfiguration: function(o, e) {
        return o && e ? { options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"] } : o ? { options: ["block", "side"] } : e ? { options: ["inline", "alignLeft", "alignRight"] } : {};
      }, getDefaultDropdownDefinitions: function(o) {
        return o.has("ImageBlockEditing") && o.has("ImageInlineEditing") ? [...Km] : [];
      }, warnInvalidStyle: Gm, DEFAULT_OPTIONS: ur, DEFAULT_ICONS: Wm, DEFAULT_DROPDOWN_DEFINITIONS: Km };
      function Zm(o, e) {
        for (const t of e) if (t.name === o) return t;
      }
      class Jm extends K {
        static get pluginName() {
          return "ImageStyleEditing";
        }
        static get requires() {
          return [Yt];
        }
        init() {
          const { normalizeStyles: e, getDefaultStylesConfiguration: t } = Pa, n = this.editor, i = n.plugins.has("ImageBlockEditing"), r = n.plugins.has("ImageInlineEditing");
          n.config.define("image.styles", t(i, r)), this.normalizedStyles = e({ configuredStyles: n.config.get("image.styles"), isBlockPluginLoaded: i, isInlinePluginLoaded: r }), this._setupConversion(i, r), this._setupPostFixer(), n.commands.add("imageStyle", new Y1(n, this.normalizedStyles));
        }
        _setupConversion(e, t) {
          const n = this.editor, i = n.model.schema, r = (s = this.normalizedStyles, (l, c, d) => {
            if (!d.consumable.consume(c.item, l.name)) return;
            const u = Zm(c.attributeNewValue, s), g = Zm(c.attributeOldValue, s), p = d.mapper.toViewElement(c.item), b = d.writer;
            g && b.removeClass(g.className, p), u && b.addClass(u.className, p);
          });
          var s;
          const a = function(l) {
            const c = { imageInline: l.filter((d) => !d.isDefault && d.modelElements.includes("imageInline")), imageBlock: l.filter((d) => !d.isDefault && d.modelElements.includes("imageBlock")) };
            return (d, u, g) => {
              if (!u.modelRange) return;
              const p = u.viewItem, b = Ke(u.modelRange.getItems());
              if (b && g.schema.checkAttribute(b, "imageStyle")) for (const w of c[b.name]) g.consumable.consume(p, { classes: w.className }) && g.writer.setAttribute("imageStyle", w.name, b);
            };
          }(this.normalizedStyles);
          n.editing.downcastDispatcher.on("attribute:imageStyle", r), n.data.downcastDispatcher.on("attribute:imageStyle", r), e && (i.extend("imageBlock", { allowAttributes: "imageStyle" }), n.data.upcastDispatcher.on("element:figure", a, { priority: "low" })), t && (i.extend("imageInline", { allowAttributes: "imageStyle" }), n.data.upcastDispatcher.on("element:img", a, { priority: "low" }));
        }
        _setupPostFixer() {
          const e = this.editor, t = e.model.document, n = e.plugins.get(Yt), i = new Map(this.normalizedStyles.map((r) => [r.name, r]));
          t.registerPostFixer((r) => {
            let s = !1;
            for (const a of t.differ.getChanges()) if (a.type == "insert" || a.type == "attribute" && a.attributeKey == "imageStyle") {
              let l = a.type == "insert" ? a.position.nodeAfter : a.range.start.nodeAfter;
              if (l && l.is("element", "paragraph") && l.childCount > 0 && (l = l.getChild(0)), !n.isImage(l)) continue;
              const c = l.getAttribute("imageStyle");
              if (!c) continue;
              const d = i.get(c);
              d && d.modelElements.includes(l.name) || (r.removeAttribute("imageStyle", l), s = !0);
            }
            return s;
          });
        }
      }
      var Ym = D(5083), ny = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Ym.Z, ny), Ym.Z.locals;
      class oy extends K {
        static get requires() {
          return [Jm];
        }
        static get pluginName() {
          return "ImageStyleUI";
        }
        get localizedDefaultStylesTitles() {
          const e = this.editor.t;
          return { "Wrap text": e("Wrap text"), "Break text": e("Break text"), "In line": e("In line"), "Full size image": e("Full size image"), "Side image": e("Side image"), "Left aligned image": e("Left aligned image"), "Centered image": e("Centered image"), "Right aligned image": e("Right aligned image") };
        }
        init() {
          const e = this.editor.plugins, t = this.editor.config.get("image.toolbar") || [], n = Qm(e.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
          for (const r of n) this._createButton(r);
          const i = Qm([...t.filter(ze), ...Pa.getDefaultDropdownDefinitions(e)], this.localizedDefaultStylesTitles);
          for (const r of i) this._createDropdown(r, n);
        }
        _createDropdown(e, t) {
          const n = this.editor.ui.componentFactory;
          n.add(e.name, (i) => {
            let r;
            const { defaultItem: s, items: a, title: l } = e, c = a.filter((p) => t.find(({ name: b }) => Xm(b) === p)).map((p) => {
              const b = n.create(p);
              return p === s && (r = b), b;
            });
            a.length !== c.length && Pa.warnInvalidStyle({ dropdown: e });
            const d = Kt(i, na), u = d.buttonView, g = u.arrowView;
            return Zi(d, c, { enableActiveItemFocusOnDropdownOpen: !0 }), u.set({ label: ep(l, r.label), class: null, tooltip: !0 }), g.unbind("label"), g.set({ label: l }), u.bind("icon").toMany(c, "isOn", (...p) => {
              const b = p.findIndex(vn);
              return b < 0 ? r.icon : c[b].icon;
            }), u.bind("label").toMany(c, "isOn", (...p) => {
              const b = p.findIndex(vn);
              return ep(l, b < 0 ? r.label : c[b].label);
            }), u.bind("isOn").toMany(c, "isOn", (...p) => p.some(vn)), u.bind("class").toMany(c, "isOn", (...p) => p.some(vn) ? "ck-splitbutton_flatten" : void 0), u.on("execute", () => {
              c.some(({ isOn: p }) => p) ? d.isOpen = !d.isOpen : r.fire("execute");
            }), d.bind("isEnabled").toMany(c, "isEnabled", (...p) => p.some(vn)), this.listenTo(d, "execute", () => {
              this.editor.editing.view.focus();
            }), d;
          });
        }
        _createButton(e) {
          const t = e.name;
          this.editor.ui.componentFactory.add(Xm(t), (n) => {
            const i = this.editor.commands.get("imageStyle"), r = new De(n);
            return r.set({ label: e.title, icon: e.icon, tooltip: !0, isToggleable: !0 }), r.bind("isEnabled").to(i, "isEnabled"), r.bind("isOn").to(i, "value", (s) => s === t), r.on("execute", this._executeCommand.bind(this, t)), r;
          });
        }
        _executeCommand(e) {
          this.editor.execute("imageStyle", { value: e }), this.editor.editing.view.focus();
        }
      }
      function Qm(o, e) {
        for (const t of o) e[t.title] && (t.title = e[t.title]);
        return o;
      }
      function Xm(o) {
        return `imageStyle:${o}`;
      }
      function ep(o, e) {
        return (o ? o + ": " : "") + e;
      }
      class iy extends K {
        static get pluginName() {
          return "IndentEditing";
        }
        init() {
          const e = this.editor;
          e.commands.add("indent", new hd(e)), e.commands.add("outdent", new hd(e));
        }
      }
      const tp = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>', np = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
      class ry extends K {
        static get pluginName() {
          return "IndentUI";
        }
        init() {
          const e = this.editor, t = e.locale, n = e.t, i = t.uiLanguageDirection == "ltr" ? tp : np, r = t.uiLanguageDirection == "ltr" ? np : tp;
          this._defineButton("indent", n("Increase indent"), i), this._defineButton("outdent", n("Decrease indent"), r);
        }
        _defineButton(e, t, n) {
          const i = this.editor;
          i.ui.componentFactory.add(e, (r) => {
            const s = i.commands.get(e), a = new De(r);
            return a.set({ label: t, icon: n, tooltip: !0 }), a.bind("isEnabled").to(s, "isEnabled"), this.listenTo(a, "execute", () => {
              i.execute(e), i.editing.view.focus();
            }), a;
          });
        }
      }
      class hr extends ae {
        constructor(e, t) {
          super(e), this._indentBehavior = t;
        }
        refresh() {
          const e = this.editor.model, t = Ke(e.document.selection.getSelectedBlocks());
          t && e.schema.checkAttribute(t, "blockIndent") ? this.isEnabled = this._indentBehavior.checkEnabled(t.getAttribute("blockIndent")) : this.isEnabled = !1;
        }
        execute() {
          const e = this.editor.model, t = function(n) {
            const i = n.document.selection, r = n.schema;
            return Array.from(i.getSelectedBlocks()).filter((s) => r.checkAttribute(s, "blockIndent"));
          }(e);
          e.change((n) => {
            for (const i of t) {
              const r = i.getAttribute("blockIndent"), s = this._indentBehavior.getNextIndent(r);
              s ? n.setAttribute("blockIndent", s, i) : n.removeAttribute("blockIndent", i);
            }
          });
        }
      }
      class op {
        constructor(e) {
          this.isForward = e.direction === "forward", this.offset = e.offset, this.unit = e.unit;
        }
        checkEnabled(e) {
          const t = parseFloat(e || "0");
          return this.isForward || t > 0;
        }
        getNextIndent(e) {
          const t = parseFloat(e || "0");
          if (!(!e || e.endsWith(this.unit))) return this.isForward ? this.offset + this.unit : void 0;
          const n = t + (this.isForward ? this.offset : -this.offset);
          return n > 0 ? n + this.unit : void 0;
        }
      }
      class ip {
        constructor(e) {
          this.isForward = e.direction === "forward", this.classes = e.classes;
        }
        checkEnabled(e) {
          const t = this.classes.indexOf(e);
          return this.isForward ? t < this.classes.length - 1 : t >= 0;
        }
        getNextIndent(e) {
          const t = this.classes.indexOf(e), n = this.isForward ? 1 : -1;
          return this.classes[t + n];
        }
      }
      const sy = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"];
      class ay {
        constructor() {
          this._definitions = /* @__PURE__ */ new Set();
        }
        get length() {
          return this._definitions.size;
        }
        add(e) {
          Array.isArray(e) ? e.forEach((t) => this._definitions.add(t)) : this._definitions.add(e);
        }
        getDispatcher() {
          return (e) => {
            e.on("attribute:linkHref", (t, n, i) => {
              if (!i.consumable.test(n.item, "attribute:linkHref") || !n.item.is("selection") && !i.schema.isInline(n.item)) return;
              const r = i.writer, s = r.document.selection;
              for (const a of this._definitions) {
                const l = r.createAttributeElement("a", a.attributes, { priority: 5 });
                a.classes && r.addClass(a.classes, l);
                for (const c in a.styles) r.setStyle(c, a.styles[c], l);
                r.setCustomProperty("link", !0, l), a.callback(n.attributeNewValue) ? n.item.is("selection") ? r.wrap(s.getFirstRange(), l) : r.wrap(i.mapper.toViewRange(n.range), l) : r.unwrap(i.mapper.toViewRange(n.range), l);
              }
            }, { priority: "high" });
          };
        }
        getDispatcherForLinkedImage() {
          return (e) => {
            e.on("attribute:linkHref:imageBlock", (t, n, { writer: i, mapper: r }) => {
              const s = r.toViewElement(n.item), a = Array.from(s.getChildren()).find((l) => l.is("element", "a"));
              for (const l of this._definitions) {
                const c = Ht(l.attributes);
                if (l.callback(n.attributeNewValue)) {
                  for (const [d, u] of c) d === "class" ? i.addClass(u, a) : i.setAttribute(d, u, a);
                  l.classes && i.addClass(l.classes, a);
                  for (const d in l.styles) i.setStyle(d, l.styles[d], a);
                } else {
                  for (const [d, u] of c) d === "class" ? i.removeClass(u, a) : i.removeAttribute(d, a);
                  l.classes && i.removeClass(l.classes, a);
                  for (const d in l.styles) i.removeStyle(d, a);
                }
              }
            });
          };
        }
      }
      const ly = function(o, e, t) {
        var n = o.length;
        return t = t === void 0 ? n : t, !e && t >= n ? o : vd(o, e, t);
      };
      var cy = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
      const rp = function(o) {
        return cy.test(o);
      }, dy = function(o) {
        return o.split("");
      };
      var sp = "\\ud800-\\udfff", uy = "[" + sp + "]", Ra = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", Oa = "\\ud83c[\\udffb-\\udfff]", ap = "[^" + sp + "]", lp = "(?:\\ud83c[\\udde6-\\uddff]){2}", cp = "[\\ud800-\\udbff][\\udc00-\\udfff]", dp = "(?:" + Ra + "|" + Oa + ")?", up = "[\\ufe0e\\ufe0f]?", hy = up + dp + ("(?:\\u200d(?:" + [ap, lp, cp].join("|") + ")" + up + dp + ")*"), gy = "(?:" + [ap + Ra + "?", Ra, lp, cp, uy].join("|") + ")", my = RegExp(Oa + "(?=" + Oa + ")|" + gy + hy, "g");
      const py = function(o) {
        return o.match(my) || [];
      }, fy = function(o) {
        return rp(o) ? py(o) : dy(o);
      }, by = /* @__PURE__ */ function(o) {
        return function(e) {
          e = As(e);
          var t = rp(e) ? fy(e) : void 0, n = t ? t[0] : e.charAt(0), i = t ? ly(t, 1).join("") : e.slice(1);
          return n[o]() + i;
        };
      }("toUpperCase"), ky = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, wy = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i, Ay = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i, _y = /^((\w+:(\/{2,})?)|(\W))/i, za = "Ctrl+K";
      function hp(o, { writer: e }) {
        const t = e.createAttributeElement("a", { href: o }, { priority: 5 });
        return e.setCustomProperty("link", !0, t), t;
      }
      function gp(o) {
        const e = String(o);
        return function(t) {
          return !!t.replace(ky, "").match(wy);
        }(e) ? e : "#";
      }
      function Ma(o, e) {
        return !!o && e.checkAttribute(o.name, "linkHref");
      }
      function Fa(o, e) {
        const t = (n = o, Ay.test(n) ? "mailto:" : e);
        var n;
        const i = !!t && !mp(o);
        return o && i ? t + o : o;
      }
      function mp(o) {
        return _y.test(o);
      }
      function pp(o) {
        window.open(o, "_blank", "noopener");
      }
      class vy extends ae {
        constructor() {
          super(...arguments), this.manualDecorators = new _t(), this.automaticDecorators = new ay();
        }
        restoreManualDecoratorStates() {
          for (const e of this.manualDecorators) e.value = this._getDecoratorStateFromModel(e.id);
        }
        refresh() {
          const e = this.editor.model, t = e.document.selection, n = t.getSelectedElement() || Ke(t.getSelectedBlocks());
          Ma(n, e.schema) ? (this.value = n.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttribute(n, "linkHref")) : (this.value = t.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref"));
          for (const i of this.manualDecorators) i.value = this._getDecoratorStateFromModel(i.id);
        }
        execute(e, t = {}) {
          const n = this.editor.model, i = n.document.selection, r = [], s = [];
          for (const a in t) t[a] ? r.push(a) : s.push(a);
          n.change((a) => {
            if (i.isCollapsed) {
              const l = i.getFirstPosition();
              if (i.hasAttribute("linkHref")) {
                const c = fp(i);
                let d = mo(l, "linkHref", i.getAttribute("linkHref"), n);
                i.getAttribute("linkHref") === c && (d = this._updateLinkContent(n, a, d, e)), a.setAttribute("linkHref", e, d), r.forEach((u) => {
                  a.setAttribute(u, !0, d);
                }), s.forEach((u) => {
                  a.removeAttribute(u, d);
                }), a.setSelection(a.createPositionAfter(d.end.nodeBefore));
              } else if (e !== "") {
                const c = Ht(i.getAttributes());
                c.set("linkHref", e), r.forEach((u) => {
                  c.set(u, !0);
                });
                const { end: d } = n.insertContent(a.createText(e, c), l);
                a.setSelection(d);
              }
              ["linkHref", ...r, ...s].forEach((c) => {
                a.removeSelectionAttribute(c);
              });
            } else {
              const l = n.schema.getValidRanges(i.getRanges(), "linkHref"), c = [];
              for (const u of i.getSelectedBlocks()) n.schema.checkAttribute(u, "linkHref") && c.push(a.createRangeOn(u));
              const d = c.slice();
              for (const u of l) this._isRangeToUpdate(u, c) && d.push(u);
              for (const u of d) {
                let g = u;
                if (d.length === 1) {
                  const p = fp(i);
                  i.getAttribute("linkHref") === p && (g = this._updateLinkContent(n, a, u, e), a.setSelection(a.createSelection(g)));
                }
                a.setAttribute("linkHref", e, g), r.forEach((p) => {
                  a.setAttribute(p, !0, g);
                }), s.forEach((p) => {
                  a.removeAttribute(p, g);
                });
              }
            }
          });
        }
        _getDecoratorStateFromModel(e) {
          const t = this.editor.model, n = t.document.selection, i = n.getSelectedElement();
          return Ma(i, t.schema) ? i.getAttribute(e) : n.getAttribute(e);
        }
        _isRangeToUpdate(e, t) {
          for (const n of t) if (n.containsRange(e)) return !1;
          return !0;
        }
        _updateLinkContent(e, t, n, i) {
          const r = t.createText(i, { linkHref: i });
          return e.insertContent(r, n);
        }
      }
      function fp(o) {
        if (o.isCollapsed) {
          const e = o.getFirstPosition();
          return e.textNode && e.textNode.data;
        }
        {
          const e = Array.from(o.getFirstRange().getItems());
          if (e.length > 1) return null;
          const t = e[0];
          return t.is("$text") || t.is("$textProxy") ? t.data : null;
        }
      }
      class Cy extends ae {
        refresh() {
          const e = this.editor.model, t = e.document.selection, n = t.getSelectedElement();
          Ma(n, e.schema) ? this.isEnabled = e.schema.checkAttribute(n, "linkHref") : this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref");
        }
        execute() {
          const e = this.editor, t = this.editor.model, n = t.document.selection, i = e.commands.get("link");
          t.change((r) => {
            const s = n.isCollapsed ? [mo(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), t)] : t.schema.getValidRanges(n.getRanges(), "linkHref");
            for (const a of s) if (r.removeAttribute("linkHref", a), i) for (const l of i.manualDecorators) r.removeAttribute(l.id, a);
          });
        }
      }
      class yy extends ve() {
        constructor({ id: e, label: t, attributes: n, classes: i, styles: r, defaultValue: s }) {
          super(), this.id = e, this.set("value", void 0), this.defaultValue = s, this.label = t, this.attributes = n, this.classes = i, this.styles = r;
        }
        _createPattern() {
          return { attributes: this.attributes, classes: this.classes, styles: this.styles };
        }
      }
      var bp = D(9773), Ey = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(bp.Z, Ey), bp.Z.locals;
      var xy = Object.defineProperty, kp = Object.getOwnPropertySymbols, Sy = Object.prototype.hasOwnProperty, Dy = Object.prototype.propertyIsEnumerable, wp = (o, e, t) => e in o ? xy(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, By = (o, e) => {
        for (var t in e || (e = {})) Sy.call(e, t) && wp(o, t, e[t]);
        if (kp) for (var t of kp(e)) Dy.call(e, t) && wp(o, t, e[t]);
        return o;
      };
      const Ap = "automatic", Ty = /^(https?:)?\/\//;
      class Iy extends K {
        static get pluginName() {
          return "LinkEditing";
        }
        static get requires() {
          return [kg, ug, Gt];
        }
        constructor(e) {
          super(e), e.config.define("link", { addTargetToExternalLinks: !1 });
        }
        init() {
          const e = this.editor;
          e.model.schema.extend("$text", { allowAttributes: "linkHref" }), e.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: hp }), e.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (n, i) => hp(gp(n), i) }), e.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: { href: !0 } }, model: { key: "linkHref", value: (n) => n.getAttribute("href") } }), e.commands.add("link", new vy(e)), e.commands.add("unlink", new Cy(e));
          const t = function(n, i) {
            const r = { "Open in a new tab": n("Open in a new tab"), Downloadable: n("Downloadable") };
            return i.forEach((s) => ("label" in s && r[s.label] && (s.label = r[s.label]), s)), i;
          }(e.t, function(n) {
            const i = [];
            if (n) for (const [r, s] of Object.entries(n)) {
              const a = Object.assign({}, s, { id: `link${by(r)}` });
              i.push(a);
            }
            return i;
          }(e.config.get("link.decorators")));
          this._enableAutomaticDecorators(t.filter((n) => n.mode === Ap)), this._enableManualDecorators(t.filter((n) => n.mode === "manual")), e.plugins.get(kg).registerAttribute("linkHref"), function(n, i, r, s) {
            const a = n.editing.view, l = /* @__PURE__ */ new Set();
            a.document.registerPostFixer((c) => {
              const d = n.model.document.selection;
              let u = !1;
              if (d.hasAttribute(i)) {
                const g = mo(d.getFirstPosition(), i, d.getAttribute(i), n.model), p = n.editing.mapper.toViewRange(g);
                for (const b of p.getItems()) b.is("element", r) && !b.hasClass(s) && (c.addClass(s, b), l.add(b), u = !0);
              }
              return u;
            }), n.conversion.for("editingDowncast").add((c) => {
              function d() {
                a.change((u) => {
                  for (const g of l.values()) u.removeClass(s, g), l.delete(g);
                });
              }
              c.on("insert", d, { priority: "highest" }), c.on("remove", d, { priority: "highest" }), c.on("attribute", d, { priority: "highest" }), c.on("selection", d, { priority: "highest" });
            });
          }(e, "linkHref", "a", "ck-link_selected"), this._enableLinkOpen(), this._enableInsertContentSelectionAttributesFixer(), this._enableClickingAfterLink(), this._enableTypingOverLink(), this._handleDeleteContentAfterLink(), this._enableClipboardIntegration();
        }
        _enableAutomaticDecorators(e) {
          const t = this.editor, n = t.commands.get("link").automaticDecorators;
          t.config.get("link.addTargetToExternalLinks") && n.add({ id: "linkIsExternal", mode: Ap, callback: (i) => !!i && Ty.test(i), attributes: { target: "_blank", rel: "noopener noreferrer" } }), n.add(e), n.length && t.conversion.for("downcast").add(n.getDispatcher());
        }
        _enableManualDecorators(e) {
          if (!e.length) return;
          const t = this.editor, n = t.commands.get("link").manualDecorators;
          e.forEach((i) => {
            t.model.schema.extend("$text", { allowAttributes: i.id });
            const r = new yy(i);
            n.add(r), t.conversion.for("downcast").attributeToElement({ model: r.id, view: (s, { writer: a, schema: l }, { item: c }) => {
              if ((c.is("selection") || l.isInline(c)) && s) {
                const d = a.createAttributeElement("a", r.attributes, { priority: 5 });
                r.classes && a.addClass(r.classes, d);
                for (const u in r.styles) a.setStyle(u, r.styles[u], d);
                return a.setCustomProperty("link", !0, d), d;
              }
            } }), t.conversion.for("upcast").elementToAttribute({ view: By({ name: "a" }, r._createPattern()), model: { key: r.id } });
          });
        }
        _enableLinkOpen() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "click", (n, i) => {
            if (!(f.isMac ? i.domEvent.metaKey : i.domEvent.ctrlKey)) return;
            let r = i.domTarget;
            if (r.tagName.toLowerCase() != "a" && (r = r.closest("a")), !r) return;
            const s = r.getAttribute("href");
            s && (n.stop(), i.preventDefault(), pp(s));
          }, { context: "$capture" }), this.listenTo(t, "keydown", (n, i) => {
            const r = e.commands.get("link").value;
            r && i.keyCode === ge.enter && i.altKey && (n.stop(), pp(r));
          });
        }
        _enableInsertContentSelectionAttributesFixer() {
          const e = this.editor.model, t = e.document.selection;
          this.listenTo(e, "insertContent", () => {
            const n = t.anchor.nodeBefore, i = t.anchor.nodeAfter;
            t.hasAttribute("linkHref") && n && n.hasAttribute("linkHref") && (i && i.hasAttribute("linkHref") || e.change((r) => {
              Na(r, Va(e.schema));
            }));
          }, { priority: "low" });
        }
        _enableClickingAfterLink() {
          const e = this.editor, t = e.model;
          e.editing.view.addObserver(Xs);
          let n = !1;
          this.listenTo(e.editing.view.document, "mousedown", () => {
            n = !0;
          }), this.listenTo(e.editing.view.document, "selectionChange", () => {
            if (!n) return;
            n = !1;
            const i = t.document.selection;
            if (!i.isCollapsed || !i.hasAttribute("linkHref")) return;
            const r = i.getFirstPosition(), s = mo(r, "linkHref", i.getAttribute("linkHref"), t);
            (r.isTouching(s.start) || r.isTouching(s.end)) && t.change((a) => {
              Na(a, Va(t.schema));
            });
          });
        }
        _enableTypingOverLink() {
          const e = this.editor, t = e.editing.view;
          let n = null, i = !1;
          this.listenTo(t.document, "delete", () => {
            i = !0;
          }, { priority: "high" }), this.listenTo(e.model, "deleteContent", () => {
            const r = e.model.document.selection;
            r.isCollapsed || (i ? i = !1 : _p(e) && function(s) {
              const a = s.document.selection, l = a.getFirstPosition(), c = a.getLastPosition(), d = l.nodeAfter;
              if (!d || !d.is("$text") || !d.hasAttribute("linkHref")) return !1;
              const u = c.textNode || c.nodeBefore;
              return d === u ? !0 : mo(l, "linkHref", d.getAttribute("linkHref"), s).containsRange(s.createRange(l, c), !0);
            }(e.model) && (n = r.getAttributes()));
          }, { priority: "high" }), this.listenTo(e.model, "insertContent", (r, [s]) => {
            i = !1, _p(e) && n && (e.model.change((a) => {
              for (const [l, c] of n) a.setAttribute(l, c, s);
            }), n = null);
          }, { priority: "high" });
        }
        _handleDeleteContentAfterLink() {
          const e = this.editor, t = e.model, n = t.document.selection, i = e.editing.view;
          let r = !1, s = !1;
          this.listenTo(i.document, "delete", (a, l) => {
            s = l.direction === "backward";
          }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
            r = !1;
            const a = n.getFirstPosition(), l = n.getAttribute("linkHref");
            if (!l) return;
            const c = mo(a, "linkHref", l, t);
            r = c.containsPosition(a) || c.end.isEqual(a);
          }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
            s && (s = !1, r || e.model.enqueueChange((a) => {
              Na(a, Va(t.schema));
            }));
          }, { priority: "low" });
        }
        _enableClipboardIntegration() {
          const e = this.editor, t = e.model, n = this.editor.config.get("link.defaultProtocol");
          n && this.listenTo(e.plugins.get("ClipboardPipeline"), "contentInsertion", (i, r) => {
            t.change((s) => {
              const a = s.createRangeIn(r.content);
              for (const l of a.getItems()) if (l.hasAttribute("linkHref")) {
                const c = Fa(l.getAttribute("linkHref"), n);
                s.setAttribute("linkHref", c, l);
              }
            });
          });
        }
      }
      function Na(o, e) {
        o.removeSelectionAttribute("linkHref");
        for (const t of e) o.removeSelectionAttribute(t);
      }
      function _p(o) {
        return o.model.change((e) => e.batch).isTyping;
      }
      function Va(o) {
        return o.getDefinition("$text").allowAttributes.filter((e) => e.startsWith("link"));
      }
      var vp = D(7754), Py = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(vp.Z, Py), vp.Z.locals;
      class Ry extends de {
        constructor(e, t) {
          super(e), this.focusTracker = new Et(), this.keystrokes = new $t(), this._focusables = new wn();
          const n = e.t;
          this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n("Save"), Pe.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n("Cancel"), Pe.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(t), this.children = this._createFormChildren(t.manualDecorators), this._focusCycler = new Mo({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } });
          const i = ["ck", "ck-link-form", "ck-responsive-form"];
          t.manualDecorators.length && i.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({ tag: "form", attributes: { class: i, tabindex: "-1" }, children: this.children });
        }
        getDecoratorSwitchesState() {
          return Array.from(this._manualDecoratorSwitches).reduce((e, t) => (e[t.name] = t.isOn, e), {});
        }
        render() {
          super.render(), m({ view: this }), [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach((e) => {
            this._focusables.add(e), this.focusTracker.add(e.element);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createUrlInput() {
          const e = this.locale.t, t = new od(this.locale, Eh);
          return t.label = e("Link URL"), t;
        }
        _createButton(e, t, n, i) {
          const r = new De(this.locale);
          return r.set({ label: e, icon: t, tooltip: !0 }), r.extendTemplate({ attributes: { class: n } }), i && r.delegate("execute").to(this, i), r;
        }
        _createManualDecoratorSwitches(e) {
          const t = this.createCollection();
          for (const n of e.manualDecorators) {
            const i = new Di(this.locale);
            i.set({ name: n.id, label: n.label, withText: !0 }), i.bind("isOn").toMany([n, e], "value", (r, s) => s === void 0 && r === void 0 ? !!n.defaultValue : !!r), i.on("execute", () => {
              n.set("value", !i.isOn);
            }), t.add(i);
          }
          return t;
        }
        _createFormChildren(e) {
          const t = this.createCollection();
          if (t.add(this.urlInputView), e.length) {
            const n = new de();
            n.setTemplate({ tag: "ul", children: this._manualDecoratorSwitches.map((i) => ({ tag: "li", children: [i], attributes: { class: ["ck", "ck-list__item"] } })), attributes: { class: ["ck", "ck-reset", "ck-list"] } }), t.add(n);
          }
          return t.add(this.saveButtonView), t.add(this.cancelButtonView), t;
        }
      }
      var Cp = D(2347), Oy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Cp.Z, Oy), Cp.Z.locals;
      class zy extends de {
        constructor(e) {
          super(e), this.focusTracker = new Et(), this.keystrokes = new $t(), this._focusables = new wn();
          const t = e.t;
          this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(t("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"), this.editButtonView = this._createButton(t("Edit link"), Pe.pencil, "edit"), this.set("href", void 0), this._focusCycler = new Mo({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1" }, children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView] });
        }
        render() {
          super.render(), [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach((e) => {
            this._focusables.add(e), this.focusTracker.add(e.element);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createButton(e, t, n) {
          const i = new De(this.locale);
          return i.set({ label: e, icon: t, tooltip: !0 }), i.delegate("execute").to(this, n), i;
        }
        _createPreviewButton() {
          const e = new De(this.locale), t = this.bindTemplate, n = this.t;
          return e.set({ withText: !0, tooltip: n("Open link in new tab") }), e.extendTemplate({ attributes: { class: ["ck", "ck-link-actions__preview"], href: t.to("href", (i) => i && gp(i)), target: "_blank", rel: "noopener noreferrer" } }), e.bind("label").to(this, "href", (i) => i || n("This link has no URL")), e.bind("isEnabled").to(this, "href", (i) => !!i), e.template.tag = "a", e.template.eventListeners = {}, e;
        }
      }
      const Vt = "link-ui";
      class My extends K {
        constructor() {
          super(...arguments), this.actionsView = null, this.formView = null;
        }
        static get requires() {
          return [tr];
        }
        static get pluginName() {
          return "LinkUI";
        }
        init() {
          const e = this.editor;
          e.editing.view.addObserver(L_), this._balloon = e.plugins.get(tr), this._createToolbarLinkButton(), this._enableBalloonActivators(), e.conversion.for("editingDowncast").markerToHighlight({ model: Vt, view: { classes: ["ck-fake-link-selection"] } }), e.conversion.for("editingDowncast").markerToElement({ model: Vt, view: { name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"] } });
        }
        destroy() {
          super.destroy(), this.formView && this.formView.destroy(), this.actionsView && this.actionsView.destroy();
        }
        _createViews() {
          this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._enableUserBalloonInteractions();
        }
        _createActionsView() {
          const e = this.editor, t = new zy(e.locale), n = e.commands.get("link"), i = e.commands.get("unlink");
          return t.bind("href").to(n, "value"), t.editButtonView.bind("isEnabled").to(n), t.unlinkButtonView.bind("isEnabled").to(i), this.listenTo(t, "edit", () => {
            this._addFormView();
          }), this.listenTo(t, "unlink", () => {
            e.execute("unlink"), this._hideUI();
          }), t.keystrokes.set("Esc", (r, s) => {
            this._hideUI(), s();
          }), t.keystrokes.set(za, (r, s) => {
            this._addFormView(), s();
          }), t;
        }
        _createFormView() {
          const e = this.editor, t = e.commands.get("link"), n = e.config.get("link.defaultProtocol"), i = new (S(Ry))(e.locale, t);
          return i.urlInputView.fieldView.bind("value").to(t, "value"), i.urlInputView.bind("isEnabled").to(t, "isEnabled"), i.saveButtonView.bind("isEnabled").to(t), this.listenTo(i, "submit", () => {
            const { value: r } = i.urlInputView.fieldView.element, s = Fa(r, n);
            e.execute("link", s, i.getDecoratorSwitchesState()), this._closeFormView();
          }), this.listenTo(i, "cancel", () => {
            this._closeFormView();
          }), i.keystrokes.set("Esc", (r, s) => {
            this._closeFormView(), s();
          }), i;
        }
        _createToolbarLinkButton() {
          const e = this.editor, t = e.commands.get("link"), n = e.t;
          e.ui.componentFactory.add("link", (i) => {
            const r = new De(i);
            return r.isEnabled = !0, r.label = n("Link"), r.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', r.keystroke = za, r.tooltip = !0, r.isToggleable = !0, r.bind("isEnabled").to(t, "isEnabled"), r.bind("isOn").to(t, "value", (s) => !!s), this.listenTo(r, "execute", () => this._showUI(!0)), r;
          });
        }
        _enableBalloonActivators() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "click", () => {
            this._getSelectedLinkElement() && this._showUI();
          }), e.keystrokes.set(za, (n, i) => {
            i(), e.commands.get("link").isEnabled && this._showUI(!0);
          });
        }
        _enableUserBalloonInteractions() {
          this.editor.keystrokes.set("Tab", (e, t) => {
            this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), t());
          }, { priority: "high" }), this.editor.keystrokes.set("Esc", (e, t) => {
            this._isUIVisible && (this._hideUI(), t());
          }), k({ emitter: this.formView, activator: () => this._isUIInPanel, contextElements: () => [this._balloon.view.element], callback: () => this._hideUI() });
        }
        _addActionsView() {
          this.actionsView || this._createViews(), this._areActionsInPanel || this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() });
        }
        _addFormView() {
          if (this.formView || this._createViews(), this._isFormInPanel) return;
          const e = this.editor.commands.get("link");
          this.formView.disableCssTransitions(), this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions(), this.formView.urlInputView.fieldView.element.value = e.value || "";
        }
        _closeFormView() {
          const e = this.editor.commands.get("link");
          e.restoreManualDecoratorStates(), e.value !== void 0 ? this._removeFormView() : this._hideUI();
        }
        _removeFormView() {
          this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection());
        }
        _showUI(e = !1) {
          this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), e && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), e && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
        }
        _hideUI() {
          if (!this._isUIInPanel) return;
          const e = this.editor;
          this.stopListening(e.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), e.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection();
        }
        _startUpdatingUI() {
          const e = this.editor, t = e.editing.view.document;
          let n = this._getSelectedLinkElement(), i = s();
          const r = () => {
            const a = this._getSelectedLinkElement(), l = s();
            n && !a || !n && l !== i ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n = a, i = l;
          };
          function s() {
            return t.selection.focus.getAncestors().reverse().find((a) => a.is("element"));
          }
          this.listenTo(e.ui, "update", r), this.listenTo(this._balloon, "change:visibleView", r);
        }
        get _isFormInPanel() {
          return !!this.formView && this._balloon.hasView(this.formView);
        }
        get _areActionsInPanel() {
          return !!this.actionsView && this._balloon.hasView(this.actionsView);
        }
        get _areActionsVisible() {
          return !!this.actionsView && this._balloon.visibleView === this.actionsView;
        }
        get _isUIInPanel() {
          return this._isFormInPanel || this._areActionsInPanel;
        }
        get _isUIVisible() {
          const e = this._balloon.visibleView;
          return !!this.formView && e == this.formView || this._areActionsVisible;
        }
        _getBalloonPositionData() {
          const e = this.editor.editing.view, t = this.editor.model, n = e.document;
          let i;
          if (t.markers.has(Vt)) {
            const r = Array.from(this.editor.editing.mapper.markerNameToElements(Vt)), s = e.createRange(e.createPositionBefore(r[0]), e.createPositionAfter(r[r.length - 1]));
            i = e.domConverter.viewRangeToDom(s);
          } else i = () => {
            const r = this._getSelectedLinkElement();
            return r ? e.domConverter.mapViewToDom(r) : e.domConverter.viewRangeToDom(n.selection.getFirstRange());
          };
          return { target: i };
        }
        _getSelectedLinkElement() {
          const e = this.editor.editing.view, t = e.document.selection, n = t.getSelectedElement();
          if (t.isCollapsed || n && Ne(n)) return La(t.getFirstPosition());
          {
            const i = t.getFirstRange().getTrimmed(), r = La(i.start), s = La(i.end);
            return r && r == s && e.createRangeIn(r).getTrimmed().isEqual(i) ? r : null;
          }
        }
        _showFakeVisualSelection() {
          const e = this.editor.model;
          e.change((t) => {
            const n = e.document.selection.getFirstRange();
            if (e.markers.has(Vt)) t.updateMarker(Vt, { range: n });
            else if (n.start.isAtEnd) {
              const i = n.start.getLastMatchingPosition(({ item: r }) => !e.schema.isContent(r), { boundaries: n });
              t.addMarker(Vt, { usingOperation: !1, affectsData: !1, range: t.createRange(i, n.end) });
            } else t.addMarker(Vt, { usingOperation: !1, affectsData: !1, range: n });
          });
        }
        _hideFakeVisualSelection() {
          const e = this.editor.model;
          e.markers.has(Vt) && e.change((t) => {
            t.removeMarker(Vt);
          });
        }
      }
      function La(o) {
        return o.getAncestors().find((e) => {
          return (t = e).is("attributeElement") && !!t.getCustomProperty("link");
          var t;
        }) || null;
      }
      const Fy = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i");
      class Ny extends K {
        static get requires() {
          return [ho];
        }
        static get pluginName() {
          return "AutoLink";
        }
        init() {
          const e = this.editor.model.document.selection;
          e.on("change:range", () => {
            this.isEnabled = !e.anchor.parent.is("element", "codeBlock");
          }), this._enableTypingHandling();
        }
        afterInit() {
          this._enableEnterHandling(), this._enableShiftEnterHandling();
        }
        _enableTypingHandling() {
          const e = this.editor, t = new bg(e.model, (n) => {
            if (!function(r) {
              return r.length > 4 && r[r.length - 1] === " " && r[r.length - 2] !== " ";
            }(n)) return;
            const i = yp(n.substr(0, n.length - 1));
            return i ? { url: i } : void 0;
          });
          t.on("matched:data", (n, i) => {
            const { batch: r, range: s, url: a } = i;
            if (!r.isTyping) return;
            const l = s.end.getShiftedBy(-1), c = l.getShiftedBy(-a.length), d = e.model.createRange(c, l);
            this._applyAutoLink(a, d);
          }), t.bind("isEnabled").to(this);
        }
        _enableEnterHandling() {
          const e = this.editor, t = e.model, n = e.commands.get("enter");
          n && n.on("execute", () => {
            const i = t.document.selection.getFirstPosition();
            if (!i.parent.previousSibling) return;
            const r = t.createRangeIn(i.parent.previousSibling);
            this._checkAndApplyAutoLinkOnRange(r);
          });
        }
        _enableShiftEnterHandling() {
          const e = this.editor, t = e.model, n = e.commands.get("shiftEnter");
          n && n.on("execute", () => {
            const i = t.document.selection.getFirstPosition(), r = t.createRange(t.createPositionAt(i.parent, 0), i.getShiftedBy(-1));
            this._checkAndApplyAutoLinkOnRange(r);
          });
        }
        _checkAndApplyAutoLinkOnRange(e) {
          const t = this.editor.model, { text: n, range: i } = fg(e, t), r = yp(n);
          if (r) {
            const s = t.createRange(i.end.getShiftedBy(-r.length), i.end);
            this._applyAutoLink(r, s);
          }
        }
        _applyAutoLink(e, t) {
          const n = this.editor.model, i = Fa(e, this.editor.config.get("link.defaultProtocol"));
          this.isEnabled && function(r, s) {
            return s.schema.checkAttributeInSelection(s.createSelection(r), "linkHref");
          }(t, n) && mp(i) && !function(r) {
            const s = r.start.nodeAfter;
            return !!s && s.hasAttribute("linkHref");
          }(t) && this._persistAutoLink(i, t);
        }
        _persistAutoLink(e, t) {
          const n = this.editor.model, i = this.editor.plugins.get("Delete");
          n.enqueueChange((r) => {
            r.setAttribute("linkHref", e, t), n.enqueueChange(() => {
              i.requestUndoOnBackspace();
            });
          });
        }
      }
      function yp(o) {
        const e = Fy.exec(o);
        return e ? e[2] : null;
      }
      var Ep = D(111), Vy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Ep.Z, Vy), Ep.Z.locals;
      var xp = D(5730), Ly = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(xp.Z, Ly), xp.Z.locals;
      var Sp = D(4564), jy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Sp.Z, jy), Sp.Z.locals;
      function $y(o, e) {
        const t = e.mapper, n = e.writer, i = o.getAttribute("listType") == "numbered" ? "ol" : "ul", r = function(a) {
          const l = a.createContainerElement("li");
          return l.getFillerOffset = Uy, l;
        }(n), s = n.createContainerElement(i, null);
        return n.insert(n.createPositionAt(s, 0), r), t.bindElements(o, r), r;
      }
      function Dp(o, e, t, n) {
        const i = e.parent, r = t.mapper, s = t.writer;
        let a = r.toViewPosition(n.createPositionBefore(o));
        const l = Tp(o.previousSibling, { sameIndent: !0, smallerIndent: !0, listIndent: o.getAttribute("listIndent") }), c = o.previousSibling;
        if (l && l.getAttribute("listIndent") == o.getAttribute("listIndent")) {
          const d = r.toViewElement(l);
          a = s.breakContainer(s.createPositionAfter(d));
        } else if (c && c.name == "listItem") {
          a = r.toViewPosition(n.createPositionAt(c, "end"));
          const d = r.findMappedViewAncestor(a), u = function(g) {
            for (const p of g.getChildren()) if (p.name == "ul" || p.name == "ol") return p;
            return null;
          }(d);
          a = u ? s.createPositionBefore(u) : s.createPositionAt(d, "end");
        } else a = r.toViewPosition(n.createPositionBefore(o));
        if (a = Bp(a), s.insert(a, i), c && c.name == "listItem") {
          const d = r.toViewElement(c), u = s.createRange(s.createPositionAt(d, 0), a).getWalker({ ignoreElementEnd: !0 });
          for (const g of u) if (g.item.is("element", "li")) {
            const p = s.breakContainer(s.createPositionBefore(g.item)), b = g.item.parent, w = s.createPositionAt(e, "end");
            Ct(s, w.nodeBefore, w.nodeAfter), s.move(s.createRangeOn(b), w), u._position = p;
          }
        } else {
          const d = i.nextSibling;
          if (d && (d.is("element", "ul") || d.is("element", "ol"))) {
            let u = null;
            for (const g of d.getChildren()) {
              const p = r.toModelElement(g);
              if (!(p && p.getAttribute("listIndent") > o.getAttribute("listIndent"))) break;
              u = g;
            }
            u && (s.breakContainer(s.createPositionAfter(u)), s.move(s.createRangeOn(u.parent), s.createPositionAt(e, "end")));
          }
        }
        Ct(s, i, i.nextSibling), Ct(s, i.previousSibling, i);
      }
      function Ct(o, e, t) {
        return !e || !t || e.name != "ul" && e.name != "ol" || e.name != t.name || e.getAttribute("class") !== t.getAttribute("class") ? null : o.mergeContainers(o.createPositionAfter(e));
      }
      function Bp(o) {
        return o.getLastMatchingPosition((e) => e.item.is("uiElement"));
      }
      function Tp(o, e) {
        const t = !!e.sameIndent, n = !!e.smallerIndent, i = e.listIndent;
        let r = o;
        for (; r && r.name == "listItem"; ) {
          const s = r.getAttribute("listIndent");
          if (t && i == s || n && i > s) return r;
          r = e.direction === "forward" ? r.nextSibling : r.previousSibling;
        }
        return null;
      }
      function Ip(o, e, t, n) {
        o.ui.componentFactory.add(e, (i) => {
          const r = o.commands.get(e), s = new De(i);
          return s.set({ label: t, icon: n, tooltip: !0, isToggleable: !0 }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), s.on("execute", () => {
            o.execute(e), o.editing.view.focus();
          }), s;
        });
      }
      function ja(o, e) {
        const t = [], n = o.parent, i = { ignoreElementEnd: !1, startPosition: o, shallow: !0, direction: e }, r = n.getAttribute("listIndent"), s = [...new Ft(i)].filter((a) => a.item.is("element")).map((a) => a.item);
        for (const a of s) {
          if (!a.is("element", "listItem") || a.getAttribute("listIndent") < r) break;
          if (!(a.getAttribute("listIndent") > r)) {
            if (a.getAttribute("listType") !== n.getAttribute("listType") || a.getAttribute("listStyle") !== n.getAttribute("listStyle") || a.getAttribute("listReversed") !== n.getAttribute("listReversed") || a.getAttribute("listStart") !== n.getAttribute("listStart")) break;
            e === "backward" ? t.unshift(a) : t.push(a);
          }
        }
        return t;
      }
      const Hy = ["disc", "circle", "square"], qy = ["decimal", "decimal-leading-zero", "lower-roman", "upper-roman", "lower-latin", "upper-latin"];
      function Uy() {
        const o = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
        return this.isEmpty || o ? 0 : Dd.call(this);
      }
      class Wy extends K {
        static get pluginName() {
          return "ListUI";
        }
        init() {
          const e = this.editor.t;
          Ip(this.editor, "numberedList", e("Numbered List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'), Ip(this.editor, "bulletedList", e("Bulleted List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>');
        }
      }
      const Ky = [{ listStyle: "disc", typeAttribute: "disc", listType: "bulleted" }, { listStyle: "circle", typeAttribute: "circle", listType: "bulleted" }, { listStyle: "square", typeAttribute: "square", listType: "bulleted" }, { listStyle: "decimal", typeAttribute: "1", listType: "numbered" }, { listStyle: "decimal-leading-zero", typeAttribute: null, listType: "numbered" }, { listStyle: "lower-roman", typeAttribute: "i", listType: "numbered" }, { listStyle: "upper-roman", typeAttribute: "I", listType: "numbered" }, { listStyle: "lower-alpha", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-alpha", typeAttribute: "A", listType: "numbered" }, { listStyle: "lower-latin", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-latin", typeAttribute: "A", listType: "numbered" }];
      for (const { listStyle: o, typeAttribute: e, listType: t } of Ky) ;
      var Pp = D(4721), Gy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Pp.Z, Gy), Pp.Z.locals;
      var Rp = D(6082), Zy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Rp.Z, Zy), Rp.Z.locals;
      var Op = D(2417), Jy = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Op.Z, Jy), Op.Z.locals;
      class zp extends ae {
        constructor(e, t) {
          super(e), this._indentBy = t == "forward" ? 1 : -1;
        }
        refresh() {
          this.isEnabled = this._checkEnabled();
        }
        execute() {
          const e = this.editor.model, t = e.document;
          let n = Array.from(t.selection.getSelectedBlocks());
          e.change((i) => {
            const r = n[n.length - 1];
            let s = r.nextSibling;
            for (; s && s.name == "listItem" && s.getAttribute("listIndent") > r.getAttribute("listIndent"); ) n.push(s), s = s.nextSibling;
            this._indentBy < 0 && (n = n.reverse());
            for (const a of n) {
              const l = a.getAttribute("listIndent") + this._indentBy;
              l < 0 ? i.rename(a, "paragraph") : i.setAttribute("listIndent", l, a);
            }
            this.fire("_executeCleanup", n);
          });
        }
        _checkEnabled() {
          const e = Ke(this.editor.model.document.selection.getSelectedBlocks());
          if (!e || !e.is("element", "listItem")) return !1;
          if (this._indentBy > 0) {
            const t = e.getAttribute("listIndent"), n = e.getAttribute("listType");
            let i = e.previousSibling;
            for (; i && i.is("element", "listItem") && i.getAttribute("listIndent") >= t; ) {
              if (i.getAttribute("listIndent") == t) return i.getAttribute("listType") == n;
              i = i.previousSibling;
            }
            return !1;
          }
          return !0;
        }
      }
      class Mp extends ae {
        constructor(e, t) {
          super(e), this.type = t;
        }
        refresh() {
          this.value = this._getValue(), this.isEnabled = this._checkEnabled();
        }
        execute(e = {}) {
          const t = this.editor.model, n = t.document, i = Array.from(n.selection.getSelectedBlocks()).filter((s) => Np(s, t.schema)), r = e.forceValue !== void 0 ? !e.forceValue : this.value;
          t.change((s) => {
            if (r) {
              let a = i[i.length - 1].nextSibling, l = Number.POSITIVE_INFINITY, c = [];
              for (; a && a.name == "listItem" && a.getAttribute("listIndent") !== 0; ) {
                const d = a.getAttribute("listIndent");
                d < l && (l = d);
                const u = d - l;
                c.push({ element: a, listIndent: u }), a = a.nextSibling;
              }
              c = c.reverse();
              for (const d of c) s.setAttribute("listIndent", d.listIndent, d.element);
            }
            if (!r) {
              let a = Number.POSITIVE_INFINITY;
              for (const l of i) l.is("element", "listItem") && l.getAttribute("listIndent") < a && (a = l.getAttribute("listIndent"));
              a = a === 0 ? 1 : a, Fp(i, !0, a), Fp(i, !1, a);
            }
            for (const a of i.reverse()) r && a.name == "listItem" ? s.rename(a, "paragraph") : r || a.name == "listItem" ? r || a.name != "listItem" || a.getAttribute("listType") == this.type || s.setAttribute("listType", this.type, a) : (s.setAttributes({ listType: this.type, listIndent: 0 }, a), s.rename(a, "listItem"));
            this.fire("_executeCleanup", i);
          });
        }
        _getValue() {
          const e = Ke(this.editor.model.document.selection.getSelectedBlocks());
          return !!e && e.is("element", "listItem") && e.getAttribute("listType") == this.type;
        }
        _checkEnabled() {
          if (this.value) return !0;
          const e = this.editor.model.document.selection, t = this.editor.model.schema, n = Ke(e.getSelectedBlocks());
          return !!n && Np(n, t);
        }
      }
      function Fp(o, e, t) {
        const n = e ? o[0] : o[o.length - 1];
        if (n.is("element", "listItem")) {
          let i = n[e ? "previousSibling" : "nextSibling"], r = n.getAttribute("listIndent");
          for (; i && i.is("element", "listItem") && i.getAttribute("listIndent") >= t; ) r > i.getAttribute("listIndent") && (r = i.getAttribute("listIndent")), i.getAttribute("listIndent") == r && o[e ? "unshift" : "push"](i), i = i[e ? "previousSibling" : "nextSibling"];
        }
      }
      function Np(o, e) {
        return e.checkChild(o.parent, "listItem") && !e.isObject(o);
      }
      class Yy extends K {
        static get pluginName() {
          return "ListUtils";
        }
        getListTypeFromListStyleType(e) {
          return function(t) {
            return Hy.includes(t) ? "bulleted" : qy.includes(t) ? "numbered" : null;
          }(e);
        }
        getSelectedListItems(e) {
          return function(t) {
            let n = [...t.document.selection.getSelectedBlocks()].filter((i) => i.is("element", "listItem")).map((i) => {
              const r = t.change((s) => s.createPositionAt(i, 0));
              return [...ja(r, "backward"), ...ja(r, "forward")];
            }).flat();
            return n = [...new Set(n)], n;
          }(e);
        }
        getSiblingNodes(e, t) {
          return ja(e, t);
        }
      }
      function Vp(o) {
        return (e, t, n) => {
          const i = n.consumable;
          if (!i.test(t.item, "insert") || !i.test(t.item, "attribute:listType") || !i.test(t.item, "attribute:listIndent")) return;
          i.consume(t.item, "insert"), i.consume(t.item, "attribute:listType"), i.consume(t.item, "attribute:listIndent");
          const r = t.item;
          Dp(r, $y(r, n), n, o);
        };
      }
      const Qy = (o, e, t) => {
        if (!t.consumable.test(e.item, o.name)) return;
        const n = t.mapper.toViewElement(e.item), i = t.writer;
        i.breakContainer(i.createPositionBefore(n)), i.breakContainer(i.createPositionAfter(n));
        const r = n.parent, s = e.attributeNewValue == "numbered" ? "ol" : "ul";
        i.rename(s, r);
      }, Xy = (o, e, t) => {
        t.consumable.consume(e.item, o.name);
        const n = t.mapper.toViewElement(e.item).parent, i = t.writer;
        Ct(i, n, n.nextSibling), Ct(i, n.previousSibling, n);
      }, Lp = (o, e, t) => {
        if (t.consumable.test(e.item, o.name) && e.item.name != "listItem") {
          let n = t.mapper.toViewPosition(e.range.start);
          const i = t.writer, r = [];
          for (; (n.parent.name == "ul" || n.parent.name == "ol") && (n = i.breakContainer(n), n.parent.name == "li"); ) {
            const s = n, a = i.createPositionAt(n.parent, "end");
            if (!s.isEqual(a)) {
              const l = i.remove(i.createRange(s, a));
              r.push(l);
            }
            n = i.createPositionAfter(n.parent);
          }
          if (r.length > 0) {
            for (let s = 0; s < r.length; s++) {
              const a = n.nodeBefore;
              if (n = i.insert(n, r[s]).end, s > 0) {
                const l = Ct(i, a, a.nextSibling);
                l && l.parent == a && n.offset--;
              }
            }
            Ct(i, n.nodeBefore, n.nodeAfter);
          }
        }
      }, eE = (o, e, t) => {
        const n = t.mapper.toViewPosition(e.position), i = n.nodeBefore, r = n.nodeAfter;
        Ct(t.writer, i, r);
      }, tE = (o, e, t) => {
        if (t.consumable.consume(e.viewItem, { name: !0 })) {
          const n = t.writer, i = n.createElement("listItem"), r = function(l) {
            let c = 0, d = l.parent;
            for (; d; ) {
              if (d.is("element", "li")) c++;
              else {
                const u = d.previousSibling;
                u && u.is("element", "li") && c++;
              }
              d = d.parent;
            }
            return c;
          }(e.viewItem);
          n.setAttribute("listIndent", r, i);
          const s = e.viewItem.parent && e.viewItem.parent.name == "ol" ? "numbered" : "bulleted";
          if (n.setAttribute("listType", s, i), !t.safeInsert(i, e.modelCursor)) return;
          const a = function(l, c, d) {
            const { writer: u, schema: g } = d;
            let p = u.createPositionAfter(l);
            for (const b of c) if (b.name == "ul" || b.name == "ol") p = d.convertItem(b, p).modelCursor;
            else {
              const w = d.convertItem(b, u.createPositionAt(l, "end")), y = w.modelRange.start.nodeAfter;
              y && y.is("element") && !g.checkChild(l, y.name) && (l = w.modelCursor.parent.is("element", "listItem") ? w.modelCursor.parent : iE(w.modelCursor), p = u.createPositionAfter(l));
            }
            return p;
          }(i, e.viewItem.getChildren(), t);
          e.modelRange = n.createRange(e.modelCursor, a), t.updateConversionResult(i, e);
        }
      }, jp = (o, e, t) => {
        if (t.consumable.test(e.viewItem, { name: !0 })) {
          const n = Array.from(e.viewItem.getChildren());
          for (const i of n)
            !(i.is("element", "li") || bo(i)) && i._remove();
        }
      }, nE = (o, e, t) => {
        if (t.consumable.test(e.viewItem, { name: !0 })) {
          if (e.viewItem.childCount === 0) return;
          const n = [...e.viewItem.getChildren()];
          let i = !1;
          for (const r of n) i && !bo(r) && r._remove(), bo(r) && (i = !0);
        }
      };
      function $p(o) {
        return (e, t) => {
          if (t.isPhantom) return;
          const n = t.modelPosition.nodeBefore;
          if (n && n.is("element", "listItem")) {
            const i = t.mapper.toViewElement(n), r = i.getAncestors().find(bo), s = o.createPositionAt(i, 0).getWalker();
            for (const a of s) {
              if (a.type == "elementStart" && a.item.is("element", "li")) {
                t.viewPosition = a.previousPosition;
                break;
              }
              if (a.type == "elementEnd" && a.item == r) {
                t.viewPosition = a.nextPosition;
                break;
              }
            }
          }
        };
      }
      const oE = function(o, [e, t]) {
        const n = this;
        let i, r = e.is("documentFragment") ? e.getChild(0) : e;
        if (i = t ? n.createSelection(t) : n.document.selection, r && r.is("element", "listItem")) {
          const s = i.getFirstPosition();
          let a = null;
          if (s.parent.is("element", "listItem") ? a = s.parent : s.nodeBefore && s.nodeBefore.is("element", "listItem") && (a = s.nodeBefore), a) {
            const l = a.getAttribute("listIndent");
            if (l > 0) for (; r && r.is("element", "listItem"); ) r._setAttribute("listIndent", r.getAttribute("listIndent") + l), r = r.nextSibling;
          }
        }
      };
      function iE(o) {
        const e = new Ft({ startPosition: o });
        let t;
        do
          t = e.next();
        while (!t.value.item.is("element", "listItem"));
        return t.value.item;
      }
      function Hp(o, e, t, n, i, r) {
        const s = Tp(e.nodeBefore, { sameIndent: !0, smallerIndent: !0, listIndent: o }), a = i.mapper, l = i.writer, c = s ? s.getAttribute("listIndent") : null;
        let d;
        if (s) if (c == o) {
          const u = a.toViewElement(s).parent;
          d = l.createPositionAfter(u);
        } else {
          const u = r.createPositionAt(s, "end");
          d = a.toViewPosition(u);
        }
        else d = t;
        d = Bp(d);
        for (const u of [...n.getChildren()]) bo(u) && (d = l.move(l.createRangeOn(u), d).end, Ct(l, u, u.nextSibling), Ct(l, u.previousSibling, u));
      }
      function bo(o) {
        return o.is("element", "ol") || o.is("element", "ul");
      }
      class rE extends K {
        static get pluginName() {
          return "ListEditing";
        }
        static get requires() {
          return [ei, ho, Yy];
        }
        init() {
          const e = this.editor;
          e.model.schema.register("listItem", { inheritAllFrom: "$block", allowAttributes: ["listType", "listIndent"] });
          const t = e.data, n = e.editing;
          var i;
          e.model.document.registerPostFixer((s) => function(a, l) {
            const c = a.document.differ.getChanges(), d = /* @__PURE__ */ new Map();
            let u = !1;
            for (const w of c) if (w.type == "insert" && w.name == "listItem") g(w.position);
            else if (w.type == "insert" && w.name != "listItem") {
              if (w.name != "$text") {
                const y = w.position.nodeAfter;
                y.hasAttribute("listIndent") && (l.removeAttribute("listIndent", y), u = !0), y.hasAttribute("listType") && (l.removeAttribute("listType", y), u = !0), y.hasAttribute("listStyle") && (l.removeAttribute("listStyle", y), u = !0), y.hasAttribute("listReversed") && (l.removeAttribute("listReversed", y), u = !0), y.hasAttribute("listStart") && (l.removeAttribute("listStart", y), u = !0);
                for (const I of Array.from(a.createRangeIn(y)).filter((z) => z.item.is("element", "listItem"))) g(I.previousPosition);
              }
              g(w.position.getShiftedBy(w.length));
            } else w.type == "remove" && w.name == "listItem" ? g(w.position) : (w.type == "attribute" && w.attributeKey == "listIndent" || w.type == "attribute" && w.attributeKey == "listType") && g(w.range.start);
            for (const w of d.values()) p(w), b(w);
            return u;
            function g(w) {
              const y = w.nodeBefore;
              if (y && y.is("element", "listItem")) {
                let I = y;
                if (d.has(I)) return;
                for (let z = I.previousSibling; z && z.is("element", "listItem"); z = I.previousSibling) if (I = z, d.has(I)) return;
                d.set(y, I);
              } else {
                const I = w.nodeAfter;
                I && I.is("element", "listItem") && d.set(I, I);
              }
            }
            function p(w) {
              let y = 0, I = null;
              for (; w && w.is("element", "listItem"); ) {
                const z = w.getAttribute("listIndent");
                if (z > y) {
                  let H;
                  I === null ? (I = z - y, H = y) : (I > z && (I = z), H = z - I), l.setAttribute("listIndent", H, w), u = !0;
                } else I = null, y = w.getAttribute("listIndent") + 1;
                w = w.nextSibling;
              }
            }
            function b(w) {
              let y = [], I = null;
              for (; w && w.is("element", "listItem"); ) {
                const z = w.getAttribute("listIndent");
                if (I && I.getAttribute("listIndent") > z && (y = y.slice(0, z + 1)), z != 0) if (y[z]) {
                  const H = y[z];
                  w.getAttribute("listType") != H && (l.setAttribute("listType", H, w), u = !0);
                } else y[z] = w.getAttribute("listType");
                I = w, w = w.nextSibling;
              }
            }
          }(e.model, s)), n.mapper.registerViewToModelLength("li", $a), t.mapper.registerViewToModelLength("li", $a), n.mapper.on("modelToViewPosition", $p(n.view)), n.mapper.on("viewToModelPosition", (i = e.model, (s, a) => {
            const l = a.viewPosition, c = l.parent, d = a.mapper;
            if (c.name == "ul" || c.name == "ol") {
              if (l.isAtEnd) {
                const u = d.toModelElement(l.nodeBefore), g = d.getModelLength(l.nodeBefore);
                a.modelPosition = i.createPositionBefore(u).getShiftedBy(g);
              } else {
                const u = d.toModelElement(l.nodeAfter);
                a.modelPosition = i.createPositionBefore(u);
              }
              s.stop();
            } else if (c.name == "li" && l.nodeBefore && (l.nodeBefore.name == "ul" || l.nodeBefore.name == "ol")) {
              const u = d.toModelElement(c);
              let g = 1, p = l.nodeBefore;
              for (; p && bo(p); ) g += d.getModelLength(p), p = p.previousSibling;
              a.modelPosition = i.createPositionBefore(u).getShiftedBy(g), s.stop();
            }
          })), t.mapper.on("modelToViewPosition", $p(n.view)), e.conversion.for("editingDowncast").add((s) => {
            s.on("insert", Lp, { priority: "high" }), s.on("insert:listItem", Vp(e.model)), s.on("attribute:listType:listItem", Qy, { priority: "high" }), s.on("attribute:listType:listItem", Xy, { priority: "low" }), s.on("attribute:listIndent:listItem", /* @__PURE__ */ function(a) {
              return (l, c, d) => {
                if (!d.consumable.consume(c.item, "attribute:listIndent")) return;
                const u = d.mapper.toViewElement(c.item), g = d.writer;
                g.breakContainer(g.createPositionBefore(u)), g.breakContainer(g.createPositionAfter(u));
                const p = u.parent, b = p.previousSibling, w = g.createRangeOn(p);
                g.remove(w), b && b.nextSibling && Ct(g, b, b.nextSibling), Hp(c.attributeOldValue + 1, c.range.start, w.start, u, d, a), Dp(c.item, u, d, a);
                for (const y of c.item.getChildren()) d.consumable.consume(y, "insert");
              };
            }(e.model)), s.on("remove:listItem", /* @__PURE__ */ function(a) {
              return (l, c, d) => {
                const u = d.mapper.toViewPosition(c.position).getLastMatchingPosition((I) => !I.item.is("element", "li")).nodeAfter, g = d.writer;
                g.breakContainer(g.createPositionBefore(u)), g.breakContainer(g.createPositionAfter(u));
                const p = u.parent, b = p.previousSibling, w = g.createRangeOn(p), y = g.remove(w);
                b && b.nextSibling && Ct(g, b, b.nextSibling), Hp(d.mapper.toModelElement(u).getAttribute("listIndent") + 1, c.position, w.start, u, d, a);
                for (const I of g.createRangeIn(y).getItems()) d.mapper.unbindViewElement(I);
                l.stop();
              };
            }(e.model)), s.on("remove", eE, { priority: "low" });
          }), e.conversion.for("dataDowncast").add((s) => {
            s.on("insert", Lp, { priority: "high" }), s.on("insert:listItem", Vp(e.model));
          }), e.conversion.for("upcast").add((s) => {
            s.on("element:ul", jp, { priority: "high" }), s.on("element:ol", jp, { priority: "high" }), s.on("element:li", nE, { priority: "high" }), s.on("element:li", tE);
          }), e.model.on("insertContent", oE, { priority: "high" }), e.commands.add("numberedList", new Mp(e, "numbered")), e.commands.add("bulletedList", new Mp(e, "bulleted")), e.commands.add("indentList", new zp(e, "forward")), e.commands.add("outdentList", new zp(e, "backward"));
          const r = n.view.document;
          this.listenTo(r, "enter", (s, a) => {
            const l = this.editor.model.document, c = l.selection.getLastPosition().parent;
            l.selection.isCollapsed && c.name == "listItem" && c.isEmpty && (this.editor.execute("outdentList"), a.preventDefault(), s.stop());
          }, { context: "li" }), this.listenTo(r, "delete", (s, a) => {
            if (a.direction !== "backward") return;
            const l = this.editor.model.document.selection;
            if (!l.isCollapsed) return;
            const c = l.getFirstPosition();
            if (!c.isAtStart) return;
            const d = c.parent;
            d.name === "listItem" && (d.previousSibling && d.previousSibling.name === "listItem" || (this.editor.execute("outdentList"), a.preventDefault(), s.stop()));
          }, { context: "li" }), this.listenTo(e.editing.view.document, "tab", (s, a) => {
            const l = a.shiftKey ? "outdentList" : "indentList";
            this.editor.commands.get(l).isEnabled && (e.execute(l), a.stopPropagation(), a.preventDefault(), s.stop());
          }, { context: "li" });
        }
        afterInit() {
          const e = this.editor.commands, t = e.get("indent"), n = e.get("outdent");
          t && t.registerChildCommand(e.get("indentList")), n && n.registerChildCommand(e.get("outdentList"));
        }
      }
      function $a(o) {
        let e = 1;
        for (const t of o.getChildren()) if (t.name == "ul" || t.name == "ol") for (const n of t.getChildren()) e += $a(n);
        return e;
      }
      Ei("Ctrl+Enter");
      var qp = D(1199), sE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(qp.Z, sE), qp.Z.locals;
      function qe(o, e, t, n, i = 1) {
        e != null && i != null && e > i ? n.setAttribute(o, e, t) : n.removeAttribute(o, t);
      }
      function In(o, e, t = {}) {
        const n = o.createElement("tableCell", t);
        return o.insertElement("paragraph", n), o.insert(n, e), n;
      }
      function Ha(o, e) {
        const t = e.parent.parent, n = parseInt(t.getAttribute("headingColumns") || "0"), { column: i } = o.getCellLocation(e);
        return !!n && i < n;
      }
      function aE() {
        return (o) => {
          o.on("element:table", (e, t, n) => {
            const i = t.viewItem;
            if (!n.consumable.test(i, { name: !0 })) return;
            const { rows: r, headingRows: s, headingColumns: a } = function(d) {
              let u, g = 0;
              const p = [], b = [];
              let w;
              for (const y of Array.from(d.getChildren())) {
                if (y.name !== "tbody" && y.name !== "thead" && y.name !== "tfoot") continue;
                y.name !== "thead" || w || (w = y);
                const I = Array.from(y.getChildren()).filter((z) => z.is("element", "tr"));
                for (const z of I) if (w && y === w || y.name === "tbody" && Array.from(z.getChildren()).length && Array.from(z.getChildren()).every((H) => H.is("element", "th"))) g++, p.push(z);
                else {
                  b.push(z);
                  const H = lE(z);
                  (!u || H < u) && (u = H);
                }
              }
              return { headingRows: g, headingColumns: u || 0, rows: [...p, ...b] };
            }(i), l = {};
            a && (l.headingColumns = a), s && (l.headingRows = s);
            const c = n.writer.createElement("table", l);
            if (n.safeInsert(c, t.modelCursor)) {
              if (n.consumable.consume(i, { name: !0 }), r.forEach((d) => n.convertItem(d, n.writer.createPositionAt(c, "end"))), n.convertChildren(i, n.writer.createPositionAt(c, "end")), c.isEmpty) {
                const d = n.writer.createElement("tableRow");
                n.writer.insert(d, n.writer.createPositionAt(c, "end")), In(n.writer, n.writer.createPositionAt(d, "end"));
              }
              n.updateConversionResult(c, t);
            }
          });
        };
      }
      function Up(o) {
        return (e) => {
          e.on(`element:${o}`, (t, n, { writer: i }) => {
            if (!n.modelRange) return;
            const r = n.modelRange.start.nodeAfter, s = i.createPositionAt(r, 0);
            if (n.viewItem.isEmpty) return void i.insertElement("paragraph", s);
            const a = Array.from(r.getChildren());
            if (a.every((l) => l.is("element", "$marker"))) {
              const l = i.createElement("paragraph");
              i.insert(l, i.createPositionAt(r, 0));
              for (const c of a) i.move(i.createRangeOn(c), i.createPositionAt(l, "end"));
            }
          }, { priority: "low" });
        };
      }
      function lE(o) {
        let e = 0, t = 0;
        const n = Array.from(o.getChildren()).filter((i) => i.name === "th" || i.name === "td");
        for (; t < n.length && n[t].name === "th"; ) {
          const i = n[t];
          e += parseInt(i.getAttribute("colspan") || "1"), t++;
        }
        return e;
      }
      class we {
        constructor(e, t = {}) {
          this._table = e, this._startRow = t.row !== void 0 ? t.row : t.startRow || 0, this._endRow = t.row !== void 0 ? t.row : t.endRow, this._startColumn = t.column !== void 0 ? t.column : t.startColumn || 0, this._endColumn = t.column !== void 0 ? t.column : t.endColumn, this._includeAllSlots = !!t.includeAllSlots, this._skipRows = /* @__PURE__ */ new Set(), this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = /* @__PURE__ */ new Map(), this._nextCellAtColumn = -1;
        }
        [Symbol.iterator]() {
          return this;
        }
        next() {
          const e = this._table.getChild(this._rowIndex);
          if (!e || this._isOverEndRow()) return { done: !0, value: void 0 };
          if (!e.is("element", "tableRow")) return this._rowIndex++, this.next();
          if (this._isOverEndColumn()) return this._advanceToNextRow();
          let t = null;
          const n = this._getSpanned();
          if (n) this._includeAllSlots && !this._shouldSkipSlot() && (t = this._formatOutValue(n.cell, n.row, n.column));
          else {
            const i = e.getChild(this._cellIndex);
            if (!i) return this._advanceToNextRow();
            const r = parseInt(i.getAttribute("colspan") || "1"), s = parseInt(i.getAttribute("rowspan") || "1");
            (r > 1 || s > 1) && this._recordSpans(i, s, r), this._shouldSkipSlot() || (t = this._formatOutValue(i)), this._nextCellAtColumn = this._column + r;
          }
          return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, t || this.next();
        }
        skipRow(e) {
          this._skipRows.add(e);
        }
        _advanceToNextRow() {
          return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next();
        }
        _isOverEndRow() {
          return this._endRow !== void 0 && this._row > this._endRow;
        }
        _isOverEndColumn() {
          return this._endColumn !== void 0 && this._column > this._endColumn;
        }
        _formatOutValue(e, t = this._row, n = this._column) {
          return { done: !1, value: new cE(this, e, t, n) };
        }
        _shouldSkipSlot() {
          const e = this._skipRows.has(this._row), t = this._row < this._startRow, n = this._column < this._startColumn, i = this._endColumn !== void 0 && this._column > this._endColumn;
          return e || t || n || i;
        }
        _getSpanned() {
          const e = this._spannedCells.get(this._row);
          return e && e.get(this._column) || null;
        }
        _recordSpans(e, t, n) {
          const i = { cell: e, row: this._row, column: this._column };
          for (let r = this._row; r < this._row + t; r++) for (let s = this._column; s < this._column + n; s++) r == this._row && s == this._column || this._markSpannedCell(r, s, i);
        }
        _markSpannedCell(e, t, n) {
          this._spannedCells.has(e) || this._spannedCells.set(e, /* @__PURE__ */ new Map()), this._spannedCells.get(e).set(t, n);
        }
      }
      class cE {
        constructor(e, t, n, i) {
          this.cell = t, this.row = e._row, this.column = e._column, this.cellAnchorRow = n, this.cellAnchorColumn = i, this._cellIndex = e._cellIndex, this._rowIndex = e._rowIndex, this._table = e._table;
        }
        get isAnchor() {
          return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
        }
        get cellWidth() {
          return parseInt(this.cell.getAttribute("colspan") || "1");
        }
        get cellHeight() {
          return parseInt(this.cell.getAttribute("rowspan") || "1");
        }
        get rowIndex() {
          return this._rowIndex;
        }
        getPositionBefore() {
          return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
        }
      }
      function Wp(o, e) {
        return (t, { writer: n }) => {
          const i = t.getAttribute("headingRows") || 0, r = n.createContainerElement("table", null, []), s = n.createContainerElement("figure", { class: "table" }, r);
          i > 0 && n.insert(n.createPositionAt(r, "end"), n.createContainerElement("thead", null, n.createSlot((a) => a.is("element", "tableRow") && a.index < i))), i < o.getRows(t) && n.insert(n.createPositionAt(r, "end"), n.createContainerElement("tbody", null, n.createSlot((a) => a.is("element", "tableRow") && a.index >= i)));
          for (const { positionOffset: a, filter: l } of e.additionalSlots) n.insert(n.createPositionAt(r, a), n.createSlot(l));
          return n.insert(n.createPositionAt(r, "after"), n.createSlot((a) => !a.is("element", "tableRow") && !e.additionalSlots.some(({ filter: l }) => l(a)))), e.asWidget ? function(a, l) {
            return l.setCustomProperty("table", !0, a), va(a, l, { hasSelectionHandle: !0 });
          }(s, n) : s;
        };
      }
      function Kp(o = {}) {
        return (e, { writer: t }) => {
          const n = e.parent, i = n.parent, r = i.getChildIndex(n), s = new we(i, { row: r }), a = i.getAttribute("headingRows") || 0, l = i.getAttribute("headingColumns") || 0;
          let c = null;
          for (const d of s) if (d.cell == e) {
            const u = d.row < a || d.column < l ? "th" : "td";
            c = o.asWidget ? gC(t.createEditableElement(u), t) : t.createContainerElement(u);
            break;
          }
          return c;
        };
      }
      function Gp(o = {}) {
        return (e, { writer: t }) => {
          if (!e.parent.is("element", "tableCell") || !Zp(e)) return null;
          if (o.asWidget) return t.createContainerElement("span", { class: "ck-table-bogus-paragraph" });
          {
            const n = t.createContainerElement("p");
            return t.setCustomProperty("dataPipeline:transparentRendering", !0, n), n;
          }
        };
      }
      function Zp(o) {
        return o.parent.childCount == 1 && !!o.getAttributeKeys().next().done;
      }
      class dE extends ae {
        refresh() {
          const e = this.editor.model, t = e.document.selection, n = e.schema;
          this.isEnabled = function(i, r) {
            const s = i.getFirstPosition().parent, a = s === s.root ? s : s.parent;
            return r.checkChild(a, "table");
          }(t, n);
        }
        execute(e = {}) {
          const t = this.editor, n = t.model, i = t.plugins.get("TableUtils"), r = t.config.get("table.defaultHeadings.rows"), s = t.config.get("table.defaultHeadings.columns");
          e.headingRows === void 0 && r && (e.headingRows = r), e.headingColumns === void 0 && s && (e.headingColumns = s), n.change((a) => {
            const l = i.createTable(a, e);
            n.insertObject(l, null, null, { findOptimalPosition: "auto" }), a.setSelection(a.createPositionAt(l.getNodeByPath([0, 0, 0]), 0));
          });
        }
      }
      class Jp extends ae {
        constructor(e, t = {}) {
          super(e), this.order = t.order || "below";
        }
        refresh() {
          const e = this.editor.model.document.selection, t = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
          this.isEnabled = t;
        }
        execute() {
          const e = this.editor, t = e.model.document.selection, n = e.plugins.get("TableUtils"), i = this.order === "above", r = n.getSelectionAffectedTableCells(t), s = n.getRowIndexes(r), a = i ? s.first : s.last, l = r[0].findAncestor("table");
          n.insertRows(l, { at: i ? a : a + 1, copyStructureFromAbove: !i });
        }
      }
      class Yp extends ae {
        constructor(e, t = {}) {
          super(e), this.order = t.order || "right";
        }
        refresh() {
          const e = this.editor.model.document.selection, t = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
          this.isEnabled = t;
        }
        execute() {
          const e = this.editor, t = e.model.document.selection, n = e.plugins.get("TableUtils"), i = this.order === "left", r = n.getSelectionAffectedTableCells(t), s = n.getColumnIndexes(r), a = i ? s.first : s.last, l = r[0].findAncestor("table");
          n.insertColumns(l, { columns: 1, at: i ? a : a + 1 });
        }
      }
      class Qp extends ae {
        constructor(e, t = {}) {
          super(e), this.direction = t.direction || "horizontally";
        }
        refresh() {
          const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.length === 1;
        }
        execute() {
          const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
          this.direction === "horizontally" ? e.splitCellHorizontally(t, 2) : e.splitCellVertically(t, 2);
        }
      }
      function Xp(o, e, t) {
        const { startRow: n, startColumn: i, endRow: r, endColumn: s } = e, a = t.createElement("table"), l = r - n + 1;
        for (let d = 0; d < l; d++) t.insertElement("tableRow", a, "end");
        const c = [...new we(o, { startRow: n, endRow: r, startColumn: i, endColumn: s, includeAllSlots: !0 })];
        for (const { row: d, column: u, cell: g, isAnchor: p, cellAnchorRow: b, cellAnchorColumn: w } of c) {
          const y = d - n, I = a.getChild(y);
          if (p) {
            const z = t.cloneElement(g);
            t.append(z, I), rf(z, d, u, r, s, t);
          } else (b < n || w < i) && In(t, t.createPositionAt(I, "end"));
        }
        return function(d, u, g, p, b) {
          const w = parseInt(u.getAttribute("headingRows") || "0");
          w > 0 && qe("headingRows", w - g, d, b, 0);
          const y = parseInt(u.getAttribute("headingColumns") || "0");
          y > 0 && qe("headingColumns", y - p, d, b, 0);
        }(a, o, n, i, t), a;
      }
      function ef(o, e, t = 0) {
        const n = [], i = new we(o, { startRow: t, endRow: e - 1 });
        for (const r of i) {
          const { row: s, cellHeight: a } = r;
          s < e && e <= s + a - 1 && n.push(r);
        }
        return n;
      }
      function tf(o, e, t) {
        const n = o.parent, i = n.parent, r = n.index, s = e - r, a = {}, l = parseInt(o.getAttribute("rowspan")) - s;
        l > 1 && (a.rowspan = l);
        const c = parseInt(o.getAttribute("colspan") || "1");
        c > 1 && (a.colspan = c);
        const d = r + s, u = [...new we(i, { startRow: r, endRow: d, includeAllSlots: !0 })];
        let g, p = null;
        for (const b of u) {
          const { row: w, column: y, cell: I } = b;
          I === o && g === void 0 && (g = y), g !== void 0 && g === y && w === d && (p = In(t, b.getPositionBefore(), a));
        }
        return qe("rowspan", s, o, t), p;
      }
      function nf(o, e) {
        const t = [], n = new we(o);
        for (const i of n) {
          const { column: r, cellWidth: s } = i;
          r < e && e <= r + s - 1 && t.push(i);
        }
        return t;
      }
      function of(o, e, t, n) {
        const i = t - e, r = {}, s = parseInt(o.getAttribute("colspan")) - i;
        s > 1 && (r.colspan = s);
        const a = parseInt(o.getAttribute("rowspan") || "1");
        a > 1 && (r.rowspan = a);
        const l = In(n, n.createPositionAfter(o), r);
        return qe("colspan", i, o, n), l;
      }
      function rf(o, e, t, n, i, r) {
        const s = parseInt(o.getAttribute("colspan") || "1"), a = parseInt(o.getAttribute("rowspan") || "1");
        t + s - 1 > i && qe("colspan", i - t + 1, o, r, 1), e + a - 1 > n && qe("rowspan", n - e + 1, o, r, 1);
      }
      function qa(o, e) {
        const t = e.getColumns(o), n = new Array(t).fill(0);
        for (const { column: r } of new we(o)) n[r]++;
        const i = n.reduce((r, s, a) => s ? r : [...r, a], []);
        if (i.length > 0) {
          const r = i[i.length - 1];
          return e.removeColumns(o, { at: r }), !0;
        }
        return !1;
      }
      function Ua(o, e) {
        const t = [], n = e.getRows(o);
        for (let i = 0; i < n; i++)
          o.getChild(i).isEmpty && t.push(i);
        if (t.length > 0) {
          const i = t[t.length - 1];
          return e.removeRows(o, { at: i }), !0;
        }
        return !1;
      }
      function Wa(o, e) {
        qa(o, e) || Ua(o, e);
      }
      function sf(o, e) {
        const t = Array.from(new we(o, { startColumn: e.firstColumn, endColumn: e.lastColumn, row: e.lastRow }));
        if (t.every(({ cellHeight: i }) => i === 1)) return e.lastRow;
        const n = t[0].cellHeight - 1;
        return e.lastRow + n;
      }
      function af(o, e) {
        const t = Array.from(new we(o, { startRow: e.firstRow, endRow: e.lastRow, column: e.lastColumn }));
        if (t.every(({ cellWidth: i }) => i === 1)) return e.lastColumn;
        const n = t[0].cellWidth - 1;
        return e.lastColumn + n;
      }
      class gr extends ae {
        constructor(e, t) {
          super(e), this.direction = t.direction, this.isHorizontal = this.direction == "right" || this.direction == "left";
        }
        refresh() {
          const e = this._getMergeableCell();
          this.value = e, this.isEnabled = !!e;
        }
        execute() {
          const e = this.editor.model, t = e.document, n = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(t.selection)[0], i = this.value, r = this.direction;
          e.change((s) => {
            const a = r == "right" || r == "down", l = a ? n : i, c = a ? i : n, d = c.parent;
            (function(w, y, I) {
              lf(w) || (lf(y) && I.remove(I.createRangeIn(y)), I.move(I.createRangeIn(w), I.createPositionAt(y, "end"))), I.remove(w);
            })(c, l, s);
            const u = this.isHorizontal ? "colspan" : "rowspan", g = parseInt(n.getAttribute(u) || "1"), p = parseInt(i.getAttribute(u) || "1");
            s.setAttribute(u, g + p, l), s.setSelection(s.createRangeIn(l));
            const b = this.editor.plugins.get("TableUtils");
            Wa(d.findAncestor("table"), b);
          });
        }
        _getMergeableCell() {
          const e = this.editor.model.document, t = this.editor.plugins.get("TableUtils"), n = t.getTableCellsContainingSelection(e.selection)[0];
          if (!n) return;
          const i = this.isHorizontal ? function(a, l, c) {
            const d = a.parent, u = d.parent, g = l == "right" ? a.nextSibling : a.previousSibling, p = (u.getAttribute("headingColumns") || 0) > 0;
            if (!g) return;
            const b = l == "right" ? a : g, w = l == "right" ? g : a, { column: y } = c.getCellLocation(b), { column: I } = c.getCellLocation(w), z = parseInt(b.getAttribute("colspan") || "1"), H = Ha(c, b), X = Ha(c, w);
            if (!(p && H != X))
              return y + z === I ? g : void 0;
          }(n, this.direction, t) : function(a, l, c) {
            const d = a.parent, u = d.parent, g = u.getChildIndex(d);
            if (l == "down" && g === c.getRows(u) - 1 || l == "up" && g === 0) return null;
            const p = parseInt(a.getAttribute("rowspan") || "1"), b = u.getAttribute("headingRows") || 0, w = l == "down" && g + p === b, y = l == "up" && g === b;
            if (b && (w || y)) return null;
            const I = parseInt(a.getAttribute("rowspan") || "1"), z = l == "down" ? g + I : g, H = [...new we(u, { endRow: z })], X = H.find((be) => be.cell === a), ce = X.column, Oe = H.find(({ row: be, cellHeight: Qt, column: kt }) => kt === ce && (l == "down" ? be === z : z === be + Qt));
            return Oe && Oe.cell ? Oe.cell : null;
          }(n, this.direction, t);
          if (!i) return;
          const r = this.isHorizontal ? "rowspan" : "colspan", s = parseInt(n.getAttribute(r) || "1");
          return parseInt(i.getAttribute(r) || "1") === s ? i : void 0;
        }
      }
      function lf(o) {
        const e = o.getChild(0);
        return o.childCount == 1 && e.is("element", "paragraph") && e.isEmpty;
      }
      class uE extends ae {
        refresh() {
          const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), n = t[0];
          if (n) {
            const i = n.findAncestor("table"), r = e.getRows(i) - 1, s = e.getRowIndexes(t), a = s.first === 0 && s.last === r;
            this.isEnabled = !a;
          } else this.isEnabled = !1;
        }
        execute() {
          const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), i = t.getRowIndexes(n), r = n[0], s = r.findAncestor("table"), a = t.getCellLocation(r).column;
          e.change((l) => {
            const c = i.last - i.first + 1;
            t.removeRows(s, { at: i.first, rows: c });
            const d = function(u, g, p, b) {
              const w = u.getChild(Math.min(g, b - 1));
              let y = w.getChild(0), I = 0;
              for (const z of w.getChildren()) {
                if (I > p) return y;
                y = z, I += parseInt(z.getAttribute("colspan") || "1");
              }
              return y;
            }(s, i.first, a, t.getRows(s));
            l.setSelection(l.createPositionAt(d, 0));
          });
        }
      }
      class hE extends ae {
        refresh() {
          const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), n = t[0];
          if (n) {
            const i = n.findAncestor("table"), r = e.getColumns(i), { first: s, last: a } = e.getColumnIndexes(t);
            this.isEnabled = a - s < r - 1;
          } else this.isEnabled = !1;
        }
        execute() {
          const e = this.editor.plugins.get("TableUtils"), [t, n] = function(l, c) {
            const d = c.getSelectionAffectedTableCells(l), u = d[0], g = d.pop(), p = [u, g];
            return u.isBefore(g) ? p : p.reverse();
          }(this.editor.model.document.selection, e), i = t.parent.parent, r = [...new we(i)], s = { first: r.find((l) => l.cell === t).column, last: r.find((l) => l.cell === n).column }, a = function(l, c, d, u) {
            return parseInt(d.getAttribute("colspan") || "1") > 1 ? d : c.previousSibling || d.nextSibling ? d.nextSibling || c.previousSibling : u.first ? l.reverse().find(({ column: p }) => p < u.first).cell : l.reverse().find(({ column: p }) => p > u.last).cell;
          }(r, t, n, s);
          this.editor.model.change((l) => {
            const c = s.last - s.first + 1;
            e.removeColumns(i, { at: s.first, columns: c }), l.setSelection(l.createPositionAt(a, 0));
          });
        }
      }
      class gE extends ae {
        refresh() {
          const e = this.editor.plugins.get("TableUtils"), t = this.editor.model, n = e.getSelectionAffectedTableCells(t.document.selection), i = n.length > 0;
          this.isEnabled = i, this.value = i && n.every((r) => this._isInHeading(r, r.parent.parent));
        }
        execute(e = {}) {
          if (e.forceValue === this.value) return;
          const t = this.editor.plugins.get("TableUtils"), n = this.editor.model, i = t.getSelectionAffectedTableCells(n.document.selection), r = i[0].findAncestor("table"), { first: s, last: a } = t.getRowIndexes(i), l = this.value ? s : a + 1, c = r.getAttribute("headingRows") || 0;
          n.change((d) => {
            if (l) {
              const u = ef(r, l, l > c ? c : 0);
              for (const { cell: g } of u) tf(g, l, d);
            }
            qe("headingRows", l, r, d, 0);
          });
        }
        _isInHeading(e, t) {
          const n = parseInt(t.getAttribute("headingRows") || "0");
          return !!n && e.parent.index < n;
        }
      }
      class mE extends ae {
        refresh() {
          const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), i = n.length > 0;
          this.isEnabled = i, this.value = i && n.every((r) => Ha(t, r));
        }
        execute(e = {}) {
          if (e.forceValue === this.value) return;
          const t = this.editor.plugins.get("TableUtils"), n = this.editor.model, i = t.getSelectionAffectedTableCells(n.document.selection), r = i[0].findAncestor("table"), { first: s, last: a } = t.getColumnIndexes(i), l = this.value ? s : a + 1;
          n.change((c) => {
            if (l) {
              const d = nf(r, l);
              for (const { cell: u, column: g } of d) of(u, g, l, c);
            }
            qe("headingColumns", l, r, c, 0);
          });
        }
      }
      class nt extends K {
        static get pluginName() {
          return "TableUtils";
        }
        init() {
          this.decorate("insertColumns"), this.decorate("insertRows");
        }
        getCellLocation(e) {
          const t = e.parent, n = t.parent, i = n.getChildIndex(t), r = new we(n, { row: i });
          for (const { cell: s, row: a, column: l } of r) if (s === e) return { row: a, column: l };
        }
        createTable(e, t) {
          const n = e.createElement("table"), i = t.rows || 2, r = t.columns || 2;
          return Ka(e, n, 0, i, r), t.headingRows && qe("headingRows", Math.min(t.headingRows, i), n, e, 0), t.headingColumns && qe("headingColumns", Math.min(t.headingColumns, r), n, e, 0), n;
        }
        insertRows(e, t = {}) {
          const n = this.editor.model, i = t.at || 0, r = t.rows || 1, s = t.copyStructureFromAbove !== void 0, a = t.copyStructureFromAbove ? i - 1 : i, l = this.getRows(e), c = this.getColumns(e);
          if (i > l) throw new T("tableutils-insertrows-insert-out-of-range", this, { options: t });
          n.change((d) => {
            const u = e.getAttribute("headingRows") || 0;
            if (u > i && qe("headingRows", u + r, e, d, 0), !s && (i === 0 || i === l)) return void Ka(d, e, i, r, c);
            const g = s ? Math.max(i, a) : i, p = new we(e, { endRow: g }), b = new Array(c).fill(1);
            for (const { row: w, column: y, cellHeight: I, cellWidth: z, cell: H } of p) {
              const X = w + I - 1, ce = w <= a && a <= X;
              w < i && i <= X ? (d.setAttribute("rowspan", I + r, H), b[y] = -z) : s && ce && (b[y] = z);
            }
            for (let w = 0; w < r; w++) {
              const y = d.createElement("tableRow");
              d.insert(y, e, i);
              for (let I = 0; I < b.length; I++) {
                const z = b[I], H = d.createPositionAt(y, "end");
                z > 0 && In(d, H, z > 1 ? { colspan: z } : void 0), I += Math.abs(z) - 1;
              }
            }
          });
        }
        insertColumns(e, t = {}) {
          const n = this.editor.model, i = t.at || 0, r = t.columns || 1;
          n.change((s) => {
            const a = e.getAttribute("headingColumns");
            i < a && s.setAttribute("headingColumns", a + r, e);
            const l = this.getColumns(e);
            if (i === 0 || l === i) {
              for (const d of e.getChildren()) d.is("element", "tableRow") && ko(r, s, s.createPositionAt(d, i ? "end" : 0));
              return;
            }
            const c = new we(e, { column: i, includeAllSlots: !0 });
            for (const d of c) {
              const { row: u, cell: g, cellAnchorColumn: p, cellAnchorRow: b, cellWidth: w, cellHeight: y } = d;
              if (p < i) {
                s.setAttribute("colspan", w + r, g);
                const I = b + y - 1;
                for (let z = u; z <= I; z++) c.skipRow(z);
              } else ko(r, s, d.getPositionBefore());
            }
          });
        }
        removeRows(e, t) {
          const n = this.editor.model, i = t.rows || 1, r = this.getRows(e), s = t.at, a = s + i - 1;
          if (a > r - 1) throw new T("tableutils-removerows-row-index-out-of-range", this, { table: e, options: t });
          n.change((l) => {
            const c = { first: s, last: a }, { cellsToMove: d, cellsToTrim: u } = function(g, { first: p, last: b }) {
              const w = /* @__PURE__ */ new Map(), y = [];
              for (const { row: I, column: z, cellHeight: H, cell: X } of new we(g, { endRow: b })) {
                const ce = I + H - 1;
                if (I >= p && I <= b && ce > b) {
                  const Oe = H - (b - I + 1);
                  w.set(z, { cell: X, rowspan: Oe });
                }
                if (I < p && ce >= p) {
                  let Oe;
                  Oe = ce >= b ? b - p + 1 : ce - p + 1, y.push({ cell: X, rowspan: H - Oe });
                }
              }
              return { cellsToMove: w, cellsToTrim: y };
            }(e, c);
            d.size && function(g, p, b, w) {
              const y = new we(g, { includeAllSlots: !0, row: p }), I = [...y], z = g.getChild(p);
              let H;
              for (const { column: X, cell: ce, isAnchor: Oe } of I) if (b.has(X)) {
                const { cell: be, rowspan: Qt } = b.get(X), kt = H ? w.createPositionAfter(H) : w.createPositionAt(z, 0);
                w.move(w.createRangeOn(be), kt), qe("rowspan", Qt, be, w), H = be;
              } else Oe && (H = ce);
            }(e, a + 1, d, l);
            for (let g = a; g >= s; g--) l.remove(e.getChild(g));
            for (const { rowspan: g, cell: p } of u) qe("rowspan", g, p, l);
            (function(g, { first: p, last: b }, w) {
              const y = g.getAttribute("headingRows") || 0;
              p < y && qe("headingRows", b < y ? y - (b - p + 1) : p, g, w, 0);
            })(e, c, l), qa(e, this) || Ua(e, this);
          });
        }
        removeColumns(e, t) {
          const n = this.editor.model, i = t.at, r = t.columns || 1, s = t.at + r - 1;
          n.change((a) => {
            (function(l, c, d) {
              const u = l.getAttribute("headingColumns") || 0;
              if (u && c.first < u) {
                const g = Math.min(u - 1, c.last) - c.first + 1;
                d.setAttribute("headingColumns", u - g, l);
              }
            })(e, { first: i, last: s }, a);
            for (let l = s; l >= i; l--) for (const { cell: c, column: d, cellWidth: u } of [...new we(e)]) d <= l && u > 1 && d + u > l ? qe("colspan", u - 1, c, a) : d === l && a.remove(c);
            Ua(e, this) || qa(e, this);
          });
        }
        splitCellVertically(e, t = 2) {
          const n = this.editor.model, i = e.parent.parent, r = parseInt(e.getAttribute("rowspan") || "1"), s = parseInt(e.getAttribute("colspan") || "1");
          n.change((a) => {
            if (s > 1) {
              const { newCellsSpan: l, updatedSpan: c } = cf(s, t);
              qe("colspan", c, e, a);
              const d = {};
              l > 1 && (d.colspan = l), r > 1 && (d.rowspan = r), ko(s > t ? t - 1 : s - 1, a, a.createPositionAfter(e), d);
            }
            if (s < t) {
              const l = t - s, c = [...new we(i)], { column: d } = c.find(({ cell: b }) => b === e), u = c.filter(({ cell: b, cellWidth: w, column: y }) => b !== e && y === d || y < d && y + w > d);
              for (const { cell: b, cellWidth: w } of u) a.setAttribute("colspan", w + l, b);
              const g = {};
              r > 1 && (g.rowspan = r), ko(l, a, a.createPositionAfter(e), g);
              const p = i.getAttribute("headingColumns") || 0;
              p > d && qe("headingColumns", p + l, i, a);
            }
          });
        }
        splitCellHorizontally(e, t = 2) {
          const n = this.editor.model, i = e.parent, r = i.parent, s = r.getChildIndex(i), a = parseInt(e.getAttribute("rowspan") || "1"), l = parseInt(e.getAttribute("colspan") || "1");
          n.change((c) => {
            if (a > 1) {
              const d = [...new we(r, { startRow: s, endRow: s + a - 1, includeAllSlots: !0 })], { newCellsSpan: u, updatedSpan: g } = cf(a, t);
              qe("rowspan", g, e, c);
              const { column: p } = d.find(({ cell: w }) => w === e), b = {};
              u > 1 && (b.rowspan = u), l > 1 && (b.colspan = l);
              for (const w of d) {
                const { column: y, row: I } = w;
                I >= s + g && y === p && (I + s + g) % u == 0 && ko(1, c, w.getPositionBefore(), b);
              }
            }
            if (a < t) {
              const d = t - a, u = [...new we(r, { startRow: 0, endRow: s })];
              for (const { cell: b, cellHeight: w, row: y } of u) if (b !== e && y + w > s) {
                const I = w + d;
                c.setAttribute("rowspan", I, b);
              }
              const g = {};
              l > 1 && (g.colspan = l), Ka(c, r, s + 1, d, 1, g);
              const p = r.getAttribute("headingRows") || 0;
              p > s && qe("headingRows", p + d, r, c);
            }
          });
        }
        getColumns(e) {
          return [...e.getChild(0).getChildren()].reduce((t, n) => t + parseInt(n.getAttribute("colspan") || "1"), 0);
        }
        getRows(e) {
          return Array.from(e.getChildren()).reduce((t, n) => n.is("element", "tableRow") ? t + 1 : t, 0);
        }
        createTableWalker(e, t = {}) {
          return new we(e, t);
        }
        getSelectedTableCells(e) {
          const t = [];
          for (const n of this.sortRanges(e.getRanges())) {
            const i = n.getContainedElement();
            i && i.is("element", "tableCell") && t.push(i);
          }
          return t;
        }
        getTableCellsContainingSelection(e) {
          const t = [];
          for (const n of e.getRanges()) {
            const i = n.start.findAncestor("tableCell");
            i && t.push(i);
          }
          return t;
        }
        getSelectionAffectedTableCells(e) {
          const t = this.getSelectedTableCells(e);
          return t.length ? t : this.getTableCellsContainingSelection(e);
        }
        getRowIndexes(e) {
          const t = e.map((n) => n.parent.index);
          return this._getFirstLastIndexesObject(t);
        }
        getColumnIndexes(e) {
          const t = e[0].findAncestor("table"), n = [...new we(t)].filter((i) => e.includes(i.cell)).map((i) => i.column);
          return this._getFirstLastIndexesObject(n);
        }
        isSelectionRectangular(e) {
          if (e.length < 2 || !this._areCellInTheSameTableSection(e)) return !1;
          const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
          let i = 0;
          for (const s of e) {
            const { row: a, column: l } = this.getCellLocation(s), c = parseInt(s.getAttribute("rowspan")) || 1, d = parseInt(s.getAttribute("colspan")) || 1;
            t.add(a), n.add(l), c > 1 && t.add(a + c - 1), d > 1 && n.add(l + d - 1), i += c * d;
          }
          return function(s, a) {
            const l = Array.from(s.values()), c = Array.from(a.values()), d = Math.max(...l), u = Math.min(...l), g = Math.max(...c), p = Math.min(...c);
            return (d - u + 1) * (g - p + 1);
          }(t, n) == i;
        }
        sortRanges(e) {
          return Array.from(e).sort(pE);
        }
        _getFirstLastIndexesObject(e) {
          const t = e.sort((n, i) => n - i);
          return { first: t[0], last: t[t.length - 1] };
        }
        _areCellInTheSameTableSection(e) {
          const t = e[0].findAncestor("table"), n = this.getRowIndexes(e), i = parseInt(t.getAttribute("headingRows")) || 0;
          if (!this._areIndexesInSameSection(n, i)) return !1;
          const r = this.getColumnIndexes(e), s = parseInt(t.getAttribute("headingColumns")) || 0;
          return this._areIndexesInSameSection(r, s);
        }
        _areIndexesInSameSection({ first: e, last: t }, n) {
          return e < n == t < n;
        }
      }
      function Ka(o, e, t, n, i, r = {}) {
        for (let s = 0; s < n; s++) {
          const a = o.createElement("tableRow");
          o.insert(a, e, t), ko(i, o, o.createPositionAt(a, "end"), r);
        }
      }
      function ko(o, e, t, n = {}) {
        for (let i = 0; i < o; i++) In(e, t, n);
      }
      function cf(o, e) {
        if (o < e) return { newCellsSpan: 1, updatedSpan: 1 };
        const t = Math.floor(o / e);
        return { newCellsSpan: t, updatedSpan: o - t * e + t };
      }
      function pE(o, e) {
        const t = o.start, n = e.start;
        return t.isBefore(n) ? -1 : 1;
      }
      class fE extends ae {
        refresh() {
          const e = this.editor.plugins.get(nt), t = e.getSelectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.isSelectionRectangular(t);
        }
        execute() {
          const e = this.editor.model, t = this.editor.plugins.get(nt);
          e.change((n) => {
            const i = t.getSelectedTableCells(e.document.selection), r = i.shift(), { mergeWidth: s, mergeHeight: a } = function(l, c, d) {
              let u = 0, g = 0;
              for (const I of c) {
                const { row: z, column: H } = d.getCellLocation(I);
                u = uf(I, H, u, "colspan"), g = uf(I, z, g, "rowspan");
              }
              const { row: p, column: b } = d.getCellLocation(l), w = u - b, y = g - p;
              return { mergeWidth: w, mergeHeight: y };
            }(r, i, t);
            qe("colspan", s, r, n), qe("rowspan", a, r, n);
            for (const l of i) bE(l, r, n);
            Wa(r.findAncestor("table"), t), n.setSelection(r, "in");
          });
        }
      }
      function bE(o, e, t) {
        df(o) || (df(e) && t.remove(t.createRangeIn(e)), t.move(t.createRangeIn(o), t.createPositionAt(e, "end"))), t.remove(o);
      }
      function df(o) {
        const e = o.getChild(0);
        return o.childCount == 1 && e.is("element", "paragraph") && e.isEmpty;
      }
      function uf(o, e, t, n) {
        const i = parseInt(o.getAttribute(n) || "1");
        return Math.max(t, e + i);
      }
      class kE extends ae {
        constructor(e) {
          super(e), this.affectsData = !1;
        }
        refresh() {
          const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.length > 0;
        }
        execute() {
          const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), i = t.getRowIndexes(n), r = n[0].findAncestor("table"), s = [];
          for (let a = i.first; a <= i.last; a++) for (const l of r.getChild(a).getChildren()) s.push(e.createRangeOn(l));
          e.change((a) => {
            a.setSelection(s);
          });
        }
      }
      class wE extends ae {
        constructor(e) {
          super(e), this.affectsData = !1;
        }
        refresh() {
          const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = e.length > 0;
        }
        execute() {
          const e = this.editor.plugins.get("TableUtils"), t = this.editor.model, n = e.getSelectionAffectedTableCells(t.document.selection), i = n[0], r = n.pop(), s = i.findAncestor("table"), a = e.getCellLocation(i), l = e.getCellLocation(r), c = Math.min(a.column, l.column), d = Math.max(a.column, l.column), u = [];
          for (const g of new we(s, { startColumn: c, endColumn: d })) u.push(t.createRangeOn(g.cell));
          t.change((g) => {
            g.setSelection(u);
          });
        }
      }
      function AE(o) {
        o.document.registerPostFixer((e) => function(t, n) {
          const i = n.document.differ.getChanges();
          let r = !1;
          const s = /* @__PURE__ */ new Set();
          for (const a of i) {
            let l = null;
            a.type == "insert" && a.name == "table" && (l = a.position.nodeAfter), a.type != "insert" && a.type != "remove" || a.name != "tableRow" && a.name != "tableCell" || (l = a.position.findAncestor("table")), CE(a) && (l = a.range.start.findAncestor("table")), l && !s.has(l) && (r = _E(l, t) || r, r = vE(l, t) || r, s.add(l));
          }
          return r;
        }(e, o));
      }
      function _E(o, e) {
        let t = !1;
        const n = function(i) {
          const r = parseInt(i.getAttribute("headingRows") || "0"), s = Array.from(i.getChildren()).reduce((l, c) => c.is("element", "tableRow") ? l + 1 : l, 0), a = [];
          for (const { row: l, cell: c, cellHeight: d } of new we(i)) {
            if (d < 2) continue;
            const u = l < r ? r : s;
            if (l + d > u) {
              const g = u - l;
              a.push({ cell: c, rowspan: g });
            }
          }
          return a;
        }(o);
        if (n.length) {
          t = !0;
          for (const i of n) qe("rowspan", i.rowspan, i.cell, e, 1);
        }
        return t;
      }
      function vE(o, e) {
        let t = !1;
        const n = function(a) {
          const l = new Array(a.childCount).fill(0);
          for (const { rowIndex: c } of new we(a, { includeAllSlots: !0 })) l[c]++;
          return l;
        }(o), i = [];
        for (const [a, l] of n.entries()) !l && o.getChild(a).is("element", "tableRow") && i.push(a);
        if (i.length) {
          t = !0;
          for (const a of i.reverse()) e.remove(o.getChild(a)), n.splice(a, 1);
        }
        const r = n.filter((a, l) => o.getChild(l).is("element", "tableRow")), s = r[0];
        if (!r.every((a) => a === s)) {
          const a = r.reduce((l, c) => c > l ? c : l, 0);
          for (const [l, c] of r.entries()) {
            const d = a - c;
            if (d) {
              for (let u = 0; u < d; u++) In(e, e.createPositionAt(o.getChild(l), "end"));
              t = !0;
            }
          }
        }
        return t;
      }
      function CE(o) {
        if (o.type !== "attribute") return !1;
        const e = o.attributeKey;
        return e === "headingRows" || e === "colspan" || e === "rowspan";
      }
      function yE(o) {
        o.document.registerPostFixer((e) => function(t, n) {
          const i = n.document.differ.getChanges();
          let r = !1;
          for (const s of i) s.type == "insert" && s.name == "table" && (r = EE(s.position.nodeAfter, t) || r), s.type == "insert" && s.name == "tableRow" && (r = hf(s.position.nodeAfter, t) || r), s.type == "insert" && s.name == "tableCell" && (r = Ga(s.position.nodeAfter, t) || r), s.type != "remove" && s.type != "insert" || !xE(s) || (r = Ga(s.position.parent, t) || r);
          return r;
        }(e, o));
      }
      function EE(o, e) {
        let t = !1;
        for (const n of o.getChildren()) n.is("element", "tableRow") && (t = hf(n, e) || t);
        return t;
      }
      function hf(o, e) {
        let t = !1;
        for (const n of o.getChildren()) t = Ga(n, e) || t;
        return t;
      }
      function Ga(o, e) {
        if (o.childCount == 0) return e.insertElement("paragraph", o), !0;
        const t = Array.from(o.getChildren()).filter((n) => n.is("$text"));
        for (const n of t) e.wrap(e.createRangeOn(n), "paragraph");
        return !!t.length;
      }
      function xE(o) {
        return !!o.position.parent.is("element", "tableCell") && (o.type == "insert" && o.name == "$text" || o.type == "remove");
      }
      function SE(o, e) {
        if (!o.is("element", "paragraph")) return !1;
        const t = e.toViewElement(o);
        return !!t && Zp(o) !== t.is("element", "span");
      }
      var gf = D(3881), DE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(gf.Z, DE), gf.Z.locals;
      class BE extends K {
        constructor(e) {
          super(e), this._additionalSlots = [];
        }
        static get pluginName() {
          return "TableEditing";
        }
        static get requires() {
          return [nt];
        }
        init() {
          const e = this.editor, t = e.model, n = t.schema, i = e.conversion, r = e.plugins.get(nt);
          n.register("table", { inheritAllFrom: "$blockObject", allowAttributes: ["headingRows", "headingColumns"] }), n.register("tableRow", { allowIn: "table", isLimit: !0 }), n.register("tableCell", { allowContentOf: "$container", allowIn: "tableRow", allowAttributes: ["colspan", "rowspan"], isLimit: !0, isSelectable: !0 }), i.for("upcast").add((s) => {
            s.on("element:figure", (a, l, c) => {
              if (!c.consumable.test(l.viewItem, { name: !0, classes: "table" })) return;
              const d = function(g) {
                for (const p of g.getChildren()) if (p.is("element", "table")) return p;
              }(l.viewItem);
              if (!d || !c.consumable.test(d, { name: !0 })) return;
              c.consumable.consume(l.viewItem, { name: !0, classes: "table" });
              const u = Ke(c.convertItem(d, l.modelCursor).modelRange.getItems());
              u ? (c.convertChildren(l.viewItem, c.writer.createPositionAt(u, "end")), c.updateConversionResult(u, l)) : c.consumable.revert(l.viewItem, { name: !0, classes: "table" });
            });
          }), i.for("upcast").add(aE()), i.for("editingDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: Wp(r, { asWidget: !0, additionalSlots: this._additionalSlots }) }), i.for("dataDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: Wp(r, { additionalSlots: this._additionalSlots }) }), i.for("upcast").elementToElement({ model: "tableRow", view: "tr" }), i.for("upcast").add((s) => {
            s.on("element:tr", (a, l) => {
              l.viewItem.isEmpty && l.modelCursor.index == 0 && a.stop();
            }, { priority: "high" });
          }), i.for("downcast").elementToElement({ model: "tableRow", view: (s, { writer: a }) => s.isEmpty ? a.createEmptyElement("tr") : a.createContainerElement("tr") }), i.for("upcast").elementToElement({ model: "tableCell", view: "td" }), i.for("upcast").elementToElement({ model: "tableCell", view: "th" }), i.for("upcast").add(Up("td")), i.for("upcast").add(Up("th")), i.for("editingDowncast").elementToElement({ model: "tableCell", view: Kp({ asWidget: !0 }) }), i.for("dataDowncast").elementToElement({ model: "tableCell", view: Kp() }), i.for("editingDowncast").elementToElement({ model: "paragraph", view: Gp({ asWidget: !0 }), converterPriority: "high" }), i.for("dataDowncast").elementToElement({ model: "paragraph", view: Gp(), converterPriority: "high" }), i.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" }), i.for("upcast").attributeToAttribute({ model: { key: "colspan", value: mf("colspan") }, view: "colspan" }), i.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" }), i.for("upcast").attributeToAttribute({ model: { key: "rowspan", value: mf("rowspan") }, view: "rowspan" }), e.config.define("table.defaultHeadings.rows", 0), e.config.define("table.defaultHeadings.columns", 0), e.commands.add("insertTable", new dE(e)), e.commands.add("insertTableRowAbove", new Jp(e, { order: "above" })), e.commands.add("insertTableRowBelow", new Jp(e, { order: "below" })), e.commands.add("insertTableColumnLeft", new Yp(e, { order: "left" })), e.commands.add("insertTableColumnRight", new Yp(e, { order: "right" })), e.commands.add("removeTableRow", new uE(e)), e.commands.add("removeTableColumn", new hE(e)), e.commands.add("splitTableCellVertically", new Qp(e, { direction: "vertically" })), e.commands.add("splitTableCellHorizontally", new Qp(e, { direction: "horizontally" })), e.commands.add("mergeTableCells", new fE(e)), e.commands.add("mergeTableCellRight", new gr(e, { direction: "right" })), e.commands.add("mergeTableCellLeft", new gr(e, { direction: "left" })), e.commands.add("mergeTableCellDown", new gr(e, { direction: "down" })), e.commands.add("mergeTableCellUp", new gr(e, { direction: "up" })), e.commands.add("setTableColumnHeader", new mE(e)), e.commands.add("setTableRowHeader", new gE(e)), e.commands.add("selectTableRow", new kE(e)), e.commands.add("selectTableColumn", new wE(e)), AE(t), yE(t), this.listenTo(t.document, "change:data", () => {
            (function(s, a) {
              const l = s.document.differ;
              for (const c of l.getChanges()) {
                let d, u = !1;
                if (c.type == "attribute") {
                  const w = c.range.start.nodeAfter;
                  if (!w || !w.is("element", "table") || c.attributeKey != "headingRows" && c.attributeKey != "headingColumns") continue;
                  d = w, u = c.attributeKey == "headingRows";
                } else c.name != "tableRow" && c.name != "tableCell" || (d = c.position.findAncestor("table"), u = c.name == "tableRow");
                if (!d) continue;
                const g = d.getAttribute("headingRows") || 0, p = d.getAttribute("headingColumns") || 0, b = new we(d);
                for (const w of b) {
                  const y = w.row < g || w.column < p ? "th" : "td", I = a.mapper.toViewElement(w.cell);
                  I && I.is("element") && I.name != y && a.reconvertItem(u ? w.cell.parent : w.cell);
                }
              }
            })(t, e.editing), function(s, a) {
              const l = s.document.differ, c = /* @__PURE__ */ new Set();
              for (const d of l.getChanges()) {
                const u = d.type == "attribute" ? d.range.start.parent : d.position.parent;
                u.is("element", "tableCell") && c.add(u);
              }
              for (const d of c.values()) {
                const u = Array.from(d.getChildren()).filter((g) => SE(g, a.mapper));
                for (const g of u) a.reconvertItem(g);
              }
            }(t, e.editing);
          });
        }
        registerAdditionalSlot(e) {
          this._additionalSlots.push(e);
        }
      }
      function mf(o) {
        return (e) => {
          const t = parseInt(e.getAttribute(o));
          return Number.isNaN(t) || t <= 0 ? null : t;
        };
      }
      var pf = D(1613), TE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(pf.Z, TE), pf.Z.locals;
      class IE extends de {
        constructor(e) {
          super(e);
          const t = this.bindTemplate;
          this.items = this._createGridCollection(), this.keystrokes = new $t(), this.focusTracker = new Et(), this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (n, i) => `${i} × ${n}`), this.setTemplate({ tag: "div", attributes: { class: ["ck"] }, children: [{ tag: "div", attributes: { class: ["ck-insert-table-dropdown__grid"] }, on: { "mouseover@.ck-insert-table-dropdown-grid-box": t.to("boxover") }, children: this.items }, { tag: "div", attributes: { class: ["ck", "ck-insert-table-dropdown__label"], "aria-hidden": !0 }, children: [{ text: t.to("label") }] }], on: { mousedown: t.to((n) => {
            n.preventDefault();
          }), click: t.to(() => {
            this.fire("execute");
          }) } }), this.on("boxover", (n, i) => {
            const { row: r, column: s } = i.target.dataset;
            this.items.get(10 * (parseInt(r, 10) - 1) + (parseInt(s, 10) - 1)).focus();
          }), this.focusTracker.on("change:focusedElement", (n, i, r) => {
            if (!r) return;
            const { row: s, column: a } = r.dataset;
            this.set({ rows: parseInt(s), columns: parseInt(a) });
          }), this.on("change:columns", () => this._highlightGridBoxes()), this.on("change:rows", () => this._highlightGridBoxes());
        }
        render() {
          super.render(), function({ keystrokeHandler: e, focusTracker: t, gridItems: n, numberOfColumns: i, uiLanguageDirection: r }) {
            const s = typeof i == "number" ? () => i : i;
            function a(d) {
              return (u) => {
                const g = n.find((w) => w.element === t.focusedElement), p = n.getIndex(g), b = d(p, n);
                n.get(b).focus(), u.stopPropagation(), u.preventDefault();
              };
            }
            function l(d, u) {
              return d === u - 1 ? 0 : d + 1;
            }
            function c(d, u) {
              return d === 0 ? u - 1 : d - 1;
            }
            e.set("arrowright", a((d, u) => r === "rtl" ? c(d, u.length) : l(d, u.length))), e.set("arrowleft", a((d, u) => r === "rtl" ? l(d, u.length) : c(d, u.length))), e.set("arrowup", a((d, u) => {
              let g = d - s();
              return g < 0 && (g = d + s() * Math.floor(u.length / s()), g > u.length - 1 && (g -= s())), g;
            })), e.set("arrowdown", a((d, u) => {
              let g = d + s();
              return g > u.length - 1 && (g = d % s()), g;
            }));
          }({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.items, numberOfColumns: 10, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection });
          for (const e of this.items) this.focusTracker.add(e.element);
          this.keystrokes.listenTo(this.element);
        }
        focus() {
          this.items.get(0).focus();
        }
        focusLast() {
          this.items.get(0).focus();
        }
        _highlightGridBoxes() {
          const e = this.rows, t = this.columns;
          this.items.map((n, i) => {
            const r = Math.floor(i / 10) < e && i % 10 < t;
            n.set("isOn", r);
          });
        }
        _createGridButton(e, t, n, i) {
          const r = new De(e);
          return r.set({ label: i, class: "ck-insert-table-dropdown-grid-box" }), r.extendTemplate({ attributes: { "data-row": t, "data-column": n } }), r;
        }
        _createGridCollection() {
          const e = [];
          for (let t = 0; t < 100; t++) {
            const n = Math.floor(t / 10), i = t % 10, r = `${n + 1} × ${i + 1}`;
            e.push(this._createGridButton(this.locale, n + 1, i + 1, r));
          }
          return this.createCollection(e);
        }
      }
      class PE extends K {
        static get pluginName() {
          return "TableUI";
        }
        init() {
          const e = this.editor, t = this.editor.t, n = e.locale.contentLanguageDirection === "ltr";
          e.ui.componentFactory.add("insertTable", (i) => {
            const r = e.commands.get("insertTable"), s = Kt(i);
            let a;
            return s.bind("isEnabled").to(r), s.buttonView.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>', label: t("Insert table"), tooltip: !0 }), s.on("change:isOpen", () => {
              a || (a = new IE(i), s.panelView.children.add(a), a.delegate("execute").to(s), s.on("execute", () => {
                e.execute("insertTable", { rows: a.rows, columns: a.columns }), e.editing.view.focus();
              }));
            }), s;
          }), e.ui.componentFactory.add("tableColumn", (i) => {
            const r = [{ type: "switchbutton", model: { commandName: "setTableColumnHeader", label: t("Header column"), bindIsOn: !0 } }, { type: "separator" }, { type: "button", model: { commandName: n ? "insertTableColumnLeft" : "insertTableColumnRight", label: t("Insert column left") } }, { type: "button", model: { commandName: n ? "insertTableColumnRight" : "insertTableColumnLeft", label: t("Insert column right") } }, { type: "button", model: { commandName: "removeTableColumn", label: t("Delete column") } }, { type: "button", model: { commandName: "selectTableColumn", label: t("Select column") } }];
            return this._prepareDropdown(t("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', r, i);
          }), e.ui.componentFactory.add("tableRow", (i) => {
            const r = [{ type: "switchbutton", model: { commandName: "setTableRowHeader", label: t("Header row"), bindIsOn: !0 } }, { type: "separator" }, { type: "button", model: { commandName: "insertTableRowAbove", label: t("Insert row above") } }, { type: "button", model: { commandName: "insertTableRowBelow", label: t("Insert row below") } }, { type: "button", model: { commandName: "removeTableRow", label: t("Delete row") } }, { type: "button", model: { commandName: "selectTableRow", label: t("Select row") } }];
            return this._prepareDropdown(t("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', r, i);
          }), e.ui.componentFactory.add("mergeTableCells", (i) => {
            const r = [{ type: "button", model: { commandName: "mergeTableCellUp", label: t("Merge cell up") } }, { type: "button", model: { commandName: n ? "mergeTableCellRight" : "mergeTableCellLeft", label: t("Merge cell right") } }, { type: "button", model: { commandName: "mergeTableCellDown", label: t("Merge cell down") } }, { type: "button", model: { commandName: n ? "mergeTableCellLeft" : "mergeTableCellRight", label: t("Merge cell left") } }, { type: "separator" }, { type: "button", model: { commandName: "splitTableCellVertically", label: t("Split cell vertically") } }, { type: "button", model: { commandName: "splitTableCellHorizontally", label: t("Split cell horizontally") } }];
            return this._prepareMergeSplitButtonDropdown(t("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', r, i);
          });
        }
        _prepareDropdown(e, t, n, i) {
          const r = this.editor, s = Kt(i), a = this._fillDropdownWithListOptions(s, n);
          return s.buttonView.set({ label: e, icon: t, tooltip: !0 }), s.bind("isEnabled").toMany(a, "isEnabled", (...l) => l.some((c) => c)), this.listenTo(s, "execute", (l) => {
            r.execute(l.source.commandName), l.source instanceof Di || r.editing.view.focus();
          }), s;
        }
        _prepareMergeSplitButtonDropdown(e, t, n, i) {
          const r = this.editor, s = Kt(i, na), a = "mergeTableCells", l = r.commands.get(a), c = this._fillDropdownWithListOptions(s, n);
          return s.buttonView.set({ label: e, icon: t, tooltip: !0, isEnabled: !0 }), s.bind("isEnabled").toMany([l, ...c], "isEnabled", (...d) => d.some((u) => u)), this.listenTo(s.buttonView, "execute", () => {
            r.execute(a), r.editing.view.focus();
          }), this.listenTo(s, "execute", (d) => {
            r.execute(d.source.commandName), r.editing.view.focus();
          }), s;
        }
        _fillDropdownWithListOptions(e, t) {
          const n = this.editor, i = [], r = new _t();
          for (const s of t) RE(s, n, i, r);
          return oa(e, r), i;
        }
      }
      function RE(o, e, t, n) {
        if (o.type === "button" || o.type === "switchbutton") {
          const i = o.model = new pa(o.model), { commandName: r, bindIsOn: s } = o.model, a = e.commands.get(r);
          t.push(a), i.set({ commandName: r }), i.bind("isEnabled").to(a), s && i.bind("isOn").to(a, "value"), i.set({ withText: !0 });
        }
        n.add(o);
      }
      var ff = D(6945), OE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(ff.Z, OE), ff.Z.locals;
      class Pn extends K {
        static get pluginName() {
          return "TableSelection";
        }
        static get requires() {
          return [nt, nt];
        }
        init() {
          const e = this.editor, t = e.model, n = e.editing.view;
          this.listenTo(t, "deleteContent", (i, r) => this._handleDeleteContent(i, r), { priority: "high" }), this.listenTo(n.document, "insertText", (i, r) => this._handleInsertTextEvent(i, r), { priority: "high" }), this._defineSelectionConverter(), this._enablePluginDisabling();
        }
        getSelectedTableCells() {
          const e = this.editor.plugins.get(nt), t = this.editor.model.document.selection, n = e.getSelectedTableCells(t);
          return n.length == 0 ? null : n;
        }
        getSelectionAsFragment() {
          const e = this.editor.plugins.get(nt), t = this.getSelectedTableCells();
          return t ? this.editor.model.change((n) => {
            const i = n.createDocumentFragment(), { first: r, last: s } = e.getColumnIndexes(t), { first: a, last: l } = e.getRowIndexes(t), c = t[0].findAncestor("table");
            let d = l, u = s;
            if (e.isSelectionRectangular(t)) {
              const p = { firstColumn: r, lastColumn: s, firstRow: a, lastRow: l };
              d = sf(c, p), u = af(c, p);
            }
            const g = Xp(c, { startRow: a, startColumn: r, endRow: d, endColumn: u }, n);
            return n.insert(g, i, 0), i;
          }) : null;
        }
        setCellSelection(e, t) {
          const n = this._getCellsToSelect(e, t);
          this.editor.model.change((i) => {
            i.setSelection(n.cells.map((r) => i.createRangeOn(r)), { backward: n.backward });
          });
        }
        getFocusCell() {
          const e = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
          return e && e.is("element", "tableCell") ? e : null;
        }
        getAnchorCell() {
          const e = Ke(this.editor.model.document.selection.getRanges()).getContainedElement();
          return e && e.is("element", "tableCell") ? e : null;
        }
        _defineSelectionConverter() {
          const e = this.editor, t = /* @__PURE__ */ new Set();
          e.conversion.for("editingDowncast").add((n) => n.on("selection", (i, r, s) => {
            const a = s.writer;
            (function(d) {
              for (const u of t) d.removeClass("ck-editor__editable_selected", u);
              t.clear();
            })(a);
            const l = this.getSelectedTableCells();
            if (!l) return;
            for (const d of l) {
              const u = s.mapper.toViewElement(d);
              a.addClass("ck-editor__editable_selected", u), t.add(u);
            }
            const c = s.mapper.toViewElement(l[l.length - 1]);
            a.setSelection(c, 0);
          }, { priority: "lowest" }));
        }
        _enablePluginDisabling() {
          const e = this.editor;
          this.on("change:isEnabled", () => {
            if (!this.isEnabled) {
              const t = this.getSelectedTableCells();
              if (!t) return;
              e.model.change((n) => {
                const i = n.createPositionAt(t[0], 0), r = e.model.schema.getNearestSelectionRange(i);
                n.setSelection(r);
              });
            }
          });
        }
        _handleDeleteContent(e, t) {
          const n = this.editor.plugins.get(nt), i = t[0], r = t[1], s = this.editor.model, a = !r || r.direction == "backward", l = n.getSelectedTableCells(i);
          l.length && (e.stop(), s.change((c) => {
            const d = l[a ? l.length - 1 : 0];
            s.change((g) => {
              for (const p of l) s.deleteContent(g.createSelection(p, "in"));
            });
            const u = s.schema.getNearestSelectionRange(c.createPositionAt(d, 0));
            i.is("documentSelection") ? c.setSelection(u) : i.setTo(u);
          }));
        }
        _handleInsertTextEvent(e, t) {
          const n = this.editor, i = this.getSelectedTableCells();
          if (!i) return;
          const r = n.editing.view, s = n.editing.mapper, a = i.map((l) => r.createRangeOn(s.toViewElement(l)));
          t.selection = r.createSelection(a);
        }
        _getCellsToSelect(e, t) {
          const n = this.editor.plugins.get("TableUtils"), i = n.getCellLocation(e), r = n.getCellLocation(t), s = Math.min(i.row, r.row), a = Math.max(i.row, r.row), l = Math.min(i.column, r.column), c = Math.max(i.column, r.column), d = new Array(a - s + 1).fill(null).map(() => []), u = { startRow: s, endRow: a, startColumn: l, endColumn: c };
          for (const { row: b, cell: w } of new we(e.findAncestor("table"), u)) d[b - s].push(w);
          const g = r.row < i.row, p = r.column < i.column;
          return g && d.reverse(), p && d.forEach((b) => b.reverse()), { cells: d.flat(), backward: g || p };
        }
      }
      class zE extends K {
        static get pluginName() {
          return "TableClipboard";
        }
        static get requires() {
          return [Pn, nt];
        }
        init() {
          const e = this.editor, t = e.editing.view.document;
          this.listenTo(t, "copy", (n, i) => this._onCopyCut(n, i)), this.listenTo(t, "cut", (n, i) => this._onCopyCut(n, i)), this.listenTo(e.model, "insertContent", (n, [i, r]) => this._onInsertContent(n, i, r), { priority: "high" }), this.decorate("_replaceTableSlotCell");
        }
        _onCopyCut(e, t) {
          const n = this.editor.plugins.get(Pn);
          if (!n.getSelectedTableCells() || e.name == "cut" && !this.editor.model.canEditAt(this.editor.model.document.selection)) return;
          t.preventDefault(), e.stop();
          const i = this.editor.data, r = this.editor.editing.view.document, s = i.toView(n.getSelectionAsFragment());
          r.fire("clipboardOutput", { dataTransfer: t.dataTransfer, content: s, method: e.name });
        }
        _onInsertContent(e, t, n) {
          if (n && !n.is("documentSelection")) return;
          const i = this.editor.model, r = this.editor.plugins.get(nt);
          let s = this.getTableIfOnlyTableInContent(t, i);
          if (!s) return;
          const a = r.getSelectionAffectedTableCells(i.document.selection);
          a.length ? (e.stop(), i.change((l) => {
            const c = { width: r.getColumns(s), height: r.getRows(s) }, d = function(y, I, z, H) {
              const X = y[0].findAncestor("table"), ce = H.getColumnIndexes(y), Oe = H.getRowIndexes(y), be = { firstColumn: ce.first, lastColumn: ce.last, firstRow: Oe.first, lastRow: Oe.last }, Qt = y.length === 1;
              return Qt && (be.lastRow += I.height - 1, be.lastColumn += I.width - 1, function(kt, wr, Mn, un) {
                const vo = un.getColumns(kt), Co = un.getRows(kt);
                Mn > vo && un.insertColumns(kt, { at: vo, columns: Mn - vo }), wr > Co && un.insertRows(kt, { at: Co, rows: wr - Co });
              }(X, be.lastRow + 1, be.lastColumn + 1, H)), Qt || !H.isSelectionRectangular(y) ? function(kt, wr, Mn) {
                const { firstRow: un, lastRow: vo, firstColumn: Co, lastColumn: Yf } = wr, Qf = { first: un, last: vo }, Xf = { first: Co, last: Yf };
                Ja(kt, Co, Qf, Mn), Ja(kt, Yf + 1, Qf, Mn), Za(kt, un, Xf, Mn), Za(kt, vo + 1, Xf, Mn, un);
              }(X, be, z) : (be.lastRow = sf(X, be), be.lastColumn = af(X, be)), be;
            }(a, c, l, r), u = d.lastRow - d.firstRow + 1, g = d.lastColumn - d.firstColumn + 1, p = { startRow: 0, startColumn: 0, endRow: Math.min(u, c.height) - 1, endColumn: Math.min(g, c.width) - 1 };
            s = Xp(s, p, l);
            const b = a[0].findAncestor("table"), w = this._replaceSelectedCellsWithPasted(s, c, b, d, l);
            if (this.editor.plugins.get("TableSelection").isEnabled) {
              const y = r.sortRanges(w.map((I) => l.createRangeOn(I)));
              l.setSelection(y);
            } else l.setSelection(w[0], 0);
          })) : Wa(s, r);
        }
        _replaceSelectedCellsWithPasted(e, t, n, i, r) {
          const { width: s, height: a } = t, l = function(y, I, z) {
            const H = new Array(z).fill(null).map(() => new Array(I).fill(null));
            for (const { column: X, row: ce, cell: Oe } of new we(y)) H[ce][X] = Oe;
            return H;
          }(e, s, a), c = [...new we(n, { startRow: i.firstRow, endRow: i.lastRow, startColumn: i.firstColumn, endColumn: i.lastColumn, includeAllSlots: !0 })], d = [];
          let u;
          for (const y of c) {
            const { row: I, column: z } = y;
            z === i.firstColumn && (u = y.getPositionBefore());
            const H = I - i.firstRow, X = z - i.firstColumn, ce = l[H % a][X % s], Oe = ce ? r.cloneElement(ce) : null, be = this._replaceTableSlotCell(y, Oe, u, r);
            be && (rf(be, I, z, i.lastRow, i.lastColumn, r), d.push(be), u = r.createPositionAfter(be));
          }
          const g = parseInt(n.getAttribute("headingRows") || "0"), p = parseInt(n.getAttribute("headingColumns") || "0"), b = i.firstRow < g && g <= i.lastRow, w = i.firstColumn < p && p <= i.lastColumn;
          if (b) {
            const y = Za(n, g, { first: i.firstColumn, last: i.lastColumn }, r, i.firstRow);
            d.push(...y);
          }
          if (w) {
            const y = Ja(n, p, { first: i.firstRow, last: i.lastRow }, r);
            d.push(...y);
          }
          return d;
        }
        _replaceTableSlotCell(e, t, n, i) {
          const { cell: r, isAnchor: s } = e;
          return s && i.remove(r), t ? (i.insert(t, n), t) : null;
        }
        getTableIfOnlyTableInContent(e, t) {
          if (!e.is("documentFragment") && !e.is("element")) return null;
          if (e.is("element", "table")) return e;
          if (e.childCount == 1 && e.getChild(0).is("element", "table")) return e.getChild(0);
          const n = t.createRangeIn(e);
          for (const i of n.getItems()) if (i.is("element", "table")) {
            const r = t.createRange(n.start, t.createPositionBefore(i));
            if (t.hasContent(r, { ignoreWhitespaces: !0 })) return null;
            const s = t.createRange(t.createPositionAfter(i), n.end);
            return t.hasContent(s, { ignoreWhitespaces: !0 }) ? null : i;
          }
          return null;
        }
      }
      function Za(o, e, t, n, i = 0) {
        if (!(e < 1))
          return ef(o, e, i).filter(({ column: r, cellWidth: s }) => bf(r, s, t)).map(({ cell: r }) => tf(r, e, n));
      }
      function Ja(o, e, t, n) {
        if (!(e < 1))
          return nf(o, e).filter(({ row: i, cellHeight: r }) => bf(i, r, t)).map(({ cell: i, column: r }) => of(i, r, e, n));
      }
      function bf(o, e, t) {
        const n = o + e - 1, { first: i, last: r } = t;
        return o >= i && o <= r || o < i && n >= i;
      }
      class ME extends K {
        static get pluginName() {
          return "TableKeyboard";
        }
        static get requires() {
          return [Pn, nt];
        }
        init() {
          const e = this.editor.editing.view.document;
          this.listenTo(e, "arrowKey", (...t) => this._onArrowKey(...t), { context: "table" }), this.listenTo(e, "tab", (...t) => this._handleTabOnSelectedTable(...t), { context: "figure" }), this.listenTo(e, "tab", (...t) => this._handleTab(...t), { context: ["th", "td"] });
        }
        _handleTabOnSelectedTable(e, t) {
          const n = this.editor, i = n.model.document.selection.getSelectedElement();
          i && i.is("element", "table") && (t.preventDefault(), t.stopPropagation(), e.stop(), n.model.change((r) => {
            r.setSelection(r.createRangeIn(i.getChild(0).getChild(0)));
          }));
        }
        _handleTab(e, t) {
          const n = this.editor, i = this.editor.plugins.get(nt), r = this.editor.plugins.get("TableSelection"), s = n.model.document.selection, a = !t.shiftKey;
          let l = i.getTableCellsContainingSelection(s)[0];
          if (l || (l = r.getFocusCell()), !l) return;
          t.preventDefault(), t.stopPropagation(), e.stop();
          const c = l.parent, d = c.parent, u = d.getChildIndex(c), g = c.getChildIndex(l), p = g === 0;
          if (!a && p && u === 0) return void n.model.change((I) => {
            I.setSelection(I.createRangeOn(d));
          });
          const b = g === c.childCount - 1, w = u === i.getRows(d) - 1;
          if (a && w && b && (n.execute("insertTableRowBelow"), u === i.getRows(d) - 1)) return void n.model.change((I) => {
            I.setSelection(I.createRangeOn(d));
          });
          let y;
          if (a && b)
            y = d.getChild(u + 1).getChild(0);
          else if (!a && p) {
            const I = d.getChild(u - 1);
            y = I.getChild(I.childCount - 1);
          } else y = c.getChild(g + (a ? 1 : -1));
          n.model.change((I) => {
            I.setSelection(I.createRangeIn(y));
          });
        }
        _onArrowKey(e, t) {
          const n = this.editor, i = ls(t.keyCode, n.locale.contentLanguageDirection);
          this._handleArrowKeys(i, t.shiftKey) && (t.preventDefault(), t.stopPropagation(), e.stop());
        }
        _handleArrowKeys(e, t) {
          const n = this.editor.plugins.get(nt), i = this.editor.plugins.get("TableSelection"), r = this.editor.model, s = r.document.selection, a = ["right", "down"].includes(e), l = n.getSelectedTableCells(s);
          if (l.length) {
            let d;
            return d = t ? i.getFocusCell() : a ? l[l.length - 1] : l[0], this._navigateFromCellInDirection(d, e, t), !0;
          }
          const c = s.focus.findAncestor("tableCell");
          if (!c) return !1;
          if (!s.isCollapsed) if (t) {
            if (s.isBackward == a && !s.containsEntireContent(c)) return !1;
          } else {
            const d = s.getSelectedElement();
            if (!d || !r.schema.isObject(d)) return !1;
          }
          return !!this._isSelectionAtCellEdge(s, c, a) && (this._navigateFromCellInDirection(c, e, t), !0);
        }
        _isSelectionAtCellEdge(e, t, n) {
          const i = this.editor.model, r = this.editor.model.schema, s = n ? e.getLastPosition() : e.getFirstPosition();
          if (!r.getLimitElement(s).is("element", "tableCell"))
            return i.createPositionAt(t, n ? "end" : 0).isTouching(s);
          const a = i.createSelection(s);
          return i.modifySelection(a, { direction: n ? "forward" : "backward" }), s.isEqual(a.focus);
        }
        _navigateFromCellInDirection(e, t, n = !1) {
          const i = this.editor.model, r = e.findAncestor("table"), s = [...new we(r, { includeAllSlots: !0 })], { row: a, column: l } = s[s.length - 1], c = s.find(({ cell: w }) => w == e);
          let { row: d, column: u } = c;
          switch (t) {
            case "left":
              u--;
              break;
            case "up":
              d--;
              break;
            case "right":
              u += c.cellWidth;
              break;
            case "down":
              d += c.cellHeight;
          }
          if (d < 0 || d > a || u < 0 && d <= 0 || u > l && d >= a) return void i.change((w) => {
            w.setSelection(w.createRangeOn(r));
          });
          u < 0 ? (u = n ? 0 : l, d--) : u > l && (u = n ? l : 0, d++);
          const g = s.find((w) => w.row == d && w.column == u).cell, p = ["right", "down"].includes(t), b = this.editor.plugins.get("TableSelection");
          if (n && b.isEnabled) {
            const w = b.getAnchorCell() || e;
            b.setCellSelection(w, g);
          } else {
            const w = i.createPositionAt(g, p ? 0 : "end");
            i.change((y) => {
              y.setSelection(w);
            });
          }
        }
      }
      class FE extends rn {
        constructor() {
          super(...arguments), this.domEventType = ["mousemove", "mouseleave"];
        }
        onDomEvent(e) {
          this.fire(e.type, e);
        }
      }
      class NE extends K {
        static get pluginName() {
          return "TableMouse";
        }
        static get requires() {
          return [Pn, nt];
        }
        init() {
          this.editor.editing.view.addObserver(FE), this._enableShiftClickSelection(), this._enableMouseDragSelection();
        }
        _enableShiftClickSelection() {
          const e = this.editor, t = e.plugins.get(nt);
          let n = !1;
          const i = e.plugins.get(Pn);
          this.listenTo(e.editing.view.document, "mousedown", (r, s) => {
            const a = e.model.document.selection;
            if (!this.isEnabled || !i.isEnabled || !s.domEvent.shiftKey) return;
            const l = i.getAnchorCell() || t.getTableCellsContainingSelection(a)[0];
            if (!l) return;
            const c = this._getModelTableCellFromDomEvent(s);
            c && kf(l, c) && (n = !0, i.setCellSelection(l, c), s.preventDefault());
          }), this.listenTo(e.editing.view.document, "mouseup", () => {
            n = !1;
          }), this.listenTo(e.editing.view.document, "selectionChange", (r) => {
            n && r.stop();
          }, { priority: "highest" });
        }
        _enableMouseDragSelection() {
          const e = this.editor;
          let t, n, i = !1, r = !1;
          const s = e.plugins.get(Pn);
          this.listenTo(e.editing.view.document, "mousedown", (a, l) => {
            this.isEnabled && s.isEnabled && (l.domEvent.shiftKey || l.domEvent.ctrlKey || l.domEvent.altKey || (t = this._getModelTableCellFromDomEvent(l)));
          }), this.listenTo(e.editing.view.document, "mousemove", (a, l) => {
            if (!l.domEvent.buttons || !t) return;
            const c = this._getModelTableCellFromDomEvent(l);
            c && kf(t, c) && (n = c, i || n == t || (i = !0)), i && (r = !0, s.setCellSelection(t, n), l.preventDefault());
          }), this.listenTo(e.editing.view.document, "mouseup", () => {
            i = !1, r = !1, t = null, n = null;
          }), this.listenTo(e.editing.view.document, "selectionChange", (a) => {
            r && a.stop();
          }, { priority: "highest" });
        }
        _getModelTableCellFromDomEvent(e) {
          const t = e.target, n = this.editor.editing.view.createPositionAt(t, 0);
          return this.editor.editing.mapper.toModelPosition(n).parent.findAncestor("tableCell", { includeSelf: !0 });
        }
      }
      function kf(o, e) {
        return o.parent.parent == e.parent.parent;
      }
      var wf = D(6306), VE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(wf.Z, VE), wf.Z.locals;
      function LE(o) {
        const e = o.getSelectedElement();
        return e && Af(e) ? e : null;
      }
      function jE(o) {
        const e = o.getFirstPosition();
        if (!e) return null;
        let t = e.parent;
        for (; t; ) {
          if (t.is("element") && Af(t)) return t;
          t = t.parent;
        }
        return null;
      }
      function Af(o) {
        return !!o.getCustomProperty("table") && Ne(o);
      }
      var _f = D(7368), $E = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(_f.Z, $E), _f.Z.locals;
      var vf = D(9247), HE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(vf.Z, HE), vf.Z.locals;
      var Cf = D(4070), qE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Cf.Z, qE), Cf.Z.locals;
      var yf = D(6237), UE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(yf.Z, UE), yf.Z.locals;
      var Ef = D(5087), WE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Ef.Z, WE), Ef.Z.locals;
      const Rn = ut.defaultPositions;
      Rn.northArrowSouth, Rn.northArrowSouthWest, Rn.northArrowSouthEast, Rn.southArrowNorth, Rn.southArrowNorthWest, Rn.southArrowNorthEast, Rn.viewportStickyNorth;
      var xf = D(7341), KE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(xf.Z, KE), xf.Z.locals;
      var Sf = D(2128), GE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Sf.Z, GE), Sf.Z.locals;
      var Df = D(4101), ZE = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Df.Z, ZE), Df.Z.locals;
      var JE = Object.defineProperty, Bf = Object.getOwnPropertySymbols, YE = Object.prototype.hasOwnProperty, QE = Object.prototype.propertyIsEnumerable, Tf = (o, e, t) => e in o ? JE(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, If = (o, e) => {
        for (var t in e || (e = {})) YE.call(e, t) && Tf(o, t, e[t]);
        if (Bf) for (var t of Bf(e)) QE.call(e, t) && Tf(o, t, e[t]);
        return o;
      };
      const XE = { autoRefresh: !0 }, Pf = 36e5;
      class Ya extends ve() {
        constructor(e, t = {}) {
          if (super(), !e) throw new T("token-missing-token-url", this);
          t.initValue && this._validateTokenValue(t.initValue), this.set("value", t.initValue), this._refresh = typeof e == "function" ? e : () => {
            return n = e, new Promise((i, r) => {
              const s = new XMLHttpRequest();
              s.open("GET", n), s.addEventListener("load", () => {
                const a = s.status, l = s.response;
                return a < 200 || a > 299 ? r(new T("token-cannot-download-new-token", null)) : i(l);
              }), s.addEventListener("error", () => r(new Error("Network Error"))), s.addEventListener("abort", () => r(new Error("Abort"))), s.send();
            });
            var n;
          }, this._options = If(If({}, XE), t);
        }
        init() {
          return new Promise((e, t) => {
            this.value ? (this._options.autoRefresh && this._registerRefreshTokenTimeout(), e(this)) : this.refreshToken().then(e).catch(t);
          });
        }
        refreshToken() {
          return this._refresh().then((e) => (this._validateTokenValue(e), this.set("value", e), this._options.autoRefresh && this._registerRefreshTokenTimeout(), this));
        }
        destroy() {
          clearTimeout(this._tokenRefreshTimeout);
        }
        _validateTokenValue(e) {
          const t = typeof e == "string", n = !/^".*"$/.test(e), i = t && e.split(".").length === 3;
          if (!n || !i) throw new T("token-not-in-jwt-format", this);
        }
        _registerRefreshTokenTimeout() {
          const e = this._getTokenRefreshTimeoutTime();
          clearTimeout(this._tokenRefreshTimeout), this._tokenRefreshTimeout = setTimeout(() => {
            this.refreshToken();
          }, e);
        }
        _getTokenRefreshTimeoutTime() {
          try {
            const [, e] = this.value.split("."), { exp: t } = JSON.parse(atob(e));
            return t ? Math.floor((1e3 * t - Date.now()) / 2) : Pf;
          } catch {
            return Pf;
          }
        }
        static create(e, t = {}) {
          return new Ya(e, t).init();
        }
      }
      const Qa = /^data:(\S*?);base64,/;
      class e2 extends _e() {
        constructor(e, t, n) {
          if (super(), !e) throw new T("fileuploader-missing-file", null);
          if (!t) throw new T("fileuploader-missing-token", null);
          if (!n) throw new T("fileuploader-missing-api-address", null);
          this.file = function(i) {
            if (typeof i != "string") return !1;
            const r = i.match(Qa);
            return !(!r || !r.length);
          }(e) ? function(i, r = 512) {
            try {
              const s = i.match(Qa)[1], a = atob(i.replace(Qa, "")), l = [];
              for (let c = 0; c < a.length; c += r) {
                const d = a.slice(c, c + r), u = new Array(d.length);
                for (let g = 0; g < d.length; g++) u[g] = d.charCodeAt(g);
                l.push(new Uint8Array(u));
              }
              return new Blob(l, { type: s });
            } catch {
              throw new T("fileuploader-decoding-image-data-error", null);
            }
          }(e) : e, this._token = t, this._apiAddress = n;
        }
        onProgress(e) {
          return this.on("progress", (t, n) => e(n)), this;
        }
        onError(e) {
          return this.once("error", (t, n) => e(n)), this;
        }
        abort() {
          this.xhr.abort();
        }
        send() {
          return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest();
        }
        _prepareRequest() {
          const e = new XMLHttpRequest();
          e.open("POST", this._apiAddress), e.setRequestHeader("Authorization", this._token.value), e.responseType = "json", this.xhr = e;
        }
        _attachXHRListeners() {
          const e = this.xhr, t = (n) => () => this.fire("error", n);
          e.addEventListener("error", t("Network Error")), e.addEventListener("abort", t("Abort")), e.upload && e.upload.addEventListener("progress", (n) => {
            n.lengthComputable && this.fire("progress", { total: n.total, uploaded: n.loaded });
          }), e.addEventListener("load", () => {
            const n = e.status, i = e.response;
            if (n < 200 || n > 299) return this.fire("error", i.message || i.error);
          });
        }
        _sendRequest() {
          const e = new FormData(), t = this.xhr;
          return e.append("file", this.file), new Promise((n, i) => {
            t.addEventListener("load", () => {
              const r = t.status, s = t.response;
              return r < 200 || r > 299 ? s.message ? i(new T("fileuploader-uploading-data-failed", this, { message: s.message })) : i(s.error) : n(s);
            }), t.addEventListener("error", () => i(new Error("Network Error"))), t.addEventListener("abort", () => i(new Error("Abort"))), t.send(e);
          });
        }
      }
      class t2 {
        constructor(e, t) {
          if (!e) throw new T("uploadgateway-missing-token", null);
          if (!t) throw new T("uploadgateway-missing-api-address", null);
          this._token = e, this._apiAddress = t;
        }
        upload(e) {
          return new e2(e, this._token, this._apiAddress);
        }
      }
      class n2 extends Bi {
        static get pluginName() {
          return "CloudServicesCore";
        }
        createToken(e, t) {
          return new Ya(e, t);
        }
        createUploadGateway(e, t) {
          return new t2(e, t);
        }
      }
      var Rf = (o, e, t) => new Promise((n, i) => {
        var r = (l) => {
          try {
            a(t.next(l));
          } catch (c) {
            i(c);
          }
        }, s = (l) => {
          try {
            a(t.throw(l));
          } catch (c) {
            i(c);
          }
        }, a = (l) => l.done ? n(l.value) : Promise.resolve(l.value).then(r, s);
        a((t = t.apply(o, e)).next());
      });
      const Xa = ["left", "right", "center", "justify"];
      function Of(o) {
        return Xa.includes(o);
      }
      function zf(o, e) {
        return e.contentLanguageDirection == "rtl" ? o === "right" : o === "left";
      }
      function Mf(o) {
        const e = o.map((n) => {
          let i;
          return i = typeof n == "string" ? { name: n } : n, i;
        }).filter((n) => {
          const i = Xa.includes(n.name);
          return i || ee("alignment-config-name-not-recognized", { option: n }), i;
        }), t = e.filter((n) => !!n.className).length;
        if (t && t < e.length) throw new T("alignment-config-classnames-are-missing", { configuredOptions: o });
        return e.forEach((n, i, r) => {
          const s = r.slice(i + 1);
          if (s.some((a) => a.name == n.name)) throw new T("alignment-config-name-already-defined", { option: n, configuredOptions: o });
          if (n.className && s.some((a) => a.className == n.className))
            throw new T("alignment-config-classname-already-defined", { option: n, configuredOptions: o });
        }), e;
      }
      const el = "alignment";
      class o2 extends ae {
        refresh() {
          const e = this.editor.locale, t = Ke(this.editor.model.document.selection.getSelectedBlocks());
          this.isEnabled = !!t && this._canBeAligned(t), this.isEnabled && t.hasAttribute("alignment") ? this.value = t.getAttribute("alignment") : this.value = e.contentLanguageDirection === "rtl" ? "right" : "left";
        }
        execute(e = {}) {
          const t = this.editor, n = t.locale, i = t.model, r = i.document, s = e.value;
          i.change((a) => {
            const l = Array.from(r.selection.getSelectedBlocks()).filter((d) => this._canBeAligned(d)), c = l[0].getAttribute("alignment");
            zf(s, n) || c === s || !s ? function(d, u) {
              for (const g of d) u.removeAttribute(el, g);
            }(l, a) : function(d, u, g) {
              for (const p of d) u.setAttribute(el, g, p);
            }(l, a, s);
          });
        }
        _canBeAligned(e) {
          return this.editor.model.schema.checkAttribute(e, el);
        }
      }
      class i2 extends K {
        static get pluginName() {
          return "AlignmentEditing";
        }
        constructor(e) {
          super(e), e.config.define("alignment", { options: Xa.map((t) => ({ name: t })) });
        }
        init() {
          const e = this.editor, t = e.locale, n = e.model.schema, i = Mf(e.config.get("alignment.options")).filter((l) => Of(l.name) && !zf(l.name, t)), r = i.some((l) => !!l.className);
          n.extend("$block", { allowAttributes: "alignment" }), e.model.schema.setAttributeProperties("alignment", { isFormatting: !0 }), r ? e.conversion.attributeToAttribute(function(l) {
            const c = {};
            for (const u of l) c[u.name] = { key: "class", value: u.className };
            return { model: { key: "alignment", values: l.map((u) => u.name) }, view: c };
          }(i)) : e.conversion.for("downcast").attributeToAttribute(function(l) {
            const c = {};
            for (const { name: u } of l) c[u] = { key: "style", value: { "text-align": u } };
            return { model: { key: "alignment", values: l.map((u) => u.name) }, view: c };
          }(i));
          const s = function(l) {
            const c = [];
            for (const { name: d } of l) c.push({ view: { key: "style", value: { "text-align": d } }, model: { key: "alignment", value: d } });
            return c;
          }(i);
          for (const l of s) e.conversion.for("upcast").attributeToAttribute(l);
          const a = function(l) {
            const c = [];
            for (const { name: d } of l) c.push({ view: { key: "align", value: d }, model: { key: "alignment", value: d } });
            return c;
          }(i);
          for (const l of a) e.conversion.for("upcast").attributeToAttribute(l);
          e.commands.add("alignment", new o2(e));
        }
      }
      const mr = /* @__PURE__ */ new Map([["left", Pe.alignLeft], ["right", Pe.alignRight], ["center", Pe.alignCenter], ["justify", Pe.alignJustify]]);
      class r2 extends K {
        get localizedOptionTitles() {
          const e = this.editor.t;
          return { left: e("Align left"), right: e("Align right"), center: e("Align center"), justify: e("Justify") };
        }
        static get pluginName() {
          return "AlignmentUI";
        }
        init() {
          const e = this.editor, t = e.ui.componentFactory, n = e.t, i = Mf(e.config.get("alignment.options"));
          i.map((r) => r.name).filter(Of).forEach((r) => this._addButton(r)), t.add("alignment", (r) => {
            const s = Kt(r);
            Zi(s, () => i.map((c) => t.create(`alignment:${c.name}`)), { enableActiveItemFocusOnDropdownOpen: !0, isVertical: !0, ariaLabel: n("Text alignment toolbar") }), s.buttonView.set({ label: n("Text alignment"), tooltip: !0 }), s.extendTemplate({ attributes: { class: "ck-alignment-dropdown" } });
            const a = r.contentLanguageDirection === "rtl" ? mr.get("right") : mr.get("left"), l = e.commands.get("alignment");
            return s.buttonView.bind("icon").to(l, "value", (c) => mr.get(c) || a), s.bind("isEnabled").to(l, "isEnabled"), this.listenTo(s, "execute", () => {
              e.editing.view.focus();
            }), s;
          });
        }
        _addButton(e) {
          const t = this.editor;
          t.ui.componentFactory.add(`alignment:${e}`, (n) => {
            const i = t.commands.get("alignment"), r = new De(n);
            return r.set({ label: this.localizedOptionTitles[e], icon: mr.get(e), tooltip: !0, isToggleable: !0 }), r.bind("isEnabled").to(i), r.bind("isOn").to(i, "value", (s) => s === e), this.listenTo(r, "execute", () => {
              t.execute("alignment", { value: e }), t.editing.view.focus();
            }), r;
          });
        }
      }
      function s2(o) {
        const e = [{ name: "address", isVoid: !1 }, { name: "article", isVoid: !1 }, { name: "aside", isVoid: !1 }, { name: "blockquote", isVoid: !1 }, { name: "br", isVoid: !0 }, { name: "details", isVoid: !1 }, { name: "dialog", isVoid: !1 }, { name: "dd", isVoid: !1 }, { name: "div", isVoid: !1 }, { name: "dl", isVoid: !1 }, { name: "dt", isVoid: !1 }, { name: "fieldset", isVoid: !1 }, { name: "figcaption", isVoid: !1 }, { name: "figure", isVoid: !1 }, { name: "footer", isVoid: !1 }, { name: "form", isVoid: !1 }, { name: "h1", isVoid: !1 }, { name: "h2", isVoid: !1 }, { name: "h3", isVoid: !1 }, { name: "h4", isVoid: !1 }, { name: "h5", isVoid: !1 }, { name: "h6", isVoid: !1 }, { name: "header", isVoid: !1 }, { name: "hgroup", isVoid: !1 }, { name: "hr", isVoid: !0 }, { name: "input", isVoid: !0 }, { name: "li", isVoid: !1 }, { name: "main", isVoid: !1 }, { name: "nav", isVoid: !1 }, { name: "ol", isVoid: !1 }, { name: "p", isVoid: !1 }, { name: "section", isVoid: !1 }, { name: "table", isVoid: !1 }, { name: "tbody", isVoid: !1 }, { name: "td", isVoid: !1 }, { name: "textarea", isVoid: !1 }, { name: "th", isVoid: !1 }, { name: "thead", isVoid: !1 }, { name: "tr", isVoid: !1 }, { name: "ul", isVoid: !1 }], t = e.map((r) => r.name).join("|"), n = o.replace(new RegExp(`</?(${t})( .*?)?>`, "g"), `
$&
`).split(`
`);
        let i = 0;
        return n.filter((r) => r.length).map((r) => function(s, a) {
          return a.some((l) => !l.isVoid && !!new RegExp(`<${l.name}( .*?)?>`).test(s));
        }(r, e) ? tl(r, i++) : function(s, a) {
          return a.some((l) => new RegExp(`</${l.name}>`).test(s));
        }(r, e) ? tl(r, --i) : tl(r, i)).join(`
`);
      }
      function tl(o, e, t = "    ") {
        return `${t.repeat(Math.max(0, e))}${o}`;
      }
      var Ff = D(2896), a2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Ff.Z, a2), Ff.Z.locals;
      const Nf = "SourceEditingMode";
      function l2(o) {
        return function(e) {
          return e.startsWith("<");
        }(o) ? s2(o) : o;
      }
      const nl = "removeFormat";
      class c2 extends K {
        static get pluginName() {
          return "RemoveFormatUI";
        }
        init() {
          const e = this.editor, t = e.t;
          e.ui.componentFactory.add(nl, (n) => {
            const i = e.commands.get(nl), r = new De(n);
            return r.set({ label: t("Remove Format"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>', tooltip: !0 }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(r, "execute", () => {
              e.execute(nl), e.editing.view.focus();
            }), r;
          });
        }
      }
      class d2 extends ae {
        refresh() {
          const e = this.editor.model;
          this.isEnabled = !!Ke(this._getFormattingItems(e.document.selection, e.schema));
        }
        execute() {
          const e = this.editor.model, t = e.schema;
          e.change((n) => {
            for (const i of this._getFormattingItems(e.document.selection, t)) if (i.is("selection")) for (const r of this._getFormattingAttributes(i, t)) n.removeSelectionAttribute(r);
            else {
              const r = n.createRangeOn(i);
              for (const s of this._getFormattingAttributes(i, t)) n.removeAttribute(s, r);
            }
          });
        }
        *_getFormattingItems(e, t) {
          const n = (i) => !!Ke(this._getFormattingAttributes(i, t));
          for (const i of e.getRanges()) for (const r of i.getItems()) !t.isBlock(r) && n(r) && (yield r);
          for (const i of e.getSelectedBlocks()) n(i) && (yield i);
          n(e) && (yield e);
        }
        *_getFormattingAttributes(e, t) {
          for (const [n] of e.getAttributes()) {
            const i = t.getAttributeProperties(n);
            i && i.isFormatting && (yield n);
          }
        }
      }
      class u2 extends K {
        static get pluginName() {
          return "RemoveFormatEditing";
        }
        init() {
          const e = this.editor;
          e.commands.add("removeFormat", new d2(e));
        }
      }
      var h2 = Object.defineProperty, Vf = Object.getOwnPropertySymbols, g2 = Object.prototype.hasOwnProperty, m2 = Object.prototype.propertyIsEnumerable, Lf = (o, e, t) => e in o ? h2(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, jf = (o, e) => {
        for (var t in e || (e = {})) g2.call(e, t) && Lf(o, t, e[t]);
        if (Vf) for (var t of Vf(e)) m2.call(e, t) && Lf(o, t, e[t]);
        return o;
      };
      function On(o, e, t, n) {
        e && function(i, r, s) {
          if (r.attributes) for (const [a] of Object.entries(r.attributes)) i.removeAttribute(a, s);
          if (r.styles) for (const a of Object.keys(r.styles)) i.removeStyle(a, s);
          r.classes && i.removeClass(r.classes, s);
        }(o, e, n), t && dn(o, t, n);
      }
      function dn(o, e, t) {
        if (e.attributes) for (const [n, i] of Object.entries(e.attributes)) o.setAttribute(n, i, t);
        e.styles && o.setStyle(e.styles, t), e.classes && o.addClass(e.classes, t);
      }
      function p2(o, e) {
        const t = an(o);
        let n = "attributes";
        for (n in e) t[n] = n == "classes" ? Array.from(/* @__PURE__ */ new Set([...o[n] || [], ...e[n]])) : jf(jf({}, o[n]), e[n]);
        return t;
      }
      function zn(o, e, t, n, i) {
        const r = e.getAttribute(t), s = {};
        for (const a of ["attributes", "styles", "classes"]) {
          if (a != n) {
            r && r[a] && (s[a] = r[a]);
            continue;
          }
          if (n == "classes") {
            const c = new Set(r && r.classes || []);
            i(c), c.size && (s[a] = Array.from(c));
            continue;
          }
          const l = new Map(Object.entries(r && r[a] || {}));
          i(l), l.size && (s[a] = Object.fromEntries(l));
        }
        Object.keys(s).length ? e.is("documentSelection") ? o.setSelectionAttribute(t, s) : o.setAttribute(t, s, e) : r && (e.is("documentSelection") ? o.removeSelectionAttribute(t) : o.removeAttribute(t, e));
      }
      function ol({ model: o }) {
        return (e, t) => t.writer.createElement(o, { htmlContent: e.getCustomProperty("$rawContent") });
      }
      function f2(o, { view: e, isInline: t }) {
        const n = o.t;
        return (i, { writer: r }) => {
          const s = n("HTML object"), a = pr(e, i, r), l = i.getAttribute("htmlAttributes");
          return r.addClass("html-object-embed__content", a), l && dn(r, l, a), va(r.createContainerElement(t ? "span" : "div", { class: "html-object-embed", "data-html-object-embed-label": s }, a), r, { label: s });
        };
      }
      function pr(o, e, t) {
        return t.createRawElement(o, null, (n, i) => {
          i.setContentOf(n, e.getAttribute("htmlContent"));
        });
      }
      function b2({ priority: o, view: e }) {
        return (t, n) => {
          if (!t) return;
          const { writer: i } = n, r = i.createAttributeElement(e, null, { priority: o });
          return dn(i, t, r), r;
        };
      }
      function oi({ view: o }, e) {
        return (t) => {
          t.on(`element:${o}`, (n, i, r) => {
            if (!i.modelRange || i.modelRange.isCollapsed) return;
            const s = e.processViewAttributes(i.viewItem, r);
            s && r.writer.setAttribute("htmlAttributes", s, i.modelRange);
          }, { priority: "low" });
        };
      }
      function ii({ model: o }) {
        return (e) => {
          e.on(`attribute:htmlAttributes:${o}`, (t, n, i) => {
            if (!i.consumable.consume(n.item, t.name)) return;
            const { attributeOldValue: r, attributeNewValue: s } = n;
            On(i.writer, r, s, i.mapper.toViewElement(n.item));
          });
        };
      }
      const k2 = [{ model: "codeBlock", view: "pre" }, { model: "paragraph", view: "p" }, { model: "blockQuote", view: "blockquote" }, { model: "listItem", view: "li" }, { model: "pageBreak", view: "div" }, { model: "rawHtml", view: "div" }, { model: "table", view: "table" }, { model: "tableRow", view: "tr" }, { model: "tableCell", view: "td" }, { model: "tableCell", view: "th" }, { model: "tableColumnGroup", view: "colgroup" }, { model: "tableColumn", view: "col" }, { model: "caption", view: "caption" }, { model: "caption", view: "figcaption" }, { model: "imageBlock", view: "img" }, { model: "imageInline", view: "img" }, { model: "htmlP", view: "p", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlBlockquote", view: "blockquote", modelSchema: { inheritAllFrom: "$container" } }, { model: "htmlTable", view: "table", modelSchema: { allowWhere: "$block", isBlock: !0 } }, { model: "htmlTbody", view: "tbody", modelSchema: { allowIn: "htmlTable", isBlock: !1 } }, { model: "htmlThead", view: "thead", modelSchema: { allowIn: "htmlTable", isBlock: !1 } }, { model: "htmlTfoot", view: "tfoot", modelSchema: { allowIn: "htmlTable", isBlock: !1 } }, { model: "htmlCaption", view: "caption", modelSchema: { allowIn: "htmlTable", allowChildren: "$text", isBlock: !1 } }, { model: "htmlColgroup", view: "colgroup", modelSchema: { allowIn: "htmlTable", allowChildren: "col", isBlock: !1 } }, { model: "htmlCol", view: "col", modelSchema: { allowIn: "htmlColgroup", isBlock: !1 } }, { model: "htmlTr", view: "tr", modelSchema: { allowIn: ["htmlTable", "htmlThead", "htmlTbody"], isLimit: !0 } }, { model: "htmlTd", view: "td", modelSchema: { allowIn: "htmlTr", allowContentOf: "$container", isLimit: !0, isBlock: !1 } }, { model: "htmlTh", view: "th", modelSchema: { allowIn: "htmlTr", allowContentOf: "$container", isLimit: !0, isBlock: !1 } }, { model: "htmlFigure", view: "figure", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlFigcaption", view: "figcaption", modelSchema: { allowIn: "htmlFigure", allowChildren: "$text", isBlock: !1 } }, { model: "htmlAddress", view: "address", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlAside", view: "aside", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlMain", view: "main", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlDetails", view: "details", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlSummary", view: "summary", modelSchema: { allowChildren: "$text", allowIn: "htmlDetails", isBlock: !1 } }, { model: "htmlDiv", view: "div", paragraphLikeModel: "htmlDivParagraph", modelSchema: { inheritAllFrom: "$container" } }, { model: "htmlFieldset", view: "fieldset", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlLegend", view: "legend", modelSchema: { allowIn: "htmlFieldset", allowChildren: "$text" } }, { model: "htmlHeader", view: "header", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlFooter", view: "footer", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlForm", view: "form", modelSchema: { inheritAllFrom: "$container", isBlock: !0 } }, { model: "htmlHgroup", view: "hgroup", modelSchema: { allowChildren: ["htmlH1", "htmlH2", "htmlH3", "htmlH4", "htmlH5", "htmlH6"], isBlock: !1 } }, { model: "htmlH1", view: "h1", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH2", view: "h2", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH3", view: "h3", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH4", view: "h4", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH5", view: "h5", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH6", view: "h6", modelSchema: { inheritAllFrom: "$block" } }, { model: "$htmlList", modelSchema: { allowWhere: "$container", allowChildren: ["$htmlList", "htmlLi"], isBlock: !1 } }, { model: "htmlDir", view: "dir", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlMenu", view: "menu", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlUl", view: "ul", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlOl", view: "ol", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlLi", view: "li", modelSchema: { allowIn: "$htmlList", allowChildren: "$text", isBlock: !1 } }, { model: "htmlPre", view: "pre", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlArticle", view: "article", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlSection", view: "section", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlNav", view: "nav", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }, { model: "htmlDivDl", view: "div", modelSchema: { allowChildren: ["htmlDt", "htmlDd"], allowIn: "htmlDl" } }, { model: "htmlDl", view: "dl", modelSchema: { allowWhere: "$container", allowChildren: ["htmlDt", "htmlDd", "htmlDivDl"], isBlock: !1 } }, { model: "htmlDt", view: "dt", modelSchema: { allowChildren: "$block", isBlock: !1 } }, { model: "htmlDd", view: "dd", modelSchema: { allowChildren: "$block", isBlock: !1 } }, { model: "htmlCenter", view: "center", modelSchema: { inheritAllFrom: "$container", isBlock: !1 } }], w2 = [{ model: "htmlLiAttributes", view: "li", appliesToBlock: !0 }, { model: "htmlListAttributes", view: "ol", appliesToBlock: !0 }, { model: "htmlListAttributes", view: "ul", appliesToBlock: !0 }, { model: "htmlFigureAttributes", view: "figure", appliesToBlock: "table" }, { model: "htmlTheadAttributes", view: "thead", appliesToBlock: "table" }, { model: "htmlTbodyAttributes", view: "tbody", appliesToBlock: "table" }, { model: "htmlFigureAttributes", view: "figure", appliesToBlock: "imageBlock" }, { model: "htmlAcronym", view: "acronym", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlTt", view: "tt", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlFont", view: "font", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlTime", view: "time", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlVar", view: "var", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlBig", view: "big", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSmall", view: "small", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSamp", view: "samp", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlQ", view: "q", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlOutput", view: "output", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlKbd", view: "kbd", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlBdi", view: "bdi", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlBdo", view: "bdo", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlAbbr", view: "abbr", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlA", view: "a", priority: 5, coupledAttribute: "linkHref", attributeProperties: { copyOnEnter: !0 } }, { model: "htmlStrong", view: "strong", coupledAttribute: "bold", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlB", view: "b", coupledAttribute: "bold", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlI", view: "i", coupledAttribute: "italic", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlEm", view: "em", coupledAttribute: "italic", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlS", view: "s", coupledAttribute: "strikethrough", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlDel", view: "del", coupledAttribute: "strikethrough", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlIns", view: "ins", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlU", view: "u", coupledAttribute: "underline", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSub", view: "sub", coupledAttribute: "subscript", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSup", view: "sup", coupledAttribute: "superscript", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlCode", view: "code", coupledAttribute: "code", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlMark", view: "mark", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlSpan", view: "span", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlCite", view: "cite", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlLabel", view: "label", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlDfn", view: "dfn", attributeProperties: { copyOnEnter: !0, isFormatting: !0 } }, { model: "htmlObject", view: "object", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlIframe", view: "iframe", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlInput", view: "input", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlButton", view: "button", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlTextarea", view: "textarea", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlSelect", view: "select", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlVideo", view: "video", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlEmbed", view: "embed", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlOembed", view: "oembed", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlAudio", view: "audio", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlImg", view: "img", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlCanvas", view: "canvas", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlMeter", view: "meter", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlProgress", view: "progress", isObject: !0, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlScript", view: "script", modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 } }, { model: "htmlStyle", view: "style", modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 } }, { model: "htmlCustomElement", view: "$customElement", modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 } }], A2 = Es(function(o, e, t, n) {
        Cd(o, e, t, n);
      });
      var _2 = Object.defineProperty, v2 = Object.defineProperties, C2 = Object.getOwnPropertyDescriptors, $f = Object.getOwnPropertySymbols, y2 = Object.prototype.hasOwnProperty, E2 = Object.prototype.propertyIsEnumerable, Hf = (o, e, t) => e in o ? _2(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, fr = (o, e) => {
        for (var t in e || (e = {})) y2.call(e, t) && Hf(o, t, e[t]);
        if ($f) for (var t of $f(e)) E2.call(e, t) && Hf(o, t, e[t]);
        return o;
      }, br = (o, e) => v2(o, C2(e));
      class wo extends K {
        constructor() {
          super(...arguments), this._definitions = [];
        }
        static get pluginName() {
          return "DataSchema";
        }
        init() {
          for (const e of k2) this.registerBlockElement(e);
          for (const e of w2) this.registerInlineElement(e);
        }
        registerBlockElement(e) {
          this._definitions.push(br(fr({}, e), { isBlock: !0 }));
        }
        registerInlineElement(e) {
          this._definitions.push(br(fr({}, e), { isInline: !0 }));
        }
        extendBlockElement(e) {
          this._extendDefinition(br(fr({}, e), { isBlock: !0 }));
        }
        extendInlineElement(e) {
          this._extendDefinition(br(fr({}, e), { isInline: !0 }));
        }
        getDefinitionsForView(e, t = !1) {
          const n = /* @__PURE__ */ new Set();
          for (const i of this._getMatchingViewDefinitions(e)) {
            if (t) for (const r of this._getReferences(i.model)) n.add(r);
            n.add(i);
          }
          return n;
        }
        getDefinitionsForModel(e) {
          return this._definitions.filter((t) => t.model == e);
        }
        _getMatchingViewDefinitions(e) {
          return this._definitions.filter((t) => t.view && function(n, i) {
            return typeof n == "string" ? n === i : n instanceof RegExp ? n.test(i) : !1;
          }(e, t.view));
        }
        *_getReferences(e) {
          const t = ["inheritAllFrom", "inheritTypesFrom", "allowWhere", "allowContentOf", "allowAttributesOf"], n = this._definitions.filter((i) => i.model == e);
          for (const { modelSchema: i } of n) if (i) for (const r of t) for (const s of $e(i[r] || [])) {
            const a = this._definitions.filter((l) => l.model == s);
            for (const l of a) s !== e && (yield* this._getReferences(l.model), yield l);
          }
        }
        _extendDefinition(e) {
          const t = Array.from(this._definitions.entries()).filter(([, n]) => n.model == e.model);
          if (t.length != 0) for (const [n, i] of t) this._definitions[n] = A2({}, i, e, (r, s) => Array.isArray(r) ? r.concat(s) : void 0);
          else this._definitions.push(e);
        }
      }
      const x2 = function(o, e, t, n) {
        for (var i = o.length, r = t + -1; ++r < i; ) if (e(o[r], r, o)) return r;
        return -1;
      }, S2 = function(o) {
        return o != o;
      }, D2 = function(o, e, t) {
        for (var n = t - 1, i = o.length; ++n < i; ) if (o[n] === e) return n;
        return -1;
      }, B2 = function(o, e, t) {
        return e == e ? D2(o, e, t) : x2(o, S2, t);
      };
      var qf = Array.prototype.splice;
      const T2 = function(o, e, t, n) {
        var i = B2, r = -1, s = e.length, a = o;
        for (o === e && (e = Gr(e)), t; ++r < s; ) for (var l = 0, c = e[r], d = c; (l = i(a, d, l)) > -1; ) a !== o && qf.call(a, l, 1), qf.call(o, l, 1);
        return o;
      }, I2 = Ed(function(o, e) {
        return o && o.length && e && e.length ? T2(o, e) : o;
      });
      var Uf = D(5049), P2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Uf.Z, P2), Uf.Z.locals;
      class Ze extends K {
        constructor(e) {
          super(e), this._dataSchema = e.plugins.get("DataSchema"), this._allowedAttributes = new no(), this._disallowedAttributes = new no(), this._allowedElements = /* @__PURE__ */ new Set(), this._disallowedElements = /* @__PURE__ */ new Set(), this._dataInitialized = !1, this._coupledAttributes = null, this._registerElementsAfterInit(), this._registerElementHandlers(), this._registerModelPostFixer();
        }
        static get pluginName() {
          return "DataFilter";
        }
        static get requires() {
          return [wo, ti];
        }
        loadAllowedConfig(e) {
          for (const t of e) {
            const n = t.name || /[\s\S]+/, i = Gf(t);
            this.allowElement(n), i.forEach((r) => this.allowAttributes(r));
          }
        }
        loadDisallowedConfig(e) {
          for (const t of e) {
            const n = t.name || /[\s\S]+/, i = Gf(t);
            i.length == 0 ? this.disallowElement(n) : i.forEach((r) => this.disallowAttributes(r));
          }
        }
        allowElement(e) {
          for (const t of this._dataSchema.getDefinitionsForView(e, !0)) this._addAllowedElement(t), this._coupledAttributes = null;
        }
        disallowElement(e) {
          for (const t of this._dataSchema.getDefinitionsForView(e, !1)) this._disallowedElements.add(t.view);
        }
        allowAttributes(e) {
          this._allowedAttributes.add(e);
        }
        disallowAttributes(e) {
          this._disallowedAttributes.add(e);
        }
        processViewAttributes(e, t) {
          return Wf(e, t, this._disallowedAttributes), Wf(e, t, this._allowedAttributes);
        }
        _addAllowedElement(e) {
          if (!this._allowedElements.has(e)) {
            if (this._allowedElements.add(e), "appliesToBlock" in e && typeof e.appliesToBlock == "string") for (const t of this._dataSchema.getDefinitionsForModel(e.appliesToBlock)) t.isBlock && this._addAllowedElement(t);
            this._dataInitialized && this.editor.data.once("set", () => {
              this._fireRegisterEvent(e);
            }, { priority: se.get("highest") + 1 });
          }
        }
        _registerElementsAfterInit() {
          this.editor.data.on("init", () => {
            this._dataInitialized = !0;
            for (const e of this._allowedElements) this._fireRegisterEvent(e);
          }, { priority: se.get("highest") + 1 });
        }
        _registerElementHandlers() {
          this.on("register", (e, t) => {
            const n = this.editor.model.schema;
            if (t.isObject && !n.isRegistered(t.model)) this._registerObjectElement(t);
            else if (t.isBlock) this._registerBlockElement(t);
            else {
              if (!t.isInline) throw new T("data-filter-invalid-definition", null, t);
              this._registerInlineElement(t);
            }
            e.stop();
          }, { priority: "lowest" });
        }
        _registerModelPostFixer() {
          const e = this.editor.model;
          e.document.registerPostFixer((t) => {
            const n = e.document.differ.getChanges();
            let i = !1;
            const r = this._getCoupledAttributesMap();
            for (const s of n) {
              if (s.type != "attribute" || s.attributeNewValue !== null) continue;
              const a = r.get(s.attributeKey);
              if (a) for (const { item: l } of s.range.getWalker({ shallow: !0 })) for (const c of a) l.hasAttribute(c) && (t.removeAttribute(c, l), i = !0);
            }
            return i;
          });
        }
        _getCoupledAttributesMap() {
          if (this._coupledAttributes) return this._coupledAttributes;
          this._coupledAttributes = /* @__PURE__ */ new Map();
          for (const e of this._allowedElements) if (e.coupledAttribute && e.model) {
            const t = this._coupledAttributes.get(e.coupledAttribute);
            t ? t.push(e.model) : this._coupledAttributes.set(e.coupledAttribute, [e.model]);
          }
          return this._coupledAttributes;
        }
        _fireRegisterEvent(e) {
          e.view && this._disallowedElements.has(e.view) || this.fire(e.view ? `register:${e.view}` : "register", e);
        }
        _registerObjectElement(e) {
          const t = this.editor, n = t.model.schema, i = t.conversion, { view: r, model: s } = e;
          n.register(s, e.modelSchema), r && (n.extend(e.model, { allowAttributes: ["htmlAttributes", "htmlContent"] }), t.data.registerRawContentMatcher({ name: r }), i.for("upcast").elementToElement({ view: r, model: ol(e), converterPriority: se.get("low") + 1 }), i.for("upcast").add(oi(e, this)), i.for("editingDowncast").elementToStructure({ model: { name: s, attributes: ["htmlAttributes"] }, view: f2(t, e) }), i.for("dataDowncast").elementToElement({ model: s, view: (a, { writer: l }) => pr(r, a, l) }), i.for("dataDowncast").add(ii(e)));
        }
        _registerBlockElement(e) {
          const t = this.editor, n = t.model.schema, i = t.conversion, { view: r, model: s } = e;
          if (!n.isRegistered(e.model)) {
            if (n.register(e.model, e.modelSchema), !r) return;
            i.for("upcast").elementToElement({ model: s, view: r, converterPriority: se.get("low") + 1 }), i.for("downcast").elementToElement({ model: s, view: r });
          }
          r && (n.extend(e.model, { allowAttributes: "htmlAttributes" }), i.for("upcast").add(oi(e, this)), i.for("downcast").add(ii(e)));
        }
        _registerInlineElement(e) {
          const t = this.editor, n = t.model.schema, i = t.conversion, r = e.model;
          e.appliesToBlock || (n.extend("$text", { allowAttributes: r }), e.attributeProperties && n.setAttributeProperties(r, e.attributeProperties), i.for("upcast").add(function({ view: s, model: a }, l) {
            return (c) => {
              c.on(`element:${s}`, (d, u, g) => {
                let p = l.processViewAttributes(u.viewItem, g);
                if (p || g.consumable.test(u.viewItem, { name: !0 })) {
                  p = p || {}, g.consumable.consume(u.viewItem, { name: !0 }), u.modelRange || (u = Object.assign(u, g.convertChildren(u.viewItem, u.modelCursor)));
                  for (const b of u.modelRange.getItems()) if (g.schema.checkAttribute(b, a)) {
                    const w = p2(p, b.getAttribute(a) || {});
                    g.writer.setAttribute(a, w, b);
                  }
                }
              }, { priority: "low" });
            };
          }(e, this)), i.for("downcast").attributeToElement({ model: r, view: b2(e) }));
        }
      }
      function Wf(o, e, t) {
        const n = function(l, { consumable: c }, d) {
          const u = d.matchAll(l) || [], g = [];
          for (const p of u) R2(c, l, p), delete p.match.name, c.consume(l, p.match), g.push(p);
          return g;
        }(o, e, t), { attributes: i, styles: r, classes: s } = function(l) {
          const c = { attributes: /* @__PURE__ */ new Set(), classes: /* @__PURE__ */ new Set(), styles: /* @__PURE__ */ new Set() };
          for (const d of l) for (const u in c)
            (d.match[u] || []).forEach((g) => c[u].add(g));
          return c;
        }(n), a = {};
        if (i.size) for (const l of i) Ec(l) || i.delete(l);
        return i.size && (a.attributes = Kf(i, (l) => o.getAttribute(l))), r.size && (a.styles = Kf(r, (l) => o.getStyle(l))), s.size && (a.classes = Array.from(s)), Object.keys(a).length ? a : null;
      }
      function R2(o, e, t) {
        for (const n of ["attributes", "classes", "styles"]) {
          const i = t.match[n];
          if (i) for (const r of Array.from(i)) o.test(e, { [n]: [r] }) || I2(i, r);
        }
      }
      function Kf(o, e) {
        const t = {};
        for (const n of o)
          e(n) !== void 0 && (t[n] = e(n));
        return t;
      }
      function il(o, e) {
        const { name: t } = o, n = o[e];
        return at(n) ? Object.entries(n).map(([i, r]) => ({ name: t, [e]: { [i]: r } })) : Array.isArray(n) ? n.map((i) => ({ name: t, [e]: [i] })) : [o];
      }
      function Gf(o) {
        const { name: e, attributes: t, classes: n, styles: i } = o, r = [];
        return t && r.push(...il({ name: e, attributes: t }, "attributes")), n && r.push(...il({ name: e, classes: n }, "classes")), i && r.push(...il({ name: e, styles: i }, "styles")), r;
      }
      class O2 extends K {
        static get requires() {
          return [Ze];
        }
        static get pluginName() {
          return "CodeBlockElementSupport";
        }
        init() {
          if (!this.editor.plugins.has("CodeBlockEditing")) return;
          const e = this.editor.plugins.get(Ze);
          e.on("register:pre", (t, n) => {
            if (n.model !== "codeBlock") return;
            const i = this.editor, r = i.model.schema, s = i.conversion;
            r.extend("codeBlock", { allowAttributes: ["htmlAttributes", "htmlContentAttributes"] }), s.for("upcast").add(/* @__PURE__ */ function(a) {
              return (l) => {
                l.on("element:code", (c, d, u) => {
                  const g = d.viewItem, p = g.parent;
                  function b(w, y) {
                    const I = a.processViewAttributes(w, u);
                    I && u.writer.setAttribute(y, I, d.modelRange);
                  }
                  p && p.is("element", "pre") && (b(p, "htmlAttributes"), b(g, "htmlContentAttributes"));
                }, { priority: "low" });
              };
            }(e)), s.for("downcast").add((a) => {
              a.on("attribute:htmlAttributes:codeBlock", (l, c, d) => {
                if (!d.consumable.consume(c.item, l.name)) return;
                const { attributeOldValue: u, attributeNewValue: g } = c, p = d.mapper.toViewElement(c.item).parent;
                On(d.writer, u, g, p);
              }), a.on("attribute:htmlContentAttributes:codeBlock", (l, c, d) => {
                if (!d.consumable.consume(c.item, l.name)) return;
                const { attributeOldValue: u, attributeNewValue: g } = c, p = d.mapper.toViewElement(c.item);
                On(d.writer, u, g, p);
              });
            }), t.stop();
          });
        }
      }
      class z2 extends K {
        static get requires() {
          return [Ze];
        }
        static get pluginName() {
          return "DualContentModelElementSupport";
        }
        init() {
          this.editor.plugins.get(Ze).on("register", (e, t) => {
            const n = t, i = this.editor, r = i.model.schema, s = i.conversion;
            if (!n.paragraphLikeModel || r.isRegistered(n.model) || r.isRegistered(n.paragraphLikeModel)) return;
            const a = { model: n.paragraphLikeModel, view: n.view };
            r.register(n.model, n.modelSchema), r.register(a.model, { inheritAllFrom: "$block" }), s.for("upcast").elementToElement({ view: n.view, model: (l, { writer: c }) => this._hasBlockContent(l) ? c.createElement(n.model) : c.createElement(a.model), converterPriority: se.get("low") + 0.5 }), s.for("downcast").elementToElement({ view: n.view, model: n.model }), this._addAttributeConversion(n), s.for("downcast").elementToElement({ view: a.view, model: a.model }), this._addAttributeConversion(a), e.stop();
          });
        }
        _hasBlockContent(e) {
          const t = this.editor.editing.view, n = t.domConverter.blockElements;
          for (const i of t.createRangeIn(e).getItems()) if (i.is("element") && n.includes(i.name)) return !0;
          return !1;
        }
        _addAttributeConversion(e) {
          const t = this.editor, n = t.conversion, i = t.plugins.get(Ze);
          t.model.schema.extend(e.model, { allowAttributes: "htmlAttributes" }), n.for("upcast").add(oi(e, i)), n.for("downcast").add(ii(e));
        }
      }
      class M2 extends K {
        static get requires() {
          return [wo, ei];
        }
        static get pluginName() {
          return "HeadingElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("HeadingEditing")) return;
          const t = e.config.get("heading.options");
          this.registerHeadingElements(e, t), this.removeClassesOnEnter(e, t);
        }
        registerHeadingElements(e, t) {
          const n = e.plugins.get(wo), i = [];
          for (const r of t) "model" in r && "view" in r && (n.registerBlockElement({ view: r.view, model: r.model }), i.push(r.model));
          n.extendBlockElement({ model: "htmlHgroup", modelSchema: { allowChildren: i } });
        }
        removeClassesOnEnter(e, t) {
          const n = e.commands.get("enter");
          this.listenTo(n, "afterExecute", (i, r) => {
            const s = e.model.document.selection.getFirstPosition().parent;
            t.some((a) => s.is("element", a.model)) && s.childCount === 0 && zn(r.writer, s, "htmlAttributes", "classes", (a) => a.clear());
          });
        }
      }
      function kr(o, e, t) {
        const n = o.createRangeOn(e);
        for (const { item: i } of n.getWalker()) if (i.is("element", t)) return i;
      }
      class F2 extends K {
        static get requires() {
          return [Ze];
        }
        static get pluginName() {
          return "ImageElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("ImageInlineEditing") && !e.plugins.has("ImageBlockEditing")) return;
          const t = e.model.schema, n = e.conversion, i = e.plugins.get(Ze);
          i.on("register:figure", () => {
            n.for("upcast").add(/* @__PURE__ */ function(r) {
              return (s) => {
                s.on("element:figure", (a, l, c) => {
                  const d = l.viewItem;
                  if (!l.modelRange || !d.hasClass("image")) return;
                  const u = r.processViewAttributes(d, c);
                  u && c.writer.setAttribute("htmlFigureAttributes", u, l.modelRange);
                }, { priority: "low" });
              };
            }(i));
          }), i.on("register:img", (r, s) => {
            s.model !== "imageBlock" && s.model !== "imageInline" || (t.isRegistered("imageBlock") && t.extend("imageBlock", { allowAttributes: ["htmlAttributes", "htmlFigureAttributes", "htmlLinkAttributes"] }), t.isRegistered("imageInline") && t.extend("imageInline", { allowAttributes: ["htmlA", "htmlAttributes"] }), n.for("upcast").add(/* @__PURE__ */ function(a) {
              return (l) => {
                l.on("element:img", (c, d, u) => {
                  if (!d.modelRange) return;
                  const g = d.viewItem, p = g.parent;
                  function b(y, I) {
                    const z = a.processViewAttributes(y, u);
                    z && u.writer.setAttribute(I, z, d.modelRange);
                  }
                  function w(y) {
                    d.modelRange && d.modelRange.getContainedElement().is("element", "imageBlock") && b(y, "htmlLinkAttributes");
                  }
                  b(g, "htmlAttributes"), p.is("element", "a") && w(p);
                }, { priority: "low" });
              };
            }(i)), n.for("downcast").add((a) => {
              function l(d) {
                a.on(`attribute:${d}:imageInline`, (u, g, p) => {
                  if (!p.consumable.consume(g.item, u.name)) return;
                  const { attributeOldValue: b, attributeNewValue: w } = g, y = p.mapper.toViewElement(g.item);
                  On(p.writer, b, w, y);
                }, { priority: "low" });
              }
              function c(d, u) {
                a.on(`attribute:${u}:imageBlock`, (g, p, b) => {
                  if (!b.consumable.test(p.item, g.name)) return;
                  const { attributeOldValue: w, attributeNewValue: y } = p, I = b.mapper.toViewElement(p.item), z = kr(b.writer, I, d);
                  z && (On(b.writer, w, y, z), b.consumable.consume(p.item, g.name));
                }, { priority: "low" }), d === "a" && a.on("attribute:linkHref:imageBlock", (g, p, b) => {
                  if (!b.consumable.consume(p.item, "attribute:htmlLinkAttributes:imageBlock")) return;
                  const w = b.mapper.toViewElement(p.item), y = kr(b.writer, w, "a");
                  dn(b.writer, p.item.getAttribute("htmlLinkAttributes"), y);
                }, { priority: "low" });
              }
              l("htmlAttributes"), c("img", "htmlAttributes"), c("figure", "htmlFigureAttributes"), c("a", "htmlLinkAttributes");
            }), r.stop());
          });
        }
      }
      class N2 extends K {
        static get requires() {
          return [Ze];
        }
        static get pluginName() {
          return "MediaEmbedElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("MediaEmbed") || e.config.get("mediaEmbed.previewsInData")) return;
          const t = e.model.schema, n = e.conversion, i = this.editor.plugins.get(Ze), r = this.editor.plugins.get(wo), s = e.config.get("mediaEmbed.elementName");
          r.registerBlockElement({ model: "media", view: s }), i.on("register:figure", () => {
            n.for("upcast").add(/* @__PURE__ */ function(a) {
              return (l) => {
                l.on("element:figure", (c, d, u) => {
                  const g = d.viewItem;
                  if (!d.modelRange || !g.hasClass("media")) return;
                  const p = a.processViewAttributes(g, u);
                  p && u.writer.setAttribute("htmlFigureAttributes", p, d.modelRange);
                }, { priority: "low" });
              };
            }(i));
          }), i.on(`register:${s}`, (a, l) => {
            l.model === "media" && (t.extend("media", { allowAttributes: ["htmlAttributes", "htmlFigureAttributes"] }), n.for("upcast").add(/* @__PURE__ */ function(c, d) {
              const u = (g, p, b) => {
                function w(y, I) {
                  const z = c.processViewAttributes(y, b);
                  z && b.writer.setAttribute(I, z, p.modelRange);
                }
                w(p.viewItem, "htmlAttributes");
              };
              return (g) => {
                g.on(`element:${d}`, u, { priority: "low" });
              };
            }(i, s)), n.for("dataDowncast").add(/* @__PURE__ */ function(c) {
              return (d) => {
                function u(g, p) {
                  d.on(`attribute:${p}:media`, (b, w, y) => {
                    if (!y.consumable.consume(w.item, b.name)) return;
                    const { attributeOldValue: I, attributeNewValue: z } = w, H = y.mapper.toViewElement(w.item), X = kr(y.writer, H, g);
                    On(y.writer, I, z, X);
                  });
                }
                u(c, "htmlAttributes"), u("figure", "htmlFigureAttributes");
              };
            }(s)), a.stop());
          });
        }
      }
      class V2 extends K {
        static get requires() {
          return [Ze];
        }
        static get pluginName() {
          return "ScriptElementSupport";
        }
        init() {
          const e = this.editor.plugins.get(Ze);
          e.on("register:script", (t, n) => {
            const i = this.editor, r = i.model.schema, s = i.conversion;
            r.register("htmlScript", n.modelSchema), r.extend("htmlScript", { allowAttributes: ["htmlAttributes", "htmlContent"], isContent: !0 }), i.data.registerRawContentMatcher({ name: "script" }), s.for("upcast").elementToElement({ view: "script", model: ol(n) }), s.for("upcast").add(oi(n, e)), s.for("downcast").elementToElement({ model: "htmlScript", view: (a, { writer: l }) => pr("script", a, l) }), s.for("downcast").add(ii(n)), t.stop();
          });
        }
      }
      class L2 extends K {
        static get requires() {
          return [Ze];
        }
        static get pluginName() {
          return "TableElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("TableEditing")) return;
          const t = e.model.schema, n = e.conversion, i = e.plugins.get(Ze), r = e.plugins.get("TableUtils");
          i.on("register:figure", () => {
            n.for("upcast").add(/* @__PURE__ */ function(s) {
              return (a) => {
                a.on("element:figure", (l, c, d) => {
                  const u = c.viewItem;
                  if (!c.modelRange || !u.hasClass("table")) return;
                  const g = s.processViewAttributes(u, d);
                  g && d.writer.setAttribute("htmlFigureAttributes", g, c.modelRange);
                }, { priority: "low" });
              };
            }(i));
          }), i.on("register:table", (s, a) => {
            a.model === "table" && (t.extend("table", { allowAttributes: ["htmlAttributes", "htmlFigureAttributes", "htmlTheadAttributes", "htmlTbodyAttributes"] }), n.for("upcast").add(/* @__PURE__ */ function(l) {
              return (c) => {
                c.on("element:table", (d, u, g) => {
                  if (!u.modelRange) return;
                  const p = u.viewItem;
                  b(p, "htmlAttributes");
                  for (const w of p.getChildren()) w.is("element", "thead") && b(w, "htmlTheadAttributes"), w.is("element", "tbody") && b(w, "htmlTbodyAttributes");
                  function b(w, y) {
                    const I = l.processViewAttributes(w, g);
                    I && g.writer.setAttribute(y, I, u.modelRange);
                  }
                }, { priority: "low" });
              };
            }(i)), n.for("downcast").add((l) => {
              function c(d, u) {
                l.on(`attribute:${u}:table`, (g, p, b) => {
                  if (!b.consumable.test(p.item, g.name)) return;
                  const w = b.mapper.toViewElement(p.item), y = kr(b.writer, w, d);
                  y && (b.consumable.consume(p.item, g.name), On(b.writer, p.attributeOldValue, p.attributeNewValue, y));
                });
              }
              c("table", "htmlAttributes"), c("figure", "htmlFigureAttributes"), c("thead", "htmlTheadAttributes"), c("tbody", "htmlTbodyAttributes");
            }), e.model.document.registerPostFixer(/* @__PURE__ */ function(l, c) {
              return (d) => {
                const u = l.document.differ.getChanges();
                let g = !1;
                for (const p of u) {
                  if (p.type != "attribute" || p.attributeKey != "headingRows") continue;
                  const b = p.range.start.nodeAfter, w = b.getAttribute("htmlTheadAttributes"), y = b.getAttribute("htmlTbodyAttributes");
                  w && !p.attributeNewValue ? (d.removeAttribute("htmlTheadAttributes", b), g = !0) : y && p.attributeNewValue == c.getRows(b) && (d.removeAttribute("htmlTbodyAttributes", b), g = !0);
                }
                return g;
              };
            }(e.model, r)), s.stop());
          });
        }
      }
      class j2 extends K {
        static get requires() {
          return [Ze];
        }
        static get pluginName() {
          return "StyleElementSupport";
        }
        init() {
          const e = this.editor.plugins.get(Ze);
          e.on("register:style", (t, n) => {
            const i = this.editor, r = i.model.schema, s = i.conversion;
            r.register("htmlStyle", n.modelSchema), r.extend("htmlStyle", { allowAttributes: ["htmlAttributes", "htmlContent"], isContent: !0 }), i.data.registerRawContentMatcher({ name: "style" }), s.for("upcast").elementToElement({ view: "style", model: ol(n) }), s.for("upcast").add(oi(n, e)), s.for("downcast").elementToElement({ model: "htmlStyle", view: (a, { writer: l }) => pr("style", a, l) }), s.for("downcast").add(ii(n)), t.stop();
          });
        }
      }
      class $2 extends K {
        static get requires() {
          return [Ze];
        }
        static get pluginName() {
          return "DocumentListElementSupport";
        }
        init() {
          const e = this.editor;
          if (!e.plugins.has("DocumentListEditing")) return;
          const t = e.model.schema, n = e.conversion, i = e.plugins.get(Ze), r = e.plugins.get("DocumentListEditing");
          r.registerDowncastStrategy({ scope: "item", attributeName: "htmlLiAttributes", setAttributeOnDowncast(s, a, l) {
            dn(s, a, l);
          } }), r.registerDowncastStrategy({ scope: "list", attributeName: "htmlListAttributes", setAttributeOnDowncast(s, a, l) {
            dn(s, a, l);
          } }), i.on("register", (s, a) => {
            ["ul", "ol", "li"].includes(a.view) && (s.stop(), t.checkAttribute("$block", "htmlListAttributes") || (t.extend("$block", { allowAttributes: ["htmlListAttributes", "htmlLiAttributes"] }), t.extend("$blockObject", { allowAttributes: ["htmlListAttributes", "htmlLiAttributes"] }), t.extend("$container", { allowAttributes: ["htmlListAttributes", "htmlLiAttributes"] }), n.for("upcast").add((l) => {
              l.on("element:ul", rl("htmlListAttributes", i), { priority: "low" }), l.on("element:ol", rl("htmlListAttributes", i), { priority: "low" }), l.on("element:li", rl("htmlLiAttributes", i), { priority: "low" });
            })));
          }), r.on("postFixer", (s, { listNodes: a, writer: l }) => {
            const c = [];
            for (const { node: d, previous: u } of a) {
              if (!u) continue;
              const g = d.getAttribute("listIndent"), p = u.getAttribute("listIndent");
              let b = null;
              if (g > p ? c[p] = u : g < p ? (b = c[g], c.length = g) : b = u, b) {
                if (b.getAttribute("listType") == d.getAttribute("listType")) {
                  const w = b.getAttribute("htmlListAttributes");
                  qi(d.getAttribute("htmlListAttributes"), w) || (l.setAttribute("htmlListAttributes", w, d), s.return = !0);
                }
                if (b.getAttribute("listItemId") == d.getAttribute("listItemId")) {
                  const w = b.getAttribute("htmlLiAttributes");
                  qi(d.getAttribute("htmlLiAttributes"), w) || (l.setAttribute("htmlLiAttributes", w, d), s.return = !0);
                }
              }
            }
          });
        }
        afterInit() {
          const e = this.editor;
          if (!e.commands.get("indentList")) return;
          const t = e.commands.get("indentList");
          this.listenTo(t, "afterExecute", (n, i) => {
            e.model.change((r) => {
              for (const s of i) r.setAttribute("htmlListAttributes", {}, s);
            });
          });
        }
      }
      function rl(o, e) {
        return (t, n, i) => {
          const r = n.viewItem;
          n.modelRange || Object.assign(n, i.convertChildren(n.viewItem, n.modelCursor));
          const s = e.processViewAttributes(r, i);
          for (const a of n.modelRange.getItems({ shallow: !0 })) a.hasAttribute("listItemId") && (a.hasAttribute(o) || i.writer.setAttribute(o, s || {}, a));
        };
      }
      class H2 extends K {
        static get requires() {
          return [Ze, wo];
        }
        static get pluginName() {
          return "CustomElementSupport";
        }
        init() {
          const e = this.editor.plugins.get(Ze), t = this.editor.plugins.get(wo);
          e.on("register:$customElement", (n, i) => {
            n.stop();
            const r = this.editor, s = r.model.schema, a = r.conversion, l = r.editing.view.domConverter.unsafeElements, c = r.data.htmlProcessor.domConverter.preElements;
            s.register(i.model, i.modelSchema), s.extend(i.model, { allowAttributes: ["htmlElementName", "htmlAttributes", "htmlContent"], isContent: !0 }), a.for("upcast").elementToElement({ view: /.*/, model: (d, u) => {
              if (d.name == "$comment" || !function(y) {
                try {
                  document.createElement(y);
                } catch {
                  return !1;
                }
                return !0;
              }(d.name) || t.getDefinitionsForView(d.name).size) return null;
              l.includes(d.name) || l.push(d.name), c.includes(d.name) || c.push(d.name);
              const g = u.writer.createElement(i.model, { htmlElementName: d.name }), p = e.processViewAttributes(d, u);
              p && u.writer.setAttribute("htmlAttributes", p, g);
              const b = new Wi(d.document).createDocumentFragment(d), w = r.data.processor.toData(b);
              u.writer.setAttribute("htmlContent", w, g);
              for (const { item: y } of r.editing.view.createRangeIn(d)) u.consumable.consume(y, { name: !0 });
              return g;
            }, converterPriority: "low" }), a.for("editingDowncast").elementToElement({ model: { name: i.model, attributes: ["htmlElementName", "htmlAttributes", "htmlContent"] }, view: (d, { writer: u }) => {
              const g = d.getAttribute("htmlElementName"), p = u.createRawElement(g);
              return d.hasAttribute("htmlAttributes") && dn(u, d.getAttribute("htmlAttributes"), p), p;
            } }), a.for("dataDowncast").elementToElement({ model: { name: i.model, attributes: ["htmlElementName", "htmlAttributes", "htmlContent"] }, view: (d, { writer: u }) => {
              const g = d.getAttribute("htmlElementName"), p = d.getAttribute("htmlContent"), b = u.createRawElement(g, null, (w, y) => {
                y.setContentOf(w, p);
                const I = w.firstChild;
                for (I.remove(); I.firstChild; ) w.appendChild(I.firstChild);
              });
              return d.hasAttribute("htmlAttributes") && dn(u, d.getAttribute("htmlAttributes"), b), b;
            } });
          });
        }
      }
      function* Ao(o, e, t) {
        if (e) if (!(Symbol.iterator in e) && e.is("documentSelection") && e.isCollapsed) o.schema.checkAttributeInSelection(e, t) && (yield e);
        else for (const n of function(i, r, s) {
          return !(Symbol.iterator in r) && (r.is("node") || r.is("$text") || r.is("$textProxy")) ? i.schema.checkAttribute(r, s) ? [i.createRangeOn(r)] : [] : i.schema.getValidRanges(i.createSelection(r).getRanges(), s);
        }(o, e, t)) yield* n.getItems({ shallow: !0 });
      }
      var _o = (o, e, t) => new Promise((n, i) => {
        var r = (l) => {
          try {
            a(t.next(l));
          } catch (c) {
            i(c);
          }
        }, s = (l) => {
          try {
            a(t.throw(l));
          } catch (c) {
            i(c);
          }
        }, a = (l) => l.done ? n(l.value) : Promise.resolve(l.value).then(r, s);
        a((t = t.apply(o, e)).next());
      });
      function Zf(o, e) {
        let t = new URL(o);
        if (e && Object.keys(e).length > 0) {
          const n = new URLSearchParams();
          for (const [i, r] of Object.entries(e)) if (Array.isArray(r)) for (const s of r) n.append(i, s);
          else n.append(i, r);
          t.search = n.toString();
        }
        return t.toString();
      }
      class q2 {
        constructor(e, t) {
          this.loader = e, this.api_url = t;
        }
        _getUploadUrl(e, t) {
          return _o(this, null, function* () {
            const n = yield fetch(this.api_url + "/vi/skey", { credentials: "include" }).catch((a) => {
              t(a);
            }), i = yield n.json(), r = { fileName: e.name, mimeType: e.type || "application/octet-stream", size: e.size.toString(), skey: i }, s = yield fetch(Zf(this.api_url + "/vi/file/getUploadURL", r), { method: "POST", credentials: "include" }).catch((a) => {
              t(a);
            });
            return this.loader.uploaded = 10, s;
          });
        }
        fileUpload(e, t, n) {
          return _o(this, null, function* () {
            yield fetch(t.values.uploadUrl, { mode: "no-cors", method: "POST", body: e }).catch((l) => {
              n(l);
            }), this.loader.uploaded = 50;
            const i = yield fetch(this.api_url + "/vi/skey", { credentials: "include" }).catch((l) => {
              n(l);
            }), r = yield i.json(), s = { key: t.values.uploadKey, node: void 0, skelType: "leaf", skey: r }, a = yield fetch(Zf(this.api_url + "/vi/file/add", s), { method: "POST", credentials: "include" }).catch((l) => {
              n(l);
            });
            return this.loader.uploaded = 75, a;
          });
        }
        upload() {
          return _o(this, null, function* () {
            return this.loader.uploadTotal = 100, this.loader.uploaded = 0, this.loader.file.then((e) => _o(this, null, function* () {
              return new Promise((t, n) => {
                this._getUploadUrl(e, n).then((i) => _o(this, null, function* () {
                  const r = yield i.json();
                  this.fileUpload(e, r, n).then((s) => _o(this, null, function* () {
                    const a = yield s.json();
                    this.loader.uploaded = 100, t({ default: this.api_url + a.values.downloadUrl });
                  }));
                }));
              });
            }));
          });
        }
        abort() {
          this.xhr && this.xhr.abort();
        }
      }
      var Jf = D(2245), U2 = { injectType: "singletonStyleTag", attributes: { "data-cke": !0 }, insert: "head", singleton: !0 };
      J()(Jf.Z, U2), Jf.Z.locals;
      class sl extends nr {
      }
      sl.builtinPlugins = [class extends K {
        static get requires() {
          return [EC, ei, TC, sC, Jv, LC];
        }
        static get pluginName() {
          return "Essentials";
        }
      }, class extends K {
        static get requires() {
          return [Jt];
        }
        static get pluginName() {
          return "CKFinderUploadAdapter";
        }
        init() {
          const o = this.editor.config.get("ckfinder.uploadUrl");
          o && (this.editor.plugins.get(Jt).createUploadAdapter = (e) => new UC(e, o, this.editor.t));
        }
      }, class extends Bi {
        constructor() {
          super(...arguments), this.token = null, this._tokens = /* @__PURE__ */ new Map();
        }
        static get pluginName() {
          return "CloudServices";
        }
        static get requires() {
          return [n2];
        }
        init() {
          return Rf(this, null, function* () {
            const o = this.context.config.get("cloudServices") || {};
            for (const [t, n] of Object.entries(o)) this[t] = n;
            if (!this.tokenUrl) return void (this.token = null);
            const e = this.context.plugins.get("CloudServicesCore");
            this.token = yield e.createToken(this.tokenUrl).init(), this._tokens.set(this.tokenUrl, this.token);
          });
        }
        registerTokenUrl(o) {
          return Rf(this, null, function* () {
            if (this._tokens.has(o)) return this.getTokenFor(o);
            const e = this.context.plugins.get("CloudServicesCore"), t = yield e.createToken(o).init();
            return this._tokens.set(o, t), t;
          });
        }
        getTokenFor(o) {
          const e = this._tokens.get(o);
          if (!e) throw new T("cloudservices-token-not-registered", this);
          return e;
        }
        destroy() {
          super.destroy();
          for (const o of this._tokens.values()) o.destroy();
        }
      }, class extends K {
        static get requires() {
          return [WC, KC];
        }
        static get pluginName() {
          return "Bold";
        }
      }, class extends K {
        static get requires() {
          return [ZC, JC];
        }
        static get pluginName() {
          return "Italic";
        }
      }, class extends K {
        static get requires() {
          return [e1, n1];
        }
        static get pluginName() {
          return "BlockQuote";
        }
      }, class extends K {
        static get pluginName() {
          return "EasyImage";
        }
        static get requires() {
          return [o1, "ImageUpload"];
        }
        init() {
          const o = this.editor;
          o.plugins.has("ImageBlockEditing") || o.plugins.has("ImageInlineEditing") || ee("easy-image-image-feature-missing", o);
        }
      }, class extends K {
        static get requires() {
          return [l1, d1];
        }
        static get pluginName() {
          return "Heading";
        }
      }, class extends K {
        static get requires() {
          return [D1, T1];
        }
        static get pluginName() {
          return "Image";
        }
      }, class extends K {
        static get requires() {
          return [Jm, oy];
        }
        static get pluginName() {
          return "ImageStyle";
        }
      }, class extends K {
        static get requires() {
          return [ar, Yt];
        }
        static get pluginName() {
          return "ImageToolbar";
        }
        afterInit() {
          const o = this.editor, e = o.t, t = o.plugins.get(ar), n = o.plugins.get("ImageUtils");
          var i;
          t.register("image", { ariaLabel: e("Image toolbar"), items: (i = o.config.get("image.toolbar") || [], i.map((r) => ze(r) ? r.name : r)), getRelatedElement: (r) => n.getClosestSelectedImageWidget(r) });
        }
      }, class extends K {
        static get pluginName() {
          return "ImageUpload";
        }
        static get requires() {
          return [q1, R1, F1];
        }
      }, class extends K {
        constructor(o) {
          super(o), this._resizeUnit = o.config.get("image.resizeUnit");
        }
        static get requires() {
          return [Z1];
        }
        static get pluginName() {
          return "ImageResizeButtons";
        }
        init() {
          const o = this.editor, e = o.config.get("image.resizeOptions"), t = o.commands.get("resizeImage");
          this.bind("isEnabled").to(t);
          for (const n of e) this._registerImageResizeButton(n);
          this._registerImageResizeDropdown(e);
        }
        _registerImageResizeButton(o) {
          const e = this.editor, { name: t, value: n, icon: i } = o, r = n ? n + this._resizeUnit : null;
          e.ui.componentFactory.add(t, (s) => {
            const a = new De(s), l = e.commands.get("resizeImage"), c = this._getOptionLabelValue(o, !0);
            if (!Ba[i]) throw new T("imageresizebuttons-missing-icon", e, o);
            return a.set({ label: c, icon: Ba[i], tooltip: c, isToggleable: !0 }), a.bind("isEnabled").to(this), a.bind("isOn").to(l, "value", Fm(r)), this.listenTo(a, "execute", () => {
              e.execute("resizeImage", { width: r });
            }), a;
          });
        }
        _registerImageResizeDropdown(o) {
          const e = this.editor, t = e.t, n = o.find((r) => !r.value), i = (r) => {
            const s = e.commands.get("resizeImage"), a = Kt(r, ad), l = a.buttonView, c = t("Resize image");
            return l.set({ tooltip: c, commandValue: n.value, icon: Ba.medium, isToggleable: !0, label: this._getOptionLabelValue(n), withText: !0, class: "ck-resize-image-button", ariaLabel: c, ariaLabelledBy: void 0 }), l.bind("label").to(s, "value", (d) => d && d.width ? d.width : this._getOptionLabelValue(n)), a.bind("isEnabled").to(this), oa(a, () => this._getResizeDropdownListItemDefinitions(o, s), { ariaLabel: t("Image resize list"), role: "menu" }), this.listenTo(a, "execute", (d) => {
              e.execute(d.source.commandName, { width: d.source.commandValue }), e.editing.view.focus();
            }), a;
          };
          e.ui.componentFactory.add("resizeImage", i), e.ui.componentFactory.add("imageResize", i);
        }
        _getOptionLabelValue(o, e = !1) {
          const t = this.editor.t;
          return o.label ? o.label : e ? o.value ? t("Resize image to %0", o.value + this._resizeUnit) : t("Resize image to the original size") : o.value ? o.value + this._resizeUnit : t("Original");
        }
        _getResizeDropdownListItemDefinitions(o, e) {
          const t = new _t();
          return o.map((n) => {
            const i = n.value ? n.value + this._resizeUnit : null, r = { type: "button", model: new pa({ commandName: "resizeImage", commandValue: i, label: this._getOptionLabelValue(n), role: "menuitemradio", withText: !0, icon: null }) };
            r.model.bind("isOn").to(e, "value", Fm(i)), t.add(r);
          }), t;
        }
      }, class extends K {
        static get pluginName() {
          return "Indent";
        }
        static get requires() {
          return [iy, ry];
        }
      }, class extends K {
        constructor(o) {
          super(o), o.config.define("indentBlock", { offset: 40, unit: "px" });
        }
        static get pluginName() {
          return "IndentBlock";
        }
        init() {
          const o = this.editor, e = o.config.get("indentBlock");
          e.classes && e.classes.length ? (this._setupConversionUsingClasses(e.classes), o.commands.add("indentBlock", new hr(o, new ip({ direction: "forward", classes: e.classes }))), o.commands.add("outdentBlock", new hr(o, new ip({ direction: "backward", classes: e.classes })))) : (o.data.addStyleProcessorRules(H_), this._setupConversionUsingOffset(), o.commands.add("indentBlock", new hr(o, new op({ direction: "forward", offset: e.offset, unit: e.unit }))), o.commands.add("outdentBlock", new hr(o, new op({ direction: "backward", offset: e.offset, unit: e.unit }))));
        }
        afterInit() {
          const o = this.editor, e = o.model.schema, t = o.commands.get("indent"), n = o.commands.get("outdent"), i = o.config.get("heading.options");
          (i && i.map((r) => r.model) || sy).forEach((r) => {
            e.isRegistered(r) && e.extend(r, { allowAttributes: "blockIndent" });
          }), e.setAttributeProperties("blockIndent", { isFormatting: !0 }), t.registerChildCommand(o.commands.get("indentBlock")), n.registerChildCommand(o.commands.get("outdentBlock"));
        }
        _setupConversionUsingOffset() {
          const o = this.editor.conversion, e = this.editor.locale.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left";
          o.for("upcast").attributeToAttribute({ view: { styles: { [e]: /[\s\S]+/ } }, model: { key: "blockIndent", value: (t) => t.getStyle(e) } }), o.for("downcast").attributeToAttribute({ model: "blockIndent", view: (t) => ({ key: "style", value: { [e]: t } }) });
        }
        _setupConversionUsingClasses(o) {
          const e = { model: { key: "blockIndent", values: [] }, view: {} };
          for (const t of o) e.model.values.push(t), e.view[t] = { key: "class", value: [t] };
          this.editor.conversion.attributeToAttribute(e);
        }
      }, class extends K {
        static get requires() {
          return [Iy, My, Ny];
        }
        static get pluginName() {
          return "Link";
        }
      }, class extends K {
        static get requires() {
          return [rE, Wy];
        }
        static get pluginName() {
          return "List";
        }
      }, Sa, class extends K {
        static get requires() {
          return [BE, PE, Pn, NE, ME, zE, ti];
        }
        static get pluginName() {
          return "Table";
        }
      }, class extends K {
        static get requires() {
          return [ar];
        }
        static get pluginName() {
          return "TableToolbar";
        }
        afterInit() {
          const o = this.editor, e = o.t, t = o.plugins.get(ar), n = o.config.get("table.contentToolbar"), i = o.config.get("table.tableToolbar");
          n && t.register("tableContent", { ariaLabel: e("Table toolbar"), items: n, getRelatedElement: jE }), i && t.register("table", { ariaLabel: e("Table toolbar"), items: i, getRelatedElement: LE });
        }
      }, class extends K {
        static get requires() {
          return ["Delete", "Input"];
        }
        static get pluginName() {
          return "TextTransformation";
        }
        constructor(o) {
          super(o), o.config.define("typing", { transformations: { include: Xv } });
        }
        init() {
          const o = this.editor.model.document.selection;
          o.on("change:range", () => {
            this.isEnabled = !o.anchor.parent.is("element", "codeBlock");
          }), this._enableTransformationWatchers();
        }
        _enableTransformationWatchers() {
          const o = this.editor, e = o.model, t = o.plugins.get("Delete"), n = function(r) {
            const s = r.extra || [], a = r.remove || [], l = (c) => !a.includes(c);
            return function(c) {
              const d = /* @__PURE__ */ new Set();
              for (const u of c) if (typeof u == "string" && _g[u]) for (const g of _g[u]) d.add(g);
              else d.add(u);
              return Array.from(d);
            }(r.include.concat(s).filter(l)).filter(l).map((c) => typeof c == "string" && Ag[c] ? Ag[c] : c).filter((c) => typeof c == "object").map((c) => ({ from: eC(c.from), to: tC(c.to) }));
          }(o.config.get("typing.transformations")), i = new bg(o.model, (r) => {
            for (const s of n)
              if (s.from.test(r)) return { normalizedTransformation: s };
          });
          i.on("matched:data", (r, s) => {
            if (!s.batch.isTyping) return;
            const { from: a, to: l } = s.normalizedTransformation, c = a.exec(s.text), d = l(c.slice(1)), u = s.range;
            let g = c.index;
            e.enqueueChange((p) => {
              for (let b = 1; b < c.length; b++) {
                const w = c[b], y = d[b - 1];
                if (y == null) {
                  g += w.length;
                  continue;
                }
                const I = u.start.getShiftedBy(g), z = e.createRange(I, I.getShiftedBy(w.length)), H = nC(I);
                e.insertContent(p.createText(y, H), z), g += y.length;
              }
              e.enqueueChange(() => {
                t.requestUndoOnBackspace();
              });
            });
          }), i.bind("isEnabled").to(this);
        }
      }, class extends K {
        static get requires() {
          return [YC, QC];
        }
        static get pluginName() {
          return "Underline";
        }
      }, class extends K {
        static get requires() {
          return [i2, r2];
        }
        static get pluginName() {
          return "Alignment";
        }
      }, class extends K {
        constructor(o) {
          super(o), this.set("isSourceEditingMode", !1), this._elementReplacer = new xl(), this._replacedRoots = /* @__PURE__ */ new Map(), this._dataFromRoots = /* @__PURE__ */ new Map();
        }
        static get pluginName() {
          return "SourceEditing";
        }
        static get requires() {
          return [Gi];
        }
        init() {
          const o = this.editor;
          o.t, o.ui.componentFactory.add("sourceEditing", (e) => {
            const t = new De(e);
            return t.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 0 5 4.5v15.003h-16V0h11zM3 1.5v3.25l-1.497 1-.003 8 1.5 1v3.254L7.685 18l-.001 1.504H17.5V8.002L16 9.428l-.004-4.22-4.222-3.692L3 1.5z"/><path d="M4.06 6.64a.75.75 0 0 1 .958 1.15l-.085.07L2.29 9.75l2.646 1.89c.302.216.4.62.232.951l-.058.095a.75.75 0 0 1-.951.232l-.095-.058-3.5-2.5V9.14l3.496-2.5zm4.194 6.22a.75.75 0 0 1-.958-1.149l.085-.07 2.643-1.89-2.646-1.89a.75.75 0 0 1-.232-.952l.058-.095a.75.75 0 0 1 .95-.232l.096.058 3.5 2.5v1.22l-3.496 2.5zm7.644-.836 2.122 2.122-5.825 5.809-2.125-.005.003-2.116zm2.539-1.847 1.414 1.414a.5.5 0 0 1 0 .707l-1.06 1.06-2.122-2.12 1.061-1.061a.5.5 0 0 1 .707 0z"/></svg>', tooltip: !0, withText: !0, class: "ck-source-editing-button" }), t.bind("isOn").to(this, "isSourceEditingMode"), t.bind("isEnabled").to(this, "isEnabled", o, "isReadOnly", o.plugins.get(Gi), "hasAny", (n, i, r) => !!n && !i && !r), this.listenTo(t, "execute", () => {
              this.isSourceEditingMode = !this.isSourceEditingMode;
            }), t;
          }), this._isAllowedToHandleSourceEditingMode() && (this.on("change:isSourceEditingMode", (e, t, n) => {
            n ? (this._showSourceEditing(), this._disableCommands()) : (this._hideSourceEditing(), this._enableCommands());
          }), this.on("change:isEnabled", (e, t, n) => this._handleReadOnlyMode(!n)), this.listenTo(o, "change:isReadOnly", (e, t, n) => this._handleReadOnlyMode(n))), o.data.on("get", () => {
            this.isSourceEditingMode && this.updateEditorData();
          }, { priority: "high" });
        }
        afterInit() {
          const o = this.editor;
          ["RealTimeCollaborativeEditing", "CommentsEditing", "TrackChangesEditing", "RevisionHistory"].some((e) => o.plugins.has(e)) && console.warn("You initialized the editor with the source editing feature and at least one of the collaboration features. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the collaboration features."), o.plugins.has("RestrictedEditingModeEditing") && console.warn("You initialized the editor with the source editing feature and restricted editing feature. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the restricted editing feature.");
        }
        updateEditorData() {
          const o = this.editor, e = {};
          for (const [t, n] of this._replacedRoots) {
            const i = this._dataFromRoots.get(t), r = n.dataset.value;
            i !== r && (e[t] = r);
          }
          Object.keys(e).length && o.data.set(e, { batchType: { isUndoable: !0 } });
        }
        _showSourceEditing() {
          const o = this.editor, e = o.editing.view, t = o.model;
          t.change((n) => {
            n.setSelection(null), n.removeSelectionAttribute(t.document.selection.getAttributeKeys());
          });
          for (const [n, i] of e.domRoots) {
            const r = l2(o.data.get({ rootName: n })), s = Mr(i.ownerDocument, "textarea", { rows: "1", "aria-label": "Source code editing area" }), a = Mr(i.ownerDocument, "div", { class: "ck-source-editing-area", "data-value": r }, [s]);
            s.value = r, s.setSelectionRange(0, 0), s.addEventListener("input", () => {
              a.dataset.value = s.value, o.ui.update();
            }), e.change((l) => {
              const c = e.document.getRoot(n);
              l.addClass("ck-hidden", c);
            }), o.ui.setEditableElement("sourceEditing:" + n, s), this._replacedRoots.set(n, a), this._elementReplacer.replace(i, a), this._dataFromRoots.set(n, r);
          }
          this._focusSourceEditing();
        }
        _hideSourceEditing() {
          const o = this.editor.editing.view;
          this.updateEditorData(), o.change((e) => {
            for (const [t] of this._replacedRoots) e.removeClass("ck-hidden", o.document.getRoot(t));
          }), this._elementReplacer.restore(), this._replacedRoots.clear(), this._dataFromRoots.clear(), o.focus();
        }
        _focusSourceEditing() {
          const o = this.editor, [e] = this._replacedRoots.values(), t = e.querySelector("textarea");
          o.editing.view.document.isFocused = !1, t.focus();
        }
        _disableCommands() {
          const o = this.editor;
          for (const e of o.commands.commands()) e.forceDisabled(Nf);
        }
        _enableCommands() {
          const o = this.editor;
          for (const e of o.commands.commands()) e.clearForceDisabled(Nf);
        }
        _handleReadOnlyMode(o) {
          if (this.isSourceEditingMode) for (const [, e] of this._replacedRoots) e.querySelector("textarea").readOnly = o;
        }
        _isAllowedToHandleSourceEditingMode() {
          const o = this.editor.ui.view.editable;
          return o && !o.hasExternalElement;
        }
      }, class extends K {
        static get requires() {
          return [u2, c2];
        }
        static get pluginName() {
          return "RemoveFormat";
        }
      }, class extends K {
        static get pluginName() {
          return "GeneralHtmlSupport";
        }
        static get requires() {
          return [Ze, O2, z2, M2, F2, N2, V2, L2, j2, $2, H2];
        }
        init() {
          const o = this.editor, e = o.plugins.get(Ze);
          e.loadAllowedConfig(o.config.get("htmlSupport.allow") || []), e.loadDisallowedConfig(o.config.get("htmlSupport.disallow") || []);
        }
        getGhsAttributeNameForElement(o) {
          const e = this.editor.plugins.get("DataSchema"), t = Array.from(e.getDefinitionsForView(o, !1)), n = t.find((i) => i.isInline && !t[0].isObject);
          return n ? n.model : "htmlAttributes";
        }
        addModelHtmlClass(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of Ao(n, t, i)) zn(r, s, i, "classes", (a) => {
              for (const l of $e(e)) a.add(l);
            });
          });
        }
        removeModelHtmlClass(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of Ao(n, t, i)) zn(r, s, i, "classes", (a) => {
              for (const l of $e(e)) a.delete(l);
            });
          });
        }
        setModelHtmlAttributes(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of Ao(n, t, i)) zn(r, s, i, "attributes", (a) => {
              for (const [l, c] of Object.entries(e)) a.set(l, c);
            });
          });
        }
        removeModelHtmlAttributes(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of Ao(n, t, i)) zn(r, s, i, "attributes", (a) => {
              for (const l of $e(e)) a.delete(l);
            });
          });
        }
        setModelHtmlStyles(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of Ao(n, t, i)) zn(r, s, i, "styles", (a) => {
              for (const [l, c] of Object.entries(e)) a.set(l, c);
            });
          });
        }
        removeModelHtmlStyles(o, e, t) {
          const n = this.editor.model, i = this.getGhsAttributeNameForElement(o);
          n.change((r) => {
            for (const s of Ao(n, t, i)) zn(r, s, i, "styles", (a) => {
              for (const l of $e(e)) a.delete(l);
            });
          });
        }
      }], sl.defaultConfig = { extraPlugins: [function(o) {
        o.plugins.get("FileRepository").createUploadAdapter = (e) => new q2(e, o.config.get("viur_api_url"));
      }, function(o) {
        o.conversion.attributeToElement({ model: "bold", view: "b", upcastAlso: [(e) => {
          const t = e.getStyle("font-weight");
          return t && (t == "bold" || Number(t) >= 600) ? { name: !0, styles: ["font-weight"] } : null;
        }] });
      }], toolbar: { items: ["heading", "|", "bold", "italic", "underline", "|", "alignment", "numberedList", "bulletedList", "blockQuote", "|", "indent", "outdent", "|", "link", "insertTable", "imageUpload", "|", "undo", "redo", "RemoveFormat", "sourceEditing"] }, image: { toolbar: ["imageStyle:inline", "imageStyle:block", "imageStyle:side", "|", "resizeImage:50", "resizeImage:75", "resizeImage:original", "imageTextAlternative"], resizeOptions: [{ name: "resizeImage:original", value: null, icon: "original" }, { name: "resizeImage:50", value: "50", icon: "medium" }, { name: "resizeImage:75", value: "75", icon: "large" }] }, table: { contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"] }, heading: { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h1", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h2", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h3", title: "Heading 3", class: "ck-heading_heading3" }, { model: "heading4", view: "h4", title: "Heading 4", class: "ck-heading_heading4" }, { model: "heading5", view: "h5", title: "Heading 5", class: "ck-heading_heading5" }, { model: "heading6", view: "h6", title: "Heading 6", class: "ck-heading_heading6" }] }, alignment: { options: [{ name: "left", className: "viur-txt-align--left" }, { name: "right", className: "viur-txt-align--right" }, { name: "center", className: "viur-txt-align--center" }, { name: "justify", className: "viur-txt-align--justify" }] }, indentBlock: { classes: ["viur-txt-indent--1", "viur-txt-indent--2", "viur-txt-indent--3", "viur-txt-indent--4", "viur-txt-indent--5", "viur-txt-indent--6", "viur-txt-indent--7", "viur-txt-indent--8", "viur-txt-indent--9", "viur-txt-indent--10"] }, htmlSupport: { allow: [{ name: "a", attributes: { target: !0, rel: !0 } }] }, language: "de", viur_api_url: "http://localhost:8080" };
    })(), M = M.default;
  })());
})(xr, xr.exports);
var aD = xr.exports;
const fb = /* @__PURE__ */ sD(aD), lD = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({
      value: "",
      editorConfig: {},
      editor: ie(() => fb)
    });
    function D(S) {
      C.emit("change", h.name, O.value, h.lang, h.index);
    }
    function M(S) {
      O.value = S.target.value, C.emit("change", h.name, O.value, h.lang, h.index);
    }
    Qe(() => {
      h.value !== null && (O.value = h.value), C.emit("change", h.name, h.value, h.lang, h.index);
    });
    function k(S) {
      S.editing.view.change((m) => {
        m.setStyle("min-height", "250px", S.editing.view.document.getRoot());
      });
    }
    return Eo(
      () => h.value,
      (S, m) => {
        O.value = S;
      }
    ), {
      state: O,
      ClassicEditor: fb,
      boneState: _,
      changeEvent: D,
      onReady: k,
      changeEventTextarea: M
    };
  }
}), cD = ["disabled", "value"];
function dD(h, C, _, O, D, M) {
  var S, m, E, x;
  const k = Ln("ckeditor");
  return h.state.editor ? (L(), $(re, { key: 0 }, [
    (S = h.boneState.bonestructure) != null && S.valid_html || (m = h.boneState.bonestructure) != null && m.validHtml ? (L(), Ue(k, {
      key: 0,
      modelValue: h.state.value,
      "onUpdate:modelValue": C[0] || (C[0] = (v) => h.state.value = v),
      editor: h.state.editor,
      config: h.state.editorConfig,
      disabled: (E = h.boneState) == null ? void 0 : E.readonly,
      onReady: h.onReady,
      onInput: h.changeEvent
    }, null, 8, ["modelValue", "editor", "config", "disabled", "onReady", "onInput"])) : (L(), $("sl-textarea", {
      key: 1,
      disabled: (x = h.boneState) == null ? void 0 : x.readonly,
      value: h.value,
      onInput: C[1] || (C[1] = (...v) => h.changeEventTextarea && h.changeEventTextarea(...v))
    }, null, 40, cD))
  ], 64)) : oe("", !0);
}
const bb = /* @__PURE__ */ ke(lD, [["render", dD]]), uD = Ve({
  inheritAttrs: !1,
  props: {
    name: String,
    value: [Object, String, Number, Boolean, Array],
    index: Number,
    lang: String
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({
      valueLat: null,
      valueLng: null
    });
    function D() {
      C.emit("change", h.name, [O.valueLat, O.valueLng], h.lang, h.index);
    }
    return Qe(() => {
      try {
        O.valueLat = h.value[0], O.valueLng = h.value[1];
      } catch {
      }
      C.emit("change", h.name, [O.valueLat, O.valueLng], h.lang, h.index);
    }), {
      state: O,
      boneState: _,
      changeEvent: D
    };
  }
}), hD = ["name", "min", "max", "disabled"], gD = ["name", "min", "max", "disabled"];
function mD(h, C, _, O, D, M) {
  return L(), $(re, null, [
    hn(F("sl-input", {
      "onUpdate:modelValue": C[0] || (C[0] = (k) => h.state.valueLat = k),
      index: "lat",
      type: "number",
      name: h.name,
      min: h.boneState.bonestructure.boundslat[0],
      max: h.boneState.bonestructure.boundslat[1],
      disabled: h.boneState.readonly,
      "value-as-number": "",
      step: "0.000001",
      onSlChange: C[1] || (C[1] = (...k) => h.changeEvent && h.changeEvent(...k)),
      placeholder: "Lat"
    }, null, 40, hD), [
      [ri, h.state.valueLat]
    ]),
    hn(F("sl-input", {
      "onUpdate:modelValue": C[2] || (C[2] = (k) => h.state.valueLng = k),
      index: "lng",
      type: "number",
      name: h.name,
      min: h.boneState.bonestructure.boundslat[0],
      max: h.boneState.bonestructure.boundslat[1],
      disabled: h.boneState.readonly,
      "value-as-number": "",
      step: "0.000001",
      onSlChange: C[3] || (C[3] = (...k) => h.changeEvent && h.changeEvent(...k)),
      placeholder: "Long"
    }, null, 40, gD), [
      [ri, h.state.valueLng]
    ])
  ], 64);
}
const kb = /* @__PURE__ */ ke(uD, [["render", mD], ["__scopeId", "data-v-7bc31020"]]), pD = Ve({
  props: {
    name: String,
    value: Object,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = he({
      counter: 0,
      debounce: null
    }), D = Se("addMultipleEntry"), M = Se("removeMultipleEntries");
    function k() {
      O.counter += 1;
      let m = 200;
      O.counter > 1 && (m = 500), O.debounce && clearTimeout(O.debounce), O.debounce = setTimeout(() => {
        for (let E = O.counter; E--; )
          D(h.lang);
        O.counter = 0;
      }, m);
    }
    function S() {
      let m = 200;
      O.debounce && clearTimeout(O.debounce), O.debounce = setTimeout(() => {
        M(h.lang);
      }, m);
    }
    return Qe(() => {
      (!h.value || h.value.length === 0) && C.emit("change", h.name, [], h.lang);
    }), {
      state: O,
      boneState: _,
      handleAdd: k,
      handleRemove: S,
      removeMultipleEntries: M
    };
  }
}), yb = (h) => (rt("data-v-63e75dee"), h = h(), st(), h), fD = { class: "actionbar" }, bD = ["title"], kD = /* @__PURE__ */ yb(() => /* @__PURE__ */ F("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), wD = [
  kD
], AD = ["title"], _D = /* @__PURE__ */ yb(() => /* @__PURE__ */ F("sl-icon", {
  slot: "prefix",
  name: "plus-lg"
}, null, -1));
function vD(h, C, _, O, D, M) {
  return L(), $("div", fD, [
    h.boneState.multiple && !h.readonly ? (L(), $("sl-button", {
      key: 0,
      variant: "danger",
      title: h.$t("bone.del"),
      outline: "",
      class: "delete-btn",
      onClick: C[0] || (C[0] = (k) => h.handleRemove(h.lang))
    }, wD, 8, bD)) : oe("", !0),
    h.boneState.multiple && !h.readonly ? (L(), $("sl-button", {
      key: 1,
      variant: "success",
      title: h.$t("bone.add"),
      outline: "",
      class: "add-btn",
      onClick: C[1] || (C[1] = (k) => h.handleAdd(h.lang))
    }, [
      _D,
      ue(" " + Ae(h.$t("bone.add")) + " ", 1),
      h.state.counter > 1 ? (L(), $(re, { key: 0 }, [
        ue("(" + Ae(h.state.counter) + ")", 1)
      ], 64)) : oe("", !0)
    ], 8, AD)) : oe("", !0)
  ]);
}
const CD = /* @__PURE__ */ ke(pD, [["render", vD], ["__scopeId", "data-v-63e75dee"]]);
var yD = { VITE_API_URL: "", BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const ED = Ve({
  props: {
    name: String,
    value: Object,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = Se("addMultipleEntry"), D = Se("formatString"), M = null, k = he({
      skels: {},
      hasUsing: ie(() => _ == null ? void 0 : _.bonestructure.using)
    });
    function S(m) {
      let E = "";
      return _.bonestructure.type === "relational.tree.leaf.file" ? E = "skelType=leaf&" : _.bonestructure.type === "relational.tree.node.file" && (E = "skelType=node&"), Be.get(
        `/${yD.VITE_DEFAULT_RENDERER || "vi"}/${_.bonestructure.module}/list?${E}limit=99`
      ).then(async (x) => {
        var f;
        const v = await x.json();
        return k.skels = v.skellist.reduce((A, P) => (A[P.key] = P, A), {}), (f = v.skellist) == null ? void 0 : f.map((A) => ({ text: D(_.bonestructure.format, { dest: A }), value: A.key, data: A }));
      });
    }
    return Qe(() => {
      (!h.value || h.value.length === 0) && C.emit("change", h.name, [], h.lang);
    }), {
      state: k,
      boneState: _,
      addMultipleEntry: O,
      removeMultipleEntries: M,
      getList: S
    };
  }
}), Eb = (h) => (rt("data-v-eeea51c6"), h = h(), st(), h), xD = { class: "actionbar" }, SD = ["title"], DD = /* @__PURE__ */ Eb(() => /* @__PURE__ */ F("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), BD = [
  DD
], TD = ["source"], ID = ["title"], PD = /* @__PURE__ */ Eb(() => /* @__PURE__ */ F("sl-icon", {
  slot: "prefix",
  name: "plus-lg"
}, null, -1));
function RD(h, C, _, O, D, M) {
  return L(), $("div", xD, [
    h.boneState.multiple && !h.readonly ? (L(), $("sl-button", {
      key: 0,
      variant: "danger",
      title: h.$t("bone.del"),
      outline: "",
      class: "delete-btn",
      onClick: C[0] || (C[0] = (k) => h.openSelector())
    }, BD, 8, SD)) : oe("", !0),
    F("sl-combobox", {
      source: h.getList,
      hoist: "",
      onSlItemSelect: C[1] || (C[1] = (k) => {
        var S;
        return h.addMultipleEntry(h.lang, {
          dest: (S = h.state.skels) == null ? void 0 : S[k.detail.item.value],
          rel: h.state.hasUsing ? void 0 : null
        });
      })
    }, null, 40, TD),
    h.boneState.multiple && !h.readonly ? (L(), $("sl-button", {
      key: 1,
      variant: "success",
      title: h.$t("bone.add"),
      outline: "",
      class: "add-btn",
      onClick: C[2] || (C[2] = (k) => h.addMultipleEntry(h.lang))
    }, [
      PD,
      ue(" " + Ae(h.$t("bone.list")), 1)
    ], 8, ID)) : oe("", !0)
  ]);
}
const OD = /* @__PURE__ */ ke(ED, [["render", RD], ["__scopeId", "data-v-eeea51c6"]]);
var wb = { VITE_API_URL: "", BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const zD = Ve({
  props: {
    name: String,
    value: Object,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change"],
  setup(h, C) {
    const _ = Se("boneState"), O = Se("addMultipleEntry");
    Se("formatString");
    const D = null, M = Dt(), k = he({
      skels: {},
      uploadinput: null,
      loading: !1,
      droparea: !1,
      hasUsing: ie(() => _ == null ? void 0 : _.bonestructure.using)
    });
    function S(x) {
      const v = {
        fileName: x.name,
        mimeType: x.type || "application/octet-stream",
        size: x.size.toString()
      };
      return new Promise((f, A) => {
        Be.securePost(`/${wb.VITE_DEFAULT_RENDERER || "vi"}/file/getUploadURL`, { dataObj: v }).then(async (P) => {
          let B = await P.json();
          fetch(B.values.uploadUrl, {
            body: x,
            method: "POST",
            mode: "no-cors"
          }).then(async (R) => {
            const N = {
              key: B.values.uploadKey,
              node: void 0,
              skelType: "leaf"
            };
            Be.securePost(`/${wb.VITE_DEFAULT_RENDERER || "vi"}/file/add`, { dataObj: N }).then(async (j) => {
              let q = await j.json();
              q.action === "addSuccess" ? f(q.values) : A(q);
            }).catch((j) => {
              A(j);
            });
          }).catch((R) => {
            A(R);
          });
        }).catch((P) => {
          A(P);
        });
      });
    }
    async function m(x) {
      k.loading = !0;
      for (let v of x.target.files) {
        let f = await S(v);
        M.value.value = null;
        let A = null;
        k.hasUsing && (A = void 0), O(h.lang, { dest: f, rel: A });
      }
      k.loading = !1;
    }
    async function E(x) {
      k.loading = !0, k.droparea = !1;
      for (let v of x.dataTransfer.files) {
        let f = await S(v);
        M.value.value = null;
        let A = null;
        k.hasUsing && (A = void 0), O(h.lang, { dest: f, rel: A });
      }
      k.loading = !1;
    }
    return Qe(() => {
      (!h.value || h.value.length === 0) && C.emit("change", h.name, [], h.lang);
    }), {
      state: k,
      boneState: _,
      addMultipleEntry: O,
      removeMultipleEntries: D,
      uploadFile: S,
      uploadinput: M,
      handleUpload: m,
      handleDrop: E
    };
  }
}), ml = (h) => (rt("data-v-9bac9f8a"), h = h(), st(), h), MD = ["title"], FD = /* @__PURE__ */ ml(() => /* @__PURE__ */ F("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), ND = [
  FD
], VD = {
  key: 1,
  class: "droparea"
}, LD = ["multiple"], jD = ["title"], $D = /* @__PURE__ */ ml(() => /* @__PURE__ */ F("sl-icon", {
  slot: "prefix",
  name: "plus-lg"
}, null, -1)), HD = [
  $D
], qD = ["title"], UD = /* @__PURE__ */ ml(() => /* @__PURE__ */ F("sl-icon", { name: "upload" }, null, -1)), WD = {
  key: 0,
  slot: "suffix"
};
function KD(h, C, _, O, D, M) {
  return L(), $("div", {
    class: "actionbar",
    onDragover: C[4] || (C[4] = Er((k) => h.state.droparea = !0, ["prevent"])),
    onDragleave: C[5] || (C[5] = (k) => h.state.droparea = !1),
    onDrop: C[6] || (C[6] = Er((...k) => h.handleDrop && h.handleDrop(...k), ["prevent"]))
  }, [
    h.boneState.multiple && !h.readonly ? (L(), $("sl-button", {
      key: 0,
      variant: "danger",
      title: h.$t("bone.del"),
      outline: "",
      class: "delete-btn",
      onClick: C[0] || (C[0] = (k) => h.openSelector())
    }, ND, 8, MD)) : oe("", !0),
    h.state.droparea ? (L(), $("div", VD, " Dateien hier hinziehen ")) : oe("", !0),
    F("input", {
      ref: "uploadinput",
      hidden: "",
      type: "file",
      multiple: h.boneState.multiple,
      onChange: C[1] || (C[1] = (...k) => h.handleUpload && h.handleUpload(...k))
    }, null, 40, LD),
    h.boneState.multiple && !h.readonly ? (L(), $("sl-button", {
      key: 2,
      outline: "",
      title: h.$t("bone.list"),
      class: "add-btn",
      onClick: C[2] || (C[2] = (k) => h.addMultipleEntry(h.lang))
    }, HD, 8, jD)) : oe("", !0),
    h.boneState.multiple && !h.readonly ? (L(), $("sl-button", {
      key: 3,
      variant: "success",
      outline: "",
      title: h.$t("bone.upload"),
      class: "upload-btn",
      onClick: C[3] || (C[3] = (k) => h.uploadinput.click())
    }, [
      UD,
      ue(" " + Ae(h.$t("bone.upload")) + " ", 1),
      h.state.loading ? (L(), $("sl-spinner", WD)) : oe("", !0)
    ], 8, qD)) : oe("", !0)
  ], 32);
}
const GD = /* @__PURE__ */ ke(zD, [["render", KD], ["__scopeId", "data-v-9bac9f8a"]]), pl = hl("boneStore", () => {
  const h = he({
    additionalBones: Xt({}),
    defaultBones: Xt({
      rawBone: ul,
      keyBone: ob,
      stringBone: ib,
      emailBone: rb,
      dateBone: sb,
      booleanBone: lb,
      selectBone: ab,
      passwordBone: cb,
      recordBone: db,
      numericBone: hb,
      colorBone: ub,
      relationalBone: gb,
      jsonBone: MS,
      fileBone: pb,
      textBone: bb,
      spatialBone: kb
    }),
    actionbars: Xt({
      "relational.tree.leaf.file.file": GD,
      "relational.": OD
    }),
    multibones: Xt(["select", "select."])
  });
  function C(k, S) {
    h.additionalBones[k] = S;
  }
  function _() {
    let k = h.defaultBones;
    for (const [S, m] of Object.entries(h.additionalBones))
      k.add(m);
    return k;
  }
  function O(k) {
    if (Object.keys(h.additionalBones).includes(k))
      return h.additionalBones[k];
    {
      let S = k.split("."), m = Object.entries(h.additionalBones).filter(
        (E) => E[0].startsWith(S[0] + ".")
      );
      if (m.length > 0) {
        m.sort((E, x) => x.length - E.length);
        for (let E of m)
          if (k.startsWith(E[0]))
            return h.additionalBones[E[0]];
      }
    }
    return k === "date" ? sb : k === "key" ? ob : k === "str.email" ? rb : k === "str" || k.startsWith("str.") ? ib : k === "select" || k.startsWith("select.") ? ab : k === "bool" ? lb : k === "password" ? cb : k === "record" ? db : k === "numeric" || k.startsWith("numeric.") ? hb : k === "relational.tree.leaf.file.file" ? pb : k === "relational" || k.startsWith("relational.") ? gb : k === "color" ? ub : k === "text" ? bb : k === "spatial" ? kb : ul;
  }
  function D(k, S) {
    h.actionbars[k] = S;
  }
  function M(k) {
    if (Object.keys(h.actionbars).includes(k))
      return h.actionbars[k];
    {
      let S = k.split("."), m = Object.entries(h.actionbars).filter(
        (E) => E[0].startsWith(S[0] + ".")
      );
      if (m.length > 0) {
        m.sort((E, x) => x.length - E.length);
        for (let E of m)
          if (k.startsWith(E[0]))
            return h.actionbars[E[0]];
      }
    }
    return CD;
  }
  return {
    state: h,
    addBoneWidget: C,
    getBoneWidget: O,
    importWidgets: _,
    addBoneActionbar: D,
    getBoneActionbar: M
  };
});
function ZD(h) {
  return pl().getBoneActionbar(h);
}
function Vn(h) {
  return pl().getBoneWidget(h);
}
function JD(h) {
  const C = pl();
  if (C.state.multibones.includes(h))
    return !0;
  {
    let _ = h.split("."), O = Object.entries(C.state.multibones).filter(
      (D) => D[1].startsWith(_[0] + ".")
    );
    if (O.length > 0) {
      O.sort((D, M) => M.length - D.length);
      for (let D of O)
        if (h.startsWith(D[1]))
          return !0;
    }
  }
  return !1;
}
const fl = (h) => (rt("data-v-00cf0e53"), h = h(), st(), h), YD = /* @__PURE__ */ fl(() => /* @__PURE__ */ F("h2", { class: "viur-shop-form-headline headline" }, "Nutzterdaten", -1)), QD = /* @__PURE__ */ fl(() => /* @__PURE__ */ F("h2", { class: "viur-shop-form-headline headline" }, "Lieferadresse", -1)), XD = { key: 0 }, eB = /* @__PURE__ */ fl(() => /* @__PURE__ */ F("h2", { class: "viur-shop-form-headline headline" }, "Rechnungsadresse", -1)), tB = {
  __name: "UserInformation",
  props: {
    mode: { type: String, default: "form" },
    conditions: { type: Function }
  },
  setup(h) {
    const C = ai(), _ = he({
      formValues: {},
      requiredFieldsFilled: ie(() => {
        if (_.isCustomAdress)
          return Object.keys(_.formValues).includes("city") && Object.keys(_.formValues).includes("street") && Object.keys(_.formValues).includes("billing.city") && Object.keys(_.formValues).includes("billing.street") && Object.keys(_.formValues).includes("email") && Object.keys(_.formValues).includes("firstname") && Object.keys(_.formValues).includes("lastname");
        if (!_.isCustomAdress)
          return Object.keys(_.formValues).includes("city") && Object.keys(_.formValues).includes("street") && Object.keys(_.formValues).includes("email") && Object.keys(_.formValues).includes("firstname") && Object.keys(_.formValues).includes("lastname");
      }),
      isCustomAdress: !1,
      addSkel: null,
      errors: {}
    });
    function O(k) {
      k.target.checked && (_.isCustomAdress = !1), k.target.checked || (_.isCustomAdress = !0);
    }
    function D(k, S) {
      for (const [m, E] of Object.entries(S.value[0]))
        _.formValues[m] = E;
    }
    function M(k) {
      let S = {};
      return k instanceof Object ? k : (k.forEach((m) => {
        let E = m[0], x = m[1];
        S[E] = x;
      }), S);
    }
    return Eo(_.formValues, (k) => {
      Object.entries(k).forEach(([S, m]) => {
        m === "" && delete _.formValues[S];
      });
    }), jn(async () => {
      await C.getAdressStructure(), _.addSkel = C.state.structure.address;
    }), (k, S) => {
      const m = Ln("bone");
      return L(), $(re, null, [
        F("div", null, [
          YD,
          (L(!0), $(re, null, Je(M(_.addSkel), (E, x) => (L(), $(re, { key: x }, [
            E.visible && E.params.group === "Customer Info" ? (L(), Ue(m, {
              key: 0,
              is: wt(Vn)(E.type),
              name: x,
              structure: M(_.addSkel),
              errors: _.errors[x] ? _.errors[x] : [],
              skel: _.formValues,
              onChange: (v) => D(x, v),
              class: "viur-shop-form-grid-w-2"
            }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : oe("", !0)
          ], 64))), 128))
        ]),
        F("div", null, [
          QD,
          (L(!0), $(re, null, Je(M(_.addSkel), (E, x) => (L(), $(re, { key: x }, [
            E.visible && E.params.group === "Customer Address" ? (L(), Ue(m, {
              key: 0,
              is: wt(Vn)(E.type),
              name: x,
              structure: M(_.addSkel),
              errors: _.errors[x] ? _.errors[x] : [],
              skel: _.formValues,
              onChange: (v) => D(x, v)
            }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : oe("", !0)
          ], 64))), 128))
        ]),
        _.isCustomAdress ? (L(), $("div", XD, [
          eB,
          (L(!0), $(re, null, Je(M(_.addSkel), (E, x) => (L(), $(re, { key: x }, [
            E.visible && E.params.group === "Customer Address" ? (L(), Ue(m, {
              key: 0,
              is: wt(Vn)(E.type),
              name: x,
              structure: M(_.addSkel),
              errors: _.errors[x] ? _.errors[x] : [],
              skel: _.formValues,
              onChange: (v) => D(x, v)
            }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : oe("", !0)
          ], 64))), 128))
        ])) : oe("", !0),
        F("sl-checkbox", {
          onSlChange: O,
          checked: ""
        }, " Rechnungsadresse wie Lieferadresse ", 32)
      ], 64);
    };
  }
}, nB = /* @__PURE__ */ ke(tB, [["__scopeId", "data-v-00cf0e53"]]), oB = Ve({
  props: {
    isDragging: Boolean,
    draggingLineBottom: Boolean,
    draggingLineTop: Boolean
  },
  components: {},
  emits: ["change", "delete", "handleDragStart", "handleDragEnd", "handleDragOver", "handleDrop"],
  setup(h, C) {
    const _ = Se("boneState");
    return {
      state: he({
        isDraggable: !1
      }),
      boneState: _
    };
  }
}), xb = (h) => (rt("data-v-141aaf9b"), h = h(), st(), h), iB = ["draggable"], rB = ["disabled"], sB = /* @__PURE__ */ xb(() => /* @__PURE__ */ F("sl-icon", {
  slot: "prefix",
  name: "grip-vertical"
}, null, -1)), aB = [
  sB
], lB = { class: "value" }, cB = ["disabled", "title"], dB = /* @__PURE__ */ xb(() => /* @__PURE__ */ F("sl-icon", {
  slot: "prefix",
  name: "x-lg"
}, null, -1)), uB = [
  dB
];
function hB(h, C, _, O, D, M) {
  return L(), $("div", {
    class: yo(["value-line", {
      "is-dragging": h.isDragging,
      "dragging-line-bottom": h.draggingLineBottom,
      "dragging-line-top": h.draggingLineTop
    }]),
    draggable: h.state.isDraggable,
    onDragover: C[2] || (C[2] = (k) => h.$emit("handleDragOver", k)),
    onDrop: C[3] || (C[3] = (k) => h.$emit("handleDrop", k)),
    onDragstart: C[4] || (C[4] = (k) => h.$emit("handleDragStart", k)),
    onDragend: C[5] || (C[5] = (k) => h.$emit("handleDragEnd"))
  }, [
    F("sl-button", {
      disabled: h.boneState.readonly,
      class: "drag-button",
      onMousedown: C[0] || (C[0] = (k) => h.state.isDraggable = !0)
    }, aB, 40, rB),
    F("div", lB, [
      Ab(h.$slots, "default", {}, void 0, !0)
    ]),
    F("sl-button", {
      variant: "danger",
      disabled: h.boneState.readonly,
      outline: "",
      title: h.$t("bone.del"),
      class: "delete-btn",
      onClick: C[1] || (C[1] = (k) => h.$emit("delete"))
    }, uB, 8, cB)
  ], 42, iB);
}
const gB = /* @__PURE__ */ ke(oB, [["render", hB], ["__scopeId", "data-v-141aaf9b"]]), mB = Ve({
  props: {
    name: String,
    value: Object,
    index: Number,
    lang: String,
    readonly: Boolean,
    params: Object
  },
  components: {},
  emits: ["change", "handleClick"],
  setup(h, C) {
    const _ = Se("boneState");
    return {
      state: he({
        debug: !1
      }),
      boneState: _
    };
  }
}), pB = { class: "bone-name" }, fB = { key: 0 }, bB = { class: "bone" };
function kB(h, C, _, O, D, M) {
  return L(), $(re, null, [
    F("label", pB, [
      Ab(h.$slots, "default", {}, void 0, !0),
      oe("", !0)
    ]),
    h.state.debug ? (L(), $("div", fB, [
      F("div", bB, Ae(h.name), 1),
      F("pre", null, "    " + Ae(h.boneState) + `
    `, 1)
    ])) : oe("", !0)
  ], 64);
}
const wB = /* @__PURE__ */ ke(mB, [["render", kB], ["__scopeId", "data-v-b7149172"]]), AB = Ve({
  inheritAttrs: !1,
  emits: ["change", "change-internal", "handleClick"],
  components: {
    wrapperMultiple: gB,
    BoneLabel: wB
  },
  props: {
    is: {
      type: Object,
      default: ul
    },
    name: {
      type: String,
      required: !0
    },
    languages: Array,
    multiple: Boolean,
    readonly: Boolean,
    required: Boolean,
    params: Object,
    value: [Object, String, Number, Boolean, Array],
    structure: {
      type: Object,
      required: !0
    },
    skel: {
      type: null,
      required: !0
    },
    errors: Object,
    showLabelInfo: { type: Boolean, required: !1, default: !1 },
    autofocus: { type: Boolean, required: !1, default: !1 }
  },
  setup(h, C) {
    const _ = he({
      bonestructure: ie(() => {
        var B;
        return (B = h.structure) == null ? void 0 : B[h.name];
      }),
      bonevalue: null,
      dragStartIndex: {
        lang: null,
        index: Number
      },
      dropIndex: {
        lang: null,
        index: Number
      },
      draggingLineBottom: {
        lang: String,
        index: Number
      },
      draggingLineTop: {
        lang: String,
        index: Number
      },
      isDragging: {
        lang: String,
        index: Number
      },
      multilanguage: ie(() => {
        var B;
        return ((B = _.languages) == null ? void 0 : B.length) && _.languages.length > 0;
      }),
      languages: ie(() => h.languages ? h.languages : _.bonestructure && Object.keys(_.bonestructure).includes("languages") ? _.bonestructure.languages : []),
      readonly: ie(() => h.readonly ? h.readonly : _.bonestructure && Object.keys(_.bonestructure).includes("readonly") ? _.bonestructure.readonly : !1),
      required: ie(() => h.required ? h.required : _.bonestructure && Object.keys(_.bonestructure).includes("required") ? _.bonestructure.required : !1),
      hasTooltip: ie(() => !!(_.bonestructure && Object.keys(_.bonestructure.params).includes("tooltip"))),
      multiple: ie(() => h.multiple ? h.multiple : _.bonestructure && Object.keys(_.bonestructure).includes("multiple") ? _.bonestructure.multiple : !1),
      params: ie(() => h.params ? h.params : _.bonestructure && Object.keys(_.bonestructure).includes("params") ? _.bonestructure.params : {}),
      actionbar: ie(() => {
        var B;
        return ZD((B = _.bonestructure) == null ? void 0 : B.type);
      }),
      isEmpty: ie(() => {
        function B(R) {
          for (const [N, j] of Object.entries(R))
            if (j !== null) {
              if (Array.isArray(j) && j.length > 0)
                return !1;
              if (!Array.isArray(j))
                return !1;
            }
          return !0;
        }
        return _.readonly ? !1 : !_.bonevalue || Array.isArray(_.bonevalue) && _.bonevalue.length === 0 ? !0 : _.bonevalue === Object(_.bonevalue) && !Array.isArray(_.bonevalue) ? B(_.bonevalue) : !1;
      }),
      errors: [],
      errorMessages: ie(() => {
        let B = [];
        for (let R of h.errors)
          R.fieldPath[0] === h.name && (R.severity > 2 || _.required && (R.severity === 2 || R.severity === 0)) && B.push(R.errorMessage);
        return B;
      })
    });
    Ar("boneState", _);
    function O(B, R, N) {
      k(R, B, "isDragging"), k(R, B, "dragStartIndex");
    }
    function D(B, R, N) {
      N.preventDefault();
      const j = N.clientY - N.target.getBoundingClientRect().top, q = N.target.closest(".value-line");
      j < q.offsetHeight / 2 ? (k(R, B, "draggingLineTop"), S("draggingLineBottom"), _.dropIndex.index = B) : (k(R, B, "draggingLineBottom"), S("draggingLineTop"), _.dropIndex.index = B + 1);
      let Z = R ? _.bonevalue[R] : _.bonevalue;
      _.dropIndex.index > Z.length - 1 && (_.dropIndex.index -= 1);
    }
    function M(B, R, N) {
      let j = null;
      _.dragStartIndex.index !== _.dropIndex.index && (R ? (j = _.bonevalue[R].splice(_.dragStartIndex.index, 1)[0], _.bonevalue[R].splice(_.dropIndex.index, 0, j)) : (j = _.bonevalue.splice(_.dragStartIndex.index, 1)[0], _.bonevalue.splice(_.dropIndex.index, 0, j)), console.dir(_.bonevalue[0]), C.emit("change", {
        name: h.name,
        value: E(),
        lang: R,
        index: B
      })), S("draggingLineBottom", "draggingLineTop", "isDragging", "dragStartIndex", "dropIndex");
    }
    function k(B, R, N) {
      _[N].lang = B || null, _[N].index = R;
    }
    function S(...B) {
      B.forEach((R) => {
        _[R] = {
          lang: null,
          index: Number
        };
      });
    }
    function m(B, R, N = null, j = null, q) {
      if (R === void 0 || (N ? (_.bonevalue || (_.bonevalue = {}), Object.keys(_.bonevalue).includes(N) && j !== null ? _.bonevalue[N][j] = R : _.bonevalue[N] = R) : j !== null ? _.bonevalue[j] = R : q === !1 || (_.bonevalue = R), _.readonly)) return !1;
      let Z = {
        name: B,
        value: E(),
        lang: N,
        index: j
      }, Q = {
        name: B,
        value: R,
        lang: N,
        index: j
      };
      q != null && (Z.pwMatch = q, Q.pwMatch = q), C.emit("change", Z), C.emit("change-internal", Q);
    }
    function E() {
      function B(N, j = null) {
        let q = [];
        if (Array.isArray(N))
          if (_.bonestructure.type == "spatial" && N.length === 2 && !Array.isArray(N[0]))
            q.push({ [j + ".lat"]: N[0] }), q.push({ [j + ".lng"]: N[1] });
          else if (Object.values(N).filter((Z) => Z === Object(Z)).length > 0)
            for (const [Z, Q] of N.entries())
              Q.rel !== null ? q.push(B(Q, j + "." + Z)) : q.push(B(Q, j));
          else
            for (const [Z, Q] of N.entries())
              q.push(B(Q, j));
        else if (N === Object(N))
          for (const [Z, Q] of Object.entries(N))
            j ? j.endsWith(".dest") || j.endsWith(".rel") ? j.endsWith(".dest") && Z === "key" ? (/\.[0-9]*\.dest$/.test(j) ? q.push(B(Q, j.replace(/\.[0-9]*\.dest/, ""))) : q.push(B(Q, j.replace(/\.dest/, ""))), q.push(B(Q, j.replace(/\.dest/, "") + "." + Z))) : j.endsWith(".rel") && q.push(B(Q, j.replace(/\.rel/, "") + "." + Z)) : q.push(B(Q, j + "." + Z)) : q.push(B(Q, Z));
        else
          N == null && (N = ""), j !== null && q.push({ [j]: N });
        return q;
      }
      let R = B(_.bonevalue, h.name);
      return R = R.flat(10), R;
    }
    function x(B = null, R = "") {
      B ? Object.keys(_.bonevalue).includes(B) ? _.bonevalue[B].push(R) : _.bonevalue[B] = [R] : _.bonevalue ? _.bonevalue.push(R) : _.bonevalue = [R];
    }
    Ar("addMultipleEntry", x);
    function v(B, R = null) {
      var N;
      R ? (N = _.bonevalue) == null || N[R].splice(B, 1) : _.bonevalue.splice(B, 1), C.emit("change", {
        name: h.name,
        value: E(),
        lang: R,
        index: B
      }), C.emit("change-internal", {
        name: h.name,
        value: E(),
        lang: R,
        index: B
      });
    }
    function f(B = null) {
      var R;
      B ? (R = _.bonevalue) == null || R[B].splice(0) : _.bonevalue.splice(0), C.emit("change", {
        name: h.name,
        value: E(),
        lang: B
      }), C.emit("change-internal", {
        name: h.name,
        value: E(),
        lang: B
      });
    }
    Ar("removeMultipleEntries", f);
    function A(B = null, R = "") {
      x(B, R);
    }
    function P(B, R) {
      function N(Q) {
        let se = [], Y = [], ne = /\$\((.*?)\)/g;
        for (; Y; ) {
          if (Y = ne.exec(Q), !Y) {
            Y = !1;
            continue;
          }
          se.push(Y[1]);
        }
        return se;
      }
      function j(Q, se) {
        let Y = Q.split("."), ne = Q.split("."), T = se;
        for (let ee of Y)
          if (ne.shift(), T && T !== "-" && Object.keys(T).includes(ee) && T[ee])
            if (Array.isArray(T[ee])) {
              let Te = [];
              for (let Me of T[ee])
                Te.push(j(ne.join("."), Me));
              T = Te.join(", ");
            } else
              T = T[ee];
          else (!T || typeof T[ee] == "object" && !T[ee]) && (T = "-");
        return T;
      }
      let q = N(B), Z = [];
      Array.isArray(R) || (R = [R]);
      for (let Q of R) {
        let se = B;
        for (let Y of q) {
          let ne = j(Y, Q);
          se = se.replace("$(" + Y + ")", ne);
        }
        Z.push(se);
      }
      return Z.join(", ");
    }
    return Ar("formatString", P), jn(() => {
      var B;
      h.value ? _.bonevalue = h.value : _.bonevalue = (B = h.skel) == null ? void 0 : B[h.name];
    }), Eo(
      () => h.skel,
      (B, R) => {
        var N;
        _.bonevalue = (N = h.skel) == null ? void 0 : N[h.name];
      }
    ), Eo(
      () => {
        var B;
        return (B = h.errors) == null ? void 0 : B[h.name];
      },
      (B, R) => {
        _.errors = h.errors;
      }
    ), {
      state: _,
      updateValue: m,
      addMultipleEntry: x,
      removeMultipleEntry: v,
      removeMultipleEntries: f,
      BoneHasMultipleHandling: JD,
      multipleBonePressEnter: A,
      handleDragStart: O,
      handleDragOver: D,
      handleDrop: M,
      setStateProperties: k,
      resetStateProperties: S
    };
  }
}), ci = (h) => (rt("data-v-dee63f3c"), h = h(), st(), h), _B = {
  key: 0,
  class: "required"
}, vB = ["content"], CB = /* @__PURE__ */ ci(() => /* @__PURE__ */ F("div", { class: "tooltip" }, [
  /* @__PURE__ */ F("sl-icon", { name: "question" })
], -1)), yB = [
  CB
], EB = {
  key: 0,
  variant: "info",
  open: "",
  class: "label-info"
}, xB = /* @__PURE__ */ ci(() => /* @__PURE__ */ F("sl-icon", {
  slot: "icon",
  library: "bootstrap",
  name: "info-circle-fill"
}, null, -1)), SB = { class: "bone-inner-wrap" }, DB = {
  key: 0,
  class: "lang-tab",
  placement: "bottom"
}, BB = ["panel"], TB = ["name"], IB = /* @__PURE__ */ ci(() => /* @__PURE__ */ F("sl-input", {
  readonly: "",
  size: "medium",
  placeholder: "Keine Einträge"
}, null, -1)), PB = [
  IB
], RB = {
  key: 1,
  class: "multiple-placeholder"
}, OB = /* @__PURE__ */ ci(() => /* @__PURE__ */ F("sl-input", {
  readonly: "",
  size: "medium",
  placeholder: "Keine Einträge"
}, null, -1)), zB = [
  OB
], MB = {
  open: "",
  summary: "Errors",
  variant: "info"
}, FB = /* @__PURE__ */ ci(() => /* @__PURE__ */ F("sl-icon", {
  slot: "icon",
  name: "exclamation-triangle"
}, null, -1)), NB = { class: "error-msg" };
function VB(h, C, _, O, D, M) {
  var m;
  const k = Ln("bone-label"), S = Ln("wrapper-multiple");
  return L(), $("div", {
    class: yo([
      "bone-wrapper",
      ("" + h.state.bonestructure.type.split(".")[0], { "has-subbones": h.state.bonestructure.using })
    ])
  }, [
    yr(k, { name: h.name }, {
      default: Cr(() => [
        F("span", {
          class: yo({ required: h.state.required })
        }, Ae(h.state.bonestructure.descr), 3),
        h.state.required ? (L(), $("span", _B, " *")) : oe("", !0),
        h.state.hasTooltip && !h.showLabelInfo ? (L(), $("sl-tooltip", {
          key: 1,
          content: h.state.bonestructure.params.tooltip,
          placement: "top-center"
        }, yB, 8, vB)) : oe("", !0)
      ]),
      _: 1
    }, 8, ["name"]),
    h.showLabelInfo && h.state.hasTooltip ? (L(), $("sl-alert", EB, [
      xB,
      ue(" " + Ae(h.state.bonestructure.params.tooltip), 1)
    ])) : oe("", !0),
    F("div", SB, [
      h.state.multilanguage ? (L(), $("sl-tab-group", DB, [
        (L(!0), $(re, null, Je(h.state.languages, (E) => {
          var x, v, f, A;
          return L(), $(re, {
            key: E + "_tab"
          }, [
            F("sl-tab", {
              slot: "nav",
              panel: "lang_" + E
            }, Ae(h.$t(E)), 9, BB),
            F("sl-tab-panel", {
              name: "lang_" + E
            }, [
              h.state.multiple && !h.BoneHasMultipleHandling(h.state.bonestructure.type) ? (L(), $(re, { key: 0 }, [
                (x = h.state.bonevalue) != null && x[E].length ? (L(!0), $(re, { key: 0 }, Je((v = h.state.bonevalue) == null ? void 0 : v[E], (P, B) => (L(), $("div", {
                  key: B,
                  class: "multiple-bone"
                }, [
                  yr(S, {
                    readonly: !h.state.readonly,
                    "is-dragging": h.state.isDragging.lang === E && h.state.isDragging.index === B,
                    "dragging-line-bottom": h.state.draggingLineBottom.lang === E && h.state.draggingLineBottom.index === B,
                    "dragging-line-top": h.state.draggingLineTop.lang === E && h.state.draggingLineTop.index === B,
                    onDelete: (R) => h.removeMultipleEntry(B, E),
                    onHandleDragStart: (R) => h.handleDragStart(B, E, R),
                    onHandleDragOver: (R) => h.handleDragOver(B, E, R),
                    onHandleDrop: (R) => h.handleDrop(B, E, R)
                  }, {
                    default: Cr(() => [
                      (L(), Ue(Nn(h.is), {
                        value: P,
                        index: B,
                        lang: E,
                        name: h.name,
                        onChange: h.updateValue,
                        onKeydown: al((R) => h.multipleBonePressEnter(E), ["enter"])
                      }, null, 40, ["value", "index", "lang", "name", "onChange", "onKeydown"]))
                    ]),
                    _: 2
                  }, 1032, ["readonly", "is-dragging", "dragging-line-bottom", "dragging-line-top", "onDelete", "onHandleDragStart", "onHandleDragOver", "onHandleDrop"])
                ]))), 128)) : (L(), $("div", {
                  key: 1,
                  class: yo(["multiple-placeholder", { readonly: h.state.readonly }])
                }, PB, 2)),
                h.state.readonly ? oe("", !0) : (L(), Ue(Nn(h.state.actionbar), {
                  key: 2,
                  value: (f = h.state.bonevalue) == null ? void 0 : f[E],
                  name: h.name,
                  lang: E,
                  onChange: h.updateValue
                }, null, 40, ["value", "name", "lang", "onChange"]))
              ], 64)) : (L(), Ue(Nn(h.is), {
                key: 1,
                value: (A = h.state.bonevalue) == null ? void 0 : A[E],
                index: null,
                lang: E,
                name: h.name,
                onChange: h.updateValue
              }, null, 40, ["value", "lang", "name", "onChange"]))
            ], 8, TB)
          ], 64);
        }), 128))
      ])) : (L(), $(re, { key: 1 }, [
        h.state.multiple && !h.BoneHasMultipleHandling(h.state.bonestructure.type) ? (L(), $(re, { key: 0 }, [
          (m = h.state.bonevalue) != null && m.length ? (L(!0), $(re, { key: 0 }, Je(h.state.bonevalue, (E, x) => (L(), $("div", {
            key: x,
            class: "multiple-bone"
          }, [
            yr(S, {
              readonly: !h.state.readonly,
              "is-dragging": h.state.isDragging.index === x,
              "dragging-line-bottom": h.state.draggingLineBottom.index === x,
              "dragging-line-top": h.state.draggingLineTop.index === x,
              onDelete: (v) => h.removeMultipleEntry(x),
              onHandleDragStart: (v) => h.handleDragStart(x, h.lang = null, v),
              onHandleDragOver: (v) => h.handleDragOver(x, h.lang = null, v),
              onHandleDrop: (v) => h.handleDrop(x, h.lang = null, v)
            }, {
              default: Cr(() => [
                (L(), Ue(Nn(h.is), {
                  value: E,
                  index: x,
                  name: h.name,
                  onChange: h.updateValue,
                  onKeydown: C[0] || (C[0] = al((v) => h.multipleBonePressEnter(), ["enter"]))
                }, null, 40, ["value", "index", "name", "onChange"]))
              ]),
              _: 2
            }, 1032, ["readonly", "is-dragging", "dragging-line-bottom", "dragging-line-top", "onDelete", "onHandleDragStart", "onHandleDragOver", "onHandleDrop"])
          ]))), 128)) : (L(), $("div", RB, zB)),
          h.state.readonly ? oe("", !0) : (L(), Ue(Nn(h.state.actionbar), {
            key: 2,
            value: h.state.bonevalue,
            name: h.name,
            onChange: h.updateValue
          }, null, 40, ["value", "name", "onChange"]))
        ], 64)) : (L(), Ue(Nn(h.is), {
          key: 1,
          value: h.state.bonevalue,
          name: h.name,
          index: null,
          autofocus: h.autofocus,
          onChange: h.updateValue,
          onKeypress: al(h.updateValue, ["enter"])
        }, null, 40, ["value", "name", "autofocus", "onChange", "onKeypress"]))
      ], 64)),
      (L(!0), $(re, null, Je(h.state.errorMessages, (E) => (L(), $("sl-alert", MB, [
        FB,
        F("div", NB, Ae(E), 1)
      ]))), 256))
    ])
  ], 2);
}
const cl = /* @__PURE__ */ ke(AB, [["render", VB], ["__scopeId", "data-v-dee63f3c"]]), $n = (h) => (rt("data-v-71a3c8c9"), h = h(), st(), h), LB = /* @__PURE__ */ $n(() => /* @__PURE__ */ F("h2", { class: "viur-shop-form-headline headline" }, "Nutzterdaten", -1)), jB = /* @__PURE__ */ $n(() => /* @__PURE__ */ F("h2", { class: "viur-shop-form-headline headline" }, "Lieferadresse", -1)), $B = ["onSlChange", "onSlClear", "label"], HB = ["value"], qB = { key: 0 }, UB = /* @__PURE__ */ $n(() => /* @__PURE__ */ F("h2", { class: "viur-shop-form-headline headline" }, "Rechnungsadresse", -1)), WB = /* @__PURE__ */ $n(() => /* @__PURE__ */ F("sl-icon", {
  name: "x-lg",
  slot: "prefix"
}, null, -1)), KB = [
  WB
], GB = /* @__PURE__ */ $n(() => /* @__PURE__ */ F("sl-icon", {
  name: "plus-lg",
  slot: "prefix"
}, null, -1)), ZB = /* @__PURE__ */ $n(() => /* @__PURE__ */ F("sl-icon", {
  slot: "icon",
  name: "exclamation-triangle"
}, null, -1)), JB = /* @__PURE__ */ $n(() => /* @__PURE__ */ F("br", null, null, -1)), YB = {
  __name: "UserInfoMulti",
  props: {
    mode: { type: String, default: "form" }
  },
  setup(h) {
    const C = ai(), _ = he({
      formValues: {},
      requiredFieldsFilled: ie(() => {
        if (_.isCustomAdress)
          return Object.keys(_.formValues).includes("city") && Object.keys(_.formValues).includes("street") && Object.keys(_.formValues).includes("billing.city") && Object.keys(_.formValues).includes("billing.street") && Object.keys(_.formValues).includes("email") && Object.keys(_.formValues).includes("firstname") && Object.keys(_.formValues).includes("lastname");
        if (!_.isCustomAdress)
          return Object.keys(_.formValues).includes("city") && Object.keys(_.formValues).includes("street") && Object.keys(_.formValues).includes("email") && Object.keys(_.formValues).includes("firstname") && Object.keys(_.formValues).includes("lastname");
      }),
      isCustomAdress: !1,
      shippingAdressAmount: 1,
      maxShippingAdress: ie(
        () => Object.keys(C.state.carts).length + 2
      ),
      amountAlert: { title: "", msg: "" },
      items: null,
      addSkel: null,
      errors: {},
      selectedItem: {},
      isInit: ie(() => !!C.state.carts[C.state.basket])
    }), O = Dt(null), D = Dt(null);
    function M(f) {
      f.target.checked && (_.isCustomAdress = !1), f.target.checked || (_.isCustomAdress = !0);
    }
    function k() {
      if (_.shippingAdressAmount === _.maxShippingAdress) {
        _.amountAlert.title = "Zu viele Lieferadressen", _.amountAlert.msg = `Sie können nur maximal: "${_.maxShippingAdress}" Lieferadressen verwenden.`, D.value.show();
        return;
      }
      _.shippingAdressAmount += 1;
    }
    function S(f, A) {
      for (const [P, B] of Object.entries(A.value[0]))
        _.formValues[P] = B;
    }
    function m() {
      if (_.shippingAdressAmount === 1) {
        _.amountAlert.title = "Zu wenig Lieferadressen", _.amountAlert.msg = "Mindestens eine Lieferadresse muss angegeben werden.", D.value.show();
        return;
      }
      _.shippingAdressAmount -= 1;
    }
    function E(f, A) {
      if (console.log(f.target.value), !f.target.value.length) {
        x();
        return;
      }
      _.selectedItem[A] = f.target.value, _.isItemSelected = !0;
    }
    function x(f, A) {
      console.log("clearing..."), delete _.selectedItem[A], _.isItemSelected = !1;
    }
    function v(f) {
      let A = {};
      return f.forEach((P) => {
        let B = P[0], R = P[1];
        A[B] = R;
      }), A;
    }
    return Eo(_.formValues, (f) => {
      Object.entries(f).forEach(([A, P]) => {
        P === "" && delete _.formValues[A];
      });
    }), jn(async () => {
      await C.getAdressStructure(), _.addSkel = C.state.structure.address;
    }), (f, A) => (L(), $(re, null, [
      F("div", null, [
        LB,
        (L(!0), $(re, null, Je(_.addSkel, (P) => (L(), $(re, {
          key: P[0]
        }, [
          P[1].visible && P[1].params.group === "Customer Info" ? (L(), Ue(cl, {
            key: 0,
            is: wt(Vn)(P[1].type),
            name: P[0],
            structure: v(_.addSkel),
            errors: _.errors[P[0]] ? _.errors[P[0]] : [],
            skel: _.formValues,
            onChange: (B) => S(P[0], B),
            class: "viur-shop-form-grid-w-2"
          }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : oe("", !0)
        ], 64))), 128))
      ]),
      jB,
      (L(!0), $(re, null, Je(_.shippingAdressAmount, (P) => (L(), $("div", { key: P }, [
        F("sl-select", {
          clearable: "",
          ref_for: !0,
          ref_key: "itemSelection",
          ref: O,
          onSlChange: (B) => E(B, P),
          onSlClear: (B) => x(B, P),
          label: _.selectedItem[P] ? wt(C).state.carts[_.selectedItem[P]].info.name : "Warenkorb für Adresse wählen.",
          class: "grid-w-4"
        }, [
          (L(!0), $(re, null, Je(wt(C).state.carts, (B, R) => (L(), $("sl-option", { value: R }, Ae(B.info.name), 9, HB))), 256))
        ], 40, $B),
        (L(!0), $(re, null, Je(_.addSkel, (B) => (L(), $(re, {
          key: B[0]
        }, [
          B[1].visible && B[1].params.group === "Customer Address" ? (L(), Ue(cl, {
            key: 0,
            is: wt(Vn)(B[1].type),
            name: B[0],
            structure: v(_.addSkel),
            errors: _.errors[B[0]] ? _.errors[B[0]] : [],
            skel: _.formValues,
            onChange: (R) => S(B[0], R)
          }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : oe("", !0)
        ], 64))), 128))
      ]))), 128)),
      _.isCustomAdress ? (L(), $("div", qB, [
        UB,
        (L(!0), $(re, null, Je(_.addSkel, (P) => (L(), $(re, {
          key: P[0]
        }, [
          P[1].visible && P[1].params.group === "Customer Address" ? (L(), Ue(cl, {
            key: 0,
            is: wt(Vn)(P[1].type),
            name: P[0],
            structure: v(_.addSkel),
            errors: _.errors[P[0]] ? _.errors[P[0]] : [],
            skel: _.formValues,
            onChange: (B) => S(P[0], B)
          }, null, 8, ["is", "name", "structure", "errors", "skel", "onChange"])) : oe("", !0)
        ], 64))), 128))
      ])) : oe("", !0),
      F("div", { class: "viur-shop-form-btn-wrap" }, [
        F("sl-button", {
          size: "medium",
          onClick: m,
          title: "Lieferadresse entfernen"
        }, KB),
        F("sl-button", {
          size: "medium",
          variant: "primary",
          onClick: k
        }, [
          GB,
          ue(" Lieferadresse hinzufügen ")
        ])
      ]),
      F("sl-alert", {
        variant: "warning",
        duration: "2000",
        ref_key: "shippingWarning",
        ref: D,
        closable: ""
      }, [
        ZB,
        F("strong", null, Ae(_.amountAlert.title), 1),
        JB,
        ue(" " + Ae(_.amountAlert.msg), 1)
      ], 512),
      F("sl-checkbox", {
        onSlChange: M,
        checked: ""
      }, " Rechnungsadresse wie Lieferadresse ", 32)
    ], 64));
  }
}, QB = /* @__PURE__ */ ke(YB, [["__scopeId", "data-v-71a3c8c9"]]), XB = {
  __name: "ExampleUsage",
  setup(h) {
    const C = ai(), _ = ie(
      () => C.state.basketRootNode.key ? C.state.basketRootNode.key : ""
    ), O = he({
      rootNode: {},
      tabs: {
        cart: {
          component: Xt(_b),
          props: {
            sidebar: !0,
            mode: "basket",
            cartKey: _
          },
          // cartKey (on initial call has to be a root node) is a required prop, make sure that cartStore.init() is called before cart is mounted
          displayName: "Warenkorb",
          icon: { name: "cart", library: "hsk" },
          position: 2,
          disabled: !1,
          atShow: null,
          atHide: null
        },
        confirm: {
          component: Xt(vb),
          props: {},
          displayName: "Bestellung prüfen",
          icon: { name: "order-check", library: "hsk" },
          position: 5,
          disabled: !1,
          atShow: null,
          atHide: null
        },
        // order: {
        //   component: shallowRef(CategoryView),
        //   props: {
        //     listHandler: ListRequest("categorystore", {
        //       module: "variante",
        //       params: { type: "dk", limit: 99 },
        //     }),
        //   },
        //   displayName: "Artikel Bestellen",
        //   icon: { name: "cart-add", library: "hsk" },
        //   position: 1,
        //   disabled: false,
        //   atShow: null,
        //   atHide: null,
        // },
        orderComplete: {
          component: Xt(E5),
          props: {},
          displayName: "Bestellung Abgeschlossen",
          icon: { name: "order-confirmed", library: "hsk" },
          position: 6,
          disabled: !0,
          atShow: null,
          atHide: null
        },
        userInfo: {
          component: Xt(nB),
          props: {},
          displayName: "Daten Eingeben",
          icon: { name: "user", library: "hsk" },
          position: 3,
          disabled: !1,
          atShow: null,
          atHide: null
        },
        userInfoMulti: {
          component: Xt(QB),
          props: {},
          displayName: "Daten Eingeben (Multi)",
          icon: { name: "user", library: "hsk" },
          position: 4,
          disabled: !1,
          atShow: null,
          atHide: null
        }
      }
    });
    function D(M) {
      (M == null ? void 0 : M.detail.name) === "confirm" && (O.tabs.orderComplete.disabled = !1);
    }
    return jn(async () => {
      await C.init(), await C.getAdressStructure(), console.log("debug init exampleusage :", C.state.basketRootNode);
    }), (M, k) => (L(), Ue(f5, {
      tabs: O.tabs,
      onTabChange: D
    }, null, 8, ["tabs"]));
  }
}, aT = {
  install(h) {
    h.component("CartView", _b), h.component("ExampleUsage", XB), h.component("ConfirmView", vb);
  }
};
export {
  _b as CartView,
  vb as ConfirmView,
  XB as ExampleUsage,
  aT as default,
  ai as useCartStore
};
